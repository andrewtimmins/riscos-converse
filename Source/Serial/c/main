/* ******************************************************************************************************************************************************** */
/* Serial Handler - Main Module                                                                                                                             */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"
#include "C:Desk.Error.h"
#include "C:Desk.Error.h"
#include "C:Desk.Sprite.h"
#include "C:Desk.File.h"

/* Our Includes */
#include "main.h"
#include "serial.h"
#include "ansiterm.h"
#include "debug.h"
#include "version.h"

/* ******************************************************************************************************************************************************** */
/* Global Variables                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

WIMP_STATE wimp;
SERIAL_LINE_STATE serial_lines[SERIAL_MAX_LINES];
int serial_line_count = 0;

SERIAL_STATUS_ROW *serial_status_rows = NULL;
int serial_status_row_count = 0;

static Desk_sprite_area status_sprites = NULL;

static Desk_window_handle proginfo_window;

/* Menu indices */
enum
{
    ICONBAR_MENU_INFO = 0,
    ICONBAR_MENU_QUIT
};

/* Forward declarations for handlers used before definition */
static Desk_bool handle_menu_selection(Desk_event_pollblock *event, void *ref);

/* ******************************************************************************************************************************************************** */
/* Utility Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

void serial_log(const char *format, ...)
{
    char buffer[256];
    va_list args;
    _kernel_swi_regs regs;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    regs.r[0] = FILER_LOG_CMD_SERIAL;
    regs.r[1] = (int)buffer;
    _kernel_swi(SWI_FILER_LOGGING, &regs, &regs);

    debug_printf("Serial: %s", buffer);
}

/* ******************************************************************************************************************************************************** */
/* Pipe Helper Functions                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

int pipes_input_status(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_STATUS, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int pipes_input_write_block(int line_id, const char *buffer, int length)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = (int)buffer;
    regs.r[2] = length;
    if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_WRITE_BLOCK, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int pipes_output_read_block(int line_id, char *buffer, int length)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = (int)buffer;
    regs.r[2] = length;
    if (_kernel_swi(SWI_CONVERSE_PIPES_OUTPUT_READ_BLOCK, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

void pipes_reset_line(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    _kernel_swi(SWI_CONVERSE_PIPES_RESET_STATE, &regs, &regs);
    regs.r[0] = line_id;
    _kernel_swi(SWI_CONVERSE_PIPES_CLEAR_INPUT, &regs, &regs);
    regs.r[0] = line_id;
    _kernel_swi(SWI_CONVERSE_PIPES_CLEAR_OUTPUT, &regs, &regs);
}

void pipes_send_control_command(int line_id, char command)
{
    unsigned char frame[3];

    frame[0] = PIPE_CONTROL_TOKEN;
    frame[1] = (unsigned char)command;
    frame[2] = PIPE_CONTROL_TOKEN;
    pipes_input_write_block(line_id, (const char *)frame, sizeof(frame));
}

/* ******************************************************************************************************************************************************** */
/* Support Module Helper Functions                                                                                                                          */
/* ******************************************************************************************************************************************************** */

void support_set_line_connected(int line_id, int connected)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_CONNECTED;
    regs.r[3] = connected;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

void support_set_line_hostname(int line_id, const char *hostname)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_HOSTNAME;
    regs.r[3] = (int)hostname;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

void support_set_line_connect_time(int line_id, time_t connect_time)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_CONNECT_TIME;
    regs.r[3] = (int)connect_time;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

int support_get_line_type(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_TYPE;
    if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int support_get_serial_config(int line_id, SERIAL_LINE_CONFIG *config)
{
    _kernel_swi_regs regs;
    SERIAL_LINE_CONFIG *src;

    if (config == NULL)
    {
        return -1;
    }

    regs.r[0] = 0;  /* SERIAL_CONFIG_REASON_GET */
    regs.r[1] = line_id;
    if (_kernel_swi(SWI_CONVERSEBBS_SERIAL_CONFIG, &regs, &regs) != NULL)
    {
        return -1;
    }

    src = (SERIAL_LINE_CONFIG *)regs.r[0];
    if (src == NULL)
    {
        return -1;
    }

    memcpy(config, src, sizeof(SERIAL_LINE_CONFIG));
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Wimp Message Sending                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

void send_serial_connect_message(int line_id)
{
    Desk_message_block msg;

    memset(&msg, 0, sizeof(msg));
    msg.header.size = 24;
    msg.header.yourref = 0;
    msg.header.action = MESSAGE_SERIAL_CONNECT;
    msg.data.words[0] = line_id;

    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, 0, 0);

    debug_printf("serial: Sent MESSAGE_SERIAL_CONNECT for line %d", line_id);
}

void send_serial_disconnect_message(int line_id)
{
    Desk_message_block msg;

    memset(&msg, 0, sizeof(msg));
    msg.header.size = 24;
    msg.header.yourref = 0;
    msg.header.action = MESSAGE_SERIAL_DISCONNECT;
    msg.data.words[0] = line_id;

    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, 0, 0);

    debug_printf("serial: Sent MESSAGE_SERIAL_DISCONNECT for line %d", line_id);
}

/* ******************************************************************************************************************************************************** */
/* Line Configuration Loading                                                                                                                               */
/* ******************************************************************************************************************************************************** */

static void load_serial_lines(void)
{
    int line_id;
    SERIAL_LINE_CONFIG config;
    int line_type;

    serial_line_count = 0;
    memset(serial_lines, 0, sizeof(serial_lines));

    debug_printf("serial: Scanning for serial lines...");

    /* Scan all possible lines looking for serial types */
    for (line_id = 0; line_id < SERIAL_MAX_LINES; line_id++)
    {
        /* Check if this line is configured as serial */
        line_type = support_get_line_type(line_id);
        
        if (line_type == LINE_TYPE_SERIAL)
        {
            /* Get the serial config for this line */
            if (support_get_serial_config(line_id, &config) == 0 && config.enabled)
            {
                debug_printf("serial: Found serial line %d: driver=%s port=%d speed=%d",
                             line_id, config.driver_name, config.port_number, config.baud_rate);

                serial_lines[serial_line_count].line_id = line_id;
                serial_lines[serial_line_count].enabled = 1;
                serial_lines[serial_line_count].driver = NULL;
                serial_lines[serial_line_count].port_number = config.port_number;
                serial_lines[serial_line_count].baud_rate = config.baud_rate;
                serial_lines[serial_line_count].word_format = config.word_format;
                serial_lines[serial_line_count].flow_control = config.flow_control;
                serial_lines[serial_line_count].rings = (config.rings <= 0) ? 1 : config.rings;
                serial_lines[serial_line_count].carrier_detect = 0;
                strncpy(serial_lines[serial_line_count].init, config.init,
                    sizeof(serial_lines[serial_line_count].init) - 1);
                serial_lines[serial_line_count].init[sizeof(serial_lines[serial_line_count].init) - 1] = '\0';
                strncpy(serial_lines[serial_line_count].ring, config.ring,
                    sizeof(serial_lines[serial_line_count].ring) - 1);
                serial_lines[serial_line_count].ring[sizeof(serial_lines[serial_line_count].ring) - 1] = '\0';
                strncpy(serial_lines[serial_line_count].answer, config.answer,
                    sizeof(serial_lines[serial_line_count].answer) - 1);
                serial_lines[serial_line_count].answer[sizeof(serial_lines[serial_line_count].answer) - 1] = '\0';
                serial_lines[serial_line_count].ring_count = 0;
                serial_lines[serial_line_count].ring_match_index = 0;
                serial_lines[serial_line_count].last_activity = 0;
                serial_lines[serial_line_count].last_ring_time = 0;
                serial_lines[serial_line_count].escape_plus_count = 0;
                serial_lines[serial_line_count].escape_silence_start = 0;
                serial_lines[serial_line_count].escape_guard_active = 0;
                strncpy(serial_lines[serial_line_count].driver_name, config.driver_name,
                        sizeof(serial_lines[serial_line_count].driver_name) - 1);
                serial_lines[serial_line_count].driver_name[sizeof(serial_lines[serial_line_count].driver_name) - 1] = '\0';

                serial_line_count++;
            }
        }
    }

    debug_printf("serial: Found %d serial lines", serial_line_count);
    serial_log("Found %d serial lines", serial_line_count);
}

/* ******************************************************************************************************************************************************** */
/* Status Window Functions                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

int serialstatus_icon_index(int line_index, int column)
{
    return SERIALSTATUS_ICON_BASE + (line_index * SERIALSTATUS_ICONS_PER_LINE) + column;
}

int serialstatus_create_icons(void)
{
    Desk_icon_createblock icon_create;
    Desk_icon_handle icon_handle;
    int row;
    int y_base;
    int column_x;
    SERIAL_STATUS_ROW *icons;
    
    if (serial_line_count <= 0)
    {
        debug_printf("serialstatus: No serial lines, skipping icon creation");
        return 1;
    }
    
    /* Allocate row array */
    serial_status_rows = malloc(serial_line_count * sizeof(SERIAL_STATUS_ROW));
    if (serial_status_rows == NULL)
    {
        debug_printf("serialstatus: Failed to allocate row array");
        return 0;
    }
    
    serial_status_row_count = serial_line_count;
    memset(serial_status_rows, 0, serial_line_count * sizeof(SERIAL_STATUS_ROW));
    
    icon_create.window = wimp.status_window;
    y_base = -((SERIALSTATUS_TOP_STATIC_ROWS * SERIALSTATUS_ICON_HEIGHT) + SERIALSTATUS_PADDING);
    
    for (row = 0; row < serial_status_row_count; row++)
    {
        icons = &serial_status_rows[row];
        
        /* Allocate text buffers */
        icons->line_text = malloc(8);
        icons->status_text = malloc(64);
        
        if (icons->line_text == NULL || icons->status_text == NULL)
        {
            debug_printf("serialstatus: Failed to allocate icon buffers for row %d", row);
            return 0;
        }
        
        /* Initialize text */
        snprintf(icons->line_text, 8, "%d", serial_lines[row].line_id);
        strcpy(icons->status_text, "Initializing");
        
        /* Calculate Y position for this row */
        icon_create.icondata.workarearect.max.y = y_base - (SERIALSTATUS_ICON_HEIGHT * row);
        icon_create.icondata.workarearect.min.y = icon_create.icondata.workarearect.max.y - SERIALSTATUS_ICON_HEIGHT;
        
        column_x = SERIALSTATUS_COLUMN_START;
        
        /* Column 0: Line Number */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + SERIALSTATUS_LINE_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = icons->line_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 8;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + SERIALSTATUS_COLUMN_GAP;
        
        /* Column 1: Status */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + SERIALSTATUS_STATUS_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = icons->status_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 64;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + SERIALSTATUS_COLUMN_GAP;
        
        /* Column 2: Terminal Button (sprite) */
        icons->terminal_text = malloc(1);
        if (icons->terminal_text) icons->terminal_text[0] = '\0';
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + SERIALSTATUS_BUTTON_WIDTH;
        icon_create.icondata.workarearect.max.y = y_base - (SERIALSTATUS_ICON_HEIGHT * row);
        icon_create.icondata.workarearect.min.y = icon_create.icondata.workarearect.max.y - SERIALSTATUS_ICON_HEIGHT;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_SPRITE |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1) |
                                           (Desk_icon_BUTTONTYPE * Desk_iconbtype_CLICK);
        icon_create.icondata.data.indirecttext.buffer = icons->terminal_text;
        icon_create.icondata.data.indirecttext.validstring = "Sterminal;R5";
        icon_create.icondata.data.indirecttext.bufflen = 1;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + SERIALSTATUS_COLUMN_GAP;
        
        /* Column 3: Init Button (sprite) */
        icons->init_text = malloc(1);
        if (icons->init_text) icons->init_text[0] = '\0';
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + SERIALSTATUS_BUTTON_WIDTH;
        icon_create.icondata.workarearect.max.y = y_base - (SERIALSTATUS_ICON_HEIGHT * row);
        icon_create.icondata.workarearect.min.y = icon_create.icondata.workarearect.max.y - SERIALSTATUS_ICON_HEIGHT;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_SPRITE |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1) |
                                           (Desk_icon_BUTTONTYPE * Desk_iconbtype_CLICK);
        icon_create.icondata.data.indirecttext.buffer = icons->init_text;
        icon_create.icondata.data.indirecttext.validstring = "Sinit;R5";
        icon_create.icondata.data.indirecttext.bufflen = 1;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
    }
    
    debug_printf("serialstatus: Created icons for %d rows", serial_status_row_count);
    return 1;
}

void serialstatus_free_icons(void)
{
    int i;
    
    if (serial_status_rows == NULL)
    {
        return;
    }
    
    for (i = 0; i < serial_status_row_count; i++)
    {
        if (serial_status_rows[i].line_text != NULL)
        {
            free(serial_status_rows[i].line_text);
        }
        if (serial_status_rows[i].status_text != NULL)
        {
            free(serial_status_rows[i].status_text);
        }
        if (serial_status_rows[i].terminal_text != NULL)
        {
            free(serial_status_rows[i].terminal_text);
        }
        if (serial_status_rows[i].init_text != NULL)
        {
            free(serial_status_rows[i].init_text);
        }
    }
    
    free(serial_status_rows);
    serial_status_rows = NULL;
    serial_status_row_count = 0;
}

void serialstatus_set_extent(void)
{
    Desk_wimp_box extent;
    int total_height;
    int total_width;
    int rows;
    
    /* Use at least 1 row for minimum window size */
    rows = (serial_status_row_count > 0) ? serial_status_row_count : 1;
    
    /* Calculate total height: (header rows + data rows) * row height + padding */
    total_height = ((rows + SERIALSTATUS_TOP_STATIC_ROWS) * SERIALSTATUS_ICON_HEIGHT) +
                   SERIALSTATUS_PADDING + SERIALSTATUS_BOTTOM_PADDING;
    
    /* Calculate total width: all columns + gaps between them */
    total_width = SERIALSTATUS_COLUMN_START +
                  SERIALSTATUS_LINE_WIDTH + SERIALSTATUS_COLUMN_GAP +
                  SERIALSTATUS_STATUS_WIDTH + SERIALSTATUS_COLUMN_GAP +
                  SERIALSTATUS_BUTTON_WIDTH + SERIALSTATUS_COLUMN_GAP +
                  SERIALSTATUS_BUTTON_WIDTH + SERIALSTATUS_COLUMN_GAP;
    
    extent.min.x = 0;
    extent.max.x = total_width;
    extent.min.y = -total_height;
    extent.max.y = 0;
    
    Desk_Wimp_SetExtent(wimp.status_window, &extent);
}

void serialstatus_update_line(int line_index, const char *status)
{
    if (serial_status_rows == NULL || line_index < 0 || line_index >= serial_status_row_count)
    {
        return;
    }
    
    if (wimp.status_window != 0 && status != NULL)
    {
        /* Update the icon text using Desk_Icon_SetText like Server does */
        Desk_Icon_SetText(wimp.status_window,
                          serialstatus_icon_index(line_index, SERIALSTATUS_COLUMN_STATUS),
                          (char *)status);
    }
}

/* ******************************************************************************************************************************************************** */
/* Terminal State Arrays (declared early for use by window handlers)                                                                                        */
/* ******************************************************************************************************************************************************** */

static Desk_window_handle terminal_windows[SERIAL_MAX_LINES];
static ansiterm_state terminal_states[SERIAL_MAX_LINES];

/* ******************************************************************************************************************************************************** */
/* Wimp Event Handlers                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

/*
 * Handle window open events - required to allow window dragging.
 */
static Desk_bool handle_window_open(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Wimp_OpenWindow(&event->data.openblock);
    return Desk_bool_TRUE;
}

/*
 * Handle window close events.
 * Checks if it's a terminal window and handles appropriately.
 */
static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref)
{
    int i;
    Desk_window_handle window;
    
    Desk_UNUSED(ref);
    
    window = event->data.openblock.window;
    
    /* Check if it's a terminal window */
    for (i = 0; i < serial_line_count; i++)
    {
        if (terminal_windows[i] == window && serial_lines[i].terminal_active)
        {
            serial_close_terminal(i);
            return Desk_bool_TRUE;
        }
    }
    
    /* Not a terminal - just hide the window */
    Desk_Window_Hide(window);
    return Desk_bool_TRUE;
}

static Desk_bool handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;
    Desk_window_state state;
    int win_width, win_height;

    if (event->data.mouse.button.data.menu)
    {
        Desk_Menu_Show(w->iconbar_menu, event->data.mouse.pos.x, -1);
    }
    else if (event->data.mouse.button.data.select)
    {
        /* Open status window on SELECT click - position at bottom-left like FTN mailer */
        debug_printf("serial: Iconbar SELECT clicked, status_window=%d", (int)w->status_window);
        if (w->status_window != 0)
        {
            /* Get current window state */
            Desk_Wimp_GetWindowState(w->status_window, &state);
            win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
            win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
            
            /* Position at bottom-left, just above iconbar */
            state.openblock.screenrect.min.x = 16;
            state.openblock.screenrect.max.x = 16 + win_width;
            state.openblock.screenrect.min.y = 134;  /* Just above iconbar (128) + margin */
            state.openblock.screenrect.max.y = 134 + win_height;
            state.openblock.behind = -1;  /* Open at front */
            
            Desk_Wimp_OpenWindow(&state.openblock);
            debug_printf("serial: Window opened at bottom-left");
        }
        else
        {
            debug_printf("serial: status_window is 0, cannot show");
        }
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_menu_selection(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;

    switch (event->data.selection[0])
    {
        case ICONBAR_MENU_QUIT:
            w->quit = Desk_bool_TRUE;
            debug_printf("serial: Menu Quit selected, setting quit flag");
            break;
    }

    return Desk_bool_TRUE;
}

/* ******************************************************************************************************************************************************** */
/* Terminal Functions                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

/* Callback to send data from terminal to serial port */
static void terminal_send_to_serial(int line_index, const char *data, int len)
{
    int i;
    SERIAL_LINE_STATE *state;
    
    if (line_index < 0 || line_index >= serial_line_count)
        return;
    
    state = &serial_lines[line_index];
    if (state->driver == NULL)
        return;
    
    /* Write each byte to the serial port */
    for (i = 0; i < len; i++)
    {
        state->driver(DRIVER_PUTBYTE, (unsigned char)data[i]);
    }
}

void serial_open_terminal(int line_index)
{
    SERIAL_LINE_STATE *state;
    ansiterm_state *term;
    char title[128];
    
    if (line_index < 0 || line_index >= serial_line_count)
        return;
    
    state = &serial_lines[line_index];
    term = &terminal_states[line_index];
    
    /* Check if already open */
    if (state->terminal_active)
    {
        /* Just bring window to front */
        if (terminal_windows[line_index] != 0)
        {
            ansiterm_open_window(term, NULL);
        }
        return;
    }
    
    /* If there's an active connection, disconnect it first */
    if (state->carrier_detect)
    {
        debug_printf("serial: Disconnecting line %d before opening terminal", line_index);
        serial_handle_disconnect(line_index);
        serialstatus_update_line(line_index, "Disconnected for terminal");
    }
    
    /* Initialize the terminal state */
    ansiterm_init(term, line_index);
    term->send_to_serial = terminal_send_to_serial;
    
    /* Create the terminal window if not yet created */
    if (terminal_windows[line_index] == 0)
    {
        terminal_windows[line_index] = Desk_Window_Create("main", Desk_template_TITLEMIN);
        debug_printf("serial: Created terminal window %d for line %d", 
                     (int)terminal_windows[line_index], line_index);
    }
    
    if (terminal_windows[line_index] == 0)
    {
        debug_printf("serial: Failed to create terminal window for line %d", line_index);
        return;
    }
    
    term->window = terminal_windows[line_index];
    
    /* Load font */
    ansiterm_load_font(term, "<Converse$Dir>.Resources.Font");
    
    /* Set up title */
    snprintf(title, sizeof(title), "Terminal - Line %d (%s port %d @ %d)", 
             state->line_id, state->driver_name, state->port_number, state->baud_rate);
    
    /* Open the window */
    ansiterm_open_window(term, title);
    
    /* Mark terminal as active */
    state->terminal_active = 1;
    state->terminal = term;
    
    /* Update status */
    serialstatus_update_line(line_index, "Terminal active");
    serial_log("Terminal opened for line %d", state->line_id);
    
    /* Display welcome message in terminal */
    ansiterm_process_block(term, (const unsigned char *)"\033[1;32mTerminal connected to serial port\033[0m\r\n", 44);
    ansiterm_update_dirty(term);
}

void serial_close_terminal(int line_index)
{
    SERIAL_LINE_STATE *state;
    ansiterm_state *term;
    
    if (line_index < 0 || line_index >= serial_line_count)
        return;
    
    state = &serial_lines[line_index];
    term = &terminal_states[line_index];
    
    if (!state->terminal_active)
        return;
    
    /* Close the window */
    ansiterm_close_window(term);
    
    /* Clean up terminal state */
    ansiterm_finalise(term);
    
    /* Mark terminal as inactive */
    state->terminal_active = 0;
    state->terminal = NULL;
    
    /* Update status */
    serialstatus_update_line(line_index, "Ready");
    serial_log("Terminal closed for line %d", state->line_id);
}

int serial_terminal_active(int line_index)
{
    if (line_index < 0 || line_index >= serial_line_count)
        return 0;
    return serial_lines[line_index].terminal_active;
}

/* ******************************************************************************************************************************************************** */
/* Init Function                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

void serial_reinit_line(int line_index)
{
    SERIAL_LINE_STATE *state;
    char status_msg[64];
    
    if (line_index < 0 || line_index >= serial_line_count)
        return;
    
    state = &serial_lines[line_index];
    
    /* If there's an active connection, disconnect it first */
    if (state->carrier_detect)
    {
        debug_printf("serial: Disconnecting line %d before reinit", line_index);
        serial_handle_disconnect(line_index);
    }
    
    /* Close terminal if open */
    if (state->terminal_active)
    {
        serial_close_terminal(line_index);
    }
    
    /* Update status to show we're initializing */
    snprintf(status_msg, sizeof(status_msg), "Init: %s", state->init);
    serialstatus_update_line(line_index, status_msg);
    
    /* Re-initialize the port (sends init string to modem) */
    serial_init_port(line_index);
    
    /* Update status to show ready */
    serialstatus_update_line(line_index, "Ready");
    
    serial_log("Line %d reinitialized", state->line_id);
}

/* ******************************************************************************************************************************************************** */
/* Button Click Handler                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

static Desk_bool serialstatus_icon_to_line(Desk_icon_handle icon, int *line_index, int *column)
{
    int relative;
    
    if (icon < SERIALSTATUS_ICON_BASE || serial_status_row_count <= 0)
        return Desk_bool_FALSE;
    
    relative = icon - SERIALSTATUS_ICON_BASE;
    if (relative < 0 || relative >= (serial_status_row_count * SERIALSTATUS_ICONS_PER_LINE))
        return Desk_bool_FALSE;
    
    if (line_index != NULL)
        *line_index = relative / SERIALSTATUS_ICONS_PER_LINE;
    
    if (column != NULL)
        *column = relative % SERIALSTATUS_ICONS_PER_LINE;
    
    return Desk_bool_TRUE;
}

static Desk_bool handle_status_click(Desk_event_pollblock *event, void *ref)
{
    int line_index, column;
    
    Desk_UNUSED(ref);
    
    if (!event->data.mouse.button.data.select && !event->data.mouse.button.data.adjust)
        return Desk_bool_FALSE;
    
    if (!serialstatus_icon_to_line(event->data.mouse.icon, &line_index, &column))
        return Desk_bool_FALSE;
    
    debug_printf("serial: Status window click: line_index=%d column=%d", line_index, column);
    
    switch (column)
    {
        case SERIALSTATUS_COLUMN_TERMINAL:
            /* Terminal button clicked */
            debug_printf("serial: Terminal button clicked for line %d", line_index);
            if (serial_lines[line_index].terminal_active)
            {
                /* Toggle - close if open */
                if (event->data.mouse.button.data.adjust)
                    serial_close_terminal(line_index);
                else
                    serial_open_terminal(line_index);  /* Bring to front */
            }
            else
            {
                serial_open_terminal(line_index);
            }
            break;
            
        case SERIALSTATUS_COLUMN_INIT:
            /* Init button clicked */
            debug_printf("serial: Init button clicked for line %d", line_index);
            serial_reinit_line(line_index);
            break;
    }
    
    return Desk_bool_TRUE;
}

/* ******************************************************************************************************************************************************** */
/* Terminal Window Event Handlers                                                                                                                           */
/* ******************************************************************************************************************************************************** */

static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event, void *ref)
{
    int i;
    
    Desk_UNUSED(ref);
    
    /* Find which terminal this belongs to */
    for (i = 0; i < serial_line_count; i++)
    {
        if (terminal_windows[i] == event->data.openblock.window)
        {
            if (serial_lines[i].terminal_active)
            {
                ansiterm_redraw(&terminal_states[i], &event->data);
                return Desk_bool_TRUE;
            }
        }
    }
    
    return Desk_bool_FALSE;
}

static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref)
{
    int i;
    int key_code;
    int result;
    char ch;
    
    Desk_UNUSED(ref);
    
    key_code = event->data.key.code;
    
    /* Find which terminal this belongs to */
    for (i = 0; i < serial_line_count; i++)
    {
        if (terminal_windows[i] == event->data.key.caret.window)
        {
            if (serial_lines[i].terminal_active)
            {
                result = ansiterm_keypress(&terminal_states[i], key_code);
                
                if (result > 0)
                {
                    /* Send character to serial port */
                    ch = (char)result;
                    terminal_send_to_serial(i, &ch, 1);
                    
                    /* Local echo */
                    ansiterm_process_byte(&terminal_states[i], (unsigned char)result);
                    ansiterm_update_dirty(&terminal_states[i]);
                }
                else if (result < 0)
                {
                    /* Arrow key - send escape sequence */
                    const char *seq = NULL;
                    switch (result)
                    {
                        case -1: seq = "\033[D"; break;  /* Left */
                        case -2: seq = "\033[C"; break;  /* Right */
                        case -3: seq = "\033[B"; break;  /* Down */
                        case -4: seq = "\033[A"; break;  /* Up */
                    }
                    if (seq)
                        terminal_send_to_serial(i, seq, 3);
                }
                
                return Desk_bool_TRUE;
            }
        }
    }
    
    /* Pass on unhandled keys */
    Desk_Wimp_ProcessKey(key_code);
    return Desk_bool_TRUE;
}

static Desk_bool handle_null_event(Desk_event_pollblock *event, void *ref)
{
    int i;

    Desk_UNUSED(event);
    Desk_UNUSED(ref);

    /* Poll all serial lines */
    for (i = 0; i < serial_line_count; i++)
    {
        serial_poll(i);
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_broadcast_message(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;
    int reason;

    if (event == NULL)
    {
        return Desk_bool_FALSE;
    }

    reason = event->data.message.data.words[0];

    /* Reason 0 = quit */
    if (reason == 0)
    {
        debug_printf("serial: Received broadcast quit message");
        w->quit = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

/* Proginfo now attached as a submenu window; warn handler no longer needed */

static void poll_idle(void)
{
    _kernel_swi_regs regs;
    Desk_event_pollblock event;
    int earliest;

    /* Get current monotonic time and add delay */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    earliest = regs.r[0] + SERIAL_POLL_DELAY;

    /* Poll with idle time */
    Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
    Desk_Event_Process(&event);
}

/* ******************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int main(void)
{
    char menu_title[32];
    char menu_items[64];

    /* Initialise Wimp state */
    wimp.quit = Desk_bool_FALSE;

    /* Initialise debug */
    debug_initialise();
    debug_printf("serial: Starting Serial Handler");

    /* Initialise DeskLib */
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");

    Desk_Event_Initialise("Serial Server");
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();

    /* Set up event handlers */
    Desk_EventMsg_Claim(Desk_message_MODECHANGE, Desk_event_ANY, Desk_Handler_ModeChange, NULL);
    Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_BROADCAST, Desk_event_ANY, handle_broadcast_message, &wimp);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, handle_null_event, NULL);
    Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY, handle_menu_selection, &wimp);

    /* Create iconbar icon */
    wimp.iconbar_icon = Desk_Icon_BarIcon("!serial", Desk_iconbar_RIGHT);
    debug_printf("serial: Created iconbar icon, handle=%d", (int)wimp.iconbar_icon);
    if (wimp.iconbar_icon >= 0)
    {
        Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, wimp.iconbar_icon,
                         handle_iconbar_click, &wimp);
        debug_printf("serial: Claimed CLICK event for iconbar");
    }
    else
    {
        debug_printf("serial: Failed to create iconbar icon, skipping click claim");
    }
    /* Create iconbar menu */
    Desk_Msgs_Lookup("ser.ibmt", menu_title, sizeof(menu_title));
    Desk_Msgs_Lookup("ser.ibm", menu_items, sizeof(menu_items));

    if (menu_title[0] == '\0')
    {
        strcpy(menu_title, "Serial Server");
    }
    if (menu_items[0] == '\0')
    {
        strcpy(menu_items, "Info,Quit");
    }

    wimp.iconbar_menu = Desk_Menu_New(menu_title, menu_items);

    /* Load templates and create windows */
    Desk_Template_Initialise();
    Desk_Template_UseOutlineFonts();
    Desk_Template_LoadFile("Templates");

    /* Load status window sprites */
    {
        int sprite_size = Desk_File_Size("<Converse$Dir>.Resources.Sprites");
        if (sprite_size > 0)
        {
            status_sprites = (Desk_sprite_area)malloc(sprite_size + 4);
            if (status_sprites)
            {
                status_sprites->areasize = sprite_size + 4;
                status_sprites->numsprites = 0;
                status_sprites->firstoffset = 16;
                status_sprites->freeoffset = 16;
                Desk_Sprite_Load(status_sprites, "<Converse$Dir>.Resources.Sprites");
                Desk_Template_LinkSpriteArea("serial", status_sprites);
                debug_printf("serial: Loaded sprites, %d sprites in area", status_sprites->numsprites);
            }
        }
    }

    proginfo_window = Desk_Window_Create("proginfo", Desk_template_TITLEMIN);
      Desk_Icon_SetText(proginfo_window, 0, app_name);  /* PROGINFO_VERSION = 5 */
    Desk_Icon_SetText(proginfo_window, 5, wimp_version);  /* PROGINFO_VERSION = 5 */
     Desk_Icon_SetText(proginfo_window, 6, app_purpose);  /* PROGINFO_VERSION = 5 */
    wimp.status_window = Desk_Window_Create("serial", Desk_template_TITLEMIN);
    
    debug_printf("serial: Created windows: proginfo=%d, status=%d", 
                 (int)proginfo_window, (int)wimp.status_window);
    
    if (wimp.iconbar_menu != NULL && proginfo_window != 0)
    {
        /* Attach proginfo as submenu of Info entry (matches FTN approach) */
        Desk_Menu_AddSubMenu(wimp.iconbar_menu, ICONBAR_MENU_INFO, (Desk_menu_ptr)proginfo_window);
    }

    /* Handle redraws for status window explicitly (template is not autoredraw) */
    if (wimp.status_window != 0)
    {
        Desk_Event_Claim(Desk_event_REDRAW, wimp.status_window, Desk_event_ANY,
                         Desk_Handler_NullRedraw, NULL);
        
        /* Handle clicks on status window buttons */
        Desk_Event_Claim(Desk_event_CLICK, wimp.status_window, Desk_event_ANY,
                         handle_status_click, &wimp);
    }
    
    /* Terminal window event handlers - claim for ANY window, handlers check window */
    Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY,
                     handle_terminal_redraw, NULL);
    Desk_Event_Claim(Desk_event_KEY, Desk_event_ANY, Desk_event_ANY,
                     handle_terminal_key, NULL);
    
    /* Handle open/close events for all windows - required for dragging */
    Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY,
                     handle_window_open, NULL);
    Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY,
                     handle_window_close, NULL);

    /* Load serial line configuration from Support module */
    load_serial_lines();

    /* Create dynamic status window icons */
    if (wimp.status_window != 0)
    {
        debug_printf("serial: Creating status icons, line_count=%d", serial_line_count);
        if (serial_line_count > 0)
        {
            if (serialstatus_create_icons())
            {
                debug_printf("serial: Icons created successfully");
            }
            else
            {
                debug_printf("serial: Icon creation failed");
            }
        }
        debug_printf("serial: Setting extent");
        serialstatus_set_extent();
        debug_printf("serial: Extent set");
    }

    /* Initialise all serial ports */
    serial_init_all();

    serial_log("Serial handler started with %d lines", serial_line_count);
    debug_printf("serial: Entering main loop");

    /* Main event loop */
    while (wimp.quit == Desk_bool_FALSE)
    {
        poll_idle();
    }

    debug_printf("serial: Main loop exited, quit=%d", (int)wimp.quit);

    /* Shutdown */
    serial_close_all();
    serialstatus_free_icons();
    serial_log("Serial handler stopped");

    debug_printf("serial: Serial Handler shutdown complete");
    debug_finalise();

    Desk_Template_ClearAll();

    return 0;
}
