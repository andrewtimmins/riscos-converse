/* ******************************************************************************************************************************************************** */
/* Serial Handler - Main Module                                                                                                                             */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"
#include "C:Desk.Error.h"
#include "C:Desk.Error.h"

/* Our Includes */
#include "main.h"
#include "serial.h"
#include "debug.h"

/* ******************************************************************************************************************************************************** */
/* Global Variables                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

WIMP_STATE wimp;
SERIAL_LINE_STATE serial_lines[SERIAL_MAX_LINES];
int serial_line_count = 0;

SERIAL_STATUS_ROW *serial_status_rows = NULL;
int serial_status_row_count = 0;

static Desk_window_handle proginfo_window;

/* Menu indices */
enum
{
    ICONBAR_MENU_INFO = 0,
    ICONBAR_MENU_QUIT
};

/* Forward declarations for handlers used before definition */
static Desk_bool handle_menu_selection(Desk_event_pollblock *event, void *ref);

/* ******************************************************************************************************************************************************** */
/* Utility Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

void serial_log(const char *format, ...)
{
    char buffer[256];
    va_list args;
    _kernel_swi_regs regs;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    regs.r[0] = FILER_LOG_CMD_SERIAL;
    regs.r[1] = (int)buffer;
    _kernel_swi(SWI_FILER_LOGGING, &regs, &regs);

    debug_printf("Serial: %s", buffer);
}

/* ******************************************************************************************************************************************************** */
/* Pipe Helper Functions                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

int pipes_input_status(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_STATUS, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int pipes_input_write_block(int line_id, const char *buffer, int length)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = (int)buffer;
    regs.r[2] = length;
    if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_WRITE_BLOCK, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int pipes_output_read_block(int line_id, char *buffer, int length)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = (int)buffer;
    regs.r[2] = length;
    if (_kernel_swi(SWI_CONVERSE_PIPES_OUTPUT_READ_BLOCK, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

void pipes_reset_line(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    _kernel_swi(SWI_CONVERSE_PIPES_RESET_STATE, &regs, &regs);
    regs.r[0] = line_id;
    _kernel_swi(SWI_CONVERSE_PIPES_CLEAR_INPUT, &regs, &regs);
    regs.r[0] = line_id;
    _kernel_swi(SWI_CONVERSE_PIPES_CLEAR_OUTPUT, &regs, &regs);
}

void pipes_send_control_command(int line_id, char command)
{
    unsigned char frame[3];

    frame[0] = PIPE_CONTROL_TOKEN;
    frame[1] = (unsigned char)command;
    frame[2] = PIPE_CONTROL_TOKEN;
    pipes_input_write_block(line_id, (const char *)frame, sizeof(frame));
}

/* ******************************************************************************************************************************************************** */
/* Support Module Helper Functions                                                                                                                          */
/* ******************************************************************************************************************************************************** */

void support_set_line_connected(int line_id, int connected)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_CONNECTED;
    regs.r[3] = connected;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

void support_set_line_hostname(int line_id, const char *hostname)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_HOSTNAME;
    regs.r[3] = (int)hostname;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

void support_set_line_connect_time(int line_id, time_t connect_time)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_CONNECT_TIME;
    regs.r[3] = (int)connect_time;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

int support_get_line_type(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINE_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_TYPE;
    if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int support_get_serial_config(int line_id, SERIAL_LINE_CONFIG *config)
{
    _kernel_swi_regs regs;
    SERIAL_LINE_CONFIG *src;

    if (config == NULL)
    {
        return -1;
    }

    regs.r[0] = 0;  /* SERIAL_CONFIG_REASON_GET */
    regs.r[1] = line_id;
    if (_kernel_swi(SWI_CONVERSEBBS_SERIAL_CONFIG, &regs, &regs) != NULL)
    {
        return -1;
    }

    src = (SERIAL_LINE_CONFIG *)regs.r[0];
    if (src == NULL)
    {
        return -1;
    }

    memcpy(config, src, sizeof(SERIAL_LINE_CONFIG));
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Wimp Message Sending                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

void send_serial_connect_message(int line_id)
{
    Desk_message_block msg;

    memset(&msg, 0, sizeof(msg));
    msg.header.size = 24;
    msg.header.yourref = 0;
    msg.header.action = MESSAGE_SERIAL_CONNECT;
    msg.data.words[0] = line_id;

    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, 0, 0);

    debug_printf("serial: Sent MESSAGE_SERIAL_CONNECT for line %d", line_id);
}

void send_serial_disconnect_message(int line_id)
{
    Desk_message_block msg;

    memset(&msg, 0, sizeof(msg));
    msg.header.size = 24;
    msg.header.yourref = 0;
    msg.header.action = MESSAGE_SERIAL_DISCONNECT;
    msg.data.words[0] = line_id;

    Desk_Wimp_SendMessage(Desk_event_SEND, &msg, 0, 0);

    debug_printf("serial: Sent MESSAGE_SERIAL_DISCONNECT for line %d", line_id);
}

/* ******************************************************************************************************************************************************** */
/* Line Configuration Loading                                                                                                                               */
/* ******************************************************************************************************************************************************** */

static void load_serial_lines(void)
{
    int line_id;
    SERIAL_LINE_CONFIG config;
    int line_type;

    serial_line_count = 0;
    memset(serial_lines, 0, sizeof(serial_lines));

    debug_printf("serial: Scanning for serial lines...");

    /* Scan all possible lines looking for serial types */
    for (line_id = 0; line_id < SERIAL_MAX_LINES; line_id++)
    {
        /* Check if this line is configured as serial */
        line_type = support_get_line_type(line_id);
        
        if (line_type == LINE_TYPE_SERIAL)
        {
            /* Get the serial config for this line */
            if (support_get_serial_config(line_id, &config) == 0 && config.enabled)
            {
                debug_printf("serial: Found serial line %d: driver=%s port=%d speed=%d",
                             line_id, config.driver_name, config.port_number, config.baud_rate);

                serial_lines[serial_line_count].line_id = line_id;
                serial_lines[serial_line_count].enabled = 1;
                serial_lines[serial_line_count].driver = NULL;
                serial_lines[serial_line_count].port_number = config.port_number;
                serial_lines[serial_line_count].baud_rate = config.baud_rate;
                serial_lines[serial_line_count].word_format = config.word_format;
                serial_lines[serial_line_count].flow_control = config.flow_control;
                serial_lines[serial_line_count].rings = (config.rings <= 0) ? 1 : config.rings;
                serial_lines[serial_line_count].carrier_detect = 0;
                strncpy(serial_lines[serial_line_count].init, config.init,
                    sizeof(serial_lines[serial_line_count].init) - 1);
                serial_lines[serial_line_count].init[sizeof(serial_lines[serial_line_count].init) - 1] = '\0';
                strncpy(serial_lines[serial_line_count].ring, config.ring,
                    sizeof(serial_lines[serial_line_count].ring) - 1);
                serial_lines[serial_line_count].ring[sizeof(serial_lines[serial_line_count].ring) - 1] = '\0';
                strncpy(serial_lines[serial_line_count].answer, config.answer,
                    sizeof(serial_lines[serial_line_count].answer) - 1);
                serial_lines[serial_line_count].answer[sizeof(serial_lines[serial_line_count].answer) - 1] = '\0';
                serial_lines[serial_line_count].ring_count = 0;
                serial_lines[serial_line_count].ring_match_index = 0;
                serial_lines[serial_line_count].last_activity = 0;
                strncpy(serial_lines[serial_line_count].driver_name, config.driver_name,
                        sizeof(serial_lines[serial_line_count].driver_name) - 1);
                serial_lines[serial_line_count].driver_name[sizeof(serial_lines[serial_line_count].driver_name) - 1] = '\0';

                serial_line_count++;
            }
        }
    }

    debug_printf("serial: Found %d serial lines", serial_line_count);
    serial_log("Found %d serial lines", serial_line_count);
}

/* ******************************************************************************************************************************************************** */
/* Status Window Functions                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

int serialstatus_icon_index(int line_index, int column)
{
    return SERIALSTATUS_ICON_BASE + (line_index * SERIALSTATUS_ICONS_PER_LINE) + column;
}

int serialstatus_create_icons(void)
{
    Desk_icon_createblock icon_create;
    Desk_icon_handle icon_handle;
    int row;
    int y_base;
    int column_x;
    SERIAL_STATUS_ROW *icons;
    
    if (serial_line_count <= 0)
    {
        debug_printf("serialstatus: No serial lines, skipping icon creation");
        return 1;
    }
    
    /* Allocate row array */
    serial_status_rows = malloc(serial_line_count * sizeof(SERIAL_STATUS_ROW));
    if (serial_status_rows == NULL)
    {
        debug_printf("serialstatus: Failed to allocate row array");
        return 0;
    }
    
    serial_status_row_count = serial_line_count;
    memset(serial_status_rows, 0, serial_line_count * sizeof(SERIAL_STATUS_ROW));
    
    icon_create.window = wimp.status_window;
    y_base = -((SERIALSTATUS_TOP_STATIC_ROWS * SERIALSTATUS_ICON_HEIGHT) + SERIALSTATUS_PADDING);
    
    for (row = 0; row < serial_status_row_count; row++)
    {
        icons = &serial_status_rows[row];
        
        /* Allocate text buffers */
        icons->line_text = malloc(8);
        icons->status_text = malloc(64);
        
        if (icons->line_text == NULL || icons->status_text == NULL)
        {
            debug_printf("serialstatus: Failed to allocate icon buffers for row %d", row);
            return 0;
        }
        
        /* Initialize text */
        snprintf(icons->line_text, 8, "%d", serial_lines[row].line_id);
        strcpy(icons->status_text, "Initializing");
        
        /* Calculate Y position for this row */
        icon_create.icondata.workarearect.max.y = y_base - (SERIALSTATUS_ICON_HEIGHT * row);
        icon_create.icondata.workarearect.min.y = icon_create.icondata.workarearect.max.y - SERIALSTATUS_ICON_HEIGHT;
        
        column_x = SERIALSTATUS_COLUMN_START;
        
        /* Column 0: Line Number */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + SERIALSTATUS_LINE_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = icons->line_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 8;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + SERIALSTATUS_COLUMN_GAP;
        
        /* Column 1: Status */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + SERIALSTATUS_STATUS_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = icons->status_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 64;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
    }
    
    debug_printf("serialstatus: Created icons for %d rows", serial_status_row_count);
    return 1;
}

void serialstatus_free_icons(void)
{
    int i;
    
    if (serial_status_rows == NULL)
    {
        return;
    }
    
    for (i = 0; i < serial_status_row_count; i++)
    {
        if (serial_status_rows[i].line_text != NULL)
        {
            free(serial_status_rows[i].line_text);
        }
        if (serial_status_rows[i].status_text != NULL)
        {
            free(serial_status_rows[i].status_text);
        }
    }
    
    free(serial_status_rows);
    serial_status_rows = NULL;
    serial_status_row_count = 0;
}

void serialstatus_set_extent(void)
{
    Desk_wimp_box extent;
    int total_height;
    int total_width;
    int rows;
    
    /* Use at least 1 row for minimum window size */
    rows = (serial_status_row_count > 0) ? serial_status_row_count : 1;
    
    /* Calculate total height: (header rows + data rows) * row height + padding */
    total_height = ((rows + SERIALSTATUS_TOP_STATIC_ROWS) * SERIALSTATUS_ICON_HEIGHT) +
                   SERIALSTATUS_PADDING + SERIALSTATUS_BOTTOM_PADDING;
    
    /* Calculate total width: all columns + gaps between them (matching FTN mailer pattern) */
    total_width = SERIALSTATUS_COLUMN_START +
                  SERIALSTATUS_LINE_WIDTH + SERIALSTATUS_COLUMN_GAP +
                  SERIALSTATUS_STATUS_WIDTH;
    
    extent.min.x = 0;
    extent.max.x = total_width;
    extent.min.y = -total_height;
    extent.max.y = 0;
    
    Desk_Wimp_SetExtent(wimp.status_window, &extent);
}

void serialstatus_update_line(int line_index, const char *status)
{
    if (serial_status_rows == NULL || line_index < 0 || line_index >= serial_status_row_count)
    {
        return;
    }
    
    if (wimp.status_window != 0 && status != NULL)
    {
        /* Update the icon text using Desk_Icon_SetText like Server does */
        Desk_Icon_SetText(wimp.status_window,
                          serialstatus_icon_index(line_index, SERIALSTATUS_COLUMN_STATUS),
                          (char *)status);
    }
}

/* ******************************************************************************************************************************************************** */
/* Wimp Event Handlers                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

/*
 * Handle window open events - required to allow window dragging.
 */
static Desk_bool handle_window_open(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Wimp_OpenWindow(&event->data.openblock);
    return Desk_bool_TRUE;
}

/*
 * Handle window close events.
 */
static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Window_Hide(event->data.openblock.window);
    return Desk_bool_TRUE;
}

static Desk_bool handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;
    Desk_window_state state;
    int win_width, win_height;

    if (event->data.mouse.button.data.menu)
    {
        Desk_Menu_Show(w->iconbar_menu, event->data.mouse.pos.x, -1);
    }
    else if (event->data.mouse.button.data.select)
    {
        /* Open status window on SELECT click - position at bottom-left like FTN mailer */
        debug_printf("serial: Iconbar SELECT clicked, status_window=%d", (int)w->status_window);
        if (w->status_window != 0)
        {
            /* Get current window state */
            Desk_Wimp_GetWindowState(w->status_window, &state);
            win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
            win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
            
            /* Position at bottom-left, just above iconbar */
            state.openblock.screenrect.min.x = 16;
            state.openblock.screenrect.max.x = 16 + win_width;
            state.openblock.screenrect.min.y = 134;  /* Just above iconbar (128) + margin */
            state.openblock.screenrect.max.y = 134 + win_height;
            state.openblock.behind = -1;  /* Open at front */
            
            Desk_Wimp_OpenWindow(&state.openblock);
            debug_printf("serial: Window opened at bottom-left");
        }
        else
        {
            debug_printf("serial: status_window is 0, cannot show");
        }
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_menu_selection(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;

    switch (event->data.selection[0])
    {
        case ICONBAR_MENU_QUIT:
            w->quit = Desk_bool_TRUE;
            debug_printf("serial: Menu Quit selected, setting quit flag");
            break;
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_null_event(Desk_event_pollblock *event, void *ref)
{
    int i;

    Desk_UNUSED(event);
    Desk_UNUSED(ref);

    /* Poll all serial lines */
    for (i = 0; i < serial_line_count; i++)
    {
        serial_poll(i);
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_broadcast_message(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;
    int reason;

    if (event == NULL)
    {
        return Desk_bool_FALSE;
    }

    reason = event->data.message.data.words[0];

    /* Reason 0 = quit */
    if (reason == 0)
    {
        debug_printf("serial: Received broadcast quit message");
        w->quit = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

/* Proginfo now attached as a submenu window; warn handler no longer needed */

static void poll_idle(void)
{
    _kernel_swi_regs regs;
    Desk_event_pollblock event;
    int earliest;

    /* Get current monotonic time and add delay */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    earliest = regs.r[0] + SERIAL_POLL_DELAY;

    /* Poll with idle time */
    Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
    Desk_Event_Process(&event);
}

/* ******************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int main(void)
{
    char menu_title[32];
    char menu_items[64];

    /* Initialise Wimp state */
    wimp.quit = Desk_bool_FALSE;

    /* Initialise debug */
    debug_initialise();
    debug_printf("serial: Starting Serial Handler");

    /* Initialise DeskLib */
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");

    Desk_Event_Initialise("Serial Server");
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();

    /* Set up event handlers */
    Desk_EventMsg_Claim(Desk_message_MODECHANGE, Desk_event_ANY, Desk_Handler_ModeChange, NULL);
    Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_BROADCAST, Desk_event_ANY, handle_broadcast_message, &wimp);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, handle_null_event, NULL);
    Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY, handle_menu_selection, &wimp);

    /* Create iconbar icon */
    wimp.iconbar_icon = Desk_Icon_BarIcon("!serial", Desk_iconbar_RIGHT);
    debug_printf("serial: Created iconbar icon, handle=%d", (int)wimp.iconbar_icon);
    if (wimp.iconbar_icon >= 0)
    {
        Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, wimp.iconbar_icon,
                         handle_iconbar_click, &wimp);
        debug_printf("serial: Claimed CLICK event for iconbar");
    }
    else
    {
        debug_printf("serial: Failed to create iconbar icon, skipping click claim");
    }
    /* Create iconbar menu */
    Desk_Msgs_Lookup("ser.ibmt", menu_title, sizeof(menu_title));
    Desk_Msgs_Lookup("ser.ibm", menu_items, sizeof(menu_items));

    if (menu_title[0] == '\0')
    {
        strcpy(menu_title, "Serial Server");
    }
    if (menu_items[0] == '\0')
    {
        strcpy(menu_items, "Info,Quit");
    }

    wimp.iconbar_menu = Desk_Menu_New(menu_title, menu_items);

    /* Load templates and create windows */
    Desk_Template_Initialise();
    Desk_Template_UseOutlineFonts();
    Desk_Template_LoadFile("Templates");

    proginfo_window = Desk_Window_Create("proginfo", Desk_template_TITLEMIN);
    wimp.status_window = Desk_Window_Create("serial", Desk_template_TITLEMIN);
    
    debug_printf("serial: Created windows: proginfo=%d, status=%d", 
                 (int)proginfo_window, (int)wimp.status_window);
    
    if (wimp.iconbar_menu != NULL && proginfo_window != 0)
    {
        /* Attach proginfo as submenu of Info entry (matches FTN approach) */
        Desk_Menu_AddSubMenu(wimp.iconbar_menu, ICONBAR_MENU_INFO, (Desk_menu_ptr)proginfo_window);
    }

    /* Handle redraws for status window explicitly (template is not autoredraw) */
    if (wimp.status_window != 0)
    {
        Desk_Event_Claim(Desk_event_REDRAW, wimp.status_window, Desk_event_ANY,
                         Desk_Handler_NullRedraw, NULL);
    }
    
    /* Handle open/close events for all windows - required for dragging */
    Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY,
                     handle_window_open, NULL);
    Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY,
                     handle_window_close, NULL);

    /* Load serial line configuration from Support module */
    load_serial_lines();

    /* Create dynamic status window icons */
    if (wimp.status_window != 0)
    {
        debug_printf("serial: Creating status icons, line_count=%d", serial_line_count);
        if (serial_line_count > 0)
        {
            if (serialstatus_create_icons())
            {
                debug_printf("serial: Icons created successfully");
            }
            else
            {
                debug_printf("serial: Icon creation failed");
            }
        }
        debug_printf("serial: Setting extent");
        serialstatus_set_extent();
        debug_printf("serial: Extent set");
    }

    /* Initialise all serial ports */
    serial_init_all();

    serial_log("Serial handler started with %d lines", serial_line_count);
    debug_printf("serial: Entering main loop");

    /* Main event loop */
    while (wimp.quit == Desk_bool_FALSE)
    {
        poll_idle();
    }

    debug_printf("serial: Main loop exited, quit=%d", (int)wimp.quit);

    /* Shutdown */
    serial_close_all();
    serialstatus_free_icons();
    serial_log("Serial handler stopped");

    debug_printf("serial: Serial Handler shutdown complete");
    debug_finalise();

    Desk_Template_ClearAll();

    return 0;
}
