/* ******************************************************************************************************************************************************** */
/* Serial Handler - BlockDriver Support                                                                                                                     */
/* ******************************************************************************************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "main.h"
#include "serial.h"
#include "ansiterm.h"
#include "debug.h"

/* ============================================================================
 * Static Data
 * ============================================================================ */

/* Driver cache - supports multiple different drivers */
static SERIAL_DRIVER_CACHE_ENTRY driver_cache[SERIAL_MAX_DRIVERS];
static int driver_cache_initialised = 0;

/* ============================================================================
 * Helpers
 * ============================================================================ */

static void serial_reset_ring_state(SERIAL_LINE_STATE *line)
{
    if (line == NULL)
    {
        return;
    }
    line->ring_count = 0;
    line->ring_match_index = 0;
    line->last_ring_time = 0;
}

static void serial_reset_escape_state(SERIAL_LINE_STATE *line)
{
    if (line == NULL)
    {
        return;
    }
    line->escape_plus_count = 0;
    line->escape_silence_start = 0;
    line->escape_guard_active = 0;
}

static void serial_init_driver_cache(void)
{
    int i;
    if (driver_cache_initialised)
    {
        return;
    }
    for (i = 0; i < SERIAL_MAX_DRIVERS; i++)
    {
        driver_cache[i].name[0] = '\0';
        driver_cache[i].entry = NULL;
        driver_cache[i].loaded = 0;
    }
    driver_cache_initialised = 1;
}

static void serial_send_command(int line_index, const char *command)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    char buffer[128];
    size_t len;

    if (line_index < 0 || line_index >= serial_line_count || command == NULL)
    {
        return;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL || command[0] == '\0')
    {
        return;
    }

    snprintf(buffer, sizeof(buffer), "%s\r", command);
    len = strlen(buffer);
    (*driver)(DRIVER_PUTBLOCK, port, buffer, (int)len);
    /* Only log commands when not connected to reduce verbosity */
    if (!line->carrier_detect)
    {
        debug_printf("serial: Line %d sent command '%s'", line->line_id, command);
    }
}

/* ============================================================================
 * BlockDriver Loading
 * ============================================================================ */

int serial_load_driver(const char *name, int (**driver_out)(int, ...))
{
    FILE *drv;
    long len;
    char path[256];
    int i;
    int free_slot = -1;
    SERIAL_DRIVER_CACHE_ENTRY *entry;

    if (name == NULL || driver_out == NULL)
    {
        return -1;
    }

    *driver_out = NULL;

    /* Initialise cache if needed */
    serial_init_driver_cache();

    /* Check if driver is already loaded in cache */
    for (i = 0; i < SERIAL_MAX_DRIVERS; i++)
    {
        if (driver_cache[i].loaded && strcmp(driver_cache[i].name, name) == 0)
        {
            /* Already loaded - return cached entry */
            *driver_out = driver_cache[i].entry;
            debug_printf("serial: Driver '%s' found in cache (slot %d)", name, i);
            return 0;
        }
        if (!driver_cache[i].loaded && free_slot < 0)
        {
            free_slot = i;
        }
    }

    /* Need to load driver - find a free slot */
    if (free_slot < 0)
    {
        debug_printf("serial: Driver cache full, cannot load '%s'", name);
        serial_log("Driver cache full (max %d), cannot load '%s'", SERIAL_MAX_DRIVERS, name);
        return -1;
    }

    entry = &driver_cache[free_slot];

    /* Build path to driver file */
    snprintf(path, sizeof(path), "<SerialDev$Path>Modules.%s.Driver", name);
    
    debug_printf("serial: Loading driver from %s (slot %d)", path, free_slot);

    drv = fopen(path, "rb");
    if (drv == NULL)
    {
        debug_printf("serial: Failed to open driver file");
        return -1;
    }

    /* Get file length */
    fseek(drv, 0, SEEK_END);
    len = ftell(drv);
    fseek(drv, 0, SEEK_SET);

    if (len > (long)(SERIAL_DRIVER_BLOCK_SIZE * sizeof(int)))
    {
        debug_printf("serial: Driver too large (%ld bytes, max %d)", len,
                     (int)(SERIAL_DRIVER_BLOCK_SIZE * sizeof(int)));
        fclose(drv);
        return -1;
    }

    /* Load driver into cache slot */
    if (fread(entry->block, 1, len, drv) != (size_t)len)
    {
        debug_printf("serial: Failed to read driver");
        fclose(drv);
        return -1;
    }
    fclose(drv);

    /* Store driver info in cache */
    strncpy(entry->name, name, sizeof(entry->name) - 1);
    entry->name[sizeof(entry->name) - 1] = '\0';
    entry->entry = (int (*)(int, ...))entry->block;
    entry->loaded = 1;

    *driver_out = entry->entry;

    debug_printf("serial: Driver '%s' loaded successfully (%ld bytes, slot %d)", name, len, free_slot);
    serial_log("Loaded BlockDriver '%s' (%ld bytes)", name, len);
    
    return 0;
}

/* ============================================================================
 * Port Configuration
 * ============================================================================ */

int serial_parse_word_format(const char *format)
{
    if (format == NULL)
    {
        return WORDFORMAT_8N1;
    }

    if (strcmp(format, "8N1") == 0 || strcmp(format, "8n1") == 0)
    {
        return WORDFORMAT_8N1;
    }
    if (strcmp(format, "8N2") == 0 || strcmp(format, "8n2") == 0)
    {
        return WORDFORMAT_8N2;
    }
    if (strcmp(format, "8E1") == 0 || strcmp(format, "8e1") == 0)
    {
        return WORDFORMAT_8E1;
    }
    if (strcmp(format, "8O1") == 0 || strcmp(format, "8o1") == 0)
    {
        return WORDFORMAT_8O1;
    }
    if (strcmp(format, "7E1") == 0 || strcmp(format, "7e1") == 0)
    {
        return WORDFORMAT_7E1;
    }
    if (strcmp(format, "7O1") == 0 || strcmp(format, "7o1") == 0)
    {
        return WORDFORMAT_7O1;
    }
    if (strcmp(format, "7N1") == 0 || strcmp(format, "7n1") == 0)
    {
        return WORDFORMAT_7N1;
    }
    if (strcmp(format, "7N2") == 0 || strcmp(format, "7n2") == 0)
    {
        return WORDFORMAT_7N2;
    }

    return WORDFORMAT_8N1;
}

int serial_parse_flow_control(const char *flow)
{
    if (flow == NULL)
    {
        return FLOWCONTROL_RTSCTS;
    }

    if (strcmp(flow, "none") == 0 || strcmp(flow, "NONE") == 0)
    {
        return FLOWCONTROL_NONE;
    }
    if (strcmp(flow, "xonxoff") == 0 || strcmp(flow, "XONXOFF") == 0 ||
        strcmp(flow, "xon") == 0 || strcmp(flow, "software") == 0)
    {
        return FLOWCONTROL_XONXOFF;
    }
    if (strcmp(flow, "rtscts") == 0 || strcmp(flow, "RTSCTS") == 0 ||
        strcmp(flow, "hardware") == 0 || strcmp(flow, "cts") == 0 ||
        strcmp(flow, "rts") == 0 || strcmp(flow, "RTS") == 0)
    {
        return FLOWCONTROL_RTSCTS;
    }
    if (strcmp(flow, "dtrdsr") == 0 || strcmp(flow, "DTRDSR") == 0 ||
        strcmp(flow, "dtr") == 0 || strcmp(flow, "DTR") == 0)
    {
        return FLOWCONTROL_DTRDSR;
    }

    return FLOWCONTROL_RTSCTS;
}

/* ============================================================================
 * Port Initialisation
 * ============================================================================ */

int serial_init_port(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    int result;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return -1;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        debug_printf("serial: Line index %d has no driver loaded", line_index);
        return -1;
    }

    debug_printf("serial: Initialising port %d for line %d", port, line->line_id);

    /* Initialise the port */
    result = (*driver)(DRIVER_INITIALISE, port);
    if (result != 0)
    {
        debug_printf("serial: DRIVER_INITIALISE failed with %d", result);
        return -1;
    }

    /* Set baud rate */
    (*driver)(DRIVER_TXSPEED, port, line->baud_rate);
    (*driver)(DRIVER_RXSPEED, port, line->baud_rate);
    debug_printf("serial: Set baud rate to %d", line->baud_rate);

    /* Set word format */
    (*driver)(DRIVER_WORDFORMAT, port, line->word_format);
    debug_printf("serial: Set word format to %d", line->word_format);

    /* Set flow control */
    (*driver)(DRIVER_FLOWCONTROL, port, line->flow_control);
    debug_printf("serial: Set flow control to %d", line->flow_control);

    /* Flush any stale data */
    (*driver)(DRIVER_FLUSHRX, port);
    (*driver)(DRIVER_FLUSHTX, port);

    /* Initialise carrier detect state */
    line->carrier_detect = 0;

    /* Reset ring detection counters */
    serial_reset_ring_state(line);

    /* Reset escape sequence guard state */
    serial_reset_escape_state(line);

    /* Apply modem init string if provided */
    if (line->init[0] != '\0')
    {
        serial_send_command(line_index, line->init);
    }

    debug_printf("serial: Port %d initialised successfully", port);
    
    return 0;
}

void serial_close_port(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        return;
    }

    debug_printf("serial: Closing port %d for line %d", port, line->line_id);

    (*driver)(DRIVER_CLOSEDOWN, port);
}

/* ============================================================================
 * Carrier Detection
 * ============================================================================ */

int serial_check_carrier(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    int modem_status;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return 0;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        return 0;
    }

    modem_status = (*driver)(DRIVER_MODEMCONTROL, port);
    
    return (modem_status & MODEM_DCD) ? 1 : 0;
}

/* ============================================================================
 * Connection Handling
 * ============================================================================ */

void serial_handle_connect(int line_index)
{
    SERIAL_LINE_STATE *line;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];

    debug_printf("serial: Line %d - carrier detected (DCD rise)", line->line_id);
    serial_log("Line %d: Carrier detected", line->line_id);

    /* Clear any pending serial write buffer from previous connection */
    line->pending_serial_length = 0;
    line->pending_serial_offset = 0;

    /* Reset escape sequence guard for new connection */
    serial_reset_escape_state(line);

    /* Reset pipes and send connect frame */
    pipes_reset_line(line->line_id);
    pipes_send_control_command(line->line_id, PIPE_CONTROL_CONNECT);

    /* Update line state */
    line->last_activity = clock();

    /* Update Support module */
    support_set_line_connected(line->line_id, 1);
    support_set_line_hostname(line->line_id, "SERIAL");
    support_set_line_connect_time(line->line_id, time(NULL));

    /* Send Wimp message to Server */
    send_serial_connect_message(line->line_id);
}

void serial_handle_disconnect(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    debug_printf("serial: Line %d - carrier lost (DCD fall)", line->line_id);
    serial_log("Line %d: Carrier lost", line->line_id);

    /* Drain any pending serial write buffer (can't send, but clear it) */
    line->pending_serial_length = 0;
    line->pending_serial_offset = 0;

    /* Drain the output pipe so LineTask doesn't see stale data on reconnect */
    {
        char drain_buffer[PIPE_TRANSFER_CHUNK];
        int drain_loops = 0;
        while (drain_loops < 20 &&
               pipes_output_read_block(line->line_id, drain_buffer, PIPE_TRANSFER_CHUNK) > 0)
        {
            drain_loops++;
        }
    }

    /* Send disconnect frame */
    pipes_send_control_command(line->line_id, PIPE_CONTROL_DISCONNECT);

    /* Flush hardware buffers */
    if (driver != NULL)
    {
        (*driver)(DRIVER_FLUSHRX, port);
        (*driver)(DRIVER_FLUSHTX, port);
    }

    /* Update line state */
    line->last_activity = 0;
    serial_reset_ring_state(line);

    /* Update Support module */
    support_set_line_connected(line->line_id, 0);

    /* Send Wimp message to Server */
    send_serial_disconnect_message(line->line_id);

    /* Reapply modem init so the port is ready for the next call */
    if (line->init[0] != '\0')
    {
        serial_send_command(line_index, line->init);
    }
}

/* ============================================================================
 * Ring Detection / Auto-Answer
 * ============================================================================ */

static void serial_scan_for_ring(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    char buffer[64];
    int rx_waiting;
    int to_read;
    int read_bytes;
    int i;
    int rings_needed;
    clock_t now;
    _kernel_swi_regs regs;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL || line->ring[0] == '\0')
    {
        return;
    }

    /* Get current time for ring timeout check */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    now = (clock_t)regs.r[0];

    /* Check for ring count timeout - reset if no ring detected recently */
    if (line->ring_count > 0 && line->last_ring_time > 0)
    {
        clock_t elapsed = now - line->last_ring_time;
        if (elapsed > RING_TIMEOUT_CS)
        {
            debug_printf("serial: Line %d ring timeout (elapsed %ld cs), resetting count",
                         line->line_id, (long)elapsed);
            serial_reset_ring_state(line);
            serialstatus_update_line(line_index, "Idle");
        }
    }

    rx_waiting = (*driver)(DRIVER_CHECKRX, port);
    if (rx_waiting <= 0)
    {
        return;
    }

    to_read = rx_waiting;
    if (to_read > (int)sizeof(buffer))
    {
        to_read = (int)sizeof(buffer);
    }

    read_bytes = (*driver)(DRIVER_GETBLOCK, port, buffer, to_read);
    if (read_bytes <= 0)
    {
        return;
    }

    rings_needed = (line->rings <= 0) ? 1 : line->rings;

    for (i = 0; i < read_bytes; i++)
    {
        char ch = buffer[i];
        if (ch == line->ring[line->ring_match_index])
        {
            line->ring_match_index++;
            if (line->ring[line->ring_match_index] == '\0')
            {
                /* Full match - record ring time */
                line->ring_count++;
                line->last_ring_time = now;
                line->ring_match_index = 0;
                debug_printf("serial: Line %d detected ring (%d/%d)", line->line_id, line->ring_count, rings_needed);

                if (line->ring_count >= rings_needed)
                {
                    serialstatus_update_line(line_index, "Answering...");
                    serial_send_command(line_index, (line->answer[0] != '\0') ? line->answer : "ATA");
                    line->ring_count = 0;
                    line->last_ring_time = 0;
                }
                else
                {
                    char ring_status[32];
                    snprintf(ring_status, sizeof(ring_status), "Ringing (%d/%d)", line->ring_count, rings_needed);
                    serialstatus_update_line(line_index, ring_status);
                }
            }
        }
        else
        {
            /* Mismatch - use KMP-style backtracking for overlapping patterns */
            /* Check if we can continue matching from a partial overlap */
            int new_index = 0;
            if (line->ring_match_index > 0)
            {
                /* Try to find longest prefix of ring that is also a suffix of what we matched */
                int k;
                for (k = line->ring_match_index - 1; k > 0; k--)
                {
                    /* Check if ring[0..k-1] matches ring[match_index-k..match_index-1] */
                    int matches = 1;
                    int j;
                    for (j = 0; j < k; j++)
                    {
                        if (line->ring[j] != line->ring[line->ring_match_index - k + j])
                        {
                            matches = 0;
                            break;
                        }
                    }
                    if (matches && ch == line->ring[k])
                    {
                        new_index = k + 1;
                        break;
                    }
                }
            }
            /* If no partial match found, check if current char starts new match */
            if (new_index == 0 && ch == line->ring[0])
            {
                new_index = 1;
            }
            line->ring_match_index = new_index;
        }
    }
}

/* ============================================================================
 * +++ Escape Sequence Guard
 * Hayes modems use silence-+++-silence to escape to command mode.
 * We detect this pattern in incoming data and break it up to prevent
 * a malicious remote user from dropping the modem to command mode.
 * ============================================================================ */

static int serial_check_escape_sequence(SERIAL_LINE_STATE *line, const char *buffer, int length)
{
    _kernel_swi_regs regs;
    clock_t now;
    int i;
    int escape_detected = 0;

    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    now = (clock_t)regs.r[0];

    for (i = 0; i < length; i++)
    {
        char ch = buffer[i];

        if (ch == '+')
        {
            if (line->escape_plus_count == 0)
            {
                /* First '+' - check if we had guard time silence */
                if (line->escape_silence_start > 0 &&
                    (now - line->escape_silence_start) >= ESCAPE_GUARD_TIME_CS)
                {
                    line->escape_guard_active = 1;
                }
            }

            if (line->escape_guard_active)
            {
                line->escape_plus_count++;
                if (line->escape_plus_count >= 3)
                {
                    /* Potential +++ detected during guard period */
                    escape_detected = 1;
                    debug_printf("serial: Line %d detected +++ escape attempt, breaking sequence",
                                 line->line_id);
                    serial_log("Line %d: Blocked +++ escape sequence attempt", line->line_id);
                }
            }
        }
        else
        {
            /* Non-'+' character breaks the escape sequence */
            line->escape_plus_count = 0;
            line->escape_guard_active = 0;
        }

        /* Track silence for guard time detection */
        line->escape_silence_start = now;
    }

    return escape_detected;
}

/* ============================================================================
 * Data Pumping
 * ============================================================================ */

void serial_pump_to_pipe(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    char buffer[PIPE_TRANSFER_CHUNK];
    int rx_waiting;
    int pipe_free;
    int to_read;
    int read_bytes;
    int iteration = 0;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        return;
    }

    while (iteration < 4)
    {
        /* Check how much data is waiting in serial RX buffer */
        rx_waiting = (*driver)(DRIVER_CHECKRX, port);
        if (rx_waiting <= 0)
        {
            return;
        }

        /* Check how much space in pipe */
        pipe_free = PIPES_BUFFER_CAPACITY - pipes_input_status(line->line_id);
        if (pipe_free <= 0)
        {
            return;
        }

        /* Calculate how much to transfer */
        to_read = rx_waiting;
        if (to_read > pipe_free)
        {
            to_read = pipe_free;
        }
        if (to_read > PIPE_TRANSFER_CHUNK)
        {
            to_read = PIPE_TRANSFER_CHUNK;
        }

        /* Read from serial */
        read_bytes = (*driver)(DRIVER_GETBLOCK, port, buffer, to_read);
        if (read_bytes <= 0)
        {
            return;
        }

        /* Check for +++ escape sequence attempt from remote user */
        if (serial_check_escape_sequence(line, buffer, read_bytes))
        {
            /* Escape sequence detected - insert a NUL byte into the stream
               to break the timing window and prevent modem command mode */
            int (*drv)(int, ...) = line->driver;
            int p = line->port_number;
            (*drv)(DRIVER_PUTBYTE, p, 0);  /* Send a character to break the silence */
        }

        /* Write to pipe - handle partial writes */
        {
            int offset = 0;
            while (offset < read_bytes)
            {
                int written = pipes_input_write_block(line->line_id, buffer + offset, read_bytes - offset);
                if (written <= 0)
                {
                    /* Pipe full - put remaining data back into serial RX buffer is not possible,
                       so we must drop it. Log this rare condition. */
                    debug_printf("serial: Line %d dropped %d bytes (pipe full)",
                                 line->line_id, read_bytes - offset);
                    break;
                }
                offset += written;
            }
        }
        line->last_activity = clock();

        if (read_bytes < to_read)
        {
            break;
        }

        iteration++;
    }
}

void serial_pump_from_pipe(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    char buffer[PIPE_TRANSFER_CHUNK];
    int tx_free;
    int copied;
    int written;
    int loops = 0;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];
    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        return;
    }

    /* First, flush any pending data from a previous partial write */
    while (line->pending_serial_length > 0)
    {
        int remaining = line->pending_serial_length - line->pending_serial_offset;
        tx_free = (*driver)(DRIVER_CHECKTX, port);
        if (tx_free <= 0)
        {
            return;  /* TX buffer still full, try again next poll */
        }
        if (remaining > tx_free)
        {
            remaining = tx_free;
        }
        written = (*driver)(DRIVER_PUTBLOCK, port,
            line->pending_serial + line->pending_serial_offset, remaining);
        if (written <= 0)
        {
            return;  /* Can't write, try again next poll */
        }
        line->pending_serial_offset += written;
        if (line->pending_serial_offset >= line->pending_serial_length)
        {
            /* Pending buffer fully written */
            line->pending_serial_length = 0;
            line->pending_serial_offset = 0;
        }
        line->last_activity = clock();
    }

    /* Now read new data from pipe and write to serial */
    while (loops < 4)
    {
        /* Check how much space in serial TX buffer */
        tx_free = (*driver)(DRIVER_CHECKTX, port);
        if (tx_free <= 0)
        {
            return;
        }

        if (tx_free > PIPE_TRANSFER_CHUNK)
        {
            tx_free = PIPE_TRANSFER_CHUNK;
        }

        /* Read from pipe */
        copied = pipes_output_read_block(line->line_id, buffer, tx_free);
        if (copied <= 0)
        {
            return;
        }

        /* Write to serial */
        written = (*driver)(DRIVER_PUTBLOCK, port, buffer, copied);
        if (written <= 0)
        {
            /* TX buffer blocked - save all data to pending buffer */
            if (copied <= PIPE_TRANSFER_CHUNK)
            {
                memcpy(line->pending_serial, buffer, copied);
                line->pending_serial_offset = 0;
                line->pending_serial_length = copied;
            }
            return;
        }
        else if (written < copied)
        {
            /* Partial write - save remainder to pending buffer */
            int remaining = copied - written;
            memcpy(line->pending_serial, buffer + written, remaining);
            line->pending_serial_offset = 0;
            line->pending_serial_length = remaining;
            line->last_activity = clock();
            return;
        }

        line->last_activity = clock();

        if (copied < tx_free)
        {
            break;
        }

        loops++;
    }
}

/* ============================================================================
 * Terminal Mode Data Pumping
 * ============================================================================ */

void serial_pump_to_terminal(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    unsigned char buffer[PIPE_TRANSFER_CHUNK];
    int rx_waiting;
    int to_read;
    int read_bytes;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];
    
    if (!line->terminal_active || line->terminal == NULL)
    {
        return;
    }

    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        return;
    }

    /* Check how much data is waiting in serial RX buffer */
    rx_waiting = (*driver)(DRIVER_CHECKRX, port);
    if (rx_waiting <= 0)
    {
        return;
    }

    /* Limit to buffer size */
    to_read = rx_waiting;
    if (to_read > PIPE_TRANSFER_CHUNK)
    {
        to_read = PIPE_TRANSFER_CHUNK;
    }

    /* Read from serial */
    read_bytes = (*driver)(DRIVER_GETBLOCK, port, buffer, to_read);
    if (read_bytes <= 0)
    {
        return;
    }

    /* Send to terminal emulator */
    ansiterm_process_block(line->terminal, buffer, read_bytes);
    ansiterm_update_dirty(line->terminal);
}

/* ============================================================================
 * Main Poll Function
 * ============================================================================ */

void serial_poll(int line_index)
{
    SERIAL_LINE_STATE *line;
    int (*driver)(int, ...);
    int port;
    int carrier;

    if (line_index < 0 || line_index >= serial_line_count)
    {
        return;
    }

    line = &serial_lines[line_index];

    if (!line->enabled)
    {
        return;
    }

    driver = line->driver;
    port = line->port_number;

    if (driver == NULL)
    {
        return;
    }

    /* Call driver poll for cooperative multitasking */
    (*driver)(DRIVER_POLL, port);

    /* If terminal is active, handle terminal I/O instead of normal operations */
    if (line->terminal_active && line->terminal != NULL)
    {
        serial_pump_to_terminal(line_index);
        return;
    }

    /* Check carrier detect state */
    carrier = serial_check_carrier(line_index);

    /* Handle carrier state changes */
    if (carrier && !line->carrier_detect)
    {
        /* Rising edge - new connection */
        line->carrier_detect = 1;
        serial_handle_connect(line_index);
        serialstatus_update_line(line_index, "Connected");
    }
    else if (!carrier && line->carrier_detect)
    {
        /* Falling edge - disconnection */
        line->carrier_detect = 0;
        serial_handle_disconnect(line_index);
        serialstatus_update_line(line_index, "Idle");
    }

    if (line->carrier_detect)
    {
        /* Connected: move data between serial and pipes */
        serial_pump_to_pipe(line_index);
        serial_pump_from_pipe(line_index);
    }
    else
    {
        /* Not connected: watch for ring indications */
        serial_scan_for_ring(line_index);
    }
}

/* ============================================================================
 * Initialisation / Shutdown
 * ============================================================================ */

void serial_init_all(void)
{
    int i;

    debug_printf("serial: Initialising all serial lines (%d configured)", serial_line_count);
    serial_log("Initialising %d serial lines", serial_line_count);

    for (i = 0; i < serial_line_count; i++)
    {
        if (serial_lines[i].enabled)
        {
            /* Load driver if not already loaded */
            if (serial_lines[i].driver == NULL &&
                serial_lines[i].driver_name[0] != '\0')
            {
                serial_load_driver(serial_lines[i].driver_name,
                                   &serial_lines[i].driver);
            }

            /* Initialise port */
            if (serial_lines[i].driver != NULL)
            {
                serial_init_port(i);
                serialstatus_update_line(i, "Idle");
            }
            else
            {
                serialstatus_update_line(i, "No driver");
            }
        }
    }

    debug_printf("serial: Serial initialisation complete");
}

void serial_close_all(void)
{
    int i;

    debug_printf("serial: Closing all serial lines");
    serial_log("Shutting down serial handler");

    for (i = 0; i < serial_line_count; i++)
    {
        if (serial_lines[i].enabled)
        {
            serial_close_port(i);
        }
    }

    debug_printf("serial: Serial shutdown complete");
}
