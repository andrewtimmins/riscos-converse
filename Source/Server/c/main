/* ******************************************************************************************************************************************************** */
/* Server                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.File.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"
#include "C:Desk.Sound.h"
#include "C:Desk.Sprite.h"

/* TCPIP Includes */
#define COMPAT_INET4 1
#include "sys/types.h" 
#include "sys/socket.h"
#include "socklib.h"
#include "inetlib.h"
#include "netinet/in.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netdb.h"

/* Our Includes */
#include "main.h"
#include "iconnames.h"
#include "ansi.h"
#include "debug.h"
#include "config.h"
#include "timer.h"
#include "upload.h"

/* ******************************************************************************************************************************************************** */
/* Global Variable Definitions (declared extern in main.h)                                                                                                  */
/* ******************************************************************************************************************************************************** */

Desk_dialog2_block *proginfo_window;
Desk_dialog2_block *systeminfo_window;
Desk_window_handle main_window;
Desk_window_handle waiting_window;

char app_version[] = "0.01";
char app_compiled[] = __DATE__ " at " __TIME__;
char small_app_compiled[] = __DATE__ " [" __TIME__ "]";

char waiting_user[100];
char user_activity[100];

char error_bind[100];
char error_listen[100];
char error_busy[100];

char error_cantfindsystemconfig[100];
char error_cantfindlineconfig[100];
char error_toomanylines[100];
char error_nolinesdefined[100];

system_components system_configuration[1];

line_components line_configuration[MAX_LINES];
int line_configurations = 0;
int line_task_handles[MAX_LINES];

int listening_socket = 0;
int active_sockets = 0;
fd_set is_socket_ready;
struct timeval socket_timeout;
char socket_buffer[256] = "";

/* Status window state */
int connections_enabled = 1;
int chat_pager_enabled = 0;
time_t server_start_time = 0;
long status_update_timer = 0;
char error_connections_disabled[128] = "Sorry, connections to this BBS have been disabled by the Sysop.\r\n";

/* ******************************************************************************************************************************************************** */
/* Function Prototypes                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

Desk_bool wimp_handle_iconbar_click(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_window_close(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_open_proginfo_window(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_open_systeminfo_window(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_button_click(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_poll(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_activity_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_control_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_register_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_user_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_serial_connect_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_serial_disconnect_message(Desk_event_pollblock *event, void *ref);

void display_error_dialog(int isFatal, const char *stringFormat, ...);

void load_system_config(void);
void load_line_config(void);

int create_line_icons(void);

void create_listener(void);
void destroy_listener(void);
void check_listener(void);
void check_socket(int line_id, int socket);
void resolve_address(int line_id);

void send_byte_to_socket(int socket_address, int first_byte, int second_byte);
void send_string_to_socket(int socket_address, char *string_to_send);

static void free_line_icon_buffers(void);
static void pipes_reset_line(int line_id);
static void notify_line_tasks_shutdown(void);
static void close_line_connection(int line_id);
static void pipes_send_control_command(int line_id, char command);
static void telnet_advertise_capabilities(int socket);
static void pump_socket_to_pipe(int line_id, int socket);
static void pump_pipe_to_socket(int line_id, int socket);
static int telnet_filter_input(int socket, char *buffer, int length);

/* String sanitization - strips leading/trailing whitespace and control chars */
static void sanitize_string(char *str)
{
	char *src = str;
	char *dst = str;
	char *end;

	/* Skip leading whitespace and control characters */
	while (*src && ((unsigned char)*src <= 32))
	{
		src++;
	}

	/* Copy to destination, stopping at any control character (< 32) except we allow space */
	while (*src)
	{
		unsigned char c = (unsigned char)*src;
		/* Stop at CR, LF, or other control chars (but allow printable chars and space) */
		if (c < 32)
		{
			break;
		}
		*dst++ = *src++;
	}
	*dst = '\0';

	/* Strip trailing spaces */
	if (dst > str)
	{
		end = dst - 1;
		while (end >= str && *end == ' ')
		{
			*end-- = '\0';
		}
	}
}

/* Case-insensitive string comparison helper */
static int str_casecmp(const char *s1, const char *s2)
{
	while (*s1 && *s2)
	{
		int c1 = tolower((unsigned char)*s1);
		int c2 = tolower((unsigned char)*s2);
		if (c1 != c2)
		{
			return c1 - c2;
		}
		s1++;
		s2++;
	}
	return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

#define MAIN_WINDOW_ICON_BASE 15
#define MAIN_WINDOW_ICONS_PER_LINE 9
#define MAIN_WINDOW_ICON_HEIGHT 64
#define MAIN_WINDOW_TOP_STATIC_ROWS 2
#define MAIN_WINDOW_BOTTOM_STATIC_ROWS 0
#define MAIN_WINDOW_STATIC_ICON_COUNT (MAIN_WINDOW_TOP_STATIC_ROWS + MAIN_WINDOW_BOTTOM_STATIC_ROWS)
#define MAIN_WINDOW_PADDING 10

#define MAIN_WINDOW_COLUMN_START 0
#define MAIN_WINDOW_COLUMN_GAP 8
#define MAIN_WINDOW_LINE_COLUMN_WIDTH 70
#define MAIN_WINDOW_TYPE_COLUMN_WIDTH 80
#define MAIN_WINDOW_USER_COLUMN_WIDTH 280
#define MAIN_WINDOW_ACTIVITY_COLUMN_WIDTH 300
#define MAIN_WINDOW_HOSTNAME_COLUMN_WIDTH 546
#define MAIN_WINDOW_TIMER_COLUMN_WIDTH 180
#define MAIN_WINDOW_ACTION_COLUMN_WIDTH 72
#define MAIN_WINDOW_VIEW_COLUMN_WIDTH 72
#define MAIN_WINDOW_LOGON_COLUMN_WIDTH 72

#define PIPES_SWI_BASE 0x5AA00
#define PIPES_BUFFER_CAPACITY 4096
#define PIPE_TRANSFER_CHUNK 1536
#define LINE_IDLE_TIMEOUT_TICKS ((clock_t)(30 * CLOCKS_PER_SEC))

/* Word Format Constants for serial config parsing */
#define WORDFORMAT_8N1        0x00
#define WORDFORMAT_8N2        0x04
#define WORDFORMAT_7N1        0x01
#define WORDFORMAT_7N2        0x05
#define WORDFORMAT_8E1        0x18
#define WORDFORMAT_8O1        0x08
#define WORDFORMAT_7E1        0x19
#define WORDFORMAT_7O1        0x09

/* Flow Control Constants for serial config parsing */
#define FLOWCONTROL_NONE      0x00
#define FLOWCONTROL_RTSCTS    0x01
#define FLOWCONTROL_XONXOFF   0x02
#define FLOWCONTROL_DTRDSR    0x03

/* Parse word format string to constant (for serial config) */
static int serial_parse_word_format(const char *format)
{
	if (format == NULL) return WORDFORMAT_8N1;
	if (strcmp(format, "8N1") == 0 || strcmp(format, "8n1") == 0) return WORDFORMAT_8N1;
	if (strcmp(format, "8N2") == 0 || strcmp(format, "8n2") == 0) return WORDFORMAT_8N2;
	if (strcmp(format, "8E1") == 0 || strcmp(format, "8e1") == 0) return WORDFORMAT_8E1;
	if (strcmp(format, "8O1") == 0 || strcmp(format, "8o1") == 0) return WORDFORMAT_8O1;
	if (strcmp(format, "7E1") == 0 || strcmp(format, "7e1") == 0) return WORDFORMAT_7E1;
	if (strcmp(format, "7O1") == 0 || strcmp(format, "7o1") == 0) return WORDFORMAT_7O1;
	if (strcmp(format, "7N1") == 0 || strcmp(format, "7n1") == 0) return WORDFORMAT_7N1;
	if (strcmp(format, "7N2") == 0 || strcmp(format, "7n2") == 0) return WORDFORMAT_7N2;
	return WORDFORMAT_8N1;
}

/* Parse flow control string to constant (for serial config) */
static int serial_parse_flow_control(const char *flow)
{
	if (flow == NULL) return FLOWCONTROL_RTSCTS;
	if (strcmp(flow, "none") == 0 || strcmp(flow, "NONE") == 0) return FLOWCONTROL_NONE;
	if (strcmp(flow, "xonxoff") == 0 || strcmp(flow, "XONXOFF") == 0 ||
	    strcmp(flow, "xon") == 0 || strcmp(flow, "software") == 0) return FLOWCONTROL_XONXOFF;
	if (strcmp(flow, "rtscts") == 0 || strcmp(flow, "RTSCTS") == 0 ||
	    strcmp(flow, "hardware") == 0 || strcmp(flow, "cts") == 0 ||
	    strcmp(flow, "rts") == 0 || strcmp(flow, "RTS") == 0) return FLOWCONTROL_RTSCTS;
	if (strcmp(flow, "dtrdsr") == 0 || strcmp(flow, "DTRDSR") == 0 ||
	    strcmp(flow, "dtr") == 0 || strcmp(flow, "DTR") == 0) return FLOWCONTROL_DTRDSR;
	return FLOWCONTROL_RTSCTS;
}

#define MAIN_WINDOW_HOSTNAME_TEXT_LEN 256

#define SWI_CONVERSE_PIPES_INPUT_STATUS      (PIPES_SWI_BASE + 2)
#define SWI_CONVERSE_PIPES_CLEAR_INPUT       (PIPES_SWI_BASE + 6)
#define SWI_CONVERSE_PIPES_CLEAR_OUTPUT      (PIPES_SWI_BASE + 7)
#define SWI_CONVERSE_PIPES_INPUT_WRITE_BLOCK (PIPES_SWI_BASE + 13)
#define SWI_CONVERSE_PIPES_OUTPUT_READ_BLOCK (PIPES_SWI_BASE + 14)
#define SWI_CONVERSE_PIPES_RESET_STATE       (PIPES_SWI_BASE + 10)

/* ConverseBBS Support module SWIs */
#define SWI_CONVERSEBBS_CONFIG     0x5AA80
#define SWI_CONVERSEBBS_LINE       0x5AA81
#define SWI_CONVERSEBBS_ACTIVITY   0x5AA82
#define SWI_CONVERSEBBS_LINECONFIG 0x5AA83
#define SWI_CONVERSEBBS_SERIAL_CONFIG 0x5AA88

/* Wimp messages from Serial handler */
#define MESSAGE_SERIAL_CONNECT      0x5AA06
#define MESSAGE_SERIAL_DISCONNECT   0x5AA07

/* ConverseFiler Statistics SWI */
#define SWI_CONVERSEFILER_STATISTICS 0x5AA44
#define STATS_REASON_READ_CALL_TOTALS 0

/* Config reason codes */
#define CONFIG_REASON_GET 0
#define CONFIG_REASON_SET 1

/* Line reason codes */
#define LINE_REASON_SET 0
#define LINE_REASON_GET 1

/* Line field indices */
#define LINE_FIELD_CONFIGURED  0
#define LINE_FIELD_CONNECTED   1
#define LINE_FIELD_USER_ID     2
#define LINE_FIELD_CONNECT_TIME 3
#define LINE_FIELD_HOSTNAME    4
#define LINE_FIELD_TRANSFER    5
#define LINE_FIELD_TYPE        6

/* Activity reason codes */
#define ACTIVITY_REASON_SET 0
#define ACTIVITY_REASON_GET 1

/* LineConfig reason codes */
#define LINECONFIG_REASON_SET 0
#define LINECONFIG_REASON_GET 1

/* LineConfig field indices */
#define LINECONFIG_FIELD_ENABLED    0
#define LINECONFIG_FIELD_BOTSTOPPER 1
#define LINECONFIG_FIELD_HELLO      2

#define PIPE_CONTROL_TOKEN      ((unsigned char)0x00)
#define PIPE_CONTROL_CONNECT    'C'
#define PIPE_CONTROL_DISCONNECT 'D'
#define MESSAGE_LINE_BASE       0x5AA00
#define MESSAGE_LINE_BROADCAST  (MESSAGE_LINE_BASE + 0)
#define MESSAGE_LINE_ACTIVITY   (MESSAGE_LINE_BASE + 1)
#define MESSAGE_LINE_CONTROL    (MESSAGE_LINE_BASE + 2)
#define MESSAGE_LINE_VIEW_WINDOW (MESSAGE_LINE_BASE + 3)
#define MESSAGE_LINE_REGISTER   (MESSAGE_LINE_BASE + 4)
#define MESSAGE_LINE_USER       (MESSAGE_LINE_BASE + 5)
#define LINE_CONTROL_REASON_LOGOFF 1

#define SWI_OS_READMONOTONICTIME 0x00000042
#define POLL_IDLE_DELAY 1  /* centiseconds between null polls (10ms) */

static Desk_sprite_area status_sprites = NULL;

/* Column constants now defined in main.h */

static void poll_idle(void)
{
	_kernel_swi_regs regs;
	Desk_event_pollblock event;
	int earliest;

	/* Get current monotonic time and add delay */
	_kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
	earliest = regs.r[0] + POLL_IDLE_DELAY;

	/* Poll with idle time - won't return null events until 'earliest' */
	Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
	Desk_Event_Process(&event);
}

static void waiting_update(const char *status)
{
	Desk_event_pollblock event;
	Desk_event_pollmask mask;
	mask.value = 0;
	Desk_Icon_SetText(waiting_window, WAITING_ACTION, (char *)status);
	/* Force a Wimp poll to show the update */
	Desk_Wimp_Poll(mask, &event);
}

int main_window_icon_index(int line_id, int column)
{
	return MAIN_WINDOW_ICON_BASE + (line_id * MAIN_WINDOW_ICONS_PER_LINE) + column;
}

static int main_window_visible_lines(void)
{
	if (line_configurations < 1)
	{
		return 0;
	}

	return line_configurations;
}

static void launch_line_tasks(void)
{
	int line_index = 0;
	char command[128];

	while (line_index < line_configurations)
	{
		snprintf(command, sizeof(command), "<Converse$Dir>.Resources.!RunLine %d", line_index);
		Desk_Wimp_StartTask(command);
		pipes_reset_line(line_index);
		line_task_handles[line_index] = 0;
		line_index++;
	}
}

static void launch_ftn_task(void)
{
	int i;
	debug_printf("launch_ftn_task: ftnmail config value = '%s' (len=%d)\n", 
		system_configuration[0].ftnmail, 
		(int)strlen(system_configuration[0].ftnmail));
	debug_printf("launch_ftn_task: ftnmail bytes: ");
	for (i = 0; i < (int)strlen(system_configuration[0].ftnmail) && i < 10; i++)
	{
		debug_printf("%02X ", (unsigned char)system_configuration[0].ftnmail[i]);
	}
	debug_printf("\n");

	if (str_casecmp(system_configuration[0].ftnmail, "yes") != 0)
	{
		debug_printf("launch_ftn_task: FTN mailer disabled (ftnmail != 'yes')\n");
		return;
	}

	debug_printf("launch_ftn_task: Starting FTN mailer task\n");
	Desk_Wimp_StartTask("Run <Converse$Dir>.Resources.!RunFTN");
	debug_printf("launch_ftn_task: FTN mailer task started\n");
}

static void launch_web_task(void)
{
	int i;
	debug_printf("launch_web_task: webserver config value = '%s' (len=%d)\n", 
		system_configuration[0].webserver, 
		(int)strlen(system_configuration[0].webserver));
	debug_printf("launch_web_task: webserver bytes: ");
	for (i = 0; i < (int)strlen(system_configuration[0].webserver) && i < 10; i++)
	{
		debug_printf("%02X ", (unsigned char)system_configuration[0].webserver[i]);
	}
	debug_printf("\n");

	if (str_casecmp(system_configuration[0].webserver, "yes") != 0)
	{
		debug_printf("launch_web_task: Web server disabled (webserver != 'yes')\n");
		return;
	}

	debug_printf("launch_web_task: Starting Web server task\n");
	Desk_Wimp_StartTask("Run <Converse$Dir>.Resources.!RunWeb");
	debug_printf("launch_web_task: Web server task started\n");
}

/* Serial config structure for pushing to Support module */
typedef struct
{
    int enabled;
    char driver_name[32];
    int port_number;
    int baud_rate;
    int word_format;
	int flow_control;
	int rings;
	char init[64];
	char ring[32];
	char answer[32];
} SERIAL_CONFIG_BLOCK;

static void support_push_serial_config(int line_id)
{
	_kernel_swi_regs regs;
	SERIAL_CONFIG_BLOCK config;

	if (line_configuration[line_id].type != LINE_TYPE_SERIAL)
	{
		return;
	}

	config.enabled = 1;
	strncpy(config.driver_name, line_configuration[line_id].driver_name, 
	        sizeof(config.driver_name) - 1);
	config.driver_name[sizeof(config.driver_name) - 1] = '\0';
	config.port_number = line_configuration[line_id].port_number;
	config.baud_rate = line_configuration[line_id].baud_rate;
	config.word_format = line_configuration[line_id].word_format;
	config.flow_control = line_configuration[line_id].flow_control;
	config.rings = line_configuration[line_id].rings;
	strncpy(config.init, line_configuration[line_id].init, sizeof(config.init) - 1);
	config.init[sizeof(config.init) - 1] = '\0';
	strncpy(config.ring, line_configuration[line_id].ring, sizeof(config.ring) - 1);
	config.ring[sizeof(config.ring) - 1] = '\0';
	strncpy(config.answer, line_configuration[line_id].answer, sizeof(config.answer) - 1);
	config.answer[sizeof(config.answer) - 1] = '\0';

	regs.r[0] = 1;  /* SERIAL_CONFIG_REASON_SET */
	regs.r[1] = line_id;
	regs.r[2] = (int)&config;
	_kernel_swi(SWI_CONVERSEBBS_SERIAL_CONFIG, &regs, &regs);

	debug_printf("support_push_serial_config: Pushed serial config for line %d (driver=%s)\n",
	             line_id, config.driver_name);
}

static int has_serial_lines(void)
{
	int i;
	for (i = 0; i < line_configurations; i++)
	{
		if (line_configuration[i].type == LINE_TYPE_SERIAL)
		{
			return 1;
		}
	}
	return 0;
}

static void launch_serial_task(void)
{
	if (!has_serial_lines())
	{
		debug_printf("launch_serial_task: No serial lines configured, skipping\n");
		return;
	}

	debug_printf("launch_serial_task: Starting Serial handler task\n");
	Desk_Wimp_StartTask("Run <Converse$Dir>.Resources.!RunSerial");
	debug_printf("launch_serial_task: Serial handler task started\n");
}

static Desk_bool main_window_icon_to_line(Desk_icon_handle icon, int *line_id, int *column)
{
	int relative;
	int total_lines;

	total_lines = line_configurations;
	if (icon < MAIN_WINDOW_ICON_BASE || total_lines <= 0)
	{
		return Desk_bool_FALSE;
	}

	relative = icon - MAIN_WINDOW_ICON_BASE;
	if (relative < 0 || relative >= (total_lines * MAIN_WINDOW_ICONS_PER_LINE))
	{
		return Desk_bool_FALSE;
	}

	if (line_id != NULL)
	{
		*line_id = relative / MAIN_WINDOW_ICONS_PER_LINE;
	}

	if (column != NULL)
	{
		*column = relative % MAIN_WINDOW_ICONS_PER_LINE;
	}

	return Desk_bool_TRUE;
}

static void send_line_task_view_request(int line_id)
{
	Desk_message_block message;
	int total_lines;

	total_lines = line_configurations;
	if (line_id < 0 || line_id >= total_lines)
	{
		return;
	}

	memset(&message, 0, sizeof(message));
	message.header.size = 24;
	message.header.action = (Desk_message_action)MESSAGE_LINE_VIEW_WINDOW;
	message.data.words[0] = line_id;
	Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* ConverseBBS Support Functions                                                                                                                                                       */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

static void support_push_config(void)
{
	_kernel_swi_regs regs;
	char value_buf[16];

	/* Push bbs_name */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"bbs_name";
	regs.r[2] = (int)system_configuration[0].name;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push sysop_name */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"sysop_name";
	regs.r[2] = (int)system_configuration[0].sysop;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push contact email */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"contact";
	regs.r[2] = (int)system_configuration[0].contact;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push hostname */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"hostname";
	regs.r[2] = (int)system_configuration[0].hostname;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push max_lines */
	snprintf(value_buf, sizeof(value_buf), "%d", line_configurations);
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"max_lines";
	regs.r[2] = (int)value_buf;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push listen_port */
	snprintf(value_buf, sizeof(value_buf), "%d", system_configuration[0].port);
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"listen_port";
	regs.r[2] = (int)value_buf;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push idle_timeout */
	snprintf(value_buf, sizeof(value_buf), "%d", system_configuration[0].timeout);
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"idle_timeout";
	regs.r[2] = (int)value_buf;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push flags */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"botstopper";
	regs.r[2] = (int)system_configuration[0].botstopper;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"needlogin";
	regs.r[2] = (int)system_configuration[0].needlogin;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"closed";
	regs.r[2] = (int)system_configuration[0].closed;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"pager";
	regs.r[2] = (int)system_configuration[0].pager;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"ftnmail";
	regs.r[2] = (int)system_configuration[0].ftnmail;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"webserver";
	regs.r[2] = (int)system_configuration[0].webserver;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push script paths */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"anykey";
	regs.r[2] = (int)system_configuration[0].anykey;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"chatstart";
	regs.r[2] = (int)system_configuration[0].chatstart;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"chatend";
	regs.r[2] = (int)system_configuration[0].chatend;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"prelogon";
	regs.r[2] = (int)system_configuration[0].prelogon;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"postlogon";
	regs.r[2] = (int)system_configuration[0].postlogon;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"logoff";
	regs.r[2] = (int)system_configuration[0].logoff;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"welcome";
	regs.r[2] = (int)system_configuration[0].welcome;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"newuser";
	regs.r[2] = (int)system_configuration[0].newuser;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"timeup";
	regs.r[2] = (int)system_configuration[0].timeup;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"lockedout";
	regs.r[2] = (int)system_configuration[0].lockedout;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"closedsys";
	regs.r[2] = (int)system_configuration[0].closedsys;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"aftermail";
	regs.r[2] = (int)system_configuration[0].aftermail;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);
}

static void support_push_line_config(int line_id)
{
	_kernel_swi_regs regs;
	int enabled;

	/* Push enabled flag (convert "yes"/"no" to 1/0) */
	enabled = (str_casecmp(line_configuration[line_id].enabled, "yes") == 0) ? 1 : 0;
	regs.r[0] = LINECONFIG_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINECONFIG_FIELD_ENABLED;
	regs.r[3] = enabled;
	_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs);

	/* Push botstopper text */
	regs.r[0] = LINECONFIG_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINECONFIG_FIELD_BOTSTOPPER;
	regs.r[3] = (int)line_configuration[line_id].botstopper;
	_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs);

	/* Push hello text */
	regs.r[0] = LINECONFIG_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINECONFIG_FIELD_HELLO;
	regs.r[3] = (int)line_configuration[line_id].hello;
	_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs);
}

static void support_set_line_configured(int line_id, int configured)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONFIGURED;
	regs.r[3] = configured;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_connected(int line_id, int connected)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONNECTED;
	regs.r[3] = connected;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_hostname(int line_id, const char *hostname)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_HOSTNAME;
	regs.r[3] = (int)hostname;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_connect_time(int line_id, time_t connect_time)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONNECT_TIME;
	regs.r[3] = (int)connect_time;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_type(int line_id, int line_type)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_TYPE;
	regs.r[3] = line_type;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_activity(int line_id, const char *activity)
{
	_kernel_swi_regs regs;

	regs.r[0] = ACTIVITY_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = (int)activity;
	_kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs);
}

static int support_get_transfer_active(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_GET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_TRANSFER;
	if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) != NULL)
	{
		return 0;
	}
	return regs.r[0];
}

static int support_get_line_connected(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_GET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONNECTED;
	if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) != NULL)
	{
		return 0;
	}
	return regs.r[0];
}

static time_t support_get_line_connect_time(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_GET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONNECT_TIME;
	if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) != NULL)
	{
		return 0;
	}
	return (time_t)regs.r[0];
}

static void update_local_connection_timer(int line_id)
{
	time_t connect_time;
	time_t now;
	int elapsed;
	int hours, minutes, seconds;
	char tmp[16];

	/* Only update if timer has fired */
	if (!timer_action(line_configuration[line_id].timer))
	{
		return;
	}

	connect_time = support_get_line_connect_time(line_id);
	if (connect_time <= 0)
	{
		return;
	}

	now = time(NULL);
	elapsed = (int)(now - connect_time);
	if (elapsed < 0) elapsed = 0;

	hours = elapsed / 3600;
	minutes = (elapsed % 3600) / 60;
	seconds = elapsed % 60;
	sprintf(tmp, "%02d:%02d:%02d", hours, minutes, seconds);

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
		tmp);

	line_configuration[line_id].timer = timer_set(100);
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Status Window Functions                                                                                                                                                             */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

static int filer_get_call_totals(void)
{
	_kernel_swi_regs regs;

	regs.r[0] = STATS_REASON_READ_CALL_TOTALS;
	if (_kernel_swi(SWI_CONVERSEFILER_STATISTICS, &regs, &regs) != NULL)
	{
		return 0;
	}
	return regs.r[0];
}

static void status_set_icon_selected(Desk_icon_handle icon, int selected)
{
	if (selected)
	{
		Desk_Icon_Select(main_window, icon);
	}
	else
	{
		Desk_Icon_Deselect(main_window, icon);
	}
}

static void status_update_uptime(void)
{
	time_t now;
	int elapsed;
	int hours, minutes, seconds;
	char time_str[16];

	now = time(NULL);
	elapsed = (int)(now - server_start_time);
	hours = elapsed / 3600;
	minutes = (elapsed % 3600) / 60;
	seconds = elapsed % 60;

	snprintf(time_str, sizeof(time_str), "%02d:%02d:%02d", hours, minutes, seconds);
	Desk_Icon_SetText(main_window, STATUS_TOTALTIME, time_str);
}

static void status_update_call_totals(void)
{
	int total_calls;
	char calls_str[16];

	total_calls = filer_get_call_totals();
	snprintf(calls_str, sizeof(calls_str), "%05d", total_calls);
	Desk_Icon_SetText(main_window, STATUS_TOTALCALLS, calls_str);
}

static void status_initialise(void)
{
	/* Record server start time */
	server_start_time = time(NULL);

	/* Set connections enabled by default */
	connections_enabled = 1;
	status_set_icon_selected(STATUS_CONNECTIONSENABLED, 1);

	/* Set chat pager based on config */
	if (str_casecmp(system_configuration[0].pager, "yes") == 0)
	{
		chat_pager_enabled = 1;
		status_set_icon_selected(STATUS_CHATPAGER, 1);
	}
	else
	{
		chat_pager_enabled = 0;
		status_set_icon_selected(STATUS_CHATPAGER, 0);
	}

	/* Initial status update */
	status_update_uptime();
	status_update_call_totals();

	/* Set up timer for periodic updates (every second = 100 centiseconds) */
	status_update_timer = timer_set(100);
}

static void status_poll_update(void)
{
	/* Check if timer has fired */
	if (timer_action(status_update_timer))
	{
		status_update_uptime();
		status_update_call_totals();
		status_update_timer = timer_set(100);
	}
}

static void status_handle_checkbox_click(Desk_icon_handle icon)
{
	if (icon == STATUS_CONNECTIONSENABLED)
	{
		/* Toggle connections enabled state */
		connections_enabled = !connections_enabled;
		status_set_icon_selected(STATUS_CONNECTIONSENABLED, connections_enabled);
	}
	else if (icon == STATUS_CHATPAGER)
	{
		/* Toggle chat pager state */
		chat_pager_enabled = !chat_pager_enabled;
		status_set_icon_selected(STATUS_CHATPAGER, chat_pager_enabled);
	}
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Wimp Functions                                                                                                                                                                      */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref)
{
	struct wimp_components *wimp;
	wimp = (struct wimp_components *)ref;

	if(event->data.selection[0] == iconbar_menu_usereditor)
	{
		Desk_Wimp_StartTask("<Converse$Dir>.Resources.!RunUser");
	}

	if(event->data.selection[0] == iconbar_menu_uploadfile)
	{
		upload_open_window();
	}

	if(event->data.selection[0] == iconbar_menu_quit)
  	{
		notify_line_tasks_shutdown();
		Desk_Event_CloseDown();
		wimp->quit = Desk_bool_TRUE;
	}

	return(Desk_bool_TRUE);  
}

Desk_bool wimp_handle_window_close(Desk_event_pollblock *event, void *ref)
{
	Desk_UNUSED(ref);

	Desk_Window_Hide(event->data.openblock.window);

	return(Desk_bool_TRUE);
}

Desk_bool wimp_handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
	struct wimp_components *wimp;
	wimp = (struct wimp_components *)ref;

	Desk_window_redrawblock window_extent;

 	if(event->data.mouse.button.data.select)
    {
		int visible_lines;
		int total_height;
		
		window_extent.window=main_window;
		window_extent.rect.min.x=0;
		window_extent.rect.max.x=1736;
		window_extent.rect.max.y=0;

		visible_lines = main_window_visible_lines();
		total_height = ((visible_lines + MAIN_WINDOW_STATIC_ICON_COUNT) * MAIN_WINDOW_ICON_HEIGHT) + (2 * MAIN_WINDOW_PADDING);

		/* Include top/bottom icon rows plus a small buffer. */
		window_extent.rect.min.y = -total_height;

		Desk_Wimp_SetExtent(main_window, &(window_extent.rect));
		Desk_Window_Show(main_window, Desk_open_CENTERED);
	}

	if(event->data.mouse.button.data.menu)
  	{
    	Desk_Menu_Show(wimp->iconbar_menu_handle, event->data.mouse.pos.x, -1);
		Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY, wimp_handle_iconbar_menu_choice, ref); 
  	}

	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_button_click(Desk_event_pollblock *event, void *ref)
{
	Desk_UNUSED(ref);

	if (event != NULL)
	{
		Desk_mouse_block *mouse = &event->data.mouse;
		if (mouse->window == main_window && mouse->button.data.select)
		{
			int line_id;
			int column;

			/* Check if it's a status checkbox click */
			if (mouse->icon == STATUS_CONNECTIONSENABLED || 
			    mouse->icon == STATUS_CHATPAGER)
			{
				status_handle_checkbox_click(mouse->icon);
				return Desk_bool_TRUE;
			}

			/* Check if it's a line row button */
			if (main_window_icon_to_line(mouse->icon, &line_id, &column) != Desk_bool_FALSE)
			{
				if (column == MAIN_WINDOW_COLUMN_VIEW || column == MAIN_WINDOW_COLUMN_LOGON)
				{
					send_line_task_view_request(line_id);
				}
			}
		}
	}

	return Desk_bool_TRUE;
}

Desk_bool wimp_open_proginfo_window(Desk_event_pollblock *event, void *ref)
{
	if((event->data.message.data.menuwarn.selection[0] != iconbar_menu_proginfo))
	{
    	return Desk_bool_FALSE;
	}

  	Desk_Dialog2_OpenDialogMenuLeaf(event, (Desk_dialog2_block *)ref);

  	return Desk_bool_TRUE;
}

Desk_bool wimp_open_systeminfo_window(Desk_event_pollblock *event, void *ref)
{
	if((event->data.message.data.menuwarn.selection[0] != iconbar_menu_systeminfo))
	{
    	return Desk_bool_FALSE;
	}

  	Desk_Dialog2_OpenDialogMenuLeaf(event, (Desk_dialog2_block *)ref);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_NAME, (char *)system_configuration[0].name);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_SYSOP, (char *)system_configuration[0].sysop);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_CONTACT, (char *)system_configuration[0].contact);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_HOST, (char *)system_configuration[0].hostname);

  	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_poll(Desk_event_pollblock *event, void *ref)
{
	int line_id = 0;

	Desk_UNUSED(event);
	Desk_UNUSED(ref);

	/* Check for incoming telnet connections */
	check_listener();

	/* Process each line based on its type */
	while (line_id < line_configurations)
	{
		switch (line_configuration[line_id].type)
		{
			case LINE_TYPE_TELNET:
				/* Telnet line - check socket if connected */
				if (line_configuration[line_id].socket != 0)
				{
					check_socket(line_id, line_configuration[line_id].socket);
					if (line_configuration[line_id].resolved < 3)
					{
						resolve_address(line_id);
					}
				}
				break;

			case LINE_TYPE_SERIAL:
				/* Serial line - handled by Serial app, just update timer if connected */
				if (support_get_line_connected(line_id))
				{
					if (line_configuration[line_id].timer == 0)
					{
						line_configuration[line_id].timer = timer_set(100);
					}
					update_local_connection_timer(line_id);
				}
				else if (line_configuration[line_id].timer != 0)
				{
					line_configuration[line_id].timer = 0;
					Desk_Icon_SetText(main_window,
						main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
						"00:00:00");
				}
				break;

			case LINE_TYPE_LOCAL:
				/* Local line - just update timer if connected (LineTask handles I/O) */
				if (support_get_line_connected(line_id))
				{
					if (line_configuration[line_id].timer == 0)
					{
						line_configuration[line_id].timer = timer_set(100);
					}
					update_local_connection_timer(line_id);
				}
				else if (line_configuration[line_id].timer != 0)
				{
					line_configuration[line_id].timer = 0;
					Desk_Icon_SetText(main_window,
						main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
						"00:00:00");
				}
				break;
		}

		line_id++;
	}

	/* Update status window periodically */
	status_poll_update();
	
	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_line_activity_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;
	const char *activity;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	if (line_configurations <= 1)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	activity = (const char *)&event->data.message.data.bytes[4];
	if (activity == NULL || *activity == '\0')
	{
		activity = user_activity;
	}

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
		(char *)activity);

	/* Update activity in Support module */
	support_set_activity(line_id, activity);

	line_task_handles[line_id] = event->data.message.header.sender;

	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_line_control_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;
	int reason;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	if (line_configurations <= 1)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	reason = event->data.message.data.words[1];

	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	line_task_handles[line_id] = event->data.message.header.sender;

	if (reason == LINE_CONTROL_REASON_LOGOFF)
	{
		Desk_Icon_SetText(main_window,
			main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
			user_activity);
		close_line_connection(line_id);
		return Desk_bool_TRUE;
	}

	return Desk_bool_FALSE;
}

Desk_bool wimp_handle_line_register_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= 32)
	{
		return Desk_bool_FALSE;
	}

	line_task_handles[line_id] = event->data.message.header.sender;
	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_line_user_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;
	const char *username;
	char display_name[100];

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	if (line_configurations <= 1)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	username = (const char *)&event->data.message.data.bytes[4];
	if (username == NULL || *username == '\0')
	{
		/* Empty username means reset to waiting */
		strncpy(display_name, waiting_user, sizeof(display_name) - 1);
		display_name[sizeof(display_name) - 1] = '\0';
	}
	else
	{
		strncpy(display_name, username, sizeof(display_name) - 1);
		display_name[sizeof(display_name) - 1] = '\0';
	}

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_USER),
		display_name);

	line_task_handles[line_id] = event->data.message.header.sender;

	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_serial_connect_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	debug_printf("wimp_handle_serial_connect_message: Line %d connected\n", line_id);

	/* Update UI - show SERIAL in hostname column */
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
		"SERIAL");

	/* Reset timer for this line */
	line_configuration[line_id].connectedtime = (int)clock();
	line_configuration[line_id].timer = timer_set(100);

	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_serial_disconnect_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	debug_printf("wimp_handle_serial_disconnect_message: Line %d disconnected\n", line_id);

	/* Update UI - reset all columns */
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
		"----");
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_USER),
		waiting_user);
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
		user_activity);
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
		"00:00:00");

	/* Reset timer */
	line_configuration[line_id].timer = 0;

	return Desk_bool_TRUE;
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Error Handling Functions                                                                                                                                                            */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

void display_error_dialog(int exit_code, const char *error_message, ...)
{
	va_list arguments_passed;

	va_start(arguments_passed, error_message);
	Desk_Error_Report(exit_code, (char *)error_message, arguments_passed);
	va_end(arguments_passed);
	

	switch (exit_code) {
	case 0:
		return;
	case 1:
		exit(EXIT_FAILURE);
	default:
		exit(exit_code);
	}
}


/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Dynamic Icon Functions                                                                                                                                                              */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

/* Free all allocated icon text buffers */
static void free_line_icon_buffers(void)
{
	int i;
	for (i = 0; i < MAX_LINES; i++)
	{
		if (line_configuration[i].icons.line_text != NULL)
		{
			free(line_configuration[i].icons.line_text);
			line_configuration[i].icons.line_text = NULL;
		}
		if (line_configuration[i].icons.type_text != NULL)
		{
			free(line_configuration[i].icons.type_text);
			line_configuration[i].icons.type_text = NULL;
		}
		if (line_configuration[i].icons.user_text != NULL)
		{
			free(line_configuration[i].icons.user_text);
			line_configuration[i].icons.user_text = NULL;
		}
		if (line_configuration[i].icons.activity_text != NULL)
		{
			free(line_configuration[i].icons.activity_text);
			line_configuration[i].icons.activity_text = NULL;
		}
		if (line_configuration[i].icons.hostname_text != NULL)
		{
			free(line_configuration[i].icons.hostname_text);
			line_configuration[i].icons.hostname_text = NULL;
		}
		if (line_configuration[i].icons.timer_text != NULL)
		{
			free(line_configuration[i].icons.timer_text);
			line_configuration[i].icons.timer_text = NULL;
		}
		if (line_configuration[i].icons.action_text != NULL)
		{
			free(line_configuration[i].icons.action_text);
			line_configuration[i].icons.action_text = NULL;
		}
		if (line_configuration[i].icons.view_text != NULL)
		{
			free(line_configuration[i].icons.view_text);
			line_configuration[i].icons.view_text = NULL;
		}
		if (line_configuration[i].icons.logon_text != NULL)
		{
			free(line_configuration[i].icons.logon_text);
			line_configuration[i].icons.logon_text = NULL;
		}
	}
}

int create_line_icons(void) 
{
	int current_line_configuration = 0;
	int y_base;
	int column_x;
	line_icon_buffers *icons;

	Desk_icon_createblock icon_create_block;
	Desk_icon_handle icon_handle;

	/* Guard against zero lines configured */
	if (line_configurations <= 0)
	{
		debug_printf("create_line_icons: No lines configured, skipping icon creation");
		return Desk_bool_TRUE;
	}

	icon_create_block.window=main_window;
	y_base = -((MAIN_WINDOW_TOP_STATIC_ROWS * MAIN_WINDOW_ICON_HEIGHT) + MAIN_WINDOW_PADDING);
		
	do
	{
		icons = &line_configuration[current_line_configuration].icons;
		
		/* Allocate all buffers for this line */
		icons->line_text = malloc(25);
		icons->type_text = malloc(8);
		icons->user_text = malloc(sizeof(waiting_user));
		icons->activity_text = malloc(sizeof(user_activity));
		icons->hostname_text = malloc(MAIN_WINDOW_HOSTNAME_TEXT_LEN);
		icons->timer_text = malloc(25);
		icons->action_text = malloc(1);
		icons->view_text = malloc(1);
		icons->logon_text = malloc(1);
		
		/* Check allocations */
		if (icons->line_text == NULL || icons->type_text == NULL ||
		    icons->user_text == NULL ||
		    icons->activity_text == NULL || icons->hostname_text == NULL ||
		    icons->timer_text == NULL || icons->action_text == NULL ||
		    icons->view_text == NULL || icons->logon_text == NULL)
		{
			display_error_dialog(1, "Unable to allocate icon buffers");
			return Desk_bool_FALSE;
		}
		
		/* Initialize buffers */
		snprintf(icons->line_text, 25, "%d", current_line_configuration);
		/* Set type text based on line type: IP=Telnet, BD=BlockDriver/Serial, LC=Local */
		if (line_configuration[current_line_configuration].type == LINE_TYPE_LOCAL)
		{
			strcpy(icons->type_text, "LC");
		}
		else if (line_configuration[current_line_configuration].type == LINE_TYPE_SERIAL)
		{
			strcpy(icons->type_text, "BD");
		}
		else
		{
			strcpy(icons->type_text, "IP");
		}
		strncpy(icons->user_text, waiting_user, sizeof(waiting_user) - 1);
		icons->user_text[sizeof(waiting_user) - 1] = '\0';
		strncpy(icons->activity_text, user_activity, sizeof(user_activity) - 1);
		icons->activity_text[sizeof(user_activity) - 1] = '\0';
		/* Hostname starts empty - will be populated on connection */
		strncpy(icons->hostname_text, "-----", MAIN_WINDOW_HOSTNAME_TEXT_LEN - 1);
		icons->hostname_text[MAIN_WINDOW_HOSTNAME_TEXT_LEN - 1] = '\0';
		strcpy(icons->timer_text, "00:00:00");
		icons->action_text[0] = '\0';
		icons->view_text[0] = '\0';
		icons->logon_text[0] = '\0';

		icon_create_block.icondata.workarearect.max.y = y_base - (MAIN_WINDOW_ICON_HEIGHT * current_line_configuration);
		icon_create_block.icondata.workarearect.min.y = icon_create_block.icondata.workarearect.max.y - MAIN_WINDOW_ICON_HEIGHT;

		column_x = MAIN_WINDOW_COLUMN_START;

		/* Line number column */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_LINE_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=line_configuration[current_line_configuration].line;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=25;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* Type column (IP/BD/LC) */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_TYPE_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->type_text;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=8;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* User column */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_USER_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->user_text;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=sizeof(waiting_user);

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* Activity column */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_ACTIVITY_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
											Desk_icon_VCENTRE |
											Desk_icon_HCENTRE |
											Desk_icon_INDIRECTED |
											Desk_icon_BORDER |
											Desk_icon_FILLED |
											(Desk_icon_FORECOLOUR*7) |
											(Desk_icon_BACKCOLOUR*1) |
											(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->activity_text;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=sizeof(user_activity);

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* Hostname column */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_HOSTNAME_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->hostname_text;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=MAIN_WINDOW_HOSTNAME_TEXT_LEN;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* Timer column */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_TIMER_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->timer_text;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=25;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* Action (disconnect) button */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_ACTION_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_SPRITE |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->action_text;
		icon_create_block.icondata.data.indirecttext.validstring="Sdisconnect;R5";
		icon_create_block.icondata.data.indirecttext.bufflen=1;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* View (snoop) button */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_VIEW_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
											Desk_icon_SPRITE |
											Desk_icon_VCENTRE |
											Desk_icon_HCENTRE |
											Desk_icon_INDIRECTED |
											Desk_icon_BORDER |
											Desk_icon_FILLED |
											(Desk_icon_FORECOLOUR*7) |
											(Desk_icon_BACKCOLOUR*1) |
											(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->view_text;
		icon_create_block.icondata.data.indirecttext.validstring="Ssnoop;R5";
		icon_create_block.icondata.data.indirecttext.bufflen=1;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		/* Logon (local) button */
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_LOGON_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
											Desk_icon_SPRITE |
											Desk_icon_VCENTRE |
											Desk_icon_HCENTRE |
											Desk_icon_INDIRECTED |
											Desk_icon_BORDER |
											Desk_icon_FILLED |
											(Desk_icon_FORECOLOUR*7) |
											(Desk_icon_BACKCOLOUR*1) |
											(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=icons->logon_text;
		icon_create_block.icondata.data.indirecttext.validstring="Slocal;R5";
		icon_create_block.icondata.data.indirecttext.bufflen=1;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		current_line_configuration++;
	} while (current_line_configuration < line_configurations);

	return Desk_bool_TRUE;
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Networking Functions                                                                                                                                                                */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
 
void create_listener(void)
{
	int  args[2];
  	struct sockaddr_in saddr;

	/* Create the socket */
	listening_socket = socket(AF_INET, SOCK_STREAM, PF_UNSPEC);

	/* Allow address reuse - very important. If you don't do this, then you'll need to
	   wait for the socket to "expire" in between running this program, and running it again. */
	args[0] = 1; /* non-zero = enable */
	setsockopt(listening_socket, SOL_SOCKET, SO_REUSEADDR, &args, sizeof(int));

	/* Set linger time to 10 seconds maximum */
	args[0] = 1;  /* wait for data to drain */
	args[1] = 10; /* 10 seconds maximum */
	setsockopt(listening_socket, SOL_SOCKET, SO_LINGER, &args, (sizeof(int) * 2));

	/* Bind to configured port */
	memset(&saddr, 0, sizeof(saddr));   /* zero everything before use */
	saddr.sin_family = AF_INET;         /* accept internet connection... */
	saddr.sin_port = htons(system_configuration[0].port);
	saddr.sin_addr.s_addr = INADDR_ANY; /* ...from anybody. */
	if ( bind(listening_socket, (struct sockaddr *)&saddr, sizeof(saddr)) != 0 )
	{
		socketclose(listening_socket);
			display_error_dialog(1, error_bind);
	}

	/* Make it non-blocking so the machine won't hang up waiting for something to happen */
	args[0] = 1;
	socketioctl(listening_socket, FIONBIO, &args[0]);

	/* Now place an ear against the wire */
	if ( listen(listening_socket, 1) != 0 )
	{
		socketclose(listening_socket);
		display_error_dialog(1, error_listen);
	}

}

void check_listener(void)
{
	/* Check to see if there's an incoming connection */
	struct sockaddr_in saddr;
	int namelen = sizeof(saddr);
	int socket_poll = 0;

	memset(&saddr, 0, sizeof(saddr));

   FD_ZERO(&is_socket_ready);
   FD_SET(listening_socket, &is_socket_ready);
   
   socket_timeout.tv_sec = 0;
   socket_timeout.tv_usec = 0;
   select((listening_socket + 1), &is_socket_ready, 0, 0, &socket_timeout);

   if (FD_ISSET(listening_socket, &is_socket_ready))
   {
      /* There is a connection pending. */

      /* Check if connections are disabled by sysop */
      if (!connections_enabled)
      {
         int orphaned_socket;

         orphaned_socket = accept(listening_socket, (struct sockaddr *)0, (int *)0);
         if (orphaned_socket != -1)
         {
            socketwrite(orphaned_socket, error_connections_disabled, strlen(error_connections_disabled));
            shutdown(orphaned_socket, 0);
            socketclose(orphaned_socket);
         }
         return;
      }

		if (active_sockets >= line_configurations)
      	{
         int orphaned_socket;

         orphaned_socket = accept(listening_socket, (struct sockaddr *)0, (int *)0);
         if (orphaned_socket != -1)
         {
			strcpy(socket_buffer, error_busy);
			socketwrite(orphaned_socket, socket_buffer, strlen(socket_buffer));
            shutdown(orphaned_socket, 0);
            socketclose(orphaned_socket);
         }
      	}

		/* Find a free TELNET line - skip serial and local lines */
		while (socket_poll < line_configurations)
		{
			/* Skip non-telnet lines */
			if (line_configuration[socket_poll].type != LINE_TYPE_TELNET)
			{
				socket_poll++;
				continue;
			}
			/* Skip busy lines */
			if (line_configuration[socket_poll].socket != 0 || support_get_line_connected(socket_poll))
			{
				socket_poll++;
				continue;
			}
			/* Found a free telnet line */
			break;
		}

		/* Only accept if we found a truly free telnet line */
		if (socket_poll < line_configurations && 
		    line_configuration[socket_poll].type == LINE_TYPE_TELNET &&
		    line_configuration[socket_poll].socket == 0 && 
		    !support_get_line_connected(socket_poll))
		{
			int nonblock = 1;

			/* We are not connected, so accept this connection. */
			line_configuration[socket_poll].socket = accept(listening_socket, (struct sockaddr *)&saddr, &namelen);
			active_sockets++;

			if (line_configuration[socket_poll].socket == -1)
			{
				line_configuration[socket_poll].socket = 0;
				active_sockets--;
				/* Something went wrong. Just get out of here, the listener is still active. */
				return;
			}

			/* Check for banned IP */
			{
				_kernel_swi_regs regs;
				regs.r[0] = ACCESS_CMD_CHECK;
				regs.r[1] = (int)saddr.sin_addr.s_addr;
				
				/* Only check if the SWI call succeeds. If the Support module is old/missing, allow access. */
				if (_kernel_swi(SWI_SUPPORT_ACCESS, &regs, &regs) == NULL)
				{
					if (regs.r[0])
					{
						char *ip_str = inet_ntoa(saddr.sin_addr);
						debug_printf("server: Rejected banned connection from %s", ip_str);
						socketwrite(line_configuration[socket_poll].socket, "Access Denied\r\n", 15);
						shutdown(line_configuration[socket_poll].socket, 0);
						socketclose(line_configuration[socket_poll].socket);
						line_configuration[socket_poll].socket = 0;
						active_sockets--;
						return;
					}
				}
			}

			/* Make the client socket non-blocking so we don't hang waiting for data */
			socketioctl(line_configuration[socket_poll].socket, FIONBIO, &nonblock);
		}

		line_configuration[socket_poll].connectedtime = clock();
		line_configuration[socket_poll].last_activity = line_configuration[socket_poll].connectedtime;
		line_configuration[socket_poll].timer = timer_set(100);
		pipes_reset_line(socket_poll);
		pipes_send_control_command(socket_poll, PIPE_CONTROL_CONNECT);

		/* Copy the remote IP address */
		{
			char *ip_str = inet_ntoa(saddr.sin_addr);
			strncpy(line_configuration[socket_poll].remote, ip_str, sizeof(line_configuration[socket_poll].remote) - 1);
			line_configuration[socket_poll].remote[sizeof(line_configuration[socket_poll].remote) - 1] = '\0';
		}

		/* Update Support module with connection state */
		support_set_line_connected(socket_poll, 1);
		support_set_line_hostname(socket_poll, line_configuration[socket_poll].remote);
		support_set_line_connect_time(socket_poll, time(NULL));

		/* At this point, socket will be != -1 so it will be treated as a live socket and any
		   other connections will result in busy message followed by a disconnect. */

		telnet_advertise_capabilities(line_configuration[socket_poll].socket);

		send_string_to_socket(line_configuration[socket_poll].socket, ANSI_clear_screen);
	}

   return;
}

void check_socket(int line_id, int socket)
{
	int change_length = 0;

	change_length = recv(socket, socket_buffer, 1, MSG_PEEK);
	if (change_length == 0)
	{
		close_line_connection(line_id);
		return;
	}

	if(timer_action(line_configuration[line_id].timer)) /* update timer */
	{
		int d;
		int hours, minutes, seconds;
		char tmp[16]={0};

		d=(clock()-line_configuration[line_id].connectedtime)/100;  // seconds
		hours = d / 3600;
		minutes = (d % 3600) / 60;
		seconds = d % 60;
		sprintf(tmp, "%02d:%02d:%02d", hours, minutes, seconds);

		Desk_Icon_SetText(main_window,
			main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
			tmp);

		line_configuration[line_id].timer=timer_set(100);
	}

	pump_socket_to_pipe(line_id, socket);
	pump_pipe_to_socket(line_id, socket);

	if (line_configuration[line_id].last_activity != 0 && system_configuration[0].timeout > 0)
	{
		clock_t now = clock();
		clock_t timeout_ticks = (clock_t)(system_configuration[0].timeout * CLOCKS_PER_SEC);
		if ((now - line_configuration[line_id].last_activity) > timeout_ticks)
		{
			/* Don't timeout during file transfer */
			if (!support_get_transfer_active(line_id))
			{
				close_line_connection(line_id);
				return;
			}
		}
	}

	return;
}

void destroy_listener(void)
{
	int socket_poll = 0;

	/* Note: Serial ports are managed by the standalone Serial app */

	while (socket_poll < line_configurations)
	{
		if (line_configuration[socket_poll].socket != -1 )
		{
			shutdown(line_configuration[socket_poll].socket, 0);
			socketclose(line_configuration[socket_poll].socket);
		}

		socket_poll++;
	}

	if (listening_socket >= 0)
	{
		socketclose(listening_socket);
	}

	/* Free allocated icon text buffers */
	free_line_icon_buffers();

	Desk_Template_ClearAll();
	
	system("RMKill ConverseBBS");
	system("RMKill ConversePipes");
	system("RMKill ConverseFiler");
	system("RMKill ConverseDoors");
	system("RMKill ARCbbs_Doors");
	system("RMKill ARCbbs_Filer");
	system("Set Converse$Running 0");
}

void send_byte_to_socket(int socket_address, int first_byte, int second_byte)
{
	unsigned char buffer[3];

	buffer[0] = (unsigned char)Telnet_IAC;
	buffer[1] = (unsigned char)first_byte;
	buffer[2] = (unsigned char)second_byte;
	socketwrite(socket_address, (char *)buffer, sizeof(buffer));
}

void send_string_to_socket(int socket_address, char *string_to_send)
{
	char buffer[256];
	size_t len;
	
	len = strlen(string_to_send);
	if (len >= sizeof(buffer))
	{
		len = sizeof(buffer) - 1;
	}
	memcpy(buffer, string_to_send, len);
	buffer[len] = '\0';
	socketwrite(socket_address, buffer, (int)len);
}

static int pipes_input_status(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_STATUS, &regs, &regs) != NULL)
	{
		return -1;
	}

	return regs.r[0];
}

static int pipes_input_write_block(int line_id, const char *buffer, int length)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	regs.r[1] = (int)buffer;
	regs.r[2] = length;
	if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_WRITE_BLOCK, &regs, &regs) != NULL)
	{
		return -1;
	}

	return regs.r[0];
}

static int pipes_output_read_block(int line_id, char *buffer, int length)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	regs.r[1] = (int)buffer;
	regs.r[2] = length;
	if (_kernel_swi(SWI_CONVERSE_PIPES_OUTPUT_READ_BLOCK, &regs, &regs) != NULL)
	{
		return -1;
	}

	return regs.r[0];
}

static void pipes_reset_line(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	_kernel_swi(SWI_CONVERSE_PIPES_RESET_STATE, &regs, &regs);
	regs.r[0] = line_id;
	_kernel_swi(SWI_CONVERSE_PIPES_CLEAR_INPUT, &regs, &regs);
	regs.r[0] = line_id;
	_kernel_swi(SWI_CONVERSE_PIPES_CLEAR_OUTPUT, &regs, &regs);

	/* Clear any pending partial write buffer from previous connection */
	line_configuration[line_id].pending_offset = 0;
	line_configuration[line_id].pending_length = 0;
}

static void pipes_send_control_command(int line_id, char command)
{
	unsigned char frame[3];

	frame[0] = PIPE_CONTROL_TOKEN;
	frame[1] = (unsigned char)command;
	frame[2] = PIPE_CONTROL_TOKEN;
	pipes_input_write_block(line_id, (const char *)frame, sizeof(frame));
}

static void pump_socket_to_pipe(int line_id, int socket)
{
	int iteration = 0;

	while (iteration < 4)
	{
		int used_bytes = pipes_input_status(line_id);
		int free_bytes;
		int read_bytes;
		char buffer[PIPE_TRANSFER_CHUNK];

		if (used_bytes < 0)
		{
			return;
		}

		if (used_bytes >= PIPES_BUFFER_CAPACITY)
		{
			return;
		}

		free_bytes = PIPES_BUFFER_CAPACITY - used_bytes;
		if (free_bytes > PIPE_TRANSFER_CHUNK)
		{
			free_bytes = PIPE_TRANSFER_CHUNK;
		}

		read_bytes = socketread(socket, buffer, free_bytes);
		if (read_bytes <= 0)
		{
			return;
		}

		read_bytes = telnet_filter_input(socket, buffer, read_bytes);
		if (read_bytes <= 0)
		{
			iteration++;
			continue;
		}

		int offset = 0;
		while (offset < read_bytes)
		{
			int copied = pipes_input_write_block(line_id, buffer + offset, read_bytes - offset);
			if (copied <= 0)
			{
				return;
			}
			offset += copied;
			line_configuration[line_id].last_activity = clock();
		}

		if (read_bytes < free_bytes)
		{
			break;
		}

		iteration++;
	}
}

static void pump_pipe_to_socket(int line_id, int socket)
{
	int loops = 0;

	/* First, flush any pending data from a previous partial write */
	while (line_configuration[line_id].pending_length > 0)
	{
		int remaining = line_configuration[line_id].pending_length - 
		                line_configuration[line_id].pending_offset;
		int written = socketwrite(socket, 
			line_configuration[line_id].pending_buffer + line_configuration[line_id].pending_offset,
			remaining);
		if (written <= 0)
		{
			/* Socket still blocked, try again next poll */
			return;
		}
		line_configuration[line_id].pending_offset += written;
		if (line_configuration[line_id].pending_offset >= line_configuration[line_id].pending_length)
		{
			/* Pending buffer fully written */
			line_configuration[line_id].pending_length = 0;
			line_configuration[line_id].pending_offset = 0;
		}
		line_configuration[line_id].last_activity = clock();
	}

	/* Now read new data from pipe and write to socket */
	while (loops < 4)
	{
		char buffer[PIPE_TRANSFER_CHUNK];
		int copied = pipes_output_read_block(line_id, buffer, PIPE_TRANSFER_CHUNK);
		int offset = 0;

		if (copied <= 0)
		{
			return;
		}

		while (offset < copied)
		{
			int written = socketwrite(socket, buffer + offset, copied - offset);
			if (written <= 0)
			{
				/* Socket blocked - save remaining data to pending buffer */
				int remaining = copied - offset;
				if (remaining > 0 && remaining <= PIPE_TRANSFER_CHUNK)
				{
					memcpy(line_configuration[line_id].pending_buffer, 
					       buffer + offset, remaining);
					line_configuration[line_id].pending_offset = 0;
					line_configuration[line_id].pending_length = remaining;
				}
				return;
			}
			offset += written;
		}

		line_configuration[line_id].last_activity = clock();

		if (copied < PIPE_TRANSFER_CHUNK)
		{
			break;
		}

		loops++;
	}
}

static void close_line_connection(int line_id)
{
	int socket = line_configuration[line_id].socket;

	if (socket > 0)
	{
		/* Flush any pending partial write data first */
		while (line_configuration[line_id].pending_length > 0)
		{
			int remaining = line_configuration[line_id].pending_length - 
			                line_configuration[line_id].pending_offset;
			int written = socketwrite(socket, 
				line_configuration[line_id].pending_buffer + line_configuration[line_id].pending_offset,
				remaining);
			if (written <= 0)
			{
				break;  /* Can't write more, give up */
			}
			line_configuration[line_id].pending_offset += written;
			if (line_configuration[line_id].pending_offset >= line_configuration[line_id].pending_length)
			{
				line_configuration[line_id].pending_length = 0;
				line_configuration[line_id].pending_offset = 0;
			}
		}

		/* Flush any remaining output from the pipe */
		{
			char flush_buffer[PIPE_TRANSFER_CHUNK];
			int flush_loops = 0;
			int copied;

			while (flush_loops < 10 && 
			       (copied = pipes_output_read_block(line_id, flush_buffer, PIPE_TRANSFER_CHUNK)) > 0)
			{
				int offset = 0;
				while (offset < copied)
				{
					int written = socketwrite(socket, flush_buffer + offset, copied - offset);
					if (written <= 0)
					{
						break;  /* Can't write more, give up */
					}
					offset += written;
				}
				if (offset < copied)
				{
					break;  /* Couldn't write everything, stop trying */
				}
				flush_loops++;
			}
		}

		pipes_send_control_command(line_id, PIPE_CONTROL_DISCONNECT);
		shutdown(socket, 0);
		socketclose(socket);
		line_configuration[line_id].socket = 0;
		if (active_sockets > 0)
		{
			active_sockets--;
		}
	}

	line_configuration[line_id].resolved = 0;
	line_configuration[line_id].last_activity = 0;
	line_configuration[line_id].timer = 0;
	strcpy(line_configuration[line_id].remote, "");
	line_task_handles[line_id] = 0;

	/* Clear Support module line state (setting connected=0 clears other fields) */
	support_set_line_connected(line_id, 0);

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
		"----");
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_USER),
		waiting_user);
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
		user_activity);
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
		"00:00:00");

	Desk_Event_PollIdle();
}

static void notify_line_tasks_shutdown(void)
{
	Desk_message_block wimp_message;

	memset(&wimp_message, 0, sizeof(wimp_message));
	wimp_message.header.size = 28;
	wimp_message.header.action = (Desk_message_action)MESSAGE_LINE_BROADCAST;
	wimp_message.data.words[0] = 0; /* reason 0 => quit */
	Desk_Wimp_SendMessage(Desk_event_SEND, &wimp_message, 0, NULL);
}

static void telnet_advertise_capabilities(int socket)
{
	send_byte_to_socket(socket, Telnet_WILL, Option_ECHO);
	send_byte_to_socket(socket, Telnet_DONT, Option_ECHO);
	send_byte_to_socket(socket, Telnet_WILL, Option_SUPRESS);
}

static void telnet_handle_option(int socket, unsigned char command, unsigned char option)
{
	switch (command)
	{
		case Telnet_DO:
			if (option == Option_ECHO || option == Option_SUPRESS)
			{
				send_byte_to_socket(socket, Telnet_WILL, option);
			}
			else
			{
				send_byte_to_socket(socket, Telnet_WONT, option);
			}
			break;

		case Telnet_DONT:
			send_byte_to_socket(socket, Telnet_WONT, option);
			break;

		case Telnet_WILL:
			if (option == Option_ECHO)
			{
				send_byte_to_socket(socket, Telnet_DO, option);
			}
			else
			{
				send_byte_to_socket(socket, Telnet_DONT, option);
			}
			break;

		case Telnet_WONT:
			send_byte_to_socket(socket, Telnet_DONT, option);
			break;

		default:
			break;
	}
}

static int telnet_filter_input(int socket, char *buffer, int length)
{
	int read_index = 0;
	int write_index = 0;

	(void)socket;  /* Unused but part of the interface */

	while (read_index < length)
	{
		unsigned char byte = (unsigned char)buffer[read_index++];

		if (byte == Telnet_IAC)
		{
			if (read_index >= length)
			{
				break;
			}

			unsigned char command = (unsigned char)buffer[read_index++];

			if (command == Telnet_IAC)
			{
				buffer[write_index++] = (char)Telnet_IAC;
				continue;
			}

			if (command == Telnet_SB)
			{
				while (read_index < length)
				{
					if ((unsigned char)buffer[read_index] == Telnet_IAC)
					{
						if ((read_index + 1) < length && (unsigned char)buffer[read_index + 1] == Telnet_SE)
						{
							read_index += 2;
							break;
						}
					}
					read_index++;
				}
				continue;
			}

			switch (command)
			{
				case Telnet_DO:
				case Telnet_DONT:
				case Telnet_WILL:
				case Telnet_WONT:
					if (read_index < length)
					{
						unsigned char option = (unsigned char)buffer[read_index++];
						telnet_handle_option(socket, command, option);
					}
					else
					{
						read_index = length;
					}
					break;

				case Telnet_NOP:
				case Telnet_DM:
				case Telnet_BRK:
				case Telnet_IP:
				case Telnet_AO:
				case Telnet_AYT:
				case Telnet_EC:
				case Telnet_EL:
				case Telnet_GA:
					/* Command without option byte; ignore. */
					break;

				default:
					break;
			}

			continue;
		}

		/* Filter NUL bytes - Telnet sends CR-NUL for plain carriage return */
		if (byte == 0x00)
		{
			continue;
		}

		buffer[write_index++] = (char)byte;
	}

	return write_index;
}


void resolve_address(int line_id)
{
  int result;
  _kernel_swi_regs r;
  _kernel_oserror *er;
  struct hostent *host;
  char buffer[128];        // from 64

if (line_configuration[line_id].socket != 0)
{

  /* First call? */
  if (line_configuration[line_id].resolved == 0)
  {
    sprintf(buffer,"Resolving: %s",line_configuration[line_id].remote);
    Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
        buffer);
   line_configuration[line_id].resolved++;
  }

  /* Find an address */
  r.r[0]=(int)line_configuration[line_id].remote;
  r.r[1]=0;
  er=_kernel_swi(Resolver_GetHost,&r,&r);
  result=r.r[0];
  host=(struct hostent *)r.r[1];

  if (er!=NULL)
  {
    /* No ANT resolver */
    sprintf(buffer,"Resolver not loaded: %s",line_configuration[line_id].remote);
    line_configuration[line_id].resolved=3;
  }
  else
  {
    switch(result)
    {
      case 0:
        /* Got name */
        sprintf(buffer,"%s",host->h_name);
        line_configuration[line_id].resolved=3;
        break;

      case EINPROGRESS:
        /* It's working */
        break;

      case -1:
        /* Not found: update info */
        sprintf(buffer,"Unable to resolve: %s",line_configuration[line_id].remote);
        line_configuration[line_id].resolved=3;
        break;

      case -2:
        /* Not found (remote error) */
        sprintf(buffer,"Resolver error: %s",line_configuration[line_id].remote);
        line_configuration[line_id].resolved=3;
        break;
    }
  }

  Desk_Icon_SetText(main_window,
	  main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
      buffer);
}
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Config File Handling                                                                                                                                                                */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

void load_system_config(void)
{
	FILE *system_config;

	char config_line[250];
	char *temporary_line;

	/* Set defaults */
	system_configuration[0].port = 23;
	system_configuration[0].timeout = 120;
	strncpy(system_configuration[0].ftnmail, "no", sizeof(system_configuration[0].ftnmail) - 1);
	system_configuration[0].ftnmail[sizeof(system_configuration[0].ftnmail) - 1] = '\0';
	strncpy(system_configuration[0].webserver, "no", sizeof(system_configuration[0].webserver) - 1);
	system_configuration[0].webserver[sizeof(system_configuration[0].webserver) - 1] = '\0';

	if ((system_config=fopen("<Converse$Dir>.Config.System","r"))==NULL)
	{
		display_error_dialog(1, error_cantfindsystemconfig);
	}

	while (fgets(config_line, sizeof(config_line), system_config) != NULL)
	{
		/* Strip trailing control chars */
		while (strlen(config_line) > 0 && config_line[strlen(config_line)-1] < 32)
		{
			config_line[strlen(config_line)-1] = 0;
		}
		/* Strip trailing spaces */
		while (strlen(config_line) > 0 && config_line[strlen(config_line)-1] == 32)
		{
			config_line[strlen(config_line)-1] = 0;
		}

		/* Skip empty lines and comments */
		if (config_line[0] == '\0' || config_line[0] == ';')
		{
			continue;
		}

		/* Find first space or tab as delimiter */
		if ((temporary_line=strchr(config_line,' '))!=NULL)
		{
			*temporary_line++=0; 
		}
		else if ((temporary_line=strchr(config_line,'\t'))!=NULL)
		{
			*temporary_line++=0; 
		} 
		else
		{
			temporary_line="";
		}
		/* Skip any whitespace (spaces or tabs) */
		while(*temporary_line==' ' || *temporary_line=='\t')
		{
			temporary_line++;
		}

		if (strcmp(config_line,"name")==0)
		{
			strncpy(system_configuration[0].name, temporary_line, sizeof(system_configuration[0].name) - 1);
			system_configuration[0].name[sizeof(system_configuration[0].name) - 1] = '\0';
		}
		if (strcmp(config_line,"sysop")==0)
		{
			strncpy(system_configuration[0].sysop, temporary_line, sizeof(system_configuration[0].sysop) - 1);
			system_configuration[0].sysop[sizeof(system_configuration[0].sysop) - 1] = '\0';
		}
		if (strcmp(config_line,"contact")==0)
		{
			strncpy(system_configuration[0].contact, temporary_line, sizeof(system_configuration[0].contact) - 1);
			system_configuration[0].contact[sizeof(system_configuration[0].contact) - 1] = '\0';
		}
		if (strcmp(config_line,"hostname")==0)
		{
			strncpy(system_configuration[0].hostname, temporary_line, sizeof(system_configuration[0].hostname) - 1);
			system_configuration[0].hostname[sizeof(system_configuration[0].hostname) - 1] = '\0';
		}
		if (strcmp(config_line,"port")==0)
		{
			system_configuration[0].port = atoi(temporary_line);
		}
		if (strcmp(config_line,"timeout")==0)
		{
			system_configuration[0].timeout = atoi(temporary_line);
		}
		if (strcmp(config_line,"botstopper")==0)
		{
			strncpy(system_configuration[0].botstopper, temporary_line, sizeof(system_configuration[0].botstopper) - 1);
			system_configuration[0].botstopper[sizeof(system_configuration[0].botstopper) - 1] = '\0';
		}
		if (strcmp(config_line,"needlogin")==0)
		{
			strncpy(system_configuration[0].needlogin, temporary_line, sizeof(system_configuration[0].needlogin) - 1);
			system_configuration[0].needlogin[sizeof(system_configuration[0].needlogin) - 1] = '\0';
		}
		if (strcmp(config_line,"closed")==0)
		{
			strncpy(system_configuration[0].closed, temporary_line, sizeof(system_configuration[0].closed) - 1);
			system_configuration[0].closed[sizeof(system_configuration[0].closed) - 1] = '\0';
		}
		if (strcmp(config_line,"pager")==0)
		{
			strncpy(system_configuration[0].pager, temporary_line, sizeof(system_configuration[0].pager) - 1);
			system_configuration[0].pager[sizeof(system_configuration[0].pager) - 1] = '\0';
		}
		if (strcmp(config_line,"ftnmail")==0)
		{
			strncpy(system_configuration[0].ftnmail, temporary_line, sizeof(system_configuration[0].ftnmail) - 1);
			system_configuration[0].ftnmail[sizeof(system_configuration[0].ftnmail) - 1] = '\0';
		}
		if (strcmp(config_line,"webserver")==0)
		{
			strncpy(system_configuration[0].webserver, temporary_line, sizeof(system_configuration[0].webserver) - 1);
			system_configuration[0].webserver[sizeof(system_configuration[0].webserver) - 1] = '\0';
		}
		if (strcmp(config_line,"anykey")==0)
		{
			strncpy(system_configuration[0].anykey, temporary_line, sizeof(system_configuration[0].anykey) - 1);
			system_configuration[0].anykey[sizeof(system_configuration[0].anykey) - 1] = '\0';
		}
		if (strcmp(config_line,"chatstart")==0)
		{
			strncpy(system_configuration[0].chatstart, temporary_line, sizeof(system_configuration[0].chatstart) - 1);
			system_configuration[0].chatstart[sizeof(system_configuration[0].chatstart) - 1] = '\0';
		}
		if (strcmp(config_line,"chatend")==0)
		{
			strncpy(system_configuration[0].chatend, temporary_line, sizeof(system_configuration[0].chatend) - 1);
			system_configuration[0].chatend[sizeof(system_configuration[0].chatend) - 1] = '\0';
		}
		if (strcmp(config_line,"prelogon")==0)
		{
			strncpy(system_configuration[0].prelogon, temporary_line, sizeof(system_configuration[0].prelogon) - 1);
			system_configuration[0].prelogon[sizeof(system_configuration[0].prelogon) - 1] = '\0';
		}
		if (strcmp(config_line,"postlogon")==0)
		{
			strncpy(system_configuration[0].postlogon, temporary_line, sizeof(system_configuration[0].postlogon) - 1);
			system_configuration[0].postlogon[sizeof(system_configuration[0].postlogon) - 1] = '\0';
		}
		if (strcmp(config_line,"logoff")==0)
		{
			strncpy(system_configuration[0].logoff, temporary_line, sizeof(system_configuration[0].logoff) - 1);
			system_configuration[0].logoff[sizeof(system_configuration[0].logoff) - 1] = '\0';
		}
		if (strcmp(config_line,"welcome")==0)
		{
			strncpy(system_configuration[0].welcome, temporary_line, sizeof(system_configuration[0].welcome) - 1);
			system_configuration[0].welcome[sizeof(system_configuration[0].welcome) - 1] = '\0';
		}
		if (strcmp(config_line,"newuser")==0)
		{
			strncpy(system_configuration[0].newuser, temporary_line, sizeof(system_configuration[0].newuser) - 1);
			system_configuration[0].newuser[sizeof(system_configuration[0].newuser) - 1] = '\0';
		}
		if (strcmp(config_line,"timeup")==0)
		{
			strncpy(system_configuration[0].timeup, temporary_line, sizeof(system_configuration[0].timeup) - 1);
			system_configuration[0].timeup[sizeof(system_configuration[0].timeup) - 1] = '\0';
		}
		if (strcmp(config_line,"lockedout")==0)
		{
			strncpy(system_configuration[0].lockedout, temporary_line, sizeof(system_configuration[0].lockedout) - 1);
			system_configuration[0].lockedout[sizeof(system_configuration[0].lockedout) - 1] = '\0';
		}
		if (strcmp(config_line,"closedsys")==0)
		{
			strncpy(system_configuration[0].closedsys, temporary_line, sizeof(system_configuration[0].closedsys) - 1);
			system_configuration[0].closedsys[sizeof(system_configuration[0].closedsys) - 1] = '\0';
		}
		if (strcmp(config_line,"aftermail")==0)
		{
			strncpy(system_configuration[0].aftermail, temporary_line, sizeof(system_configuration[0].aftermail) - 1);
			system_configuration[0].aftermail[sizeof(system_configuration[0].aftermail) - 1] = '\0';
		}
	}

	fclose(system_config);

	/* Sanitize all string config values */
	sanitize_string(system_configuration[0].name);
	sanitize_string(system_configuration[0].sysop);
	sanitize_string(system_configuration[0].contact);
	sanitize_string(system_configuration[0].hostname);
	sanitize_string(system_configuration[0].botstopper);
	sanitize_string(system_configuration[0].needlogin);
	sanitize_string(system_configuration[0].closed);
	sanitize_string(system_configuration[0].pager);
	sanitize_string(system_configuration[0].ftnmail);
	sanitize_string(system_configuration[0].webserver);
	sanitize_string(system_configuration[0].anykey);
	sanitize_string(system_configuration[0].chatstart);
	sanitize_string(system_configuration[0].chatend);
	sanitize_string(system_configuration[0].prelogon);
	sanitize_string(system_configuration[0].postlogon);
	sanitize_string(system_configuration[0].logoff);
	sanitize_string(system_configuration[0].welcome);
	sanitize_string(system_configuration[0].newuser);
	sanitize_string(system_configuration[0].timeup);
	sanitize_string(system_configuration[0].lockedout);
	sanitize_string(system_configuration[0].closedsys);
	sanitize_string(system_configuration[0].aftermail);
}

void load_line_config(void)
{
	FILE *line_config;

	char config_line[250];
	char *temporary_line;
	int block_count = 0;
	int in_block = 0;

	/* Temporary storage for parsing before we know if enabled */
	char temp_line[4] = "";
	char temp_enabled[4] = "";
	char temp_botstopper[128] = "";
	char temp_hello[256] = "";
	char temp_init[64] = "";
	char temp_ring[32] = "";
	char temp_answer[32] = "";
	int temp_rings = 1;

	/* Line type storage */
	char temp_type[16] = "";
	line_type_t temp_line_type = LINE_TYPE_TELNET;

	/* Serial-specific storage */
	char temp_driver[32] = "";
	int temp_port = 0;
	int temp_speed = 115200;
	char temp_format[8] = "";
	char temp_flow[16] = "";

	debug_printf("load_line_config: Opening <Converse$Dir>.Config.Lines\n");

	if ((line_config=fopen("<Converse$Dir>.Config.Lines","r"))==NULL)
	{
		debug_printf("load_line_config: ERROR - Failed to open config file\n");
		display_error_dialog(1, error_cantfindlineconfig);
	}

	debug_printf("load_line_config: Config file opened successfully\n");

	while (fgets(config_line, sizeof(config_line), line_config) != NULL)
	{
		if(line_configurations > 32)
		{
			debug_printf("load_line_config: ERROR - Too many lines (>32)\n");
			display_error_dialog(1, error_toomanylines);
		}

		/* Strip trailing control characters and spaces */
		while (strlen(config_line) > 0 && config_line[strlen(config_line)-1] < 32)
		{
			config_line[strlen(config_line)-1] = 0;
		}
		while (strlen(config_line) > 0 && config_line[strlen(config_line)-1] == 32)
		{
			config_line[strlen(config_line)-1] = 0;
		}

		/* Skip empty lines and comments */
		if (config_line[0] == '\0' || config_line[0] == ';')
		{
			continue;
		}

		/* Find first space or tab as delimiter */
		if ((temporary_line=strchr(config_line,' '))!=NULL)
		{
			*temporary_line++=0; 
		}
		else if ((temporary_line=strchr(config_line,'\t'))!=NULL)
		{
			*temporary_line++=0; 
		} 
		else
		{
			temporary_line="";
		}

		/* Skip any whitespace (spaces or tabs) */
		while(*temporary_line==' ' || *temporary_line=='\t')
		{
			temporary_line++;
		}

		/* Check for block start */
		if (strcmp(config_line, "start") == 0)
		{
			/* Reset temporary storage for new block */
			temp_line[0] = '\0';
			temp_enabled[0] = '\0';
			temp_botstopper[0] = '\0';
			temp_hello[0] = '\0';
			temp_init[0] = '\0';
			temp_ring[0] = '\0';
			temp_answer[0] = '\0';
			temp_rings = 1;

			/* Reset line type storage */
			temp_type[0] = '\0';
			temp_line_type = LINE_TYPE_TELNET;

			/* Reset serial-specific storage */
			temp_driver[0] = '\0';
			temp_port = 0;
			temp_speed = 115200;
			temp_format[0] = '\0';
			temp_flow[0] = '\0';
			temp_init[0] = '\0';
			temp_ring[0] = '\0';
			temp_answer[0] = '\0';
			temp_rings = 1;

			in_block = 1;
			block_count++;
			debug_printf("load_line_config: Parsing block %d\n", block_count);
			continue;
		}

		/* Check for block end */
		if (strcmp(config_line, "end") == 0)
		{
			if (in_block)
			{
				/* Sanitize temp values before use */
				sanitize_string(temp_line);
				sanitize_string(temp_enabled);
				sanitize_string(temp_botstopper);
				sanitize_string(temp_hello);
				sanitize_string(temp_type);
				sanitize_string(temp_driver);
				sanitize_string(temp_format);
				sanitize_string(temp_flow);
				sanitize_string(temp_init);
				sanitize_string(temp_ring);
				sanitize_string(temp_answer);

				/* Parse line type */
				if (str_casecmp(temp_type, "serial") == 0)
				{
					temp_line_type = LINE_TYPE_SERIAL;
				}
				else if (str_casecmp(temp_type, "local") == 0)
				{
					temp_line_type = LINE_TYPE_LOCAL;
				}
				else
				{
					temp_line_type = LINE_TYPE_TELNET;
				}

				/* Serial and local lines never use botstopper/hello */
				if (temp_line_type != LINE_TYPE_TELNET)
				{
					temp_botstopper[0] = '\0';
					temp_hello[0] = '\0';
				}

				/* Only add line if enabled */
				if (str_casecmp(temp_enabled, "yes") == 0)
				{
					debug_printf("load_line_config: Adding line %s (index %d) type=%d - ENABLED\n", 
					             temp_line, line_configurations, temp_line_type);

					/* Basic config */
					strncpy(line_configuration[line_configurations].line, temp_line, 
					        sizeof(line_configuration[line_configurations].line) - 1);
					line_configuration[line_configurations].line[sizeof(line_configuration[line_configurations].line) - 1] = '\0';
					strncpy(line_configuration[line_configurations].enabled, temp_enabled, 
					        sizeof(line_configuration[line_configurations].enabled) - 1);
					line_configuration[line_configurations].enabled[sizeof(line_configuration[line_configurations].enabled) - 1] = '\0';
					strncpy(line_configuration[line_configurations].botstopper, temp_botstopper, 
					        sizeof(line_configuration[line_configurations].botstopper) - 1);
					line_configuration[line_configurations].botstopper[sizeof(line_configuration[line_configurations].botstopper) - 1] = '\0';
					strncpy(line_configuration[line_configurations].hello, temp_hello, 
					        sizeof(line_configuration[line_configurations].hello) - 1);
					line_configuration[line_configurations].hello[sizeof(line_configuration[line_configurations].hello) - 1] = '\0';

					/* Line type */
					line_configuration[line_configurations].type = temp_line_type;

					/* Always initialise driver to NULL */
					line_configuration[line_configurations].driver = NULL;
					line_configuration[line_configurations].driver_name[0] = '\0';

					/* Serial-specific config */
					if (temp_line_type == LINE_TYPE_SERIAL)
					{
						/* Apply serial defaults if not provided */
						if (temp_ring[0] == '\0')
						{
							strncpy(temp_ring, "RING", sizeof(temp_ring) - 1);
							temp_ring[sizeof(temp_ring) - 1] = '\0';
						}
						if (temp_answer[0] == '\0')
						{
							strncpy(temp_answer, "ATA", sizeof(temp_answer) - 1);
							temp_answer[sizeof(temp_answer) - 1] = '\0';
						}

						strncpy(line_configuration[line_configurations].driver_name, temp_driver,
						        sizeof(line_configuration[line_configurations].driver_name) - 1);
						line_configuration[line_configurations].driver_name[sizeof(line_configuration[line_configurations].driver_name) - 1] = '\0';
						line_configuration[line_configurations].port_number = temp_port;
						line_configuration[line_configurations].baud_rate = temp_speed;
						line_configuration[line_configurations].word_format = serial_parse_word_format(temp_format);
						line_configuration[line_configurations].flow_control = serial_parse_flow_control(temp_flow);
						line_configuration[line_configurations].rings = temp_rings;
						strncpy(line_configuration[line_configurations].init, temp_init,
						        sizeof(line_configuration[line_configurations].init) - 1);
						line_configuration[line_configurations].init[sizeof(line_configuration[line_configurations].init) - 1] = '\0';
						strncpy(line_configuration[line_configurations].ring, temp_ring,
						        sizeof(line_configuration[line_configurations].ring) - 1);
						line_configuration[line_configurations].ring[sizeof(line_configuration[line_configurations].ring) - 1] = '\0';
						strncpy(line_configuration[line_configurations].answer, temp_answer,
						        sizeof(line_configuration[line_configurations].answer) - 1);
						line_configuration[line_configurations].answer[sizeof(line_configuration[line_configurations].answer) - 1] = '\0';
						line_configuration[line_configurations].carrier_detect = 0;
						debug_printf("load_line_config:   Serial: driver=%s port=%d speed=%d\n",
						             temp_driver, temp_port, temp_speed);
					}
					else
					{
						/* Clear serial-only fields for non-serial lines */
						line_configuration[line_configurations].rings = 0;
						line_configuration[line_configurations].init[0] = '\0';
						line_configuration[line_configurations].ring[0] = '\0';
						line_configuration[line_configurations].answer[0] = '\0';
					}

					line_configurations++;
				}
				else
				{
					debug_printf("load_line_config: Skipping line %s - not enabled (enabled='%s')\n", 
					             temp_line[0] ? temp_line : "?", temp_enabled);
				}
				in_block = 0;
			}
			continue;
		}

		/* Parse block content only if we're inside a block */
		if (!in_block)
		{
			continue;
		}

		if (strcmp(config_line,"line")==0)
		{
			strncpy(temp_line, temporary_line, sizeof(temp_line) - 1);
			temp_line[sizeof(temp_line) - 1] = '\0';
			debug_printf("load_line_config:   line = '%s'\n", temp_line);
		}
		else if (strcmp(config_line,"enabled")==0)
		{
			strncpy(temp_enabled, temporary_line, sizeof(temp_enabled) - 1);
			temp_enabled[sizeof(temp_enabled) - 1] = '\0';
			debug_printf("load_line_config:   enabled = '%s'\n", temp_enabled);
		}
		else if (strcmp(config_line,"botstopper")==0)
		{
			strncpy(temp_botstopper, temporary_line, sizeof(temp_botstopper) - 1);
			temp_botstopper[sizeof(temp_botstopper) - 1] = '\0';
			debug_printf("load_line_config:   botstopper = '%s'\n", temp_botstopper);
		}
		else if (strcmp(config_line,"hello")==0)
		{
			strncpy(temp_hello, temporary_line, sizeof(temp_hello) - 1);
			temp_hello[sizeof(temp_hello) - 1] = '\0';
			debug_printf("load_line_config:   hello = '%s'\n", temp_hello);
		}
		else if (strcmp(config_line,"type")==0)
		{
			strncpy(temp_type, temporary_line, sizeof(temp_type) - 1);
			temp_type[sizeof(temp_type) - 1] = '\0';
			debug_printf("load_line_config:   type = '%s'\n", temp_type);
		}
		else if (strcmp(config_line,"driver")==0)
		{
			strncpy(temp_driver, temporary_line, sizeof(temp_driver) - 1);
			temp_driver[sizeof(temp_driver) - 1] = '\0';
			debug_printf("load_line_config:   driver = '%s'\n", temp_driver);
		}
		else if (strcmp(config_line,"port")==0)
		{
			temp_port = atoi(temporary_line);
			debug_printf("load_line_config:   port = %d\n", temp_port);
		}
		else if (strcmp(config_line,"speed")==0)
		{
			temp_speed = atoi(temporary_line);
			debug_printf("load_line_config:   speed = %d\n", temp_speed);
		}
		else if (strcmp(config_line,"format")==0)
		{
			strncpy(temp_format, temporary_line, sizeof(temp_format) - 1);
			temp_format[sizeof(temp_format) - 1] = '\0';
			debug_printf("load_line_config:   format = '%s'\n", temp_format);
		}
		else if (strcmp(config_line,"flow")==0)
		{
			strncpy(temp_flow, temporary_line, sizeof(temp_flow) - 1);
			temp_flow[sizeof(temp_flow) - 1] = '\0';
			debug_printf("load_line_config:   flow = '%s'\n", temp_flow);
		}
		else if (strcmp(config_line,"init")==0)
		{
			strncpy(temp_init, temporary_line, sizeof(temp_init) - 1);
			temp_init[sizeof(temp_init) - 1] = '\0';
			debug_printf("load_line_config:   init = '%s'\n", temp_init);
		}
		else if (strcmp(config_line,"ring")==0)
		{
			strncpy(temp_ring, temporary_line, sizeof(temp_ring) - 1);
			temp_ring[sizeof(temp_ring) - 1] = '\0';
			debug_printf("load_line_config:   ring = '%s'\n", temp_ring);
		}
		else if (strcmp(config_line,"rings")==0)
		{
			temp_rings = atoi(temporary_line);
			if (temp_rings <= 0)
			{
				temp_rings = 1;
			}
			debug_printf("load_line_config:   rings = %d\n", temp_rings);
		}
		else if (strcmp(config_line,"answer")==0)
		{
			strncpy(temp_answer, temporary_line, sizeof(temp_answer) - 1);
			temp_answer[sizeof(temp_answer) - 1] = '\0';
			debug_printf("load_line_config:   answer = '%s'\n", temp_answer);
		}
	}

	fclose(line_config);

	debug_printf("load_line_config: Finished - %d enabled lines configured\n", line_configurations);

	if (line_configurations == 0) {
		debug_printf("load_line_config: ERROR - No lines defined\n");
		display_error_dialog(1, error_nolinesdefined);
	}
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                                                    */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

int main(void) {
	struct wimp_components wimp;

	char iconbar_menu[100];
	char iconbar_menu_title[30];

	wimp.quit = Desk_bool_FALSE;

	Desk_Resource_Initialise("ConverseRes");
	system("Set Converse$Running 1");

	Desk_Msgs_LoadFile("Messages");

	Desk_Msgs_Lookup("server.wait", waiting_user, 100);
	Desk_Msgs_Lookup("server.nact", user_activity, 100);

	/* Fallback if Messages file tokens are missing */
	if (waiting_user[0] == '\0')
	{
		strcpy(waiting_user, "(Not logged in)");
	}
	if (user_activity[0] == '\0')
	{
		strcpy(user_activity, "----");
	}

	Desk_Msgs_Lookup("error.1", error_bind, 100);
	Desk_Msgs_Lookup("error.2", error_listen, 100);
	Desk_Msgs_Lookup("error.3", error_busy, 100);
	Desk_Msgs_Lookup("error.4", error_cantfindsystemconfig, 100);
	Desk_Msgs_Lookup("error.5", error_cantfindlineconfig, 100);
	Desk_Msgs_Lookup("error.7", error_toomanylines, 100);
	Desk_Msgs_Lookup("error.11", error_nolinesdefined, 100);

	Desk_Event_Initialise("Converse");
	Desk_EventMsg_Initialise();
	Desk_Screen_CacheModeInfo();

	Desk_EventMsg_Claim(Desk_message_MODECHANGE, Desk_event_ANY, Desk_Handler_ModeChange, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_ACTIVITY, Desk_event_ANY, wimp_handle_line_activity_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_CONTROL, Desk_event_ANY, wimp_handle_line_control_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_REGISTER, Desk_event_ANY, wimp_handle_line_register_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_USER, Desk_event_ANY, wimp_handle_line_user_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_SERIAL_CONNECT, Desk_event_ANY, wimp_handle_serial_connect_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_SERIAL_DISCONNECT, Desk_event_ANY, wimp_handle_serial_disconnect_message, NULL);
	Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY, Desk_Handler_NullRedraw, NULL);
	Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY, Desk_Handler_OpenWindow, NULL);
  	Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY, wimp_handle_window_close, NULL);
	Desk_Event_Claim(Desk_event_CLICK, Desk_event_ANY, Desk_event_ANY, wimp_handle_button_click, NULL);

	Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, wimp_handle_poll, NULL);


	wimp.iconbar_icon_handle = Desk_Icon_BarIcon("!Converse", Desk_iconbar_RIGHT);
	Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, wimp.iconbar_icon_handle, wimp_handle_iconbar_click, (void *)&wimp);
	Desk_Msgs_Lookup("server.ibmt", iconbar_menu_title, 30);
	Desk_Msgs_Lookup("server.ibm", iconbar_menu, 100);
  	wimp.iconbar_menu_handle = Desk_Menu_New(iconbar_menu_title, iconbar_menu);

	Desk_Template_Initialise();
  	Desk_Template_UseOutlineFonts();
  	Desk_Template_LoadFile("Templates");

	/* Open waiting window centred on screen immediately */
	waiting_window = Desk_Window_Create("waiting", NULL);
	Desk_Window_Show(waiting_window, Desk_open_CENTERED);
	waiting_update("Starting Converse BBS...");

	/* Load status window sprites */
	{
		int sprite_size = Desk_File_Size("<Converse$Dir>.Resources.Sprites");
		if (sprite_size > 0)
		{
			status_sprites = (Desk_sprite_area)malloc(sprite_size + 4);
			if (status_sprites)
			{
				status_sprites->areasize = sprite_size + 4;
				status_sprites->numsprites = 0;
				status_sprites->firstoffset = 16;
				status_sprites->freeoffset = 16;
				Desk_Sprite_Load(status_sprites, "<Converse$Dir>.Resources.Sprites");
				Desk_Template_LinkSpriteArea("status", status_sprites);
			}
		}
	}

  	proginfo_window=Desk_Dialog2_CreateDialogBlock("proginfo", -1, -1, NULL, NULL, NULL);
	systeminfo_window=Desk_Dialog2_CreateDialogBlock("sysinfo", -1, -1, NULL, NULL, NULL);
  	main_window=Desk_Window_Create("status", NULL);

  	Desk_Menu_Warn(wimp.iconbar_menu_handle, iconbar_menu_proginfo, Desk_bool_TRUE, wimp_open_proginfo_window, (void *)proginfo_window);
	Desk_Menu_Warn(wimp.iconbar_menu_handle, iconbar_menu_systeminfo, Desk_bool_TRUE, wimp_open_systeminfo_window, (void *)systeminfo_window);

	waiting_update("Loading system configuration...");
	load_system_config();
	waiting_update("Loading line configuration...");
	load_line_config();
	support_push_config();
	waiting_update("Checking messagebases...");
	load_msgbase_config();
	waiting_update("Checking filebases...");
	load_filebase_config();
	waiting_update("Initialising upload module...");
	upload_initialise();
	waiting_update("Loading FTN configuration...");
	load_ftn_config();
	waiting_update("Loading access control...");
	load_access_config();
	{
		int i;
		for (i = 0; i < line_configurations; i++)
		{
			support_set_line_configured(i, 1);
			support_set_line_type(i, (int)line_configuration[i].type);
			support_push_line_config(i);
			support_push_serial_config(i);
		}
	}
	waiting_update("Starting line tasks...");
	launch_line_tasks();
	waiting_update("Starting FTN mailer...");
	launch_ftn_task();
	waiting_update("Starting web server...");
	launch_web_task();
	waiting_update("Starting serial handler...");
	launch_serial_task();

	waiting_update("Starting network listener...");
	create_line_icons();
	create_listener();
	status_initialise();

	/* Close waiting window - startup complete */
	Desk_Window_Hide(waiting_window);

	atexit(destroy_listener);

	while(wimp.quit == Desk_bool_FALSE) poll_idle();

	upload_shutdown();

	return(0);
}
