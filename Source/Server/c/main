/* ******************************************************************************************************************************************************** */
/* Server                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.File.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"
#include "C:Desk.Sound.h"

/* TCPIP Includes */
#define COMPAT_INET4 1
#include "sys/types.h" 
#include "sys/socket.h"
#include "socklib.h"
#include "inetlib.h"
#include "netinet/in.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netdb.h"

/* Our Includes */
#include "main.h"
#include "iconnames.h"
#include "ansi.h"
#include "debug.h"
#include "config.h"

/* Function Prototypes */
Desk_bool wimp_handle_iconbar_click(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_window_close(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_open_proginfo_window(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_open_systeminfo_window(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_button_click(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_poll(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_activity_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_control_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_register_message(Desk_event_pollblock *event, void *ref);
Desk_bool wimp_handle_line_user_message(Desk_event_pollblock *event, void *ref);

void display_error_dialog(int isFatal, const char *stringFormat, ...);

void load_system_config(void);
void load_line_config(void);

int create_line_icons(void);

void create_listener(void);
void destroy_listener(void);
void check_listener(void);
void check_socket(int line_id, int socket);
void resolve_address(int line_id);

void send_byte_to_socket(int socket_address, int first_byte, int second_byte);
void send_string_to_socket(int socket_address, char *string_to_send);

extern long timer_monotonictime(void);
extern long timer_set(unsigned int delay);
extern int timer_action(long timer);

static void telnet_advertise_capabilities(int socket);
static void telnet_handle_option(int socket, unsigned char command, unsigned char option);
static int telnet_filter_input(int socket, char *buffer, int length);
static void launch_line_tasks(void);
static void launch_ftn_task(void);
static void launch_web_task(void);
static void pipes_reset_line(int line_id);
static int pipes_input_status(int line_id);
static int pipes_input_write_block(int line_id, const char *buffer, int length);
static int pipes_output_read_block(int line_id, char *buffer, int length);
static void pipes_send_control_command(int line_id, char command);
static void pump_socket_to_pipe(int line_id, int socket);
static void pump_pipe_to_socket(int line_id, int socket);
static void close_line_connection(int line_id);
static void notify_line_tasks_shutdown(void);
static Desk_bool main_window_icon_to_line(Desk_icon_handle icon, int *line_id, int *column);
static void send_line_task_view_request(int line_id);
static void unload_modules(void);

/* ConverseBBS support functions */
static void support_push_config(void);
static void support_push_line_config(int line_id);
static void support_set_line_configured(int line_id, int configured);
static void support_set_line_connected(int line_id, int connected);
static void support_set_line_hostname(int line_id, const char *hostname);
static void support_set_line_connect_time(int line_id, time_t connect_time);
static void support_set_activity(int line_id, const char *activity);
static int support_get_transfer_active(int line_id);

/* String sanitization - strips leading/trailing whitespace and control chars */
static void sanitize_string(char *str)
{
	char *src = str;
	char *dst = str;
	char *end;

	/* Skip leading whitespace and control characters */
	while (*src && ((unsigned char)*src <= 32))
	{
		src++;
	}

	/* Copy to destination, stopping at any control character (< 32) except we allow space */
	while (*src)
	{
		unsigned char c = (unsigned char)*src;
		/* Stop at CR, LF, or other control chars (but allow printable chars and space) */
		if (c < 32)
		{
			break;
		}
		*dst++ = *src++;
	}
	*dst = '\0';

	/* Strip trailing spaces */
	if (dst > str)
	{
		end = dst - 1;
		while (end >= str && *end == ' ')
		{
			*end-- = '\0';
		}
	}
}

/* Case-insensitive string comparison helper */
static int str_casecmp(const char *s1, const char *s2)
{
	while (*s1 && *s2)
	{
		int c1 = tolower((unsigned char)*s1);
		int c2 = tolower((unsigned char)*s2);
		if (c1 != c2)
		{
			return c1 - c2;
		}
		s1++;
		s2++;
	}
	return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

#define MAIN_WINDOW_ICON_BASE 13
#define MAIN_WINDOW_ICONS_PER_LINE 7
#define MAIN_WINDOW_ICON_HEIGHT 64
#define MAIN_WINDOW_TOP_STATIC_ROWS 2
#define MAIN_WINDOW_BOTTOM_STATIC_ROWS 0
#define MAIN_WINDOW_STATIC_ICON_COUNT (MAIN_WINDOW_TOP_STATIC_ROWS + MAIN_WINDOW_BOTTOM_STATIC_ROWS)
#define MAIN_WINDOW_PADDING 10

#define MAIN_WINDOW_COLUMN_START 5
#define MAIN_WINDOW_COLUMN_GAP 8
#define MAIN_WINDOW_LINE_COLUMN_WIDTH 88
#define MAIN_WINDOW_USER_COLUMN_WIDTH 300
#define MAIN_WINDOW_ACTIVITY_COLUMN_WIDTH 390
#define MAIN_WINDOW_HOSTNAME_COLUMN_WIDTH 390
#define MAIN_WINDOW_TIMER_COLUMN_WIDTH 200
#define MAIN_WINDOW_ACTION_COLUMN_WIDTH 80
#define MAIN_WINDOW_VIEW_COLUMN_WIDTH 80

#define PIPES_SWI_BASE 0x5AA00
#define PIPES_BUFFER_CAPACITY 4096
#define PIPE_TRANSFER_CHUNK 1536
#define LINE_IDLE_TIMEOUT_TICKS ((clock_t)(30 * CLOCKS_PER_SEC))

#define MAIN_WINDOW_HOSTNAME_TEXT_LEN 256

#define SWI_CONVERSE_PIPES_INPUT_STATUS      (PIPES_SWI_BASE + 2)
#define SWI_CONVERSE_PIPES_CLEAR_INPUT       (PIPES_SWI_BASE + 6)
#define SWI_CONVERSE_PIPES_CLEAR_OUTPUT      (PIPES_SWI_BASE + 7)
#define SWI_CONVERSE_PIPES_INPUT_WRITE_BLOCK (PIPES_SWI_BASE + 13)
#define SWI_CONVERSE_PIPES_OUTPUT_READ_BLOCK (PIPES_SWI_BASE + 14)
#define SWI_CONVERSE_PIPES_RESET_STATE       (PIPES_SWI_BASE + 10)

/* ConverseBBS Support module SWIs */
#define SWI_CONVERSEBBS_CONFIG     0x5AA80
#define SWI_CONVERSEBBS_LINE       0x5AA81
#define SWI_CONVERSEBBS_ACTIVITY   0x5AA82
#define SWI_CONVERSEBBS_LINECONFIG 0x5AA83

/* Config reason codes */
#define CONFIG_REASON_GET 0
#define CONFIG_REASON_SET 1

/* Line reason codes */
#define LINE_REASON_SET 0
#define LINE_REASON_GET 1

/* Line field indices */
#define LINE_FIELD_CONFIGURED  0
#define LINE_FIELD_CONNECTED   1
#define LINE_FIELD_USER_ID     2
#define LINE_FIELD_CONNECT_TIME 3
#define LINE_FIELD_HOSTNAME    4
#define LINE_FIELD_TRANSFER    5

/* Activity reason codes */
#define ACTIVITY_REASON_SET 0
#define ACTIVITY_REASON_GET 1

/* LineConfig reason codes */
#define LINECONFIG_REASON_SET 0
#define LINECONFIG_REASON_GET 1

/* LineConfig field indices */
#define LINECONFIG_FIELD_ENABLED    0
#define LINECONFIG_FIELD_BOTSTOPPER 1
#define LINECONFIG_FIELD_HELLO      2

#define PIPE_CONTROL_TOKEN      ((unsigned char)0x00)
#define PIPE_CONTROL_CONNECT    'C'
#define PIPE_CONTROL_DISCONNECT 'D'
#define MESSAGE_LINE_BASE       0x5AA00
#define MESSAGE_LINE_BROADCAST  (MESSAGE_LINE_BASE + 0)
#define MESSAGE_LINE_ACTIVITY   (MESSAGE_LINE_BASE + 1)
#define MESSAGE_LINE_CONTROL    (MESSAGE_LINE_BASE + 2)
#define MESSAGE_LINE_VIEW_WINDOW (MESSAGE_LINE_BASE + 3)
#define MESSAGE_LINE_REGISTER   (MESSAGE_LINE_BASE + 4)
#define MESSAGE_LINE_USER       (MESSAGE_LINE_BASE + 5)
#define LINE_CONTROL_REASON_LOGOFF 1

#define SWI_OS_READMONOTONICTIME 0x00000042
#define POLL_IDLE_DELAY 1  /* centiseconds between null polls (10ms) */


enum
{
	MAIN_WINDOW_COLUMN_LINE = 0,
	MAIN_WINDOW_COLUMN_USER,
	MAIN_WINDOW_COLUMN_ACTIVITY,
	MAIN_WINDOW_COLUMN_HOSTNAME,
	MAIN_WINDOW_COLUMN_TIMER,
	MAIN_WINDOW_COLUMN_ACTION,
	MAIN_WINDOW_COLUMN_VIEW
};

static void poll_idle(void)
{
	_kernel_swi_regs regs;
	Desk_event_pollblock event;
	int earliest;

	/* Get current monotonic time and add delay */
	_kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
	earliest = regs.r[0] + POLL_IDLE_DELAY;

	/* Poll with idle time - won't return null events until 'earliest' */
	Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
	Desk_Event_Process(&event);
}

static int main_window_icon_index(int line_id, int column)
{
	return MAIN_WINDOW_ICON_BASE + (line_id * MAIN_WINDOW_ICONS_PER_LINE) + column;
}

static int main_window_visible_lines(void)
{
	if (line_configurations < 1)
	{
		return 0;
	}

	return line_configurations;
}

static void launch_line_tasks(void)
{
	int line_index = 0;
	char command[128];

	while (line_index < line_configurations)
	{
		snprintf(command, sizeof(command), "<Converse$Dir>.Resources.!RunLine %d", line_index);
		Desk_Wimp_StartTask(command);
		pipes_reset_line(line_index);
		line_task_handles[line_index] = 0;
		line_index++;
	}
}

static void launch_ftn_task(void)
{
	int i;
	debug_printf("launch_ftn_task: ftnmail config value = '%s' (len=%d)\n", 
		system_configuration[0].ftnmail, 
		(int)strlen(system_configuration[0].ftnmail));
	debug_printf("launch_ftn_task: ftnmail bytes: ");
	for (i = 0; i < (int)strlen(system_configuration[0].ftnmail) && i < 10; i++)
	{
		debug_printf("%02X ", (unsigned char)system_configuration[0].ftnmail[i]);
	}
	debug_printf("\n");

	if (str_casecmp(system_configuration[0].ftnmail, "yes") != 0)
	{
		debug_printf("launch_ftn_task: FTN mailer disabled (ftnmail != 'yes')\n");
		return;
	}

	debug_printf("launch_ftn_task: Starting FTN mailer task\n");
	Desk_Wimp_StartTask("Run <Converse$Dir>.Resources.!RunFTN");
	debug_printf("launch_ftn_task: FTN mailer task started\n");
}

static void launch_web_task(void)
{
	int i;
	debug_printf("launch_web_task: webserver config value = '%s' (len=%d)\n", 
		system_configuration[0].webserver, 
		(int)strlen(system_configuration[0].webserver));
	debug_printf("launch_web_task: webserver bytes: ");
	for (i = 0; i < (int)strlen(system_configuration[0].webserver) && i < 10; i++)
	{
		debug_printf("%02X ", (unsigned char)system_configuration[0].webserver[i]);
	}
	debug_printf("\n");

	if (str_casecmp(system_configuration[0].webserver, "yes") != 0)
	{
		debug_printf("launch_web_task: Web server disabled (webserver != 'yes')\n");
		return;
	}

	debug_printf("launch_web_task: Starting Web server task\n");
	Desk_Wimp_StartTask("Run <Converse$Dir>.Resources.!RunWeb");
	debug_printf("launch_web_task: Web server task started\n");
}

static Desk_bool main_window_icon_to_line(Desk_icon_handle icon, int *line_id, int *column)
{
	int relative;
	int total_lines;

	total_lines = line_configurations;
	if (icon < MAIN_WINDOW_ICON_BASE || total_lines <= 0)
	{
		return Desk_bool_FALSE;
	}

	relative = icon - MAIN_WINDOW_ICON_BASE;
	if (relative < 0 || relative >= (total_lines * MAIN_WINDOW_ICONS_PER_LINE))
	{
		return Desk_bool_FALSE;
	}

	if (line_id != NULL)
	{
		*line_id = relative / MAIN_WINDOW_ICONS_PER_LINE;
	}

	if (column != NULL)
	{
		*column = relative % MAIN_WINDOW_ICONS_PER_LINE;
	}

	return Desk_bool_TRUE;
}

static void send_line_task_view_request(int line_id)
{
	Desk_message_block message;
	int total_lines;

	total_lines = line_configurations;
	if (line_id < 0 || line_id >= total_lines)
	{
		return;
	}

	memset(&message, 0, sizeof(message));
	message.header.size = 24;
	message.header.action = (Desk_message_action)MESSAGE_LINE_VIEW_WINDOW;
	message.data.words[0] = line_id;
	Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* ConverseBBS Support Functions                                                                                                                                                       */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

static void support_push_config(void)
{
	_kernel_swi_regs regs;
	char value_buf[16];

	/* Push bbs_name */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"bbs_name";
	regs.r[2] = (int)system_configuration[0].name;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push sysop_name */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"sysop_name";
	regs.r[2] = (int)system_configuration[0].sysop;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push contact email */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"contact";
	regs.r[2] = (int)system_configuration[0].contact;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push hostname */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"hostname";
	regs.r[2] = (int)system_configuration[0].hostname;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push max_lines */
	snprintf(value_buf, sizeof(value_buf), "%d", line_configurations);
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"max_lines";
	regs.r[2] = (int)value_buf;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push listen_port */
	snprintf(value_buf, sizeof(value_buf), "%d", system_configuration[0].port);
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"listen_port";
	regs.r[2] = (int)value_buf;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push idle_timeout */
	snprintf(value_buf, sizeof(value_buf), "%d", system_configuration[0].timeout);
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"idle_timeout";
	regs.r[2] = (int)value_buf;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push flags */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"botstopper";
	regs.r[2] = (int)system_configuration[0].botstopper;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"needlogin";
	regs.r[2] = (int)system_configuration[0].needlogin;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"closed";
	regs.r[2] = (int)system_configuration[0].closed;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"pager";
	regs.r[2] = (int)system_configuration[0].pager;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"ftnmail";
	regs.r[2] = (int)system_configuration[0].ftnmail;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"webserver";
	regs.r[2] = (int)system_configuration[0].webserver;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	/* Push script paths */
	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"anykey";
	regs.r[2] = (int)system_configuration[0].anykey;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"chatstart";
	regs.r[2] = (int)system_configuration[0].chatstart;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"chatend";
	regs.r[2] = (int)system_configuration[0].chatend;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"prelogon";
	regs.r[2] = (int)system_configuration[0].prelogon;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"postlogon";
	regs.r[2] = (int)system_configuration[0].postlogon;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"logoff";
	regs.r[2] = (int)system_configuration[0].logoff;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"welcome";
	regs.r[2] = (int)system_configuration[0].welcome;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"newuser";
	regs.r[2] = (int)system_configuration[0].newuser;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"timeup";
	regs.r[2] = (int)system_configuration[0].timeup;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"lockedout";
	regs.r[2] = (int)system_configuration[0].lockedout;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"closedsys";
	regs.r[2] = (int)system_configuration[0].closedsys;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);

	regs.r[0] = CONFIG_REASON_SET;
	regs.r[1] = (int)"aftermail";
	regs.r[2] = (int)system_configuration[0].aftermail;
	_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs);
}

static void support_push_line_config(int line_id)
{
	_kernel_swi_regs regs;
	int enabled;

	/* Push enabled flag (convert "yes"/"no" to 1/0) */
	enabled = (str_casecmp(line_configuration[line_id].enabled, "yes") == 0) ? 1 : 0;
	regs.r[0] = LINECONFIG_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINECONFIG_FIELD_ENABLED;
	regs.r[3] = enabled;
	_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs);

	/* Push botstopper text */
	regs.r[0] = LINECONFIG_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINECONFIG_FIELD_BOTSTOPPER;
	regs.r[3] = (int)line_configuration[line_id].botstopper;
	_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs);

	/* Push hello text */
	regs.r[0] = LINECONFIG_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINECONFIG_FIELD_HELLO;
	regs.r[3] = (int)line_configuration[line_id].hello;
	_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs);
}

static void support_set_line_configured(int line_id, int configured)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONFIGURED;
	regs.r[3] = configured;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_connected(int line_id, int connected)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONNECTED;
	regs.r[3] = connected;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_hostname(int line_id, const char *hostname)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_HOSTNAME;
	regs.r[3] = (int)hostname;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_line_connect_time(int line_id, time_t connect_time)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_CONNECT_TIME;
	regs.r[3] = (int)connect_time;
	_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
}

static void support_set_activity(int line_id, const char *activity)
{
	_kernel_swi_regs regs;

	regs.r[0] = ACTIVITY_REASON_SET;
	regs.r[1] = line_id;
	regs.r[2] = (int)activity;
	_kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs);
}

static int support_get_transfer_active(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = LINE_REASON_GET;
	regs.r[1] = line_id;
	regs.r[2] = LINE_FIELD_TRANSFER;
	if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) != NULL)
	{
		return 0;
	}
	return regs.r[0];
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Wimp Functions                                                                                                                                                                      */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref)
{
	struct wimp_components *wimp;
	wimp = (struct wimp_components *)ref;

	if(event->data.selection[0] == iconbar_menu_usereditor)
	{
		Desk_Wimp_StartTask("<Converse$Dir>.Resources.!RunUser");
	}

	if(event->data.selection[0] == iconbar_menu_quit)
  	{
		notify_line_tasks_shutdown();
		Desk_Event_CloseDown();
		wimp->quit = Desk_bool_TRUE;
	}

	return(Desk_bool_TRUE);  
}

Desk_bool wimp_handle_window_close(Desk_event_pollblock *event, void *ref)
{
	Desk_UNUSED(ref);

	Desk_Window_Hide(event->data.openblock.window);

	return(Desk_bool_TRUE);
}

Desk_bool wimp_handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
	struct wimp_components *wimp;
	wimp = (struct wimp_components *)ref;

	Desk_window_redrawblock window_extent;

 	if(event->data.mouse.button.data.select)
    {
		int visible_lines;
		int total_height;
		
		window_extent.window=main_window;
		window_extent.rect.min.x=0;
		window_extent.rect.max.x=1960;
		window_extent.rect.max.y=0;

		visible_lines = main_window_visible_lines();
		total_height = ((visible_lines + MAIN_WINDOW_STATIC_ICON_COUNT) * MAIN_WINDOW_ICON_HEIGHT) + (2 * MAIN_WINDOW_PADDING);

		/* Include top/bottom icon rows plus a small buffer. */
		window_extent.rect.min.y = -total_height;

		Desk_Wimp_SetExtent(main_window, &(window_extent.rect));
		Desk_Window_Show(main_window, Desk_open_CENTERED);
	}

	if(event->data.mouse.button.data.menu)
  	{
    	Desk_Menu_Show(wimp->iconbar_menu_handle, event->data.mouse.pos.x, -1);
		Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY, wimp_handle_iconbar_menu_choice, ref); 
  	}

	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_button_click(Desk_event_pollblock *event, void *ref)
{
	Desk_UNUSED(ref);

	if (event != NULL)
	{
		Desk_mouse_block *mouse = &event->data.mouse;
		if (mouse->window == main_window && mouse->button.data.select)
		{
			int line_id;
			int column;
			if (main_window_icon_to_line(mouse->icon, &line_id, &column) != Desk_bool_FALSE)
			{
				if (column == MAIN_WINDOW_COLUMN_VIEW)
				{
					send_line_task_view_request(line_id);
				}
			}
		}
	}

	return Desk_bool_TRUE;
}

Desk_bool wimp_open_proginfo_window(Desk_event_pollblock *event, void *ref)
{
	if((event->data.message.data.menuwarn.selection[0] != iconbar_menu_proginfo))
	{
    	return Desk_bool_FALSE;
	}

  	Desk_Dialog2_OpenDialogMenuLeaf(event, (Desk_dialog2_block *)ref);

  	return Desk_bool_TRUE;
}

Desk_bool wimp_open_systeminfo_window(Desk_event_pollblock *event, void *ref)
{
	if((event->data.message.data.menuwarn.selection[0] != iconbar_menu_systeminfo))
	{
    	return Desk_bool_FALSE;
	}

  	Desk_Dialog2_OpenDialogMenuLeaf(event, (Desk_dialog2_block *)ref);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_NAME, (char *)system_configuration[0].name);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_SYSOP, (char *)system_configuration[0].sysop);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_CONTACT, (char *)system_configuration[0].contact);
	Desk_Icon_SetText(systeminfo_window->window, SYSINFO_HOST, (char *)system_configuration[0].hostname);

  	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_poll(Desk_event_pollblock *event, void *ref)
{
	int socket_poll = 0;

	Desk_UNUSED(event);
	Desk_UNUSED(ref);

	check_listener();

	while (socket_poll < line_configurations)
	{
		if (line_configuration[socket_poll].socket != 0 )
		{
			check_socket(socket_poll, line_configuration[socket_poll].socket);
			if (line_configuration[socket_poll].resolved<3)
			{
        		resolve_address(socket_poll);
			}
		}

		socket_poll++;
	}
	
	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_line_activity_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;
	const char *activity;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	if (line_configurations <= 1)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	activity = (const char *)&event->data.message.data.bytes[4];
	if (activity == NULL || *activity == '\0')
	{
		activity = user_activity;
	}

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
		(char *)activity);

	/* Update activity in Support module */
	support_set_activity(line_id, activity);

	line_task_handles[line_id] = event->data.message.header.sender;

	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_line_control_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;
	int reason;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	if (line_configurations <= 1)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	reason = event->data.message.data.words[1];

	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	line_task_handles[line_id] = event->data.message.header.sender;

	if (reason == LINE_CONTROL_REASON_LOGOFF)
	{
		Desk_Icon_SetText(main_window,
			main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
			user_activity);
		close_line_connection(line_id);
		return Desk_bool_TRUE;
	}

	return Desk_bool_FALSE;
}

Desk_bool wimp_handle_line_register_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= 32)
	{
		return Desk_bool_FALSE;
	}

	line_task_handles[line_id] = event->data.message.header.sender;
	return Desk_bool_TRUE;
}

Desk_bool wimp_handle_line_user_message(Desk_event_pollblock *event, void *ref)
{
	int line_id;
	const char *username;
	char display_name[100];

	Desk_UNUSED(ref);

	if (event == NULL)
	{
		return Desk_bool_FALSE;
	}

	if (line_configurations <= 1)
	{
		return Desk_bool_FALSE;
	}

	line_id = event->data.message.data.words[0];
	if (line_id < 0 || line_id >= line_configurations)
	{
		return Desk_bool_FALSE;
	}

	username = (const char *)&event->data.message.data.bytes[4];
	if (username == NULL || *username == '\0')
	{
		/* Empty username means reset to waiting */
		strncpy(display_name, waiting_user, sizeof(display_name) - 1);
		display_name[sizeof(display_name) - 1] = '\0';
	}
	else
	{
		strncpy(display_name, username, sizeof(display_name) - 1);
		display_name[sizeof(display_name) - 1] = '\0';
	}

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_USER),
		display_name);

	line_task_handles[line_id] = event->data.message.header.sender;

	return Desk_bool_TRUE;
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Error Handling Functions                                                                                                                                                            */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

void display_error_dialog(int exit_code, const char *error_message, ...)
{
	va_list arguments_passed;

	va_start(arguments_passed, error_message);
	Desk_Error_Report(exit_code, (char *)error_message, arguments_passed);
	va_end(arguments_passed);
	

	switch (exit_code) {
	case 0:
		return;
	case 1:
		exit(EXIT_FAILURE);
	default:
		exit(exit_code);
	}
}


/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Dynamic Icon Functions                                                                                                                                                              */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

int create_line_icons(void) 
{
	int current_line_configuration = 0;
	int y_base;
	char *text_buffer;
	int column_x;

	Desk_icon_createblock icon_create_block;
	Desk_icon_handle icon_handle;

	icon_create_block.window=main_window;
	y_base = -((MAIN_WINDOW_TOP_STATIC_ROWS * MAIN_WINDOW_ICON_HEIGHT) + MAIN_WINDOW_PADDING);
		
	do
	{
		icon_create_block.icondata.workarearect.max.y = y_base - (MAIN_WINDOW_ICON_HEIGHT * current_line_configuration);
		icon_create_block.icondata.workarearect.min.y = icon_create_block.icondata.workarearect.max.y - MAIN_WINDOW_ICON_HEIGHT;

		column_x = MAIN_WINDOW_COLUMN_START;

		text_buffer=malloc(25);
		sprintf(text_buffer, "%d", current_line_configuration);
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_LINE_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=line_configuration[current_line_configuration].line;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=25;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_USER_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		text_buffer=malloc(sizeof(waiting_user));
		if (text_buffer == NULL)
		{
			display_error_dialog(1, "Unable to allocate user icon buffer");
			return Desk_bool_FALSE;
		}
		strncpy(text_buffer, waiting_user, sizeof(waiting_user) - 1);
		text_buffer[sizeof(waiting_user) - 1] = '\0';
		icon_create_block.icondata.data.indirecttext.buffer=text_buffer;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=sizeof(waiting_user);

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_ACTIVITY_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
											Desk_icon_VCENTRE |
											Desk_icon_HCENTRE |
											Desk_icon_INDIRECTED |
											Desk_icon_BORDER |
											Desk_icon_FILLED |
											(Desk_icon_FORECOLOUR*7) |
											(Desk_icon_BACKCOLOUR*1) |
											(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		text_buffer=malloc(sizeof(user_activity));
		if (text_buffer == NULL)
		{
			display_error_dialog(1, "Unable to allocate activity icon buffer");
			return Desk_bool_FALSE;
		}
		strncpy(text_buffer, user_activity, sizeof(user_activity) - 1);
		text_buffer[sizeof(user_activity) - 1] = '\0';
		icon_create_block.icondata.data.indirecttext.buffer=text_buffer;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=sizeof(user_activity);

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		text_buffer=malloc(MAIN_WINDOW_HOSTNAME_TEXT_LEN);
		if (text_buffer == NULL)
		{
			display_error_dialog(1, "Unable to allocate hostname icon buffer");
			return Desk_bool_FALSE;
		}
		text_buffer[0] = '\0';
		strncpy(text_buffer, "-----", MAIN_WINDOW_HOSTNAME_TEXT_LEN - 1);
		text_buffer[MAIN_WINDOW_HOSTNAME_TEXT_LEN - 1] = '\0';
		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_HOSTNAME_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=text_buffer;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=MAIN_WINDOW_HOSTNAME_TEXT_LEN;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		text_buffer=malloc(25);
		strcpy(text_buffer, "00:00");
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_TIMER_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=text_buffer;
		icon_create_block.icondata.data.indirecttext.validstring="R2";
		icon_create_block.icondata.data.indirecttext.bufflen=25;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		text_buffer=malloc(4);
		strcpy(text_buffer, "D");
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_ACTION_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
												Desk_icon_VCENTRE |
												Desk_icon_HCENTRE |
												Desk_icon_INDIRECTED |
												Desk_icon_BORDER |
												Desk_icon_FILLED |
												(Desk_icon_FORECOLOUR*7) |
												(Desk_icon_BACKCOLOUR*1) |
												(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=text_buffer;
		icon_create_block.icondata.data.indirecttext.validstring="R5";
		icon_create_block.icondata.data.indirecttext.bufflen=4;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		column_x = icon_create_block.icondata.workarearect.max.x + MAIN_WINDOW_COLUMN_GAP;

		text_buffer=malloc(4);
		strcpy(text_buffer, "V");
		icon_create_block.icondata.flags.value=0;
		icon_create_block.icondata.workarearect.min.x=column_x;
		icon_create_block.icondata.workarearect.max.x=column_x+MAIN_WINDOW_VIEW_COLUMN_WIDTH;
		icon_create_block.icondata.flags.value = Desk_icon_TEXT |
											Desk_icon_VCENTRE |
											Desk_icon_HCENTRE |
											Desk_icon_INDIRECTED |
											Desk_icon_BORDER |
											Desk_icon_FILLED |
											(Desk_icon_FORECOLOUR*7) |
											(Desk_icon_BACKCOLOUR*1) |
											(Desk_icon_BUTTONTYPE*Desk_iconbtype_CLICK);
		icon_create_block.icondata.data.indirecttext.buffer=text_buffer;
		icon_create_block.icondata.data.indirecttext.validstring="R5";
		icon_create_block.icondata.data.indirecttext.bufflen=4;

		Desk_Wimp_CreateIcon(&icon_create_block, &icon_handle);

		current_line_configuration++;
	} while (current_line_configuration < line_configurations);

	return Desk_bool_TRUE;
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Networking Functions                                                                                                                                                                */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
 
void create_listener(void)
{
	int  args[2];
  	struct sockaddr_in saddr;

	// Create the socket
	listening_socket = socket(AF_INET, SOCK_STREAM, PF_UNSPEC);

	// Allow address reuse - *very* *important*. If you don't do this, then you'll need to
	// wait for the socket to "expire" in between running this program, and running it again.
	args[0] = 1; // non-zero = enable
	setsockopt(listening_socket, SOL_SOCKET, SO_REUSEADDR, &args, sizeof(int));

	// Set linger time to 10 seconds maximum
	args[0] = 1;  // wait for data to drain
	args[1] = 10; // 10 seconds manimum
	setsockopt(listening_socket, SOL_SOCKET, SO_LINGER, &args, (sizeof(int) * 2));

	// Bind to configured port
	memset(&saddr, 0, sizeof(saddr));   // zero everything before use
	saddr.sin_family = AF_INET;         // accept internet connection...
	saddr.sin_port = htons(system_configuration[0].port);
	saddr.sin_addr.s_addr = INADDR_ANY; // ...from anybody.
	if ( bind(listening_socket, (struct sockaddr *)&saddr, sizeof(saddr)) != 0 )
	{
		socketclose(listening_socket);
			display_error_dialog(1, error_bind);
	}

	// Make it non-blocking; so the machine won't hang up waiting for something to happen.
	args[0] = 1;
	socketioctl(listening_socket, FIONBIO, &args[0]);

	// Now place an ear against the wire
	if ( listen(listening_socket, 1) != 0 )
	{
		socketclose(listening_socket);
		display_error_dialog(1, error_listen);
	}

}

void check_listener(void)
{
   // Check to see if there's an incoming connection
   struct sockaddr_in saddr;
	int namelen = sizeof(saddr);
	int socket_poll = 0;

	memset(&saddr, 0, sizeof(saddr));

   FD_ZERO(&is_socket_ready);
   FD_SET(listening_socket, &is_socket_ready);
   
   socket_timeout.tv_sec = 0;
   socket_timeout.tv_usec = 0;
   select((listening_socket + 1), &is_socket_ready, 0, 0, &socket_timeout);

   if (FD_ISSET(listening_socket, &is_socket_ready))
   {
      // There is a connection pending.
		if (active_sockets >= line_configurations)
      	{
         int orphaned_socket;

         orphaned_socket = accept(listening_socket, (struct sockaddr *)0, (int *)0);
         if (orphaned_socket != -1)
         {
			strcpy(socket_buffer, error_busy);
			socketwrite(orphaned_socket, socket_buffer, strlen(socket_buffer));
            shutdown(orphaned_socket, 0);
            socketclose(orphaned_socket);
         }
      	}

		while (socket_poll < line_configurations && line_configuration[socket_poll].socket != 0)
		{
			socket_poll++;
		}

		if (line_configuration[socket_poll].socket == 0)
		{
			int nonblock = 1;

			// We are not connected, so accept this connection.
			line_configuration[socket_poll].socket = accept(listening_socket, (struct sockaddr *)&saddr, &namelen);
			active_sockets++;

			if (line_configuration[socket_poll].socket == -1)
			{
				line_configuration[socket_poll].socket = 0;
				active_sockets--;
				// Something went wrong. Just get out of here, the listener is still active...
				return;
			}

			// Make the client socket non-blocking so we don't hang waiting for data
			socketioctl(line_configuration[socket_poll].socket, FIONBIO, &nonblock);
		}

		line_configuration[socket_poll].connectedtime = clock();
		line_configuration[socket_poll].last_activity = line_configuration[socket_poll].connectedtime;
		line_configuration[socket_poll].timer = timer_set(100);
		pipes_reset_line(socket_poll);
		pipes_send_control_command(socket_poll, PIPE_CONTROL_CONNECT);

		// The IP address of the remote user is saddr.sin_addr.s_addr, if you need it.

		char ip[30];
		strcpy(ip, (char*)inet_ntoa((struct in_addr)saddr.sin_addr));
	  	strncpy(line_configuration[socket_poll].remote, ip, 128);

		/* Update Support module with connection state */
		support_set_line_connected(socket_poll, 1);
		support_set_line_hostname(socket_poll, ip);
		support_set_line_connect_time(socket_poll, time(NULL));

		// At this point, "mysock" will be != -1 so it will be treated as a live socket and any
		// other connections will result in busy message followed by a disconnect.

		telnet_advertise_capabilities(line_configuration[socket_poll].socket);

		send_string_to_socket(line_configuration[socket_poll].socket, ANSI_clear_screen);
	}

   return;
}

void check_socket(int line_id, int socket)
{
	int change_length = 0;

	change_length = recv(socket, socket_buffer, 1, MSG_PEEK);
	if (change_length == 0)
	{
		close_line_connection(line_id);
		return;
	}

	if(timer_action(line_configuration[line_id].timer)) /* update timer */
	{
		int d;
		char tmp[16]={0};

		d=(clock()-line_configuration[line_id].connectedtime)/100;  // seconds
		sprintf(tmp,"%d:%02d",d/60,d%60);

		Desk_Icon_SetText(main_window,
			main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
			tmp);

		line_configuration[line_id].timer=timer_set(100);
	}

	pump_socket_to_pipe(line_id, socket);
	pump_pipe_to_socket(line_id, socket);

	if (line_configuration[line_id].last_activity != 0 && system_configuration[0].timeout > 0)
	{
		clock_t now = clock();
		clock_t timeout_ticks = (clock_t)(system_configuration[0].timeout * CLOCKS_PER_SEC);
		if ((now - line_configuration[line_id].last_activity) > timeout_ticks)
		{
			/* Don't timeout during file transfer */
			if (!support_get_transfer_active(line_id))
			{
				close_line_connection(line_id);
				return;
			}
		}
	}

	return;
}

void destroy_listener(void)
{
	int socket_poll = 0;

	while (socket_poll < line_configurations)
	{
		if (line_configuration[socket_poll].socket != -1 )
		{
			shutdown(line_configuration[socket_poll].socket, 0);
      		socketclose(line_configuration[socket_poll].socket);
		}

		socket_poll++;
	}

	if (listening_socket >= 0)
	{
		socketclose(listening_socket);
	}
}

void send_byte_to_socket(int socket_address, int first_byte, int second_byte)
{
	unsigned char buffer[3];

	buffer[0] = (unsigned char)Telnet_IAC;
	buffer[1] = (unsigned char)first_byte;
	buffer[2] = (unsigned char)second_byte;
	socketwrite(socket_address, (char *)buffer, sizeof(buffer));
}

void send_string_to_socket(int socket_address, char *string_to_send)
{
	char buffer[256];
	
	strcpy(buffer, string_to_send);
	socketwrite(socket_address, buffer, strlen(buffer));
}

static int pipes_input_status(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_STATUS, &regs, &regs) != NULL)
	{
		return -1;
	}

	return regs.r[0];
}

static int pipes_input_write_block(int line_id, const char *buffer, int length)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	regs.r[1] = (int)buffer;
	regs.r[2] = length;
	if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_WRITE_BLOCK, &regs, &regs) != NULL)
	{
		return -1;
	}

	return regs.r[0];
}

static int pipes_output_read_block(int line_id, char *buffer, int length)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	regs.r[1] = (int)buffer;
	regs.r[2] = length;
	if (_kernel_swi(SWI_CONVERSE_PIPES_OUTPUT_READ_BLOCK, &regs, &regs) != NULL)
	{
		return -1;
	}

	return regs.r[0];
}

static void pipes_reset_line(int line_id)
{
	_kernel_swi_regs regs;

	regs.r[0] = line_id;
	_kernel_swi(SWI_CONVERSE_PIPES_RESET_STATE, &regs, &regs);
	regs.r[0] = line_id;
	_kernel_swi(SWI_CONVERSE_PIPES_CLEAR_INPUT, &regs, &regs);
	regs.r[0] = line_id;
	_kernel_swi(SWI_CONVERSE_PIPES_CLEAR_OUTPUT, &regs, &regs);
}

static void pipes_send_control_command(int line_id, char command)
{
	unsigned char frame[3];

	frame[0] = PIPE_CONTROL_TOKEN;
	frame[1] = (unsigned char)command;
	frame[2] = PIPE_CONTROL_TOKEN;
	pipes_input_write_block(line_id, (const char *)frame, sizeof(frame));
}

static void pump_socket_to_pipe(int line_id, int socket)
{
	int iteration = 0;

	while (iteration < 4)
	{
		int used_bytes = pipes_input_status(line_id);
		int free_bytes;
		int read_bytes;
		char buffer[PIPE_TRANSFER_CHUNK];

		if (used_bytes < 0)
		{
			return;
		}

		if (used_bytes >= PIPES_BUFFER_CAPACITY)
		{
			return;
		}

		free_bytes = PIPES_BUFFER_CAPACITY - used_bytes;
		if (free_bytes > PIPE_TRANSFER_CHUNK)
		{
			free_bytes = PIPE_TRANSFER_CHUNK;
		}

		read_bytes = socketread(socket, buffer, free_bytes);
		if (read_bytes <= 0)
		{
			return;
		}

		read_bytes = telnet_filter_input(socket, buffer, read_bytes);
		if (read_bytes <= 0)
		{
			iteration++;
			continue;
		}

		int offset = 0;
		while (offset < read_bytes)
		{
			int copied = pipes_input_write_block(line_id, buffer + offset, read_bytes - offset);
			if (copied <= 0)
			{
				return;
			}
			offset += copied;
			line_configuration[line_id].last_activity = clock();
		}

		if (read_bytes < free_bytes)
		{
			break;
		}

		iteration++;
	}
}

static void pump_pipe_to_socket(int line_id, int socket)
{
	int loops = 0;

	while (loops < 4)
	{
		char buffer[PIPE_TRANSFER_CHUNK];
		int copied = pipes_output_read_block(line_id, buffer, PIPE_TRANSFER_CHUNK);
		int offset = 0;

		if (copied <= 0)
		{
			return;
		}

		while (offset < copied)
		{
			int written = socketwrite(socket, buffer + offset, copied - offset);
			if (written <= 0)
			{
				return;
			}
			offset += written;
		}

		line_configuration[line_id].last_activity = clock();

		if (copied < PIPE_TRANSFER_CHUNK)
		{
			break;
		}

		loops++;
	}
}

static void close_line_connection(int line_id)
{
	int socket = line_configuration[line_id].socket;

	if (socket > 0)
	{
		pipes_send_control_command(line_id, PIPE_CONTROL_DISCONNECT);
		shutdown(socket, 0);
		socketclose(socket);
		line_configuration[line_id].socket = 0;
		if (active_sockets > 0)
		{
			active_sockets--;
		}
	}

	line_configuration[line_id].resolved = 0;
	line_configuration[line_id].last_activity = 0;
	line_configuration[line_id].timer = 0;
	strcpy(line_configuration[line_id].remote, "");
	line_task_handles[line_id] = 0;

	/* Clear Support module line state (setting connected=0 clears other fields) */
	support_set_line_connected(line_id, 0);

	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
		"----");
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_USER),
		waiting_user);
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_ACTIVITY),
		user_activity);
	Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_TIMER),
		"00:00");

	Desk_Event_PollIdle();
}

static void notify_line_tasks_shutdown(void)
{
	Desk_message_block wimp_message;

	memset(&wimp_message, 0, sizeof(wimp_message));
	wimp_message.header.size = 28;
	wimp_message.header.action = (Desk_message_action)MESSAGE_LINE_BROADCAST;
	wimp_message.data.words[0] = 0; /* reason 0 => quit */
	Desk_Wimp_SendMessage(Desk_event_SEND, &wimp_message, 0, NULL);
}

static void unload_modules(void)
{
	char command[128];

	snprintf(command, sizeof(command), "<Converse$Dir>.Resources.!KillAll");
	Desk_Wimp_StartTask(command);
}

static void telnet_advertise_capabilities(int socket)
{
	send_byte_to_socket(socket, Telnet_WILL, Option_ECHO);
	send_byte_to_socket(socket, Telnet_DONT, Option_ECHO);
	send_byte_to_socket(socket, Telnet_WILL, Option_SUPRESS);
}

static void telnet_handle_option(int socket, unsigned char command, unsigned char option)
{
	switch (command)
	{
		case Telnet_DO:
			if (option == Option_ECHO || option == Option_SUPRESS)
			{
				send_byte_to_socket(socket, Telnet_WILL, option);
			}
			else
			{
				send_byte_to_socket(socket, Telnet_WONT, option);
			}
			break;

		case Telnet_DONT:
			send_byte_to_socket(socket, Telnet_WONT, option);
			break;

		case Telnet_WILL:
			if (option == Option_ECHO)
			{
				send_byte_to_socket(socket, Telnet_DO, option);
			}
			else
			{
				send_byte_to_socket(socket, Telnet_DONT, option);
			}
			break;

		case Telnet_WONT:
			send_byte_to_socket(socket, Telnet_DONT, option);
			break;

		default:
			break;
	}
}

static int telnet_filter_input(int socket, char *buffer, int length)
{
	int read_index = 0;
	int write_index = 0;

	while (read_index < length)
	{
		unsigned char byte = (unsigned char)buffer[read_index++];

		if (byte == Telnet_IAC)
		{
			if (read_index >= length)
			{
				break;
			}

			unsigned char command = (unsigned char)buffer[read_index++];

			if (command == Telnet_IAC)
			{
				buffer[write_index++] = (char)Telnet_IAC;
				continue;
			}

			if (command == Telnet_SB)
			{
				while (read_index < length)
				{
					if ((unsigned char)buffer[read_index] == Telnet_IAC)
					{
						if ((read_index + 1) < length && (unsigned char)buffer[read_index + 1] == Telnet_SE)
						{
							read_index += 2;
							break;
						}
					}
					read_index++;
				}
				continue;
			}

			switch (command)
			{
				case Telnet_DO:
				case Telnet_DONT:
				case Telnet_WILL:
				case Telnet_WONT:
					if (read_index < length)
					{
						unsigned char option = (unsigned char)buffer[read_index++];
						telnet_handle_option(socket, command, option);
					}
					else
					{
						read_index = length;
					}
					break;

				case Telnet_NOP:
				case Telnet_DM:
				case Telnet_BRK:
				case Telnet_IP:
				case Telnet_AO:
				case Telnet_AYT:
				case Telnet_EC:
				case Telnet_EL:
				case Telnet_GA:
					/* Command without option byte; ignore. */
					break;

				default:
					break;
			}

			continue;
		}

		buffer[write_index++] = (char)byte;
	}

	return write_index;
}


void resolve_address(int line_id)
{
  int result;
  _kernel_swi_regs r;
  _kernel_oserror *er;
  struct hostent *host;
  char buffer[128];        // from 64

if (line_configuration[line_id].socket != 0)
{

  /* First call? */
  if (line_configuration[line_id].resolved == 0)
  {
    sprintf(buffer,"Resolving: %s",line_configuration[line_id].remote);
    Desk_Icon_SetText(main_window,
		main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
        buffer);
   line_configuration[line_id].resolved++;
  }

  /* Find an address */
  r.r[0]=(int)line_configuration[line_id].remote;
  r.r[1]=0;
  er=_kernel_swi(Resolver_GetHost,&r,&r);
  result=r.r[0];
  host=(struct hostent *)r.r[1];

  if (er!=NULL)
  {
    /* No ANT resolver */
    sprintf(buffer,"Resolver not loaded: %s",line_configuration[line_id].remote);
    line_configuration[line_id].resolved=3;
  }
  else
  {
    switch(result)
    {
      case 0:
        /* Got name */
        sprintf(buffer,"%s",host->h_name);
        line_configuration[line_id].resolved=3;
        break;

      case EINPROGRESS:
        /* It's working */
        break;

      case -1:
        /* Not found: update info */
        sprintf(buffer,"Unable to resolve: %s",line_configuration[line_id].remote);
        line_configuration[line_id].resolved=3;
        break;

      case -2:
        /* Not found (remote error) */
        sprintf(buffer,"Resolver error: %s",line_configuration[line_id].remote);
        line_configuration[line_id].resolved=3;
        break;
    }
  }

  Desk_Icon_SetText(main_window,
	  main_window_icon_index(line_id, MAIN_WINDOW_COLUMN_HOSTNAME),
      buffer);
}
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Config File Handling                                                                                                                                                                */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

void load_system_config(void)
{
	FILE *system_config;

	char config_line[250];
	char *temporary_line;

	/* Set defaults */
	system_configuration[0].port = 23;
	system_configuration[0].timeout = 120;
	strcpy(system_configuration[0].ftnmail, "no");
	strcpy(system_configuration[0].webserver, "no");

	if ((system_config=fopen("<Converse$Dir>.Config.System","r"))==NULL)
	{
		display_error_dialog(1, error_cantfindsystemconfig);
	}

 	do
  	{
    	config_line[0]=0;
    	fgets(config_line, 120, system_config);
		do
		{
			fgets(config_line, 120, system_config);
			if (config_line[strlen(config_line)-1]<32)
			{
          		config_line[strlen(config_line)-1]=0;
			}
        	while(config_line[strlen(config_line)-1]==32)
			{
				config_line[strlen(config_line)-1]=0;
			}
			/* Find first space or tab as delimiter */
          	if ((temporary_line=strchr(config_line,' '))!=NULL)
			{
          		*temporary_line++=0; 
			}
			else if ((temporary_line=strchr(config_line,'\t'))!=NULL)
			{
          		*temporary_line++=0; 
			} 
			else
			{
          		temporary_line="";
			}
			/* Skip any whitespace (spaces or tabs) */
        	while(*temporary_line==' ' || *temporary_line=='\t')
			{
				temporary_line++;
			}

			if (strcmp(config_line,"name")==0)
			{
				strcpy(system_configuration[0].name, temporary_line);
			}
			if (strcmp(config_line,"sysop")==0)
			{
				strcpy(system_configuration[0].sysop, temporary_line);
			}
			if (strcmp(config_line,"contact")==0)
			{
				strcpy(system_configuration[0].contact, temporary_line);
			}
			if (strcmp(config_line,"hostname")==0)
			{
				strcpy(system_configuration[0].hostname, temporary_line);
			}
			if (strcmp(config_line,"port")==0)
			{
				system_configuration[0].port = atoi(temporary_line);
			}
			if (strcmp(config_line,"timeout")==0)
			{
				system_configuration[0].timeout = atoi(temporary_line);
			}
			if (strcmp(config_line,"botstopper")==0)
			{
				strcpy(system_configuration[0].botstopper, temporary_line);
			}
			if (strcmp(config_line,"needlogin")==0)
			{
				strcpy(system_configuration[0].needlogin, temporary_line);
			}
			if (strcmp(config_line,"closed")==0)
			{
				strcpy(system_configuration[0].closed, temporary_line);
			}
			if (strcmp(config_line,"pager")==0)
			{
				strcpy(system_configuration[0].pager, temporary_line);
			}
			if (strcmp(config_line,"ftnmail")==0)
			{
				strcpy(system_configuration[0].ftnmail, temporary_line);
			}
			if (strcmp(config_line,"webserver")==0)
			{
				strcpy(system_configuration[0].webserver, temporary_line);
			}
			if (strcmp(config_line,"anykey")==0)
			{
				strcpy(system_configuration[0].anykey, temporary_line);
			}
			if (strcmp(config_line,"chatstart")==0)
			{
				strcpy(system_configuration[0].chatstart, temporary_line);
			}
			if (strcmp(config_line,"chatend")==0)
			{
				strcpy(system_configuration[0].chatend, temporary_line);
			}
			if (strcmp(config_line,"prelogon")==0)
			{
				strcpy(system_configuration[0].prelogon, temporary_line);
			}
			if (strcmp(config_line,"postlogon")==0)
			{
				strcpy(system_configuration[0].postlogon, temporary_line);
			}
			if (strcmp(config_line,"logoff")==0)
			{
				strcpy(system_configuration[0].logoff, temporary_line);
			}
			if (strcmp(config_line,"welcome")==0)
			{
				strcpy(system_configuration[0].welcome, temporary_line);
			}
			if (strcmp(config_line,"newuser")==0)
			{
				strcpy(system_configuration[0].newuser, temporary_line);
			}
			if (strcmp(config_line,"timeup")==0)
			{
				strcpy(system_configuration[0].timeup, temporary_line);
			}
			if (strcmp(config_line,"lockedout")==0)
			{
				strcpy(system_configuration[0].lockedout, temporary_line);
			}
			if (strcmp(config_line,"closedsys")==0)
			{
				strcpy(system_configuration[0].closedsys, temporary_line);
			}
			if (strcmp(config_line,"aftermail")==0)
			{
				strcpy(system_configuration[0].aftermail, temporary_line);
			}
		} while(feof(system_config)==0 && strcmp(config_line,"end")!=0);
	} while(feof(system_config)==0);

	fclose(system_config);

	/* Sanitize all string config values */
	sanitize_string(system_configuration[0].name);
	sanitize_string(system_configuration[0].sysop);
	sanitize_string(system_configuration[0].contact);
	sanitize_string(system_configuration[0].hostname);
	sanitize_string(system_configuration[0].botstopper);
	sanitize_string(system_configuration[0].needlogin);
	sanitize_string(system_configuration[0].closed);
	sanitize_string(system_configuration[0].pager);
	sanitize_string(system_configuration[0].ftnmail);
	sanitize_string(system_configuration[0].webserver);
	sanitize_string(system_configuration[0].anykey);
	sanitize_string(system_configuration[0].chatstart);
	sanitize_string(system_configuration[0].chatend);
	sanitize_string(system_configuration[0].prelogon);
	sanitize_string(system_configuration[0].postlogon);
	sanitize_string(system_configuration[0].logoff);
	sanitize_string(system_configuration[0].welcome);
	sanitize_string(system_configuration[0].newuser);
	sanitize_string(system_configuration[0].timeup);
	sanitize_string(system_configuration[0].lockedout);
	sanitize_string(system_configuration[0].closedsys);
	sanitize_string(system_configuration[0].aftermail);
}

void load_line_config(void)
{
	FILE *line_config;

	char config_line[250];
	char *temporary_line;
	int block_count = 0;
	int in_block = 0;

	/* Temporary storage for parsing before we know if enabled */
	char temp_line[4] = "";
	char temp_enabled[4] = "";
	char temp_botstopper[128] = "";
	char temp_hello[256] = "";

	debug_printf("load_line_config: Opening <Converse$Dir>.Config.Lines\n");

	if ((line_config=fopen("<Converse$Dir>.Config.Lines","r"))==NULL)
	{
		debug_printf("load_line_config: ERROR - Failed to open config file\n");
		display_error_dialog(1, error_cantfindlineconfig);
	}

	debug_printf("load_line_config: Config file opened successfully\n");

	while (fgets(config_line, sizeof(config_line), line_config) != NULL)
	{
		if(line_configurations > 32)
		{
			debug_printf("load_line_config: ERROR - Too many lines (>32)\n");
			display_error_dialog(1, error_toomanylines);
		}

		/* Strip trailing control characters and spaces */
		while (strlen(config_line) > 0 && config_line[strlen(config_line)-1] < 32)
		{
			config_line[strlen(config_line)-1] = 0;
		}
		while (strlen(config_line) > 0 && config_line[strlen(config_line)-1] == 32)
		{
			config_line[strlen(config_line)-1] = 0;
		}

		/* Skip empty lines and comments */
		if (config_line[0] == '\0' || config_line[0] == ';')
		{
			continue;
		}

		/* Find first space or tab as delimiter */
		if ((temporary_line=strchr(config_line,' '))!=NULL)
		{
			*temporary_line++=0; 
		}
		else if ((temporary_line=strchr(config_line,'\t'))!=NULL)
		{
			*temporary_line++=0; 
		} 
		else
		{
			temporary_line="";
		}

		/* Skip any whitespace (spaces or tabs) */
		while(*temporary_line==' ' || *temporary_line=='\t')
		{
			temporary_line++;
		}

		/* Check for block start */
		if (strcmp(config_line, "start") == 0)
		{
			/* Reset temporary storage for new block */
			temp_line[0] = '\0';
			temp_enabled[0] = '\0';
			temp_botstopper[0] = '\0';
			temp_hello[0] = '\0';
			in_block = 1;
			block_count++;
			debug_printf("load_line_config: Parsing block %d\n", block_count);
			continue;
		}

		/* Check for block end */
		if (strcmp(config_line, "end") == 0)
		{
			if (in_block)
			{
				/* Sanitize temp values before use */
				sanitize_string(temp_line);
				sanitize_string(temp_enabled);
				sanitize_string(temp_botstopper);
				sanitize_string(temp_hello);

				/* Only add line if enabled */
				if (str_casecmp(temp_enabled, "yes") == 0)
				{
					debug_printf("load_line_config: Adding line %s (index %d) - ENABLED\n", 
					             temp_line, line_configurations);
					strcpy(line_configuration[line_configurations].line, temp_line);
					strcpy(line_configuration[line_configurations].enabled, temp_enabled);
					strcpy(line_configuration[line_configurations].botstopper, temp_botstopper);
					strcpy(line_configuration[line_configurations].hello, temp_hello);
					line_configurations++;
				}
				else
				{
					debug_printf("load_line_config: Skipping line %s - not enabled (enabled='%s')\n", 
					             temp_line[0] ? temp_line : "?", temp_enabled);
				}
				in_block = 0;
			}
			continue;
		}

		/* Parse block content only if we're inside a block */
		if (!in_block)
		{
			continue;
		}

		if (strcmp(config_line,"line")==0)
		{
			strncpy(temp_line, temporary_line, sizeof(temp_line) - 1);
			temp_line[sizeof(temp_line) - 1] = '\0';
			debug_printf("load_line_config:   line = '%s'\n", temp_line);
		}
		else if (strcmp(config_line,"enabled")==0)
		{
			strncpy(temp_enabled, temporary_line, sizeof(temp_enabled) - 1);
			temp_enabled[sizeof(temp_enabled) - 1] = '\0';
			debug_printf("load_line_config:   enabled = '%s'\n", temp_enabled);
		}
		else if (strcmp(config_line,"botstopper")==0)
		{
			strncpy(temp_botstopper, temporary_line, sizeof(temp_botstopper) - 1);
			temp_botstopper[sizeof(temp_botstopper) - 1] = '\0';
			debug_printf("load_line_config:   botstopper = '%s'\n", temp_botstopper);
		}
		else if (strcmp(config_line,"hello")==0)
		{
			strncpy(temp_hello, temporary_line, sizeof(temp_hello) - 1);
			temp_hello[sizeof(temp_hello) - 1] = '\0';
			debug_printf("load_line_config:   hello = '%s'\n", temp_hello);
		}
	}

	fclose(line_config);

	debug_printf("load_line_config: Finished - %d enabled lines configured\n", line_configurations);

	if (line_configurations == 0) {
		debug_printf("load_line_config: ERROR - No lines defined\n");
		display_error_dialog(1, error_nolinesdefined);
	}
}

/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                                                    */
/* *********************************************************************************************************************************************************************************** */
/* *********************************************************************************************************************************************************************************** */

int main(void) {
	struct wimp_components wimp;

	char iconbar_menu[100];
	char iconbar_menu_title[30];

	wimp.quit = Desk_bool_FALSE;

	Desk_Resource_Initialise("ConverseRes");

	Desk_Msgs_LoadFile("Messages");

	Desk_Msgs_Lookup("server.wait", waiting_user, 100);
	Desk_Msgs_Lookup("server.nact", user_activity, 100);

	/* Fallback if Messages file tokens are missing */
	if (waiting_user[0] == '\0')
	{
		strcpy(waiting_user, "Waiting...");
	}
	if (user_activity[0] == '\0')
	{
		strcpy(user_activity, "----");
	}

	Desk_Msgs_Lookup("error.1", error_bind, 100);
	Desk_Msgs_Lookup("error.2", error_listen, 100);
	Desk_Msgs_Lookup("error.3", error_busy, 100);
	Desk_Msgs_Lookup("error.4", error_cantfindsystemconfig, 100);
	Desk_Msgs_Lookup("error.5", error_cantfindlineconfig, 100);
	Desk_Msgs_Lookup("error.7", error_toomanylines, 100);
	Desk_Msgs_Lookup("error.11", error_nolinesdefined, 100);

	Desk_Event_Initialise("Converse");
	Desk_EventMsg_Initialise();
	Desk_Screen_CacheModeInfo();

	Desk_EventMsg_Claim(Desk_message_MODECHANGE, Desk_event_ANY, Desk_Handler_ModeChange, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_ACTIVITY, Desk_event_ANY, wimp_handle_line_activity_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_CONTROL, Desk_event_ANY, wimp_handle_line_control_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_REGISTER, Desk_event_ANY, wimp_handle_line_register_message, NULL);
	Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_USER, Desk_event_ANY, wimp_handle_line_user_message, NULL);
	Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY, Desk_Handler_NullRedraw, NULL);
	Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY, Desk_Handler_OpenWindow, NULL);
  	Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY, wimp_handle_window_close, NULL);
	Desk_Event_Claim(Desk_event_CLICK, Desk_event_ANY, Desk_event_ANY, wimp_handle_button_click, NULL);

	Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, wimp_handle_poll, NULL);


	wimp.iconbar_icon_handle = Desk_Icon_BarIcon("!Converse", Desk_iconbar_RIGHT);
	Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, wimp.iconbar_icon_handle, wimp_handle_iconbar_click, (void *)&wimp);
	Desk_Msgs_Lookup("server.ibmt", iconbar_menu_title, 30);
	Desk_Msgs_Lookup("server.ibm", iconbar_menu, 100);
  	wimp.iconbar_menu_handle = Desk_Menu_New(iconbar_menu_title, iconbar_menu);

	Desk_Template_Initialise();
  	Desk_Template_UseOutlineFonts();
  	Desk_Template_LoadFile("Templates");

  	proginfo_window=Desk_Dialog2_CreateDialogBlock("proginfo", -1, -1, NULL, NULL, NULL);
	systeminfo_window=Desk_Dialog2_CreateDialogBlock("sysinfo", -1, -1, NULL, NULL, NULL);
  	main_window=Desk_Window_Create("status", NULL);

  	Desk_Menu_Warn(wimp.iconbar_menu_handle, iconbar_menu_proginfo, Desk_bool_TRUE, wimp_open_proginfo_window, (void *)proginfo_window);
	Desk_Menu_Warn(wimp.iconbar_menu_handle, iconbar_menu_systeminfo, Desk_bool_TRUE, wimp_open_systeminfo_window, (void *)systeminfo_window);

	load_system_config();
	load_line_config();
	support_push_config();
	load_msgbase_config();
	load_filebase_config();
	load_ftn_config();
	{
		int i;
		for (i = 0; i < line_configurations; i++)
		{
			support_set_line_configured(i, 1);
			support_push_line_config(i);
		}
	}
	launch_line_tasks();
	launch_ftn_task();
	launch_web_task();

	create_line_icons();
	create_listener();
	atexit(destroy_listener);

	while(wimp.quit == Desk_bool_FALSE) poll_idle();

	unload_modules();

 	Desk_Template_ClearAll();

	return(0);
}
