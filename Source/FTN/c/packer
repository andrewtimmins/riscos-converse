/* ******************************************************************************************************************************************************** */
/* FTN Mailer - Packet Packer Implementation                                                                                                                */
/* Creates Type 2+ FTN packets for outbound mail                                                                                                            */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "packer.h"
#include "tosser.h"
#include "mailer.h"
#include "queue.h"
#include "zip.h"
#include "debug.h"
#include "ftnlog.h"

/* ******************************************************************************************************************************************************** */
/* SWI Numbers                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

#define SWI_FILER_MESSAGEBASE       0x5AA42
#define SWI_SUPPORT_FTN             0x5AA86
#define SWI_SUPPORT_MSGBASE         0x5AA84

/* Filer messagebase commands */
#define MSGBASE_CMD_MESSAGE_INFO    11
#define MSGBASE_CMD_DOWNLOAD_BLOCK  5

/* Support msgbase reasons */
#define MSGBASE_REASON_GET_GLOBAL   0

/* ******************************************************************************************************************************************************** */
/* Global State                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

static PACKER_STATS packer_stats;
static unsigned long packer_serial = 0;     /* Serial number for MSGID generation */

/* ******************************************************************************************************************************************************** */
/* Helper: Get Random Origin Line                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/* Replicate msgbaseconfig structures for direct memory access */
#define P_MSGBASE_MAX_BASES        32
#define P_MSGBASE_MAX_AREAS        64
#define P_MSGBASE_NAME_LEN         64
#define P_MSGBASE_TAG_LEN          64
#define P_MSGBASE_KEYS_LEN         128
#define P_MSGBASE_PATH_LEN         256
#define P_MSGBASE_MAX_ORIGINS      16
#define P_MSGBASE_ORIGIN_LEN       128
#define P_MSGBASE_GROUPS_LEN       64

typedef struct
{
    int id;
    char name[P_MSGBASE_NAME_LEN];
    char tag[P_MSGBASE_TAG_LEN];
    int areatype;
    int daystokeep;
    int akause;
    int accesslevel;
    char keys[P_MSGBASE_KEYS_LEN];
    char groups[P_MSGBASE_GROUPS_LEN];
} P_MSGBASE_AREA_CONFIG;

typedef struct
{
    int id;
    char name[P_MSGBASE_NAME_LEN];
    int type;
    int accesslevel;
    char keys[P_MSGBASE_KEYS_LEN];
    int area_count;
    P_MSGBASE_AREA_CONFIG areas[P_MSGBASE_MAX_AREAS];
} P_MSGBASE_CONFIG;

typedef struct
{
    int default_retention;
    int default_accesslevel;
    char storage_root[P_MSGBASE_PATH_LEN];
    int base_count;
    P_MSGBASE_CONFIG bases[P_MSGBASE_MAX_BASES];
    int origin_count;
    char origins[P_MSGBASE_MAX_ORIGINS][P_MSGBASE_ORIGIN_LEN];
} P_MSGBASE_GLOBAL_CONFIG;

static const char *packer_get_random_origin(void)
{
    _kernel_swi_regs regs;
    P_MSGBASE_GLOBAL_CONFIG *cfg;
    int idx;

    regs.r[0] = MSGBASE_REASON_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_MSGBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    cfg = (P_MSGBASE_GLOBAL_CONFIG *)regs.r[0];
    if (cfg->origin_count <= 0)
    {
        return NULL;
    }

    /* Random selection */
    idx = (int)(time(NULL) % cfg->origin_count);
    return cfg->origins[idx];
}

/* ******************************************************************************************************************************************************** */
/* Helper: Write little-endian 16-bit value                                                                                                                 */
/* ******************************************************************************************************************************************************** */

static void packer_write_le16(FILE *f, unsigned short val)
{
    unsigned char buf[2];
    buf[0] = val & 0xFF;
    buf[1] = (val >> 8) & 0xFF;
    fwrite(buf, 1, 2, f);
}

static void packer_write_le32(FILE *f, unsigned long val)
{
    unsigned char buf[4];
    buf[0] = val & 0xFF;
    buf[1] = (val >> 8) & 0xFF;
    buf[2] = (val >> 16) & 0xFF;
    buf[3] = (val >> 24) & 0xFF;
    fwrite(buf, 1, 4, f);
}

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

void packer_initialise(void)
{
    memset(&packer_stats, 0, sizeof(packer_stats));
    packer_serial = (unsigned long)time(NULL);  /* Seed serial with current time */
}

void packer_finalise(void)
{
    /* Nothing to clean up */
}

/* ******************************************************************************************************************************************************** */
/* Packet Header Writing                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

static int packer_write_header(PACKER_CONTEXT *ctx)
{
    time_t now;
    struct tm *tm;
    unsigned short cap_word;
    int i;

    if (ctx == NULL || ctx->file == NULL)
    {
        return 0;
    }

    now = time(NULL);
    tm = localtime(&now);

    /* Type 2+ Packet Header (58 bytes) */
    
    /* Originating node/net */
    packer_write_le16(ctx->file, (unsigned short)ctx->orig_addr.node);
    packer_write_le16(ctx->file, (unsigned short)ctx->dest_addr.node);
    
    /* Date/time */
    packer_write_le16(ctx->file, (unsigned short)(tm->tm_year + 1900));
    packer_write_le16(ctx->file, (unsigned short)tm->tm_mon);
    packer_write_le16(ctx->file, (unsigned short)tm->tm_mday);
    packer_write_le16(ctx->file, (unsigned short)tm->tm_hour);
    packer_write_le16(ctx->file, (unsigned short)tm->tm_min);
    packer_write_le16(ctx->file, (unsigned short)tm->tm_sec);
    
    /* Baud rate (ignored) */
    packer_write_le16(ctx->file, 0);
    
    /* Packet type (always 2) */
    packer_write_le16(ctx->file, 2);
    
    /* Originating/destination net */
    packer_write_le16(ctx->file, (unsigned short)ctx->orig_addr.net);
    packer_write_le16(ctx->file, (unsigned short)ctx->dest_addr.net);
    
    /* Product code low, revision major */
    fputc(PACKER_PRODUCT_CODE, ctx->file);
    fputc(PACKER_PRODUCT_REV_MAJOR, ctx->file);
    
    /* Password (8 bytes, null-padded) */
    for (i = 0; i < 8; i++)
    {
        if (i < (int)strlen(ctx->password))
        {
            fputc(ctx->password[i], ctx->file);
        }
        else
        {
            fputc(0, ctx->file);
        }
    }
    
    /* QMail zones */
    packer_write_le16(ctx->file, (unsigned short)ctx->orig_addr.zone);
    packer_write_le16(ctx->file, (unsigned short)ctx->dest_addr.zone);
    
    /* Aux net (for points: set to our net if we're a point) */
    if (ctx->orig_addr.point != 0)
    {
        packer_write_le16(ctx->file, (unsigned short)ctx->orig_addr.net);
    }
    else
    {
        packer_write_le16(ctx->file, 0);
    }
    
    /* Capability word copy (byte-swapped) */
    cap_word = 0x0001;  /* Type 2+ capable */
    packer_write_le16(ctx->file, ((cap_word >> 8) & 0xFF) | ((cap_word & 0xFF) << 8));
    
    /* Product code high, revision minor */
    fputc(0, ctx->file);
    fputc(PACKER_PRODUCT_REV_MINOR, ctx->file);
    
    /* Capability word */
    packer_write_le16(ctx->file, cap_word);
    
    /* Type 2+ zones */
    packer_write_le16(ctx->file, (unsigned short)ctx->orig_addr.zone);
    packer_write_le16(ctx->file, (unsigned short)ctx->dest_addr.zone);
    
    /* Points */
    packer_write_le16(ctx->file, (unsigned short)ctx->orig_addr.point);
    packer_write_le16(ctx->file, (unsigned short)ctx->dest_addr.point);
    
    /* Product-specific data (4 bytes) */
    packer_write_le32(ctx->file, 0);

    ctx->packet_size = 58;
    
    debug_printf("packer: Wrote header for %d:%d/%d.%d -> %d:%d/%d.%d",
                 ctx->orig_addr.zone, ctx->orig_addr.net, ctx->orig_addr.node, ctx->orig_addr.point,
                 ctx->dest_addr.zone, ctx->dest_addr.net, ctx->dest_addr.node, ctx->dest_addr.point);

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Packet Creation                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

/*
 * Get BSO flavour extension suffix for packet files.
 * RISC OS style - no dot, suffix appended directly.
 * 
 * Normal:    out -> pkt (default)
 * Hold:      hut -> hpkt
 * Direct:    dut -> dpkt  
 * Crash:     cut -> cpkt
 * Immediate: iut -> ipkt
 */
static const char *packer_get_flavour_prefix(PACKER_FLAVOUR flavour)
{
    switch (flavour)
    {
        case PACKER_FLAVOUR_HOLD:      return "h";
        case PACKER_FLAVOUR_DIRECT:    return "d";
        case PACKER_FLAVOUR_CRASH:     return "c";
        case PACKER_FLAVOUR_IMMEDIATE: return "i";
        default:                       return "";
    }
}

PACKER_CONTEXT *packer_create_packet(const FTN_ADDR *our_addr, const FTN_ADDR *dest_addr, 
                                      const char *password, PACKER_FLAVOUR flavour)
{
    PACKER_CONTEXT *ctx;
    char filename[64];
    unsigned long pkt_time;
    const char *prefix;

    if (our_addr == NULL || dest_addr == NULL)
    {
        return NULL;
    }

    ctx = malloc(sizeof(PACKER_CONTEXT));
    if (ctx == NULL)
    {
        return NULL;
    }

    memset(ctx, 0, sizeof(PACKER_CONTEXT));
    ctx->orig_addr = *our_addr;
    ctx->dest_addr = *dest_addr;
    
    if (password != NULL)
    {
        strncpy(ctx->password, password, sizeof(ctx->password) - 1);
    }

    /* Generate unique packet filename based on time with flavour prefix */
    /* Format: <timestamp><prefix>pkt (e.g., 12345678pkt, 12345678cpkt for crash) */
    pkt_time = (unsigned long)time(NULL);
    prefix = packer_get_flavour_prefix(flavour);
    snprintf(filename, sizeof(filename), "%08lx%spkt", pkt_time & 0xFFFFFFFF, prefix);

    /* Ensure outbound directories exist and build full path using BSO helper */
    queue_ensure_outbound_directories(dest_addr);
    queue_format_outbound_name(ctx->path, sizeof(ctx->path), dest_addr, "out");
    
    /* Replace 'out' extension with our packet filename */
    {
        size_t len = strlen(ctx->path);
        if (len >= 3)
        {
            /* Remove 'out' extension and add pkt filename */
            ctx->path[len - 3] = '\0';
        }
        strncat(ctx->path, filename, sizeof(ctx->path) - strlen(ctx->path) - 1);
    }

    debug_printf("packer: Creating %s packet %s", 
                 flavour == PACKER_FLAVOUR_NORMAL ? "normal" :
                 flavour == PACKER_FLAVOUR_HOLD ? "hold" :
                 flavour == PACKER_FLAVOUR_CRASH ? "crash" :
                 flavour == PACKER_FLAVOUR_DIRECT ? "direct" : "immediate",
                 ctx->path);

    /* Open packet file */
    ctx->file = fopen(ctx->path, "wb");
    if (ctx->file == NULL)
    {
        debug_printf("packer: Failed to create packet file");
        free(ctx);
        return NULL;
    }

    /* Write packet header */
    if (!packer_write_header(ctx))
    {
        fclose(ctx->file);
        remove(ctx->path);
        free(ctx);
        return NULL;
    }

    packer_stats.packets_created++;
    
    ftnlog_printf(">> PKT %s", ctx->path);
    mailer_log("Created packet: %s", ctx->path);

    return ctx;
}

/* ******************************************************************************************************************************************************** */
/* Date/Time Formatting                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

void packer_format_datetime(time_t t, char *buffer, size_t size)
{
    struct tm *tm;
    static const char *months[] = {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
    };

    if (buffer == NULL || size < 20)
    {
        return;
    }

    tm = localtime(&t);
    
    /* Format: "DD Mon YY  HH:MM:SS" (19 chars + null) */
    snprintf(buffer, size, "%02d %s %02d  %02d:%02d:%02d",
             tm->tm_mday,
             months[tm->tm_mon],
             tm->tm_year % 100,
             tm->tm_hour,
             tm->tm_min,
             tm->tm_sec);
}

/* ******************************************************************************************************************************************************** */
/* Message Attribute Helpers                                                                                                                                */
/* ******************************************************************************************************************************************************** */

unsigned short packer_get_message_attributes(int is_echomail, int is_private, int is_crash, int is_hold)
{
    unsigned short attr = MSG_LOCAL;

    if (is_private)
    {
        attr |= MSG_PRIVATE;
    }
    if (is_crash)
    {
        attr |= MSG_CRASH;
    }
    if (is_hold)
    {
        attr |= MSG_HOLD;
    }
    if (!is_echomail)
    {
        attr |= MSG_KILLSENT;  /* Kill netmail after sending */
    }

    return attr;
}

/* ******************************************************************************************************************************************************** */
/* MSGID Generation                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

void packer_generate_msgid(const FTN_ADDR *addr, char *buffer, size_t size)
{
    if (addr == NULL || buffer == NULL || size < 40)
    {
        return;
    }

    packer_serial++;

    if (addr->point == 0)
    {
        snprintf(buffer, size, "%d:%d/%d %08lx",
                 addr->zone, addr->net, addr->node, packer_serial);
    }
    else
    {
        snprintf(buffer, size, "%d:%d/%d.%d %08lx",
                 addr->zone, addr->net, addr->node, addr->point, packer_serial);
    }
}

/* ******************************************************************************************************************************************************** */
/* Point Kludge Formatting                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

void packer_format_fmpt(char *buffer, size_t size, int point)
{
    if (buffer == NULL || size < 16 || point == 0)
    {
        if (buffer && size > 0) buffer[0] = '\0';
        return;
    }
    snprintf(buffer, size, "\001FMPT %d\r", point);
}

void packer_format_topt(char *buffer, size_t size, int point)
{
    if (buffer == NULL || size < 16 || point == 0)
    {
        if (buffer && size > 0) buffer[0] = '\0';
        return;
    }
    snprintf(buffer, size, "\001TOPT %d\r", point);
}

void packer_format_intl(char *buffer, size_t size, const FTN_ADDR *dest, const FTN_ADDR *orig)
{
    if (buffer == NULL || size < 64 || dest == NULL || orig == NULL)
    {
        if (buffer && size > 0) buffer[0] = '\0';
        return;
    }
    
    /* INTL kludge for cross-zone netmail */
    snprintf(buffer, size, "\001INTL %d:%d/%d %d:%d/%d\r",
             dest->zone, dest->net, dest->node,
             orig->zone, orig->net, orig->node);
}

/* ******************************************************************************************************************************************************** */
/* SEEN-BY/PATH Handling                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

int packer_add_seenby(char *existing_seenby, size_t size, int net, int node)
{
    char addition[32];
    size_t current_len;

    if (existing_seenby == NULL)
    {
        return 0;
    }

    current_len = strlen(existing_seenby);
    
    /* Format our node to add */
    snprintf(addition, sizeof(addition), "%d/%d", net, node);

    /* Check if already present */
    if (strstr(existing_seenby, addition) != NULL)
    {
        return 1;  /* Already there */
    }

    /* Add to SEEN-BY */
    if (current_len == 0)
    {
        snprintf(existing_seenby, size, "SEEN-BY: %s", addition);
    }
    else
    {
        /* Append to existing line */
        if (current_len + strlen(addition) + 2 < size)
        {
            strcat(existing_seenby, " ");
            strcat(existing_seenby, addition);
        }
    }

    return 1;
}

int packer_add_path(char *existing_path, size_t size, int net, int node)
{
    char addition[32];
    size_t current_len;

    if (existing_path == NULL)
    {
        return 0;
    }

    current_len = strlen(existing_path);
    
    /* Format our node to add */
    snprintf(addition, sizeof(addition), "%d/%d", net, node);

    /* Check if already present */
    if (strstr(existing_path, addition) != NULL)
    {
        return 1;  /* Already there */
    }

    /* Add to PATH */
    if (current_len == 0)
    {
        snprintf(existing_path, size, "\001PATH: %s", addition);
    }
    else
    {
        /* Append to existing line */
        if (current_len + strlen(addition) + 2 < size)
        {
            strcat(existing_path, " ");
            strcat(existing_path, addition);
        }
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Message Writing                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

static void packer_write_string(FILE *f, const char *str)
{
    if (str != NULL)
    {
        fputs(str, f);
    }
    fputc(0, f);
}

int packer_write_message(PACKER_CONTEXT *ctx, const PACKER_MESSAGE *msg)
{
    char datetime[24];
    char kludge_buf[256];
    char origin_line[128];
    char seenby[PACKER_MAX_SEENBY];
    char path[PACKER_MAX_PATH];
    long msg_start;

    if (ctx == NULL || ctx->file == NULL || msg == NULL)
    {
        return 0;
    }

    msg_start = ftell(ctx->file);

    /* Packed message header (14 bytes) */
    packer_write_le16(ctx->file, 2);  /* Message type, always 2 */
    packer_write_le16(ctx->file, (unsigned short)msg->orig_addr.node);
    packer_write_le16(ctx->file, (unsigned short)msg->dest_addr.node);
    packer_write_le16(ctx->file, (unsigned short)msg->orig_addr.net);
    packer_write_le16(ctx->file, (unsigned short)msg->dest_addr.net);
    packer_write_le16(ctx->file, msg->attribute);
    packer_write_le16(ctx->file, 0);  /* Cost */

    /* Null-terminated strings: datetime, to, from, subject */
    packer_format_datetime(msg->datetime, datetime, sizeof(datetime));
    packer_write_string(ctx->file, datetime);
    packer_write_string(ctx->file, msg->to);
    packer_write_string(ctx->file, msg->from);
    packer_write_string(ctx->file, msg->subject);

    /* Message body with kludges */
    
    /* AREA tag for echomail */
    if (msg->is_echomail && msg->area[0] != '\0')
    {
        fprintf(ctx->file, "AREA:%s\r", msg->area);
    }

    /* MSGID kludge */
    if (msg->msgid[0] != '\0')
    {
        fprintf(ctx->file, "\001MSGID: %s\r", msg->msgid);
    }

    /* REPLY kludge */
    if (msg->reply[0] != '\0')
    {
        fprintf(ctx->file, "\001REPLY: %s\r", msg->reply);
    }

    /* Point kludges for netmail */
    if (!msg->is_echomail)
    {
        /* INTL for cross-zone */
        if (msg->orig_addr.zone != msg->dest_addr.zone)
        {
            packer_format_intl(kludge_buf, sizeof(kludge_buf), &msg->dest_addr, &msg->orig_addr);
            fputs(kludge_buf, ctx->file);
        }

        /* FMPT if origin is a point */
        if (msg->orig_addr.point != 0)
        {
            packer_format_fmpt(kludge_buf, sizeof(kludge_buf), msg->orig_addr.point);
            fputs(kludge_buf, ctx->file);
        }

        /* TOPT if destination is a point */
        if (msg->dest_addr.point != 0)
        {
            packer_format_topt(kludge_buf, sizeof(kludge_buf), msg->dest_addr.point);
            fputs(kludge_buf, ctx->file);
        }
    }

    /* PID kludge */
    fprintf(ctx->file, "\001PID: Converse %s\r", MAILER_VERSION);

    /* Message body */
    if (msg->body != NULL && msg->body_len > 0)
    {
        fwrite(msg->body, 1, msg->body_len, ctx->file);
        
        /* Ensure body ends with CR */
        if (msg->body[msg->body_len - 1] != '\r')
        {
            fputc('\r', ctx->file);
        }
    }

    /* Tearline and Origin - only for locally posted messages */
    if (msg->is_local)
    {
        const char *origin_text = packer_get_random_origin();
        
        /* Use configured origin or fall back to system name */
        if (origin_text == NULL || origin_text[0] == '\0')
        {
            origin_text = mailer.system_name;
        }

        /* Tearline - just three dashes */
        fprintf(ctx->file, "---\r");

        /* Origin line with FTN address */
        if (msg->orig_addr.point == 0)
        {
            snprintf(origin_line, sizeof(origin_line), " * Origin: %s (%d:%d/%d)",
                     origin_text,
                     msg->orig_addr.zone, msg->orig_addr.net, msg->orig_addr.node);
        }
        else
        {
            snprintf(origin_line, sizeof(origin_line), " * Origin: %s (%d:%d/%d.%d)",
                     origin_text,
                     msg->orig_addr.zone, msg->orig_addr.net, msg->orig_addr.node, msg->orig_addr.point);
        }
        fprintf(ctx->file, "%s\r", origin_line);
    }

    /* SEEN-BY and PATH for echomail */
    if (msg->is_echomail)
    {
        /* Start with existing or empty */
        if (msg->seen_by != NULL)
        {
            strncpy(seenby, msg->seen_by, sizeof(seenby) - 1);
            seenby[sizeof(seenby) - 1] = '\0';
        }
        else
        {
            seenby[0] = '\0';
        }

        if (msg->path != NULL)
        {
            strncpy(path, msg->path, sizeof(path) - 1);
            path[sizeof(path) - 1] = '\0';
        }
        else
        {
            path[0] = '\0';
        }

        /* Add our node */
        packer_add_seenby(seenby, sizeof(seenby), msg->orig_addr.net, msg->orig_addr.node);
        packer_add_path(path, sizeof(path), msg->orig_addr.net, msg->orig_addr.node);

        /* Write SEEN-BY */
        if (seenby[0] != '\0')
        {
            fprintf(ctx->file, "%s\r", seenby);
        }

        /* Write PATH */
        if (path[0] != '\0')
        {
            fprintf(ctx->file, "%s\r", path);
        }
    }

    /* Null terminator for message */
    fputc(0, ctx->file);

    ctx->message_count++;
    ctx->packet_size = ftell(ctx->file);

    if (msg->is_echomail)
    {
        packer_stats.echomail_count++;
    }
    else
    {
        packer_stats.netmail_count++;
    }
    packer_stats.messages_packed++;
    packer_stats.bytes_written += (ctx->packet_size - msg_start);

    debug_printf("packer: Wrote message #%d (%s) from %s to %s",
                 ctx->message_count,
                 msg->is_echomail ? msg->area : "netmail",
                 msg->from, msg->to);

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Pack Message from Filer                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

int packer_pack_message_from_filer(PACKER_CONTEXT *ctx, int base_id, int message_id, 
                                    const char *area_tag, int is_echomail, int aka_index)
{
    _kernel_swi_regs regs;
    PACKER_MESSAGE msg;
    char *body_buffer = NULL;
    long body_size;

    /* Local structure matching MESSAGE_RECORD layout */
    typedef struct
    {
        int id;
        int messagebaseid;
        int messagebaseareaid;
        int type;
        int deleted;
        int accesslevel;
        char keys[128];
        int sentby;
        int receivedby;
        struct { char domain[100]; int zone, net, node, point; } orgaddr;
        struct { char domain[100]; int zone, net, node, point; } dstaddr;
        time_t imported;
        time_t sent;
        time_t read;
        int timesread;
        long bodysize;
        char subject[256];
        char fromname[36];
        char toname[36];
        int exported;
    } MSG_REC;

    MSG_REC *record;

    if (ctx == NULL || base_id <= 0 || message_id <= 0)
    {
        return 0;
    }

    memset(&msg, 0, sizeof(msg));

    /* Get message record from Filer */
    regs.r[0] = MSGBASE_CMD_MESSAGE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = message_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] <= 0)
    {
        debug_printf("packer: Failed to get message %d from base %d", message_id, base_id);
        return 0;
    }

    record = (MSG_REC *)regs.r[0];
    body_size = record->bodysize;

    /* Set up addresses */
    msg.orig_addr.zone = record->orgaddr.zone;
    msg.orig_addr.net = record->orgaddr.net;
    msg.orig_addr.node = record->orgaddr.node;
    msg.orig_addr.point = record->orgaddr.point;
    strncpy(msg.orig_addr.domain, record->orgaddr.domain, sizeof(msg.orig_addr.domain) - 1);

    msg.dest_addr.zone = record->dstaddr.zone;
    msg.dest_addr.net = record->dstaddr.net;
    msg.dest_addr.node = record->dstaddr.node;
    msg.dest_addr.point = record->dstaddr.point;
    strncpy(msg.dest_addr.domain, record->dstaddr.domain, sizeof(msg.dest_addr.domain) - 1);

    /* If origin address is empty, this is a locally posted message - use our AKA */
    if (msg.orig_addr.zone == 0 && msg.orig_addr.net == 0)
    {
        msg.is_local = 1;  /* Needs tearline/origin */
        if (aka_index >= 0 && aka_index < mailer.our_addr_count)
        {
            msg.orig_addr = mailer.our_addrs[aka_index];
        }
        else if (mailer.our_addr_count > 0)
        {
            msg.orig_addr = mailer.our_addrs[0];
        }
    }
    else
    {
        msg.is_local = 0;  /* Already has tearline/origin from source */
    }

    /* Header fields */
    strncpy(msg.from, record->fromname, sizeof(msg.from) - 1);
    strncpy(msg.to, record->toname, sizeof(msg.to) - 1);
    strncpy(msg.subject, record->subject, sizeof(msg.subject) - 1);
    msg.datetime = record->sent;
    msg.is_echomail = is_echomail;

    /* Default names if empty */
    if (msg.from[0] == '\0')
    {
        strncpy(msg.from, mailer.sysop, sizeof(msg.from) - 1);
    }
    if (msg.to[0] == '\0')
    {
        strncpy(msg.to, "All", sizeof(msg.to) - 1);
    }

    /* Set attributes */
    msg.attribute = packer_get_message_attributes(is_echomail, 0, 0, 0);

    /* Area tag for echomail */
    if (is_echomail && area_tag != NULL)
    {
        strncpy(msg.area, area_tag, sizeof(msg.area) - 1);
    }

    /* Generate MSGID */
    packer_generate_msgid(&msg.orig_addr, msg.msgid, sizeof(msg.msgid));

    /* Read message body */
    if (body_size > 0)
    {
        body_buffer = malloc(body_size + 1);
        if (body_buffer != NULL)
        {
            regs.r[0] = MSGBASE_CMD_DOWNLOAD_BLOCK;
            regs.r[1] = base_id;
            regs.r[2] = message_id;
            regs.r[3] = (int)body_buffer;
            regs.r[4] = 0;  /* Offset */
            regs.r[5] = body_size;

            if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] < 0)
            {
                free(body_buffer);
                body_buffer = NULL;
            }
            else
            {
                msg.body = body_buffer;
                msg.body_len = regs.r[0];
            }
        }
    }

    /* Write message to packet */
    if (!packer_write_message(ctx, &msg))
    {
        if (body_buffer != NULL) free(body_buffer);
        return 0;
    }

    if (body_buffer != NULL)
    {
        free(body_buffer);
    }

    ftnlog_printf(">> MSG %d:%d/%d.%d -> %d:%d/%d.%d [%s]",
                   msg.orig_addr.zone, msg.orig_addr.net, msg.orig_addr.node, msg.orig_addr.point,
                   msg.dest_addr.zone, msg.dest_addr.net, msg.dest_addr.node, msg.dest_addr.point,
                   is_echomail ? msg.area : "netmail");

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Packet Closing                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

int packer_close_packet(PACKER_CONTEXT *ctx)
{
    if (ctx == NULL)
    {
        return 0;
    }

    if (ctx->file != NULL)
    {
        /* Write packet terminator (two null bytes) */
        fputc(0, ctx->file);
        fputc(0, ctx->file);
        
        fclose(ctx->file);
        ctx->file = NULL;

        debug_printf("packer: Closed packet %s with %d messages (%ld bytes)",
                     ctx->path, ctx->message_count, ctx->packet_size);

        ftnlog_printf(">> PKT closed: %d messages, %ld bytes", ctx->message_count, ctx->packet_size);
        mailer_log("Packet closed: %d messages", ctx->message_count);
    }

    free(ctx);
    return 1;
}

void packer_abort_packet(PACKER_CONTEXT *ctx)
{
    if (ctx == NULL)
    {
        return;
    }

    if (ctx->file != NULL)
    {
        fclose(ctx->file);
        ctx->file = NULL;
    }

    /* Remove incomplete packet */
    if (ctx->path[0] != '\0')
    {
        remove(ctx->path);
        debug_printf("packer: Aborted and removed %s", ctx->path);
    }

    free(ctx);
}

/* ******************************************************************************************************************************************************** */
/* Statistics                                                                                                                                               */
/* ******************************************************************************************************************************************************** */

void packer_get_stats(PACKER_STATS *stats)
{
    if (stats != NULL)
    {
        *stats = packer_stats;
    }
}

void packer_reset_stats(void)
{
    memset(&packer_stats, 0, sizeof(packer_stats));
}

/* ******************************************************************************************************************************************************** */
/* Arcmail Creation                                                                                                                                         */
/* Creates compressed mail bundles for outbound mail                                                                                                        */
/* ******************************************************************************************************************************************************** */

/*
 * Get arcmail extension based on day of week.
 * Format: mo0, tu0, we0, th0, fr0, sa0, su0 (with digit cycling 0-9)
 */
static void packer_get_arcmail_extension(char *ext, size_t size)
{
    static const char *day_codes[] = { "su", "mo", "tu", "we", "th", "fr", "sa" };
    static int ext_counter = 0;
    time_t now = time(NULL);
    struct tm *tm = localtime(&now);
    int dow = tm->tm_wday;  /* 0=Sunday */
    
    snprintf(ext, size, "%s%d", day_codes[dow], ext_counter % 10);
    ext_counter++;
}

/*
 * Create arcmail bundle from a packet file.
 * The packet is compressed and the original packet is removed.
 *
 * Entry:
 *   packet_path - Path to the .pkt file
 *   dest_addr   - Destination address (for arcmail naming)
 *
 * Exit:
 *   Returns 1 on success, 0 on failure
 */
int packer_create_arcmail(const char *packet_path, const FTN_ADDR *dest_addr)
{
    ZIP_ARCHIVE archive;
    char arc_path[PACKER_MAX_PATH];
    char arc_name[64];
    char ext[8];
    const char *pkt_leaf;
    int result;
    
    if (packet_path == NULL || dest_addr == NULL)
        return 0;
    
    /* Get packet leaf name for archive entry */
    pkt_leaf = strrchr(packet_path, '.');
    if (pkt_leaf != NULL)
        pkt_leaf++;
    else
        pkt_leaf = packet_path;
    
    /* Generate arcmail filename */
    packer_get_arcmail_extension(ext, sizeof(ext));
    
    /* Build arcmail path in same directory as packet */
    {
        size_t dir_len;
        const char *last_dot = strrchr(packet_path, '.');
        
        if (last_dot != NULL)
        {
            dir_len = last_dot - packet_path;
            snprintf(arc_path, sizeof(arc_path), "%.*s.%08lx%s",
                     (int)dir_len, packet_path,
                     (unsigned long)time(NULL) & 0xFFFFFFFF, ext);
        }
        else
        {
            snprintf(arc_path, sizeof(arc_path), "%s_%08lx%s",
                     packet_path,
                     (unsigned long)time(NULL) & 0xFFFFFFFF, ext);
        }
    }
    
    /* Create archive name for internal .pkt file (with / separators for ZIP) */
    snprintf(arc_name, sizeof(arc_name), "%s", pkt_leaf);
    
    debug_printf("packer: Creating arcmail %s from %s", arc_path, packet_path);
    
    result = zip_create(&archive, arc_path);
    if (result != ZIP_OK)
    {
        mailer_log("Failed to create arcmail: %s", zip_error_string(result));
        return 0;
    }
    
    result = zip_add_file(&archive, packet_path, arc_name, 1);  /* Compress */
    if (result != ZIP_OK)
    {
        zip_abort(&archive);
        mailer_log("Failed to add packet to arcmail: %s", zip_error_string(result));
        return 0;
    }
    
    result = zip_close(&archive);
    if (result != ZIP_OK)
    {
        mailer_log("Failed to close arcmail: %s", zip_error_string(result));
        remove(arc_path);
        return 0;
    }
    
    /* Remove original packet */
    remove(packet_path);
    
    ftnlog_printf(">> ARC %s", arc_path);
    mailer_log("Created arcmail: %s", arc_path);
    
    return 1;
}

/*
 * Create arcmail bundle from multiple packet files.
 *
 * Entry:
 *   packet_paths - Array of paths to .pkt files
 *   count        - Number of packets
 *   dest_addr    - Destination address
 *
 * Exit:
 *   Returns 1 on success, 0 on failure
 */
int packer_create_arcmail_multi(const char **packet_paths, int count, const FTN_ADDR *dest_addr)
{
    ZIP_ARCHIVE archive;
    char arc_path[PACKER_MAX_PATH];
    char ext[8];
    int result;
    int i;
    int added = 0;
    
    if (packet_paths == NULL || count <= 0 || dest_addr == NULL)
        return 0;
    
    /* Generate arcmail filename based on first packet's directory */
    packer_get_arcmail_extension(ext, sizeof(ext));
    
    {
        const char *first = packet_paths[0];
        const char *last_dot = strrchr(first, '.');
        size_t dir_len;
        
        if (last_dot != NULL)
        {
            dir_len = last_dot - first;
            snprintf(arc_path, sizeof(arc_path), "%.*s.%08lx%s",
                     (int)dir_len, first,
                     (unsigned long)time(NULL) & 0xFFFFFFFF, ext);
        }
        else
        {
            snprintf(arc_path, sizeof(arc_path), "%08lx%s",
                     (unsigned long)time(NULL) & 0xFFFFFFFF, ext);
        }
    }
    
    debug_printf("packer: Creating multi-packet arcmail %s", arc_path);
    
    result = zip_create(&archive, arc_path);
    if (result != ZIP_OK)
    {
        mailer_log("Failed to create arcmail: %s", zip_error_string(result));
        return 0;
    }
    
    for (i = 0; i < count; i++)
    {
        const char *pkt_leaf;
        char arc_name[64];
        
        pkt_leaf = strrchr(packet_paths[i], '.');
        if (pkt_leaf != NULL)
            pkt_leaf++;
        else
            pkt_leaf = packet_paths[i];
        
        snprintf(arc_name, sizeof(arc_name), "%s", pkt_leaf);
        
        result = zip_add_file(&archive, packet_paths[i], arc_name, 1);
        if (result == ZIP_OK)
        {
            added++;
        }
        else
        {
            debug_printf("packer: Failed to add %s to arcmail", packet_paths[i]);
        }
    }
    
    if (added == 0)
    {
        zip_abort(&archive);
        mailer_log("No packets added to arcmail");
        return 0;
    }
    
    result = zip_close(&archive);
    if (result != ZIP_OK)
    {
        mailer_log("Failed to close arcmail: %s", zip_error_string(result));
        remove(arc_path);
        return 0;
    }
    
    /* Remove original packets */
    for (i = 0; i < count; i++)
    {
        remove(packet_paths[i]);
    }
    
    ftnlog_printf(">> ARC %s (%d packets)", arc_path, added);
    mailer_log("Created arcmail with %d packets: %s", added, arc_path);
    
    return 1;
}
