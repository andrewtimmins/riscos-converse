/* ******************************************************************************************************************************************************** */
/* MD5 Implementation for CRAM-MD5 Authentication                                                                                                           */
/* Based on RFC 1321                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

#include <string.h>
#include "md5.h"

/* ******************************************************************************************************************************************************** */
/* Constants                                                                                                                                                */
/* ******************************************************************************************************************************************************** */

/* Constants for MD5Transform routine */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static unsigned char PADDING[64] = {
    0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* ******************************************************************************************************************************************************** */
/* Basic MD5 Functions                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

/* F, G, H and I are basic MD5 functions */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

/* ROTATE_LEFT rotates x left n bits */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

/* ******************************************************************************************************************************************************** */
/* Helper Functions                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

/* Encodes input (unsigned int) into output (unsigned char). Assumes len is a multiple of 4. */
static void Encode(unsigned char *output, const unsigned int *input, size_t len)
{
    size_t i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

/* Decodes input (unsigned char) into output (unsigned int). Assumes len is a multiple of 4. */
static void Decode(unsigned int *output, const unsigned char *input, size_t len)
{
    size_t i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
        output[i] = ((unsigned int)input[j]) | (((unsigned int)input[j+1]) << 8) |
                    (((unsigned int)input[j+2]) << 16) | (((unsigned int)input[j+3]) << 24);
}

/* MD5 basic transformation. Transforms state based on block. */
static void MD5Transform(unsigned int state[4], const unsigned char block[64])
{
    unsigned int a, b, c, d, x[16];

    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];

    Decode(x, block, 64);

    /* Round 1 */
    a += F(b, c, d) + x[ 0] + 0xd76aa478; a = ROTATE_LEFT(a, S11); a += b;
    d += F(a, b, c) + x[ 1] + 0xe8c7b756; d = ROTATE_LEFT(d, S12); d += a;
    c += F(d, a, b) + x[ 2] + 0x242070db; c = ROTATE_LEFT(c, S13); c += d;
    b += F(c, d, a) + x[ 3] + 0xc1bdceee; b = ROTATE_LEFT(b, S14); b += c;
    a += F(b, c, d) + x[ 4] + 0xf57c0faf; a = ROTATE_LEFT(a, S11); a += b;
    d += F(a, b, c) + x[ 5] + 0x4787c62a; d = ROTATE_LEFT(d, S12); d += a;
    c += F(d, a, b) + x[ 6] + 0xa8304613; c = ROTATE_LEFT(c, S13); c += d;
    b += F(c, d, a) + x[ 7] + 0xfd469501; b = ROTATE_LEFT(b, S14); b += c;
    a += F(b, c, d) + x[ 8] + 0x698098d8; a = ROTATE_LEFT(a, S11); a += b;
    d += F(a, b, c) + x[ 9] + 0x8b44f7af; d = ROTATE_LEFT(d, S12); d += a;
    c += F(d, a, b) + x[10] + 0xffff5bb1; c = ROTATE_LEFT(c, S13); c += d;
    b += F(c, d, a) + x[11] + 0x895cd7be; b = ROTATE_LEFT(b, S14); b += c;
    a += F(b, c, d) + x[12] + 0x6b901122; a = ROTATE_LEFT(a, S11); a += b;
    d += F(a, b, c) + x[13] + 0xfd987193; d = ROTATE_LEFT(d, S12); d += a;
    c += F(d, a, b) + x[14] + 0xa679438e; c = ROTATE_LEFT(c, S13); c += d;
    b += F(c, d, a) + x[15] + 0x49b40821; b = ROTATE_LEFT(b, S14); b += c;

    /* Round 2 */
    a += G(b, c, d) + x[ 1] + 0xf61e2562; a = ROTATE_LEFT(a, S21); a += b;
    d += G(a, b, c) + x[ 6] + 0xc040b340; d = ROTATE_LEFT(d, S22); d += a;
    c += G(d, a, b) + x[11] + 0x265e5a51; c = ROTATE_LEFT(c, S23); c += d;
    b += G(c, d, a) + x[ 0] + 0xe9b6c7aa; b = ROTATE_LEFT(b, S24); b += c;
    a += G(b, c, d) + x[ 5] + 0xd62f105d; a = ROTATE_LEFT(a, S21); a += b;
    d += G(a, b, c) + x[10] + 0x02441453; d = ROTATE_LEFT(d, S22); d += a;
    c += G(d, a, b) + x[15] + 0xd8a1e681; c = ROTATE_LEFT(c, S23); c += d;
    b += G(c, d, a) + x[ 4] + 0xe7d3fbc8; b = ROTATE_LEFT(b, S24); b += c;
    a += G(b, c, d) + x[ 9] + 0x21e1cde6; a = ROTATE_LEFT(a, S21); a += b;
    d += G(a, b, c) + x[14] + 0xc33707d6; d = ROTATE_LEFT(d, S22); d += a;
    c += G(d, a, b) + x[ 3] + 0xf4d50d87; c = ROTATE_LEFT(c, S23); c += d;
    b += G(c, d, a) + x[ 8] + 0x455a14ed; b = ROTATE_LEFT(b, S24); b += c;
    a += G(b, c, d) + x[13] + 0xa9e3e905; a = ROTATE_LEFT(a, S21); a += b;
    d += G(a, b, c) + x[ 2] + 0xfcefa3f8; d = ROTATE_LEFT(d, S22); d += a;
    c += G(d, a, b) + x[ 7] + 0x676f02d9; c = ROTATE_LEFT(c, S23); c += d;
    b += G(c, d, a) + x[12] + 0x8d2a4c8a; b = ROTATE_LEFT(b, S24); b += c;

    /* Round 3 */
    a += H(b, c, d) + x[ 5] + 0xfffa3942; a = ROTATE_LEFT(a, S31); a += b;
    d += H(a, b, c) + x[ 8] + 0x8771f681; d = ROTATE_LEFT(d, S32); d += a;
    c += H(d, a, b) + x[11] + 0x6d9d6122; c = ROTATE_LEFT(c, S33); c += d;
    b += H(c, d, a) + x[14] + 0xfde5380c; b = ROTATE_LEFT(b, S34); b += c;
    a += H(b, c, d) + x[ 1] + 0xa4beea44; a = ROTATE_LEFT(a, S31); a += b;
    d += H(a, b, c) + x[ 4] + 0x4bdecfa9; d = ROTATE_LEFT(d, S32); d += a;
    c += H(d, a, b) + x[ 7] + 0xf6bb4b60; c = ROTATE_LEFT(c, S33); c += d;
    b += H(c, d, a) + x[10] + 0xbebfbc70; b = ROTATE_LEFT(b, S34); b += c;
    a += H(b, c, d) + x[13] + 0x289b7ec6; a = ROTATE_LEFT(a, S31); a += b;
    d += H(a, b, c) + x[ 0] + 0xeaa127fa; d = ROTATE_LEFT(d, S32); d += a;
    c += H(d, a, b) + x[ 3] + 0xd4ef3085; c = ROTATE_LEFT(c, S33); c += d;
    b += H(c, d, a) + x[ 6] + 0x04881d05; b = ROTATE_LEFT(b, S34); b += c;
    a += H(b, c, d) + x[ 9] + 0xd9d4d039; a = ROTATE_LEFT(a, S31); a += b;
    d += H(a, b, c) + x[12] + 0xe6db99e5; d = ROTATE_LEFT(d, S32); d += a;
    c += H(d, a, b) + x[15] + 0x1fa27cf8; c = ROTATE_LEFT(c, S33); c += d;
    b += H(c, d, a) + x[ 2] + 0xc4ac5665; b = ROTATE_LEFT(b, S34); b += c;

    /* Round 4 */
    a += I(b, c, d) + x[ 0] + 0xf4292244; a = ROTATE_LEFT(a, S41); a += b;
    d += I(a, b, c) + x[ 7] + 0x432aff97; d = ROTATE_LEFT(d, S42); d += a;
    c += I(d, a, b) + x[14] + 0xab9423a7; c = ROTATE_LEFT(c, S43); c += d;
    b += I(c, d, a) + x[ 5] + 0xfc93a039; b = ROTATE_LEFT(b, S44); b += c;
    a += I(b, c, d) + x[12] + 0x655b59c3; a = ROTATE_LEFT(a, S41); a += b;
    d += I(a, b, c) + x[ 3] + 0x8f0ccc92; d = ROTATE_LEFT(d, S42); d += a;
    c += I(d, a, b) + x[10] + 0xffeff47d; c = ROTATE_LEFT(c, S43); c += d;
    b += I(c, d, a) + x[ 1] + 0x85845dd1; b = ROTATE_LEFT(b, S44); b += c;
    a += I(b, c, d) + x[ 8] + 0x6fa87e4f; a = ROTATE_LEFT(a, S41); a += b;
    d += I(a, b, c) + x[15] + 0xfe2ce6e0; d = ROTATE_LEFT(d, S42); d += a;
    c += I(d, a, b) + x[ 6] + 0xa3014314; c = ROTATE_LEFT(c, S43); c += d;
    b += I(c, d, a) + x[13] + 0x4e0811a1; b = ROTATE_LEFT(b, S44); b += c;
    a += I(b, c, d) + x[ 4] + 0xf7537e82; a = ROTATE_LEFT(a, S41); a += b;
    d += I(a, b, c) + x[11] + 0xbd3af235; d = ROTATE_LEFT(d, S42); d += a;
    c += I(d, a, b) + x[ 2] + 0x2ad7d2bb; c = ROTATE_LEFT(c, S43); c += d;
    b += I(c, d, a) + x[ 9] + 0xeb86d391; b = ROTATE_LEFT(b, S44); b += c;

    state[0] += a;
    state[1] += b;
    state[2] += c;
    state[3] += d;

    /* Zeroize sensitive information */
    memset(x, 0, sizeof(x));
}

/* ******************************************************************************************************************************************************** */
/* Public MD5 Functions                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/* MD5 initialization. Begins an MD5 operation, writing a new context. */
void MD5_Init(MD5_CTX *context)
{
    context->count[0] = context->count[1] = 0;
    /* Load magic initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xefcdab89;
    context->state[2] = 0x98badcfe;
    context->state[3] = 0x10325476;
}

/* MD5 block update operation. Continues an MD5 message-digest operation,
   processing another message block, and updating the context. */
void MD5_Update(MD5_CTX *context, const unsigned char *input, size_t inputLen)
{
    size_t i, index, partLen;

    /* Compute number of bytes mod 64 */
    index = (size_t)((context->count[0] >> 3) & 0x3F);

    /* Update number of bits */
    if ((context->count[0] += ((unsigned int)inputLen << 3)) < ((unsigned int)inputLen << 3))
        context->count[1]++;
    context->count[1] += ((unsigned int)inputLen >> 29);

    partLen = 64 - index;

    /* Transform as many times as possible */
    if (inputLen >= partLen) {
        memcpy(&context->buffer[index], input, partLen);
        MD5Transform(context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
            MD5Transform(context->state, &input[i]);

        index = 0;
    } else {
        i = 0;
    }

    /* Buffer remaining input */
    memcpy(&context->buffer[index], &input[i], inputLen - i);
}

/* MD5 finalization. Ends an MD5 message-digest operation, writing the
   the message digest and zeroizing the context. */
void MD5_Final(unsigned char digest[16], MD5_CTX *context)
{
    unsigned char bits[8];
    size_t index, padLen;

    /* Save number of bits */
    Encode(bits, context->count, 8);

    /* Pad out to 56 mod 64 */
    index = (size_t)((context->count[0] >> 3) & 0x3f);
    padLen = (index < 56) ? (56 - index) : (120 - index);
    MD5_Update(context, PADDING, padLen);

    /* Append length (before padding) */
    MD5_Update(context, bits, 8);

    /* Store state in digest */
    Encode(digest, context->state, 16);

    /* Zeroize sensitive information */
    memset(context, 0, sizeof(*context));
}

/* Convenience function to compute MD5 of a buffer */
void MD5(const unsigned char *input, size_t len, unsigned char digest[16])
{
    MD5_CTX ctx;
    MD5_Init(&ctx);
    MD5_Update(&ctx, input, len);
    MD5_Final(digest, &ctx);
}

/* ******************************************************************************************************************************************************** */
/* HMAC-MD5 Implementation (RFC 2104)                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void HMAC_MD5(const unsigned char *key, size_t key_len,
              const unsigned char *data, size_t data_len,
              unsigned char digest[16])
{
    MD5_CTX ctx;
    unsigned char k_ipad[64];
    unsigned char k_opad[64];
    unsigned char tk[16];
    size_t i;

    /* If key is longer than 64 bytes, hash it first */
    if (key_len > 64) {
        MD5(key, key_len, tk);
        key = tk;
        key_len = 16;
    }

    /* XOR key with ipad and opad values */
    memset(k_ipad, 0x36, 64);
    memset(k_opad, 0x5c, 64);

    for (i = 0; i < key_len; i++) {
        k_ipad[i] ^= key[i];
        k_opad[i] ^= key[i];
    }

    /* Inner: MD5(K XOR ipad, data) */
    MD5_Init(&ctx);
    MD5_Update(&ctx, k_ipad, 64);
    MD5_Update(&ctx, data, data_len);
    MD5_Final(digest, &ctx);

    /* Outer: MD5(K XOR opad, inner_result) */
    MD5_Init(&ctx);
    MD5_Update(&ctx, k_opad, 64);
    MD5_Update(&ctx, digest, 16);
    MD5_Final(digest, &ctx);
}
