/* ******************************************************************************************************************************************************** */
/* FTN Mailer - Outbound Scanner Implementation                                                                                                             */
/* Scans messagebases for unexported messages and routes them to uplinks                                                                                    */
/* ******************************************************************************************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include "kernel.h"
#include "swis.h"

#include "scanner.h"
#include "packer.h"
#include "mailer.h"
#include "echofix.h"
#include "debug.h"
#include "ftnlog.h"

/* ******************************************************************************************************************************************************** */
/* SWI Numbers                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

#define SWI_FILER_MESSAGEBASE       0x5AA42
#define SWI_SUPPORT_MSGBASECONFIG   0x5AA84
#define SWI_SUPPORT_FTN             0x5AA86

/* Filer messagebase commands */
#define MSGBASE_CMD_MESSAGE_INFO    11
#define MSGBASE_CMD_FIND_UNEXPORTED 13
#define MSGBASE_CMD_MARK_EXPORTED   14

/* Support messagebase config reasons */
#define MSGBASE_CONFIG_COUNT_BASES  6
#define MSGBASE_CONFIG_COUNT_AREAS  7
#define MSGBASE_CONFIG_GET_BASE     2
#define MSGBASE_CONFIG_GET_AREA     4

/* Support FTN config reasons */
#define FTN_CONFIG_GET_GLOBAL       0
#define FTN_CONFIG_COUNT_UPLINKS    7
#define FTN_CONFIG_GET_UPLINK       4

/* FTN config structure sizes */
#define FTN_MAX_UPLINKS             16
#define FTN_NAME_LEN                64
#define FTN_PATH_LEN                256
#define FTN_PASSWORD_LEN            32
#define FTN_GROUPS_LEN              64
#define FTN_MAX_ALIASES             8

/* ******************************************************************************************************************************************************** */
/* Global State                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

static SCANNER_STATS scanner_stats;

/* Uplink batch storage */
static SCANNER_UPLINK_BATCH uplink_batches[SCANNER_MAX_UPLINKS];
static int uplink_batch_count = 0;

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

void scanner_initialise(void)
{
    memset(&scanner_stats, 0, sizeof(scanner_stats));
    memset(uplink_batches, 0, sizeof(uplink_batches));
    uplink_batch_count = 0;
}

void scanner_finalise(void)
{
    /* Nothing to clean up */
}

/* ******************************************************************************************************************************************************** */
/* Group Matching                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/* Case-insensitive string compare */
static int scanner_strcasecmp(const char *s1, const char *s2)
{
    while (*s1 && *s2)
    {
        int c1 = tolower((unsigned char)*s1);
        int c2 = tolower((unsigned char)*s2);
        if (c1 != c2)
        {
            return c1 - c2;
        }
        s1++;
        s2++;
    }
    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

/* Extract next token from comma-separated list. Updates *pos. Returns token start or NULL. */
static char *get_next_group(char *buf, const char **pos)
{
    const char *p = *pos;
    char *out = buf;

    if (p == NULL || *p == '\0')
    {
        return NULL;
    }

    /* Skip leading spaces and commas */
    while (*p == ' ' || *p == ',')
    {
        p++;
    }

    if (*p == '\0')
    {
        *pos = p;
        return NULL;
    }

    /* Copy token until comma, space, or end */
    while (*p != '\0' && *p != ',' && *p != ' ')
    {
        *out++ = *p++;
    }
    *out = '\0';

    /* Skip trailing spaces */
    while (*p == ' ')
    {
        p++;
    }

    *pos = p;
    return buf;
}

/* Check if any group in area_groups matches any group in uplink_groups */
/* Group lists are comma-separated, e.g. "A,B,C" */
static int groups_match(const char *area_groups, const char *uplink_groups)
{
    const char *p1, *p2;
    char g1[32], g2[32];

    /* Empty list matches everything */
    if (area_groups == NULL || area_groups[0] == '\0')
    {
        return 1;
    }
    if (uplink_groups == NULL || uplink_groups[0] == '\0')
    {
        return 1;
    }

    /* Check each group in area_groups against uplink_groups */
    p1 = area_groups;
    while (get_next_group(g1, &p1) != NULL)
    {
        p2 = uplink_groups;
        while (get_next_group(g2, &p2) != NULL)
        {
            if (scanner_strcasecmp(g1, g2) == 0)
            {
                return 1;  /* Match found */
            }
        }
    }

    return 0;  /* No match */
}

/* ******************************************************************************************************************************************************** */
/* Area Information Lookup                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

int scanner_get_area_info(int base_id, int area_id, char *tag, int *areatype, int *akause)
{
    return scanner_get_area_info_full(base_id, area_id, tag, areatype, akause, NULL);
}

int scanner_get_area_info_full(int base_id, int area_id, char *tag, int *areatype, int *akause, char *groups)
{
    _kernel_swi_regs regs;

    /* MSGBASE_AREA_CONFIG structure from Support module */
    typedef struct
    {
        int id;
        char name[64];
        char tag[64];
        int areatype;
        int daystokeep;
        int akause;
        int accesslevel;
        char keys[128];
        char groups[64];
    } AREA_CFG;

    AREA_CFG *area;

    regs.r[0] = MSGBASE_CONFIG_GET_AREA;
    regs.r[1] = base_id;
    regs.r[2] = area_id;

    if (_kernel_swi(SWI_SUPPORT_MSGBASECONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }

    area = (AREA_CFG *)regs.r[0];

    if (tag != NULL)
    {
        strncpy(tag, area->tag, 63);
        tag[63] = '\0';
    }
    if (areatype != NULL)
    {
        *areatype = area->areatype;
    }
    if (akause != NULL)
    {
        *akause = area->akause;
    }
    if (groups != NULL)
    {
        strncpy(groups, area->groups, 63);
        groups[63] = '\0';
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Find Unexported Messages                                                                                                                                 */
/* ******************************************************************************************************************************************************** */

int scanner_find_unexported_messages(int base_id, int area_id, int *message_ids, int max_count)
{
    _kernel_swi_regs regs;

    if (message_ids == NULL || max_count <= 0)
    {
        return 0;
    }

    regs.r[0] = MSGBASE_CMD_FIND_UNEXPORTED;
    regs.r[1] = base_id;
    regs.r[2] = area_id;
    regs.r[3] = (int)message_ids;
    regs.r[4] = max_count;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    return regs.r[0];  /* Count of message IDs found */
}

/* ******************************************************************************************************************************************************** */
/* Get Message Destination Address                                                                                                                          */
/* ******************************************************************************************************************************************************** */

int scanner_get_message_dest(int base_id, int message_id, FTN_ADDR *dest_out)
{
    _kernel_swi_regs regs;

    /* MESSAGE_RECORD structure - only need dstaddr field */
    /* Offsets from Filer/h/structs MESSAGE_RECORD: */
    /* id(4), msgbaseid(4), msgbaseareaid(4), type(4), deleted(4), accesslevel(4), */
    /* keys(128), subject(256), sentby(4), receivedby(4), */
    /* orgaddr: domain(100)+zone(4)+net(4)+node(4)+point(4) = 116 bytes */
    /* dstaddr starts at offset: 4+4+4+4+4+4+128+256+4+4+116 = 532 */
    typedef struct {
        char domain[100];
        int zone;
        int net;
        int node;
        int point;
    } MSG_FTN_ADDR;

    if (dest_out == NULL)
    {
        return 0;
    }

    regs.r[0] = MSGBASE_CMD_MESSAGE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = message_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
    {
        debug_printf("scanner: Failed to get message %d info from base %d", message_id, base_id);
        return 0;
    }

    /* Parse destination address from MESSAGE_RECORD */
    {
        unsigned char *record = (unsigned char *)regs.r[0];
        MSG_FTN_ADDR *dstaddr = (MSG_FTN_ADDR *)(record + 532);

        dest_out->zone = dstaddr->zone;
        dest_out->net = dstaddr->net;
        dest_out->node = dstaddr->node;
        dest_out->point = dstaddr->point;

        debug_printf("scanner: Message %d dest: %d:%d/%d.%d",
                     message_id, dest_out->zone, dest_out->net, dest_out->node, dest_out->point);
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Get Message Flags                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

/* Message flag constants (must match Filer/h/structs MSG_FLAG_*) */
#define SCAN_MSG_FLAG_PRIVATE       0x0001
#define SCAN_MSG_FLAG_CRASH         0x0002
#define SCAN_MSG_FLAG_HOLD          0x0004
#define SCAN_MSG_FLAG_DIRECT        0x0008
#define SCAN_MSG_FLAG_IMMEDIATE     0x0010

int scanner_get_message_flags(int base_id, int message_id, unsigned short *flags_out)
{
    _kernel_swi_regs regs;

    if (flags_out == NULL)
    {
        return 0;
    }

    *flags_out = 0;

    regs.r[0] = MSGBASE_CMD_MESSAGE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = message_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    /* MESSAGE_RECORD.flags is at the end of the structure */
    /* After exported(4) comes flags(2) */
    /* Offset: see structs.h - exported is near end, flags follows it */
    /* Calculate: ~660 bytes before exported, then flags at offset + 664 */
    {
        unsigned char *record = (unsigned char *)regs.r[0];
        /* exported is at offset 660, flags at offset 664 */
        *flags_out = *((unsigned short *)(record + 664));
    }

    return 1;
}

SCANNER_FLAVOUR scanner_flags_to_flavour(unsigned short flags)
{
    /* Priority order: Immediate > Crash > Direct > Hold > Normal */
    if (flags & SCAN_MSG_FLAG_IMMEDIATE)
    {
        return SCANNER_FLAVOUR_IMMEDIATE;
    }
    if (flags & SCAN_MSG_FLAG_CRASH)
    {
        return SCANNER_FLAVOUR_CRASH;
    }
    if (flags & SCAN_MSG_FLAG_DIRECT)
    {
        return SCANNER_FLAVOUR_DIRECT;
    }
    if (flags & SCAN_MSG_FLAG_HOLD)
    {
        return SCANNER_FLAVOUR_HOLD;
    }
    return SCANNER_FLAVOUR_NORMAL;
}

/* ******************************************************************************************************************************************************** */
/* Uplink Lookup                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/* FTN global config structure (must match Support module) */
typedef struct
{
    int id;
    char address[FTN_NAME_LEN];
    char network[FTN_NAME_LEN];
    char host[FTN_NAME_LEN];
    int port;
    char password[FTN_PASSWORD_LEN];
    char areafix_password[FTN_PASSWORD_LEN];
    char filefix_password[FTN_PASSWORD_LEN];
    char groups[FTN_GROUPS_LEN];
    int alias_count;
    char aliases[FTN_MAX_ALIASES][FTN_NAME_LEN];
} SCAN_UPLINK_CFG;

typedef struct
{
    int id;
    char network[FTN_NAME_LEN];
    int zone, net, node, point;
    char type[8];
} SCAN_ADDRESS_CFG;

typedef struct
{
    char sysop[FTN_NAME_LEN];
    char system[FTN_NAME_LEN];
    char location[FTN_NAME_LEN];
    char phone[FTN_NAME_LEN];
    int speed;
    char flags[FTN_GROUPS_LEN];
    char inbound[FTN_PATH_LEN];
    char outbound[FTN_PATH_LEN];
    char netmail[FTN_PATH_LEN];
    char nodelists[FTN_PATH_LEN];
    char freqpath[FTN_PATH_LEN];
    char freqexec[FTN_PATH_LEN];
    long max_packet_size;
    int listen_port;
    int max_sessions;
    int connect_timeout;
    int session_timeout;
    int scan_interval;
    int toss_interval;
    int poll_interval;
    int retry_delay;
    int address_count;
    SCAN_ADDRESS_CFG addresses[8];
    int uplink_count;
    SCAN_UPLINK_CFG uplinks[FTN_MAX_UPLINKS];
} SCAN_FTN_GLOBAL_CFG;

/* Downlink config structure (must match Support module) */
typedef struct
{
    int id;
    char address[FTN_NAME_LEN];
    char name[FTN_NAME_LEN];
    char password[FTN_PASSWORD_LEN];
    char areafix_password[FTN_PASSWORD_LEN];
    char filefix_password[FTN_PASSWORD_LEN];
    char allowed_groups[FTN_GROUPS_LEN];
    char allowed_echoes[256];
    char allowed_files[256];
    int max_echoes;
    int max_files;
} SCAN_DOWNLINK_CFG;

/* SWI reason codes for downlinks */
#define FTN_CONFIG_GET_DOWNLINK      8
#define FTN_CONFIG_COUNT_DOWNLINKS  10

int scanner_find_uplink_by_address(const FTN_ADDR *addr, char *password_out, size_t pw_size)
{
    _kernel_swi_regs regs;
    SCAN_FTN_GLOBAL_CFG *global;
    int i;

    if (addr == NULL)
    {
        return 0;
    }

    /* Get global FTN config */
    regs.r[0] = FTN_CONFIG_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }
    global = (SCAN_FTN_GLOBAL_CFG *)regs.r[0];

    /* Search uplinks by array index */
    for (i = 0; i < global->uplink_count; i++)
    {
        SCAN_UPLINK_CFG *uplink = &global->uplinks[i];
        FTN_ADDR uplink_addr;

        /* Parse uplink address */
        if (ftn_string_to_addr(uplink->address, &uplink_addr))
        {
            if (ftn_addr_match(addr, &uplink_addr))
            {
                if (password_out != NULL && pw_size > 0)
                {
                    strncpy(password_out, uplink->password, pw_size - 1);
                    password_out[pw_size - 1] = '\0';
                }
                return 1;
            }
        }
    }

    return 0;
}

int scanner_find_uplink_for_zone(int zone, FTN_ADDR *uplink_out, char *password_out, size_t pw_size)
{
    _kernel_swi_regs regs;
    SCAN_FTN_GLOBAL_CFG *global;
    int i;
    int found_default = 0;
    FTN_ADDR default_uplink;
    char default_password[32] = "";

    /* Get global FTN config */
    regs.r[0] = FTN_CONFIG_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }
    global = (SCAN_FTN_GLOBAL_CFG *)regs.r[0];

    /* Search for uplink in target zone, or save first as default */
    for (i = 0; i < global->uplink_count; i++)
    {
        SCAN_UPLINK_CFG *uplink = &global->uplinks[i];
        FTN_ADDR uplink_addr;

        if (ftn_string_to_addr(uplink->address, &uplink_addr))
        {
            /* Save first uplink as default */
            if (!found_default)
            {
                default_uplink = uplink_addr;
                strncpy(default_password, uplink->password, sizeof(default_password) - 1);
                found_default = 1;
            }

            /* Check if this uplink is in target zone */
            if (uplink_addr.zone == zone)
            {
                if (uplink_out != NULL)
                {
                    *uplink_out = uplink_addr;
                }
                if (password_out != NULL && pw_size > 0)
                {
                    strncpy(password_out, uplink->password, pw_size - 1);
                    password_out[pw_size - 1] = '\0';
                }
                return 1;
            }
        }
    }

    /* Use default uplink if no zone match */
    if (found_default)
    {
        if (uplink_out != NULL)
        {
            *uplink_out = default_uplink;
        }
        if (password_out != NULL && pw_size > 0)
        {
            strncpy(password_out, default_password, pw_size - 1);
            password_out[pw_size - 1] = '\0';
        }
        return 1;
    }

    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Downlink Lookup                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

int scanner_find_downlink_by_address(const FTN_ADDR *addr, char *password_out, size_t pw_size)
{
    _kernel_swi_regs regs;
    int count;
    int i;

    if (addr == NULL)
    {
        return 0;
    }

    /* Get downlink count */
    regs.r[0] = FTN_CONFIG_COUNT_DOWNLINKS;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL)
    {
        return 0;
    }
    count = regs.r[0];

    /* Search downlinks */
    for (i = 0; i < count; i++)
    {
        regs.r[0] = FTN_CONFIG_GET_DOWNLINK;
        regs.r[1] = i + 1;  /* 1-based ID */
        if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
        {
            continue;
        }

        {
            SCAN_DOWNLINK_CFG *dl = (SCAN_DOWNLINK_CFG *)regs.r[0];
            FTN_ADDR dl_addr;

            if (dl->id > 0 && ftn_string_to_addr(dl->address, &dl_addr))
            {
                if (ftn_addr_match(addr, &dl_addr))
                {
                    if (password_out != NULL && pw_size > 0)
                    {
                        strncpy(password_out, dl->password, pw_size - 1);
                        password_out[pw_size - 1] = '\0';
                    }
                    return 1;
                }
            }
        }
    }

    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Point Routing                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

int scanner_is_our_point(const FTN_ADDR *addr)
{
    int i;

    if (addr == NULL || addr->point == 0)
    {
        return 0;
    }

    /* Check if this is a point off one of our nodes */
    for (i = 0; i < mailer.our_addr_count; i++)
    {
        if (addr->zone == mailer.our_addrs[i].zone &&
            addr->net == mailer.our_addrs[i].net &&
            addr->node == mailer.our_addrs[i].node)
        {
            return 1;  /* This is our point */
        }
    }

    return 0;
}

int scanner_route_to_point(const FTN_ADDR *dest, FTN_ADDR *boss_out)
{
    if (dest == NULL || boss_out == NULL)
    {
        return 0;
    }

    if (dest->point == 0)
    {
        return 0;  /* Not a point */
    }

    /* Route via boss node (same address with point=0) */
    *boss_out = *dest;
    boss_out->point = 0;

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Netmail Routing                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

int scanner_route_netmail(const FTN_ADDR *dest, FTN_ADDR *uplink_out, char *password_out, size_t pw_size)
{
    FTN_ADDR route_addr;

    if (dest == NULL)
    {
        return 0;
    }

    /* Start with destination as route target */
    route_addr = *dest;

    /* If destination is a point, route to boss node */
    if (dest->point != 0)
    {
        route_addr.point = 0;
    }

    /* Check if destination node is a direct uplink */
    if (scanner_find_uplink_by_address(&route_addr, password_out, pw_size))
    {
        if (uplink_out != NULL)
        {
            *uplink_out = route_addr;
        }
        return 1;
    }

    /* Route via zone uplink */
    return scanner_find_uplink_for_zone(dest->zone, uplink_out, password_out, pw_size);
}

/* ******************************************************************************************************************************************************** */
/* Echomail Uplink Discovery                                                                                                                                */
/* ******************************************************************************************************************************************************** */

int scanner_get_echomail_uplinks(const char *area_groups, FTN_ADDR *uplinks, int max_uplinks)
{
    _kernel_swi_regs regs;
    SCAN_FTN_GLOBAL_CFG *global;
    int i;
    int found = 0;

    if (uplinks == NULL || max_uplinks <= 0)
    {
        return 0;
    }

    /* Get global FTN config */
    regs.r[0] = FTN_CONFIG_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }
    global = (SCAN_FTN_GLOBAL_CFG *)regs.r[0];

    /* Send echomail to uplinks whose groups overlap with the area's groups */
    for (i = 0; i < global->uplink_count && found < max_uplinks; i++)
    {
        SCAN_UPLINK_CFG *uplink = &global->uplinks[i];
        FTN_ADDR uplink_addr;

        /* Check if area groups match uplink groups */
        if (!groups_match(area_groups, uplink->groups))
        {
            debug_printf("scanner: Skipping uplink %s (groups '%s' don't match area '%s')",
                         uplink->address, uplink->groups, 
                         area_groups ? area_groups : "(empty)");
            continue;
        }

        if (ftn_string_to_addr(uplink->address, &uplink_addr))
        {
            uplinks[found] = uplink_addr;
            found++;
            debug_printf("scanner: Including uplink %s (groups match)", uplink->address);
        }
    }

    return found;
}

/* ******************************************************************************************************************************************************** */
/* Uplink Batch Management                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

static SCANNER_UPLINK_BATCH *scanner_get_or_create_batch(const FTN_ADDR *uplink, const char *password)
{
    int i;
    SCANNER_UPLINK_BATCH *batch;

    /* Look for existing batch */
    for (i = 0; i < uplink_batch_count; i++)
    {
        if (ftn_addr_match(&uplink_batches[i].uplink_addr, uplink))
        {
            return &uplink_batches[i];
        }
    }

    /* Create new batch */
    if (uplink_batch_count >= SCANNER_MAX_UPLINKS)
    {
        return NULL;
    }

    batch = &uplink_batches[uplink_batch_count];
    memset(batch, 0, sizeof(SCANNER_UPLINK_BATCH));
    batch->uplink_addr = *uplink;
    if (password != NULL)
    {
        strncpy(batch->password, password, sizeof(batch->password) - 1);
    }
    uplink_batch_count++;

    return batch;
}

static int scanner_add_message_to_batch(SCANNER_UPLINK_BATCH *batch, const SCANNER_MESSAGE *msg)
{
    if (batch == NULL || msg == NULL)
    {
        return 0;
    }

    if (batch->message_count >= SCANNER_MAX_MESSAGES)
    {
        return 0;
    }

    batch->messages[batch->message_count] = *msg;
    batch->message_count++;

    /* Track highest priority flavour in batch */
    /* Priority: IMMEDIATE > CRASH > DIRECT > HOLD > NORMAL */
    if (msg->flavour > batch->max_flavour)
    {
        batch->max_flavour = msg->flavour;
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Packet Creation for Uplink Batch                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int scanner_create_packets_for_uplink(SCANNER_UPLINK_BATCH *batch)
{
    PACKER_CONTEXT *ctx;
    int i;
    int packed = 0;
    PACKER_FLAVOUR packer_flavour;

    if (batch == NULL || batch->message_count == 0)
    {
        return 0;
    }

    /* Determine which of our addresses to use (use first, or match zone) */
    if (mailer.our_addr_count == 0)
    {
        debug_printf("scanner: No local addresses configured");
        return 0;
    }

    /* Convert scanner flavour to packer flavour */
    switch (batch->max_flavour)
    {
        case SCANNER_FLAVOUR_HOLD:      packer_flavour = PACKER_FLAVOUR_HOLD; break;
        case SCANNER_FLAVOUR_DIRECT:    packer_flavour = PACKER_FLAVOUR_DIRECT; break;
        case SCANNER_FLAVOUR_CRASH:     packer_flavour = PACKER_FLAVOUR_CRASH; break;
        case SCANNER_FLAVOUR_IMMEDIATE: packer_flavour = PACKER_FLAVOUR_IMMEDIATE; break;
        default:                        packer_flavour = PACKER_FLAVOUR_NORMAL; break;
    }

    /* Create packet with appropriate flavour */
    ctx = packer_create_packet(&mailer.our_addrs[0], &batch->uplink_addr, batch->password, packer_flavour);
    if (ctx == NULL)
    {
        debug_printf("scanner: Failed to create packet for uplink");
        scanner_stats.errors++;
        return 0;
    }

    /* Pack all messages for this uplink */
    for (i = 0; i < batch->message_count; i++)
    {
        SCANNER_MESSAGE *msg = &batch->messages[i];
        int is_echomail = (msg->areatype == SCANNER_AREATYPE_ECHO);

        if (packer_pack_message_from_filer(ctx, msg->base_id, msg->message_id,
                                            msg->echotag, is_echomail, msg->akause))
        {
            packed++;
            scanner_stats.messages_packed++;
        }
        else
        {
            debug_printf("scanner: Failed to pack message %d from base %d",
                         msg->message_id, msg->base_id);
            scanner_stats.errors++;
        }
    }

    /* Close packet */
    if (packed > 0)
    {
        packer_close_packet(ctx);
        scanner_stats.packets_created++;
    }
    else
    {
        packer_abort_packet(ctx);
    }

    return packed;
}

/* ******************************************************************************************************************************************************** */
/* Mark Messages Exported                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

int scanner_mark_messages_exported(SCANNER_UPLINK_BATCH *batch)
{
    _kernel_swi_regs regs;
    int i;
    int marked = 0;

    if (batch == NULL)
    {
        return 0;
    }

    for (i = 0; i < batch->message_count; i++)
    {
        SCANNER_MESSAGE *msg = &batch->messages[i];

        regs.r[0] = MSGBASE_CMD_MARK_EXPORTED;
        regs.r[1] = msg->base_id;
        regs.r[2] = msg->message_id;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) == NULL && regs.r[0] == 1)
        {
            marked++;
        }
    }

    return marked;
}

/* ******************************************************************************************************************************************************** */
/* Main Scan Function                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

int scanner_scan_outbound(void)
{
    _kernel_swi_regs regs;
    int b;
    int total_messages = 0;
    int message_ids[SCANNER_MAX_MESSAGES];
    
    /* Global config structure from Support module */
    typedef struct
    {
        int id;
        char name[64];
        char tag[64];
        int areatype;
        int daystokeep;
        int akause;
        int accesslevel;
        char keys[128];
        char groups[64];
    } SCAN_AREA_CFG;

    typedef struct
    {
        int id;
        char name[64];
        int type;
        int accesslevel;
        char keys[128];
        int readonly;
        char path[256];
        int area_count;
        SCAN_AREA_CFG areas[64];
    } SCAN_BASE_CFG;

    typedef struct
    {
        int default_retention;
        int default_accesslevel;
        char storage_root[256];
        int base_count;
        SCAN_BASE_CFG bases[32];
    } SCAN_GLOBAL_CFG;

    SCAN_GLOBAL_CFG *global;

    debug_printf("scanner: Starting outbound scan");
    ftnlog_printf("-- Scanning for outbound mail");

    /* Reset batch storage */
    memset(uplink_batches, 0, sizeof(uplink_batches));
    uplink_batch_count = 0;

    /* Get global config pointer from Support module */
    regs.r[0] = 0;  /* MSGBASE_CONFIG_REASON_GET_GLOBAL */
    if (_kernel_swi(SWI_SUPPORT_MSGBASECONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        debug_printf("scanner: Failed to get messagebase global config");
        return 0;
    }
    global = (SCAN_GLOBAL_CFG *)regs.r[0];

    debug_printf("scanner: Found %d messagebases to scan", global->base_count);

    /* Scan each messagebase by array index */
    for (b = 0; b < global->base_count; b++)
    {
        SCAN_BASE_CFG *base = &global->bases[b];
        int a;

        /* Scan each area by array index */
        for (a = 0; a < base->area_count; a++)
        {
            SCAN_AREA_CFG *area = &base->areas[a];
            int real_base_id = base->id;
            int real_area_id = area->id;
            int msg_count;
            int m;

            scanner_stats.areas_scanned++;

            /* Only scan ECHO and NETMAIL areas */
            if (area->areatype != SCANNER_AREATYPE_ECHO && area->areatype != SCANNER_AREATYPE_NETMAIL)
            {
                continue;
            }

            /* Find unexported messages using REAL IDs */
            msg_count = scanner_find_unexported_messages(real_base_id, real_area_id, message_ids, SCANNER_MAX_MESSAGES);
            if (msg_count <= 0)
            {
                continue;
            }

            debug_printf("scanner: Base %d area %d (%s): %d unexported messages",
                         real_base_id, real_area_id, area->tag, msg_count);

            scanner_stats.messages_found += msg_count;
            total_messages += msg_count;

            /* Process each message */
            for (m = 0; m < msg_count; m++)
            {
                SCANNER_MESSAGE scan_msg;
                FTN_ADDR uplink_addr;
                char password[32] = "";
                unsigned short msg_flags = 0;

                memset(&scan_msg, 0, sizeof(scan_msg));
                scan_msg.base_id = real_base_id;
                scan_msg.area_id = real_area_id;
                scan_msg.message_id = message_ids[m];
                scan_msg.areatype = area->areatype;
                scan_msg.akause = area->akause;
                strncpy(scan_msg.echotag, area->tag, sizeof(scan_msg.echotag) - 1);

                /* Get message flags and determine flavour */
                if (scanner_get_message_flags(real_base_id, message_ids[m], &msg_flags))
                {
                    scan_msg.flags = msg_flags;
                    scan_msg.flavour = scanner_flags_to_flavour(msg_flags);
                }
                else
                {
                    scan_msg.flags = 0;
                    scan_msg.flavour = SCANNER_FLAVOUR_NORMAL;
                }

                if (area->areatype == SCANNER_AREATYPE_ECHO)
                {
                    /* Echomail: send to uplinks with matching groups */
                    FTN_ADDR uplinks[SCANNER_MAX_UPLINKS];
                    int uplink_count;
                    int u;

                    uplink_count = scanner_get_echomail_uplinks(area->groups, uplinks, SCANNER_MAX_UPLINKS);

                    for (u = 0; u < uplink_count; u++)
                    {
                        SCANNER_UPLINK_BATCH *batch;

                        scanner_find_uplink_by_address(&uplinks[u], password, sizeof(password));
                        batch = scanner_get_or_create_batch(&uplinks[u], password);

                        if (batch != NULL)
                        {
                            scanner_add_message_to_batch(batch, &scan_msg);
                        }
                    }

                    /* Also send to subscribed downlinks */
                    {
                        FTN_ADDR downlinks[32];
                        int downlink_count;
                        int d;

                        downlink_count = echofix_get_subscribers(ECHOFIX_TYPE_AREAFIX, area->tag,
                                                                  downlinks, 32);

                        for (d = 0; d < downlink_count; d++)
                        {
                            SCANNER_UPLINK_BATCH *batch;

                            scanner_find_downlink_by_address(&downlinks[d], password, sizeof(password));
                            batch = scanner_get_or_create_batch(&downlinks[d], password);

                            if (batch != NULL)
                            {
                                scanner_add_message_to_batch(batch, &scan_msg);
                            }
                        }
                    }
                }
                else
                {
                    /* Netmail: route to appropriate uplink based on destination address */
                    FTN_ADDR msg_dest;
                    
                    /* Get the actual destination address from the message record using REAL base ID */
                    if (scanner_get_message_dest(real_base_id, message_ids[m], &msg_dest))
                    {
                        scan_msg.dest_addr = msg_dest;
                        
                        if (scanner_route_netmail(&msg_dest, &uplink_addr, password, sizeof(password)))
                        {
                            SCANNER_UPLINK_BATCH *batch = scanner_get_or_create_batch(&uplink_addr, password);

                            if (batch != NULL)
                            {
                                scanner_add_message_to_batch(batch, &scan_msg);
                            }
                        }
                        else
                        {
                            debug_printf("scanner: No route for netmail to %d:%d/%d.%d",
                                         msg_dest.zone, msg_dest.net, msg_dest.node, msg_dest.point);
                        }
                    }
                }
            }
        }
    }

    debug_printf("scanner: Found %d messages for %d uplinks", total_messages, uplink_batch_count);

    /* Create packets for each uplink batch */
    {
        int i;
        for (i = 0; i < uplink_batch_count; i++)
        {
            SCANNER_UPLINK_BATCH *batch = &uplink_batches[i];

            debug_printf("scanner: Creating packet for %d:%d/%d.%d (%d messages)",
                         batch->uplink_addr.zone, batch->uplink_addr.net,
                         batch->uplink_addr.node, batch->uplink_addr.point,
                         batch->message_count);

            if (scanner_create_packets_for_uplink(batch) > 0)
            {
                scanner_mark_messages_exported(batch);
            }
        }
    }

    ftnlog_printf("-- Scan complete: %d messages, %d packets",
                   scanner_stats.messages_packed, scanner_stats.packets_created);

    debug_printf("scanner: Scan complete - %d messages packed, %d packets created",
                 scanner_stats.messages_packed, scanner_stats.packets_created);

    return scanner_stats.messages_packed;
}

/* ******************************************************************************************************************************************************** */
/* Statistics                                                                                                                                               */
/* ******************************************************************************************************************************************************** */

void scanner_get_stats(SCANNER_STATS *stats)
{
    if (stats != NULL)
    {
        *stats = scanner_stats;
    }
}

void scanner_reset_stats(void)
{
    memset(&scanner_stats, 0, sizeof(scanner_stats));
}
