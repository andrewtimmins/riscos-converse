/* ******************************************************************************************************************************************************** */
/* FTN Mailer - TIC File Processor Implementation                                                                                                           */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "tic.h"
#include "mailer.h"
#include "queue.h"
#include "debug.h"
#include "ftnlog.h"

/* ******************************************************************************************************************************************************** */
/* Constants                                                                                                                                                */
/* ******************************************************************************************************************************************************** */

#define TIC_LINE_MAX            512
#define TIC_DEFAULT_INBOUND_PATH "<Converse$Dir>.FTN.Inbound"

/* SWI numbers */
#define SWI_FILER_FILEBASE      0x5AA43
#define SWI_SUPPORT_FILEBASE    0x5AA85

/* Filer filebase commands */
#define FILEBASE_CMD_BEGIN_UPLOAD   3
#define FILEBASE_CMD_UPLOAD_BLOCK   4

/* Support filebase config reasons */
#define FILEBASE_CONFIG_COUNT_BASES 6
#define FILEBASE_CONFIG_COUNT_AREAS 7
#define FILEBASE_CONFIG_GET_BASE    2
#define FILEBASE_CONFIG_GET_AREA    4

/* ******************************************************************************************************************************************************** */
/* Module State                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

static TIC_STATS tic_stats;
static char tic_inbound_path[TIC_MAX_PATH] = TIC_DEFAULT_INBOUND_PATH;

/* CRC-32 lookup table */
static unsigned long crc32_table[256];
static int crc32_table_init = 0;

/* ******************************************************************************************************************************************************** */
/* CRC-32 Implementation                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

static void tic_init_crc32_table(void)
{
    unsigned long crc;
    int i, j;

    for (i = 0; i < 256; i++)
    {
        crc = (unsigned long)i;
        for (j = 0; j < 8; j++)
        {
            if (crc & 1)
            {
                crc = (crc >> 1) ^ 0xEDB88320UL;
            }
            else
            {
                crc = crc >> 1;
            }
        }
        crc32_table[i] = crc;
    }
    crc32_table_init = 1;
}

unsigned long tic_calculate_crc32(const char *file_path)
{
    FILE *f;
    unsigned long crc = 0xFFFFFFFFUL;
    unsigned char buffer[4096];
    size_t bytes_read;
    size_t i;

    if (!crc32_table_init)
    {
        tic_init_crc32_table();
    }

    f = fopen(file_path, "rb");
    if (f == NULL)
    {
        return 0;
    }

    while ((bytes_read = fread(buffer, 1, sizeof(buffer), f)) > 0)
    {
        for (i = 0; i < bytes_read; i++)
        {
            crc = crc32_table[(crc ^ buffer[i]) & 0xFF] ^ (crc >> 8);
        }
    }

    fclose(f);
    return crc ^ 0xFFFFFFFFUL;
}

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

void tic_initialise(void)
{
    memset(&tic_stats, 0, sizeof(tic_stats));
    
    if (!crc32_table_init)
    {
        tic_init_crc32_table();
    }
}

void tic_finalise(void)
{
    /* Nothing to clean up */
}

void tic_set_inbound_path(const char *path)
{
    if (path != NULL && path[0] != '\0')
    {
        strncpy(tic_inbound_path, path, sizeof(tic_inbound_path) - 1);
        tic_inbound_path[sizeof(tic_inbound_path) - 1] = '\0';
    }
    else
    {
        strncpy(tic_inbound_path, TIC_DEFAULT_INBOUND_PATH, sizeof(tic_inbound_path) - 1);
        tic_inbound_path[sizeof(tic_inbound_path) - 1] = '\0';
    }

    debug_printf("tic: Inbound path set to %s", tic_inbound_path);
}

/* ******************************************************************************************************************************************************** */
/* String Utilities                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

/* Trim leading/trailing whitespace */
static char *tic_trim(char *str)
{
    char *end;

    while (isspace((unsigned char)*str))
    {
        str++;
    }

    if (*str == '\0')
    {
        return str;
    }

    end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end))
    {
        end--;
    }

    *(end + 1) = '\0';
    return str;
}

/* Case-insensitive string compare */
static int tic_strcasecmp(const char *s1, const char *s2)
{
    while (*s1 && *s2)
    {
        int c1 = tolower((unsigned char)*s1);
        int c2 = tolower((unsigned char)*s2);
        if (c1 != c2)
        {
            return c1 - c2;
        }
        s1++;
        s2++;
    }
    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

/* ******************************************************************************************************************************************************** */
/* TIC File Parsing                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int tic_parse_file(const char *tic_path, TIC_FILE *tic)
{
    FILE *f;
    char line[TIC_LINE_MAX];
    char *key, *value;

    if (tic_path == NULL || tic == NULL)
    {
        return 0;
    }

    memset(tic, 0, sizeof(TIC_FILE));

    f = fopen(tic_path, "r");
    if (f == NULL)
    {
        debug_printf("tic: Cannot open %s", tic_path);
        return 0;
    }

    while (fgets(line, sizeof(line), f) != NULL)
    {
        /* Parse "keyword value" format */
        key = tic_trim(line);
        
        if (*key == '\0' || *key == ';')
        {
            continue;  /* Empty or comment */
        }

        value = key;
        while (*value && !isspace((unsigned char)*value))
        {
            value++;
        }

        if (*value)
        {
            *value++ = '\0';
            value = tic_trim(value);
        }

        /* Process keywords */
        if (tic_strcasecmp(key, "File") == 0)
        {
            strncpy(tic->filename, value, TIC_MAX_FILENAME - 1);
        }
        else if (tic_strcasecmp(key, "Area") == 0)
        {
            strncpy(tic->area, value, TIC_MAX_AREA - 1);
        }
        else if (tic_strcasecmp(key, "Desc") == 0)
        {
            strncpy(tic->desc, value, TIC_MAX_DESC - 1);
        }
        else if (tic_strcasecmp(key, "Size") == 0)
        {
            tic->size = atol(value);
        }
        else if (tic_strcasecmp(key, "CRC") == 0)
        {
            tic->crc = strtoul(value, NULL, 16);
        }
        else if (tic_strcasecmp(key, "Date") == 0)
        {
            /* Parse date - format varies, often "DD Mon YYYY" or timestamp */
            tic->date = (time_t)atol(value);
        }
        else if (tic_strcasecmp(key, "Origin") == 0)
        {
            ftn_string_to_addr(value, &tic->origin);
        }
        else if (tic_strcasecmp(key, "From") == 0)
        {
            ftn_string_to_addr(value, &tic->from);
        }
        else if (tic_strcasecmp(key, "To") == 0)
        {
            ftn_string_to_addr(value, &tic->to);
        }
        else if (tic_strcasecmp(key, "Pw") == 0 || tic_strcasecmp(key, "Password") == 0)
        {
            strncpy(tic->password, value, TIC_MAX_PASSWORD - 1);
        }
        else if (tic_strcasecmp(key, "Seenby") == 0)
        {
            if (tic->seenby_count < TIC_MAX_SEENBY)
            {
                if (ftn_string_to_addr(value, &tic->seenby[tic->seenby_count]))
                {
                    tic->seenby_count++;
                }
            }
        }
        else if (tic_strcasecmp(key, "Path") == 0)
        {
            if (tic->path_count < TIC_MAX_SEENBY)
            {
                if (ftn_string_to_addr(value, &tic->path[tic->path_count]))
                {
                    tic->path_count++;
                }
            }
        }
    }

    fclose(f);

    /* Validate required fields */
    tic->valid = (tic->filename[0] != '\0' && tic->area[0] != '\0');

    if (tic->valid)
    {
        debug_printf("tic: Parsed %s - file=%s area=%s size=%ld",
                     tic_path, tic->filename, tic->area, tic->size);
    }

    return tic->valid;
}

void tic_free(TIC_FILE *tic)
{
    /* No dynamic allocations currently */
    (void)tic;
}

/* ******************************************************************************************************************************************************** */
/* Area Matching                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

int tic_match_area(const char *area_tag, int *filebase_id, int *filebase_area_id)
{
    _kernel_swi_regs regs;
    int base_count, area_count;
    int b, a;

    /* Area config structure from Support module */
    typedef struct
    {
        int id;
        char name[64];
        char tag[64];
        int accesslevel;
        char keys[128];
    } AREA_CFG;

    /* Base config structure from Support module */
    typedef struct
    {
        int id;
        char name[64];
        int type;
        int accesslevel;
        char keys[128];
        int area_count;
        /* areas follow... */
    } BASE_CFG;

    if (area_tag == NULL || filebase_id == NULL || filebase_area_id == NULL)
    {
        return 0;
    }

    /* Get base count */
    regs.r[0] = FILEBASE_CONFIG_COUNT_BASES;
    if (_kernel_swi(SWI_SUPPORT_FILEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }
    base_count = regs.r[0];

    /* Search all bases for matching area tag */
    for (b = 1; b <= base_count; b++)
    {
        regs.r[0] = FILEBASE_CONFIG_COUNT_AREAS;
        regs.r[1] = b;
        if (_kernel_swi(SWI_SUPPORT_FILEBASE, &regs, &regs) != NULL)
        {
            continue;
        }
        area_count = regs.r[0];

        for (a = 1; a <= area_count; a++)
        {
            AREA_CFG *area;

            regs.r[0] = FILEBASE_CONFIG_GET_AREA;
            regs.r[1] = b;
            regs.r[2] = a;
            if (_kernel_swi(SWI_SUPPORT_FILEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
            {
                continue;
            }

            area = (AREA_CFG *)regs.r[0];

            /* Compare tags case-insensitively */
            if (tic_strcasecmp(area->tag, area_tag) == 0)
            {
                *filebase_id = b;
                *filebase_area_id = a;
                debug_printf("tic: Matched area %s to filebase %d area %d",
                             area_tag, b, a);
                return 1;
            }
        }
    }

    debug_printf("tic: No match for area %s", area_tag);
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* File Storage                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

int tic_store_file(const TIC_FILE *tic, const char *file_path)
{
    _kernel_swi_regs regs;
    int filebase_id, area_id;
    int file_id;
    FILE *f;
    unsigned char buffer[4096];
    size_t bytes_read;

    /* FILE_RECORD structure matching Filer module */
    typedef struct
    {
        int id;
        int filebaseid;
        int filebaseareaid;
        int deleted;
        int accesslevel;
        char keys[128];
        char name[64];
        char description[256];
        int uploadedby;
        time_t uploaddate;
        long filesize;
        int downloads;
    } FILE_REC;

    FILE_REC record;

    if (tic == NULL || file_path == NULL)
    {
        return 0;
    }

    /* Match area tag to filebase */
    if (!tic_match_area(tic->area, &filebase_id, &area_id))
    {
        debug_printf("tic: Unknown area %s, cannot store file", tic->area);
        return 0;
    }

    /* Build file record */
    memset(&record, 0, sizeof(record));
    record.filebaseid = filebase_id;
    record.filebaseareaid = area_id;
    record.deleted = 0;
    record.accesslevel = 0;
    strncpy(record.name, tic->filename, sizeof(record.name) - 1);
    strncpy(record.description, tic->desc, sizeof(record.description) - 1);
    record.uploadedby = 0;  /* System upload */
    record.uploaddate = time(NULL);
    record.filesize = tic->size;
    record.downloads = 0;

    /* Begin upload via Filer SWI */
    regs.r[0] = FILEBASE_CMD_BEGIN_UPLOAD;
    regs.r[1] = filebase_id;
    regs.r[2] = (int)&record;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] <= 0)
    {
        debug_printf("tic: Failed to begin file upload");
        return 0;
    }

    file_id = regs.r[0];

    /* Upload file content */
    f = fopen(file_path, "rb");
    if (f == NULL)
    {
        debug_printf("tic: Cannot open file %s for upload", file_path);
        return 0;
    }

    while ((bytes_read = fread(buffer, 1, sizeof(buffer), f)) > 0)
    {
        regs.r[0] = FILEBASE_CMD_UPLOAD_BLOCK;
        regs.r[1] = filebase_id;
        regs.r[2] = file_id;
        regs.r[3] = (int)buffer;
        regs.r[4] = (int)bytes_read;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            debug_printf("tic: Failed to upload file block");
            fclose(f);
            return 0;
        }
    }

    fclose(f);

    debug_printf("tic: Stored file %s in filebase %d area %d as file %d",
                 tic->filename, filebase_id, area_id, file_id);

    tic_stats.files_received++;
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* TIC File Creation                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

int tic_write_file(const TIC_FILE *tic, const char *tic_path)
{
    FILE *f;
    int i;
    char addr_str[32];

    if (tic == NULL || tic_path == NULL)
    {
        return 0;
    }

    f = fopen(tic_path, "w");
    if (f == NULL)
    {
        debug_printf("tic: Cannot create %s", tic_path);
        return 0;
    }

    /* Write required fields */
    fprintf(f, "File %s\n", tic->filename);
    fprintf(f, "Area %s\n", tic->area);
    
    if (tic->desc[0] != '\0')
    {
        fprintf(f, "Desc %s\n", tic->desc);
    }

    if (tic->size > 0)
    {
        fprintf(f, "Size %ld\n", tic->size);
    }

    if (tic->crc != 0)
    {
        fprintf(f, "CRC %08lX\n", tic->crc);
    }

    if (tic->date != 0)
    {
        fprintf(f, "Date %ld\n", (long)tic->date);
    }

    /* Origin */
    if (tic->origin.zone != 0)
    {
        ftn_addr_to_string(&tic->origin, addr_str, sizeof(addr_str));
        fprintf(f, "Origin %s\n", addr_str);
    }

    /* From/To */
    if (tic->from.zone != 0)
    {
        ftn_addr_to_string(&tic->from, addr_str, sizeof(addr_str));
        fprintf(f, "From %s\n", addr_str);
    }

    if (tic->to.zone != 0)
    {
        ftn_addr_to_string(&tic->to, addr_str, sizeof(addr_str));
        fprintf(f, "To %s\n", addr_str);
    }

    /* Password if set */
    if (tic->password[0] != '\0')
    {
        fprintf(f, "Pw %s\n", tic->password);
    }

    /* SEENBY lines */
    for (i = 0; i < tic->seenby_count; i++)
    {
        ftn_addr_to_string(&tic->seenby[i], addr_str, sizeof(addr_str));
        fprintf(f, "Seenby %s\n", addr_str);
    }

    /* PATH lines */
    for (i = 0; i < tic->path_count; i++)
    {
        ftn_addr_to_string(&tic->path[i], addr_str, sizeof(addr_str));
        fprintf(f, "Path %s\n", addr_str);
    }

    fclose(f);

    debug_printf("tic: Created TIC file %s", tic_path);
    tic_stats.tics_created++;
    return 1;
}

int tic_create_for_file(int filebase_id, int file_id, const char *area_tag,
                        const FTN_ADDR *dest, const char *password)
{
    /* TODO: Implement - needs to read file info from Filer and create TIC */
    /* This would be called when scanning for files to forward */
    
    (void)filebase_id;
    (void)file_id;
    (void)area_tag;
    (void)dest;
    (void)password;
    
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Inbound Processing                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

int tic_process_single(const char *tic_path, const char *file_path)
{
    TIC_FILE tic;

    if (!tic_parse_file(tic_path, &tic))
    {
        tic_stats.tics_bad++;
        return 0;
    }

    tic_stats.tics_processed++;

    /* Verify CRC if specified */
    if (tic.crc != 0)
    {
        unsigned long actual_crc = tic_calculate_crc32(file_path);
        if (actual_crc != tic.crc)
        {
            debug_printf("tic: CRC mismatch for %s (expected %08lX, got %08lX)",
                         tic.filename, tic.crc, actual_crc);
            ftnlog_printf("TIC CRC mismatch: %s", tic.filename);
            tic_stats.tics_bad++;
            tic_free(&tic);
            return 0;
        }
    }

    /* Store the file */
    if (tic_store_file(&tic, file_path))
    {
        tic_stats.tics_good++;
        ftnlog_printf("Received file: %s -> %s", tic.filename, tic.area);
        tic_free(&tic);
        return 1;
    }

    tic_stats.tics_bad++;
    tic_free(&tic);
    return 0;
}

typedef struct
{
    int count;
} TIC_INBOUND_CONTEXT;

static void tic_process_zone_directory(const char *zone_path, int zone, void *ctx)
{
    _kernel_swi_regs regs;
    char buffer[256];
    char tic_path[TIC_MAX_PATH];
    char file_path[TIC_MAX_PATH];
    int context = 0;
    TIC_INBOUND_CONTEXT *scan = (TIC_INBOUND_CONTEXT *)ctx;

    debug_printf("tic: Processing inbound TIC zone %d from %s", zone, zone_path);

    do
    {
        regs.r[0] = 12;  /* OS_GBPB reason 12: read directory entries with info */
        regs.r[1] = (int)zone_path;
        regs.r[2] = (int)buffer;
        regs.r[3] = 1;
        regs.r[4] = context;
        regs.r[5] = sizeof(buffer);
        regs.r[6] = (int)"*tic";  /* Match *tic files */

        if (_kernel_swi(0x0C, &regs, &regs) != NULL)
        {
            break;
        }

        context = regs.r[4];

        if (regs.r[3] > 0)
        {
            /* Found a TIC file */
            TIC_FILE tic;
            char *name = buffer + 20;  /* Filename starts at offset 20 */

            snprintf(tic_path, sizeof(tic_path), "%s.%s", zone_path, name);

            if (tic_parse_file(tic_path, &tic))
            {
                snprintf(file_path, sizeof(file_path), "%s.%s", zone_path, tic.filename);

                if (tic_process_single(tic_path, file_path))
                {
                    scan->count++;
                    /* TODO: Move processed files to processed folder */
                }

                tic_free(&tic);
            }
        }
    } while (context != -1 && regs.r[3] > 0);
}

int tic_process_inbound(void)
{
    TIC_INBOUND_CONTEXT scan;

    scan.count = 0;

    debug_printf("tic: Processing inbound TIC files from %s", tic_inbound_path);

    ftn_enumerate_zone_directories(tic_inbound_path, tic_process_zone_directory, &scan);

    debug_printf("tic: Processed %d TIC files", scan.count);
    return scan.count;
}

/* ******************************************************************************************************************************************************** */
/* Statistics                                                                                                                                               */
/* ******************************************************************************************************************************************************** */

void tic_get_stats(TIC_STATS *stats)
{
    if (stats != NULL)
    {
        *stats = tic_stats;
    }
}

void tic_reset_stats(void)
{
    memset(&tic_stats, 0, sizeof(tic_stats));
}
