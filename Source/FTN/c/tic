/* ******************************************************************************************************************************************************** */
/* FTN Mailer - TIC File Processor Implementation                                                                                                           */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "tic.h"
#include "mailer.h"
#include "queue.h"
#include "echofix.h"
#include "debug.h"
#include "ftnlog.h"

/* ******************************************************************************************************************************************************** */
/* Constants                                                                                                                                                */
/* ******************************************************************************************************************************************************** */

#define TIC_LINE_MAX            512
#define TIC_DEFAULT_INBOUND_PATH "<Converse$Dir>.FTN.Inbound"

/* SWI numbers */
#define SWI_FILER_FILEBASE      0x5AA43
#define SWI_SUPPORT_FILEBASE    0x5AA85

/* Filer filebase commands */
#define FILEBASE_CMD_BEGIN_UPLOAD   3
#define FILEBASE_CMD_UPLOAD_BLOCK   4

/* Support filebase config reasons */
#define FILEBASE_CONFIG_COUNT_BASES 6
#define FILEBASE_CONFIG_COUNT_AREAS 7
#define FILEBASE_CONFIG_GET_BASE    2
#define FILEBASE_CONFIG_GET_AREA    4

/* ******************************************************************************************************************************************************** */
/* Module State                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

static TIC_STATS tic_stats;
static char tic_inbound_path[TIC_MAX_PATH] = TIC_DEFAULT_INBOUND_PATH;

/* CRC-32 lookup table */
static unsigned long crc32_table[256];
static int crc32_table_init = 0;

/* ******************************************************************************************************************************************************** */
/* CRC-32 Implementation                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

static void tic_init_crc32_table(void)
{
    unsigned long crc;
    int i, j;

    for (i = 0; i < 256; i++)
    {
        crc = (unsigned long)i;
        for (j = 0; j < 8; j++)
        {
            if (crc & 1)
            {
                crc = (crc >> 1) ^ 0xEDB88320UL;
            }
            else
            {
                crc = crc >> 1;
            }
        }
        crc32_table[i] = crc;
    }
    crc32_table_init = 1;
}

unsigned long tic_calculate_crc32(const char *file_path)
{
    FILE *f;
    unsigned long crc = 0xFFFFFFFFUL;
    unsigned char buffer[4096];
    size_t bytes_read;
    size_t i;

    if (!crc32_table_init)
    {
        tic_init_crc32_table();
    }

    f = fopen(file_path, "rb");
    if (f == NULL)
    {
        return 0;
    }

    while ((bytes_read = fread(buffer, 1, sizeof(buffer), f)) > 0)
    {
        for (i = 0; i < bytes_read; i++)
        {
            crc = crc32_table[(crc ^ buffer[i]) & 0xFF] ^ (crc >> 8);
        }
    }

    fclose(f);
    return crc ^ 0xFFFFFFFFUL;
}

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

void tic_initialise(void)
{
    memset(&tic_stats, 0, sizeof(tic_stats));
    
    if (!crc32_table_init)
    {
        tic_init_crc32_table();
    }
}

void tic_finalise(void)
{
    /* Nothing to clean up */
}

/* Convert DOS/FTN filename to RISC OS format by removing dots */
static void tic_filename_to_riscos(const char *src, char *dest, size_t dest_size)
{
    size_t i, j;

    if (src == NULL || dest == NULL || dest_size == 0)
    {
        return;
    }

    j = 0;
    for (i = 0; src[i] != '\0' && j < dest_size - 1; i++)
    {
        if (src[i] != '.')
        {
            dest[j++] = src[i];
        }
    }
    dest[j] = '\0';
}

void tic_set_inbound_path(const char *path)
{
    if (path != NULL && path[0] != '\0')
    {
        strncpy(tic_inbound_path, path, sizeof(tic_inbound_path) - 1);
        tic_inbound_path[sizeof(tic_inbound_path) - 1] = '\0';
    }
    else
    {
        strncpy(tic_inbound_path, TIC_DEFAULT_INBOUND_PATH, sizeof(tic_inbound_path) - 1);
        tic_inbound_path[sizeof(tic_inbound_path) - 1] = '\0';
    }

    debug_printf("tic: Inbound path set to %s", tic_inbound_path);
}

/* ******************************************************************************************************************************************************** */
/* String Utilities                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

/* Trim leading/trailing whitespace */
static char *tic_trim(char *str)
{
    char *end;

    while (isspace((unsigned char)*str))
    {
        str++;
    }

    if (*str == '\0')
    {
        return str;
    }

    end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end))
    {
        end--;
    }

    *(end + 1) = '\0';
    return str;
}

/* Case-insensitive string compare */
static int tic_strcasecmp(const char *s1, const char *s2)
{
    while (*s1 && *s2)
    {
        int c1 = tolower((unsigned char)*s1);
        int c2 = tolower((unsigned char)*s2);
        if (c1 != c2)
        {
            return c1 - c2;
        }
        s1++;
        s2++;
    }
    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

/* ******************************************************************************************************************************************************** */
/* File Move Operations                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/*
 * Move a file to a new location using OS_FSControl 25 (rename).
 * Returns 1 on success, 0 on failure.
 */
static int tic_move_file(const char *src, const char *dest)
{
    _kernel_swi_regs regs;

    regs.r[0] = 25;  /* Rename object */
    regs.r[1] = (int)src;
    regs.r[2] = (int)dest;

    if (_kernel_swi(0x29, &regs, &regs) != NULL)  /* OS_FSControl */
    {
        debug_printf("tic: Failed to move %s to %s", src, dest);
        return 0;
    }

    debug_printf("tic: Moved %s to %s", src, dest);
    return 1;
}

/*
 * Move TIC file and its associated data file to Processed folder.
 * zone_path: Base zone directory (e.g., "<Converse$Dir>.FTN.Inbound.002")
 * tic_name: Name of the TIC file
 * file_name: Name of the data file
 */
static void tic_move_to_processed(const char *zone_path, const char *tic_name, const char *file_name)
{
    char src_tic[TIC_MAX_PATH];
    char src_file[TIC_MAX_PATH];
    char dest_tic[TIC_MAX_PATH];
    char dest_file[TIC_MAX_PATH];

    snprintf(src_tic, sizeof(src_tic), "%s.%s", zone_path, tic_name);
    snprintf(src_file, sizeof(src_file), "%s.%s", zone_path, file_name);
    snprintf(dest_tic, sizeof(dest_tic), "%s.Processed.%s", zone_path, tic_name);
    snprintf(dest_file, sizeof(dest_file), "%s.Processed.%s", zone_path, file_name);

    tic_move_file(src_tic, dest_tic);
    tic_move_file(src_file, dest_file);

    ftnlog_printf("TIC moved to Processed: %s, %s", tic_name, file_name);
}

/*
 * Move TIC file and its associated data file to Bad folder.
 * zone_path: Base zone directory (e.g., "<Converse$Dir>.FTN.Inbound.002")
 * tic_name: Name of the TIC file
 * file_name: Name of the data file (may be NULL if file doesn't exist)
 */
static void tic_move_to_bad(const char *zone_path, const char *tic_name, const char *file_name)
{
    char src_tic[TIC_MAX_PATH];
    char dest_tic[TIC_MAX_PATH];

    snprintf(src_tic, sizeof(src_tic), "%s.%s", zone_path, tic_name);
    snprintf(dest_tic, sizeof(dest_tic), "%s.Bad.%s", zone_path, tic_name);

    tic_move_file(src_tic, dest_tic);

    if (file_name != NULL && file_name[0] != '\0')
    {
        char src_file[TIC_MAX_PATH];
        char dest_file[TIC_MAX_PATH];

        snprintf(src_file, sizeof(src_file), "%s.%s", zone_path, file_name);
        snprintf(dest_file, sizeof(dest_file), "%s.Bad.%s", zone_path, file_name);

        tic_move_file(src_file, dest_file);
    }

    ftnlog_printf("TIC moved to Bad: %s", tic_name);
}

/* ******************************************************************************************************************************************************** */
/* TIC File Parsing                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int tic_parse_file(const char *tic_path, TIC_FILE *tic)
{
    FILE *f;
    char line[TIC_LINE_MAX];
    char *key, *value;

    if (tic_path == NULL || tic == NULL)
    {
        return 0;
    }

    memset(tic, 0, sizeof(TIC_FILE));

    f = fopen(tic_path, "r");
    if (f == NULL)
    {
        debug_printf("tic: Cannot open %s", tic_path);
        return 0;
    }

    while (fgets(line, sizeof(line), f) != NULL)
    {
        /* Parse "keyword value" format */
        key = tic_trim(line);
        
        if (*key == '\0' || *key == ';')
        {
            continue;  /* Empty or comment */
        }

        value = key;
        while (*value && !isspace((unsigned char)*value))
        {
            value++;
        }

        if (*value)
        {
            *value++ = '\0';
            value = tic_trim(value);
        }

        /* Process keywords */
        if (tic_strcasecmp(key, "File") == 0)
        {
            strncpy(tic->filename, value, TIC_MAX_FILENAME - 1);
        }
        else if (tic_strcasecmp(key, "Area") == 0)
        {
            strncpy(tic->area, value, TIC_MAX_AREA - 1);
        }
        else if (tic_strcasecmp(key, "Desc") == 0)
        {
            strncpy(tic->desc, value, TIC_MAX_DESC - 1);
        }
        else if (tic_strcasecmp(key, "Size") == 0)
        {
            tic->size = atol(value);
        }
        else if (tic_strcasecmp(key, "CRC") == 0)
        {
            tic->crc = strtoul(value, NULL, 16);
        }
        else if (tic_strcasecmp(key, "Date") == 0)
        {
            /* Parse date - format varies, often "DD Mon YYYY" or timestamp */
            tic->date = (time_t)atol(value);
        }
        else if (tic_strcasecmp(key, "Origin") == 0)
        {
            ftn_string_to_addr(value, &tic->origin);
        }
        else if (tic_strcasecmp(key, "From") == 0)
        {
            ftn_string_to_addr(value, &tic->from);
        }
        else if (tic_strcasecmp(key, "To") == 0)
        {
            ftn_string_to_addr(value, &tic->to);
        }
        else if (tic_strcasecmp(key, "Pw") == 0 || tic_strcasecmp(key, "Password") == 0)
        {
            strncpy(tic->password, value, TIC_MAX_PASSWORD - 1);
        }
        else if (tic_strcasecmp(key, "Seenby") == 0)
        {
            if (tic->seenby_count < TIC_MAX_SEENBY)
            {
                if (ftn_string_to_addr(value, &tic->seenby[tic->seenby_count]))
                {
                    tic->seenby_count++;
                }
            }
        }
        else if (tic_strcasecmp(key, "Path") == 0)
        {
            if (tic->path_count < TIC_MAX_SEENBY)
            {
                if (ftn_string_to_addr(value, &tic->path[tic->path_count]))
                {
                    tic->path_count++;
                }
            }
        }
    }

    fclose(f);

    /* Validate required fields */
    tic->valid = (tic->filename[0] != '\0' && tic->area[0] != '\0');

    if (tic->valid)
    {
        debug_printf("tic: Parsed %s - file=%s area=%s size=%ld",
                     tic_path, tic->filename, tic->area, tic->size);
    }

    return tic->valid;
}

void tic_free(TIC_FILE *tic)
{
    /* No dynamic allocations currently */
    (void)tic;
}

/* ******************************************************************************************************************************************************** */
/* Area Matching                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

int tic_match_area(const char *area_tag, int *filebase_id, int *filebase_area_id)
{
    _kernel_swi_regs regs;
    int base_count;
    int b;

    /* Global config structure from Support module */
    typedef struct
    {
        int id;
        char name[64];
        char tag[64];
        int accesslevel;
        char keys[128];
        char path[256];
    } AREA_CFG;

    typedef struct
    {
        int id;
        char name[64];
        int type;
        int accesslevel;
        char keys[128];
        int readonly;
        char path[256];
        int area_count;
        AREA_CFG areas[64];
    } BASE_CFG;

    typedef struct
    {
        int default_accesslevel;
        char storage_root[256];
        long max_upload_size;
        int base_count;
        BASE_CFG bases[32];
    } GLOBAL_CFG;

    if (area_tag == NULL || filebase_id == NULL || filebase_area_id == NULL)
    {
        return 0;
    }

    /* Get global config pointer */
    regs.r[0] = 0;  /* FILEBASE_CONFIG_REASON_GET_GLOBAL */
    if (_kernel_swi(SWI_SUPPORT_FILEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        debug_printf("tic: Cannot get filebase global config");
        return 0;
    }

    {
        GLOBAL_CFG *global = (GLOBAL_CFG *)regs.r[0];
        base_count = global->base_count;

        debug_printf("tic: Searching %d filebases for area tag '%s'", base_count, area_tag);

        /* Search all bases for matching area tag */
        for (b = 0; b < base_count; b++)
        {
            BASE_CFG *base = &global->bases[b];
            int a;

            debug_printf("tic: Filebase %d '%s' has %d areas", 
                         base->id, base->name, base->area_count);

            for (a = 0; a < base->area_count; a++)
            {
                AREA_CFG *area = &base->areas[a];

                if (area->tag[0] != '\0')
                {
                    debug_printf("tic: Checking area %d tag '%s'", area->id, area->tag);
                }

                /* Compare tags case-insensitively */
                if (area->tag[0] != '\0' && tic_strcasecmp(area->tag, area_tag) == 0)
                {
                    *filebase_id = base->id;
                    *filebase_area_id = area->id;
                    debug_printf("tic: Matched area %s to filebase %d area %d",
                                 area_tag, base->id, area->id);
                    return 1;
                }
            }
        }
    }

    debug_printf("tic: No match for area %s", area_tag);
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* File Storage                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

int tic_store_file(const TIC_FILE *tic, const char *file_path)
{
    _kernel_swi_regs regs;
    int filebase_id, area_id;
    int file_id;
    FILE *f;
    unsigned char buffer[4096];
    size_t bytes_read;

    /* FILE_RECORD structure matching Filer module */
    typedef struct
    {
        int id;
        int filebaseid;
        int filebaseareaid;
        int deleted;
        int accesslevel;
        char keys[128];
        char name[64];
        char description[256];
        int uploadedby;
        time_t uploaddate;
        long filesize;
        int downloads;
    } FILE_REC;

    FILE_REC record;

    if (tic == NULL || file_path == NULL)
    {
        return 0;
    }

    /* Match area tag to filebase */
    if (!tic_match_area(tic->area, &filebase_id, &area_id))
    {
        debug_printf("tic: Unknown area %s, cannot store file", tic->area);
        return 0;
    }

    /* Build file record */
    memset(&record, 0, sizeof(record));
    record.filebaseid = filebase_id;
    record.filebaseareaid = area_id;
    record.deleted = 0;
    record.accesslevel = 0;
    strncpy(record.name, tic->filename, sizeof(record.name) - 1);
    strncpy(record.description, tic->desc, sizeof(record.description) - 1);
    record.uploadedby = 0;  /* System upload */
    record.uploaddate = time(NULL);
    record.filesize = tic->size;
    record.downloads = 0;

    /* Begin upload via Filer SWI */
    regs.r[0] = FILEBASE_CMD_BEGIN_UPLOAD;
    regs.r[1] = filebase_id;
    regs.r[2] = (int)&record;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] <= 0)
    {
        debug_printf("tic: Failed to begin file upload");
        return 0;
    }

    file_id = regs.r[0];

    /* Upload file content */
    f = fopen(file_path, "rb");
    if (f == NULL)
    {
        debug_printf("tic: Cannot open file %s for upload", file_path);
        return 0;
    }

    while ((bytes_read = fread(buffer, 1, sizeof(buffer), f)) > 0)
    {
        regs.r[0] = FILEBASE_CMD_UPLOAD_BLOCK;
        regs.r[1] = filebase_id;
        regs.r[2] = file_id;
        regs.r[3] = (int)buffer;
        regs.r[4] = (int)bytes_read;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            debug_printf("tic: Failed to upload file block");
            fclose(f);
            return 0;
        }
    }

    fclose(f);

    debug_printf("tic: Stored file %s in filebase %d area %d as file %d",
                 tic->filename, filebase_id, area_id, file_id);

    tic_stats.files_received++;
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* TIC File Creation                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

int tic_write_file(const TIC_FILE *tic, const char *tic_path)
{
    FILE *f;
    int i;
    char addr_str[32];

    if (tic == NULL || tic_path == NULL)
    {
        return 0;
    }

    f = fopen(tic_path, "w");
    if (f == NULL)
    {
        debug_printf("tic: Cannot create %s", tic_path);
        return 0;
    }

    /* Write required fields */
    fprintf(f, "File %s\n", tic->filename);
    fprintf(f, "Area %s\n", tic->area);
    
    if (tic->desc[0] != '\0')
    {
        fprintf(f, "Desc %s\n", tic->desc);
    }

    if (tic->size > 0)
    {
        fprintf(f, "Size %ld\n", tic->size);
    }

    if (tic->crc != 0)
    {
        fprintf(f, "CRC %08lX\n", tic->crc);
    }

    if (tic->date != 0)
    {
        fprintf(f, "Date %ld\n", (long)tic->date);
    }

    /* Origin */
    if (tic->origin.zone != 0)
    {
        ftn_addr_to_string(&tic->origin, addr_str, sizeof(addr_str));
        fprintf(f, "Origin %s\n", addr_str);
    }

    /* From/To */
    if (tic->from.zone != 0)
    {
        ftn_addr_to_string(&tic->from, addr_str, sizeof(addr_str));
        fprintf(f, "From %s\n", addr_str);
    }

    if (tic->to.zone != 0)
    {
        ftn_addr_to_string(&tic->to, addr_str, sizeof(addr_str));
        fprintf(f, "To %s\n", addr_str);
    }

    /* Password if set */
    if (tic->password[0] != '\0')
    {
        fprintf(f, "Pw %s\n", tic->password);
    }

    /* SEENBY lines */
    for (i = 0; i < tic->seenby_count; i++)
    {
        ftn_addr_to_string(&tic->seenby[i], addr_str, sizeof(addr_str));
        fprintf(f, "Seenby %s\n", addr_str);
    }

    /* PATH lines */
    for (i = 0; i < tic->path_count; i++)
    {
        ftn_addr_to_string(&tic->path[i], addr_str, sizeof(addr_str));
        fprintf(f, "Path %s\n", addr_str);
    }

    fclose(f);

    debug_printf("tic: Created TIC file %s", tic_path);
    tic_stats.tics_created++;
    return 1;
}

/* Filer FILE_RECORD structure - must match Filer/h/structs */
typedef struct
{
    int id;
    int filebaseid;
    int filebaseareaid;
    int deleted;
    int accesslevel;
    char keys[128];
    char name[64];
    int uploadedby;
    int uploaddate;
    char description[256];
    long filesize;
    int downloads;
} TIC_FILE_RECORD;

#define FILEBASE_CMD_FILE_INFO      11
#define FILEBASE_CMD_DOWNLOAD_BLOCK 5

int tic_create_for_file(int filebase_id, int file_id, const char *area_tag,
                        const FTN_ADDR *dest, const char *password)
{
    _kernel_swi_regs regs;
    TIC_FILE_RECORD *file_rec;
    TIC_FILE tic;
    char tic_path[TIC_MAX_PATH];
    char file_path[TIC_MAX_PATH];
    int zone;
    
    if (area_tag == NULL || dest == NULL)
    {
        return 0;
    }
    
    /* Get file info from Filer */
    regs.r[0] = FILEBASE_CMD_FILE_INFO;
    regs.r[1] = filebase_id;
    regs.r[2] = file_id;
    
    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
    {
        debug_printf("tic: Cannot get file info for filebase %d file %d", 
                     filebase_id, file_id);
        return 0;
    }
    
    file_rec = (TIC_FILE_RECORD *)regs.r[0];
    
    /* Check file not deleted */
    if (file_rec->deleted)
    {
        debug_printf("tic: File %d in filebase %d is deleted", file_id, filebase_id);
        return 0;
    }
    
    /* Build the filesystem path to the file */
    {
        int group = (file_id - 1) / 60;
        if (file_rec->filebaseareaid > 0)
        {
            snprintf(file_path, sizeof(file_path),
                     "<Converse$Dir>.FileBases.%d.Files.A%d.G%02d.%d",
                     filebase_id, file_rec->filebaseareaid, group, file_id);
        }
        else
        {
            snprintf(file_path, sizeof(file_path),
                     "<Converse$Dir>.FileBases.%d.Files.G%02d.%d",
                     filebase_id, group, file_id);
        }
    }
    
    /* Initialise TIC structure */
    memset(&tic, 0, sizeof(tic));
    
    strncpy(tic.filename, file_rec->name, sizeof(tic.filename) - 1);
    strncpy(tic.area, area_tag, sizeof(tic.area) - 1);
    strncpy(tic.desc, file_rec->description, sizeof(tic.desc) - 1);
    tic.size = file_rec->filesize;
    tic.date = (time_t)file_rec->uploaddate;
    
    /* Calculate CRC-32 of the file */
    tic.crc = tic_calculate_crc32(file_path);
    
    /* Set origin from our primary address */
    if (mailer.our_addr_count > 0)
    {
        tic.origin = mailer.our_addrs[0];
        tic.from = mailer.our_addrs[0];
    }
    
    /* Set destination */
    tic.to = *dest;
    
    /* Add ourselves to SEENBY */
    if (mailer.our_addr_count > 0 && tic.seenby_count < TIC_MAX_SEENBY)
    {
        tic.seenby[tic.seenby_count++] = mailer.our_addrs[0];
    }
    
    /* Add ourselves to PATH */
    if (mailer.our_addr_count > 0 && tic.path_count < TIC_MAX_SEENBY)
    {
        tic.path[tic.path_count++] = mailer.our_addrs[0];
    }
    
    /* Set password if provided */
    if (password != NULL && password[0] != '\0')
    {
        strncpy(tic.password, password, sizeof(tic.password) - 1);
    }
    
    tic.valid = 1;
    
    /* Build TIC filename - use file ID and random component */
    zone = dest->zone > 0 ? dest->zone : 2;
    snprintf(tic_path, sizeof(tic_path),
             "<Converse$Dir>.FTN.Outbound.%d.%08X.tic",
             zone, (unsigned int)(file_id * 65536 + (rand() & 0xFFFF)));
    
    /* Write TIC file */
    if (!tic_write_file(&tic, tic_path))
    {
        debug_printf("tic: Failed to write TIC file %s", tic_path);
        return 0;
    }
    
    /* Get or create queue node for destination */
    {
        QUEUE_NODE *node = queue_find_node(dest);
        if (node == NULL)
        {
            node = queue_add_node(dest);
        }
        if (node == NULL)
        {
            debug_printf("tic: Cannot create queue node for destination");
            return 0;
        }
        
        /* Queue the associated file for sending */
        if (!queue_add_file(node, file_path, QUEUE_FILE_ATTACH, QUEUE_FLAVOUR_NORMAL))
        {
            debug_printf("tic: Failed to queue file %s", file_path);
            return 0;
        }
        
        /* Queue the TIC file itself */
        if (!queue_add_file(node, tic_path, QUEUE_FILE_ATTACH, QUEUE_FLAVOUR_NORMAL))
        {
            debug_printf("tic: Failed to queue TIC file %s", tic_path);
            return 0;
        }
    }
    
    debug_printf("tic: Created TIC for %s to %d:%d/%d.%d",
                 file_rec->name, dest->zone, dest->net, dest->node, dest->point);
    
    ftnlog_printf("Created TIC: %s -> %s (%d:%d/%d.%d)",
                  file_rec->name, area_tag, 
                  dest->zone, dest->net, dest->node, dest->point);
    
    tic_stats.tics_created++;
    tic_stats.files_forwarded++;
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Forwarding to Subscribers                                                                                                                                */
/* ******************************************************************************************************************************************************** */

/* SWI definitions for downlink access */
#define SWI_SUPPORT_FTN             0x5AA86
#define FTN_CONFIG_GET_DOWNLINK     8
#define FTN_CONFIG_COUNT_DOWNLINKS  10

/* Downlink config structure (must match Support module) */
typedef struct
{
    int id;
    char address[64];
    char name[64];
    char password[32];
    char areafix_password[32];
    char filefix_password[32];
    char allowed_groups[64];
    char allowed_echoes[256];
    char allowed_files[256];
    int max_echoes;
    int max_files;
} TIC_DOWNLINK_CFG;

int tic_forward_to_subscribers(int filebase_id, int file_id, const char *area_tag)
{
    FTN_ADDR subscribers[32];
    int subscriber_count;
    int i;
    int forwarded = 0;

    if (area_tag == NULL || area_tag[0] == '\0')
    {
        debug_printf("tic_forward_to_subscribers: No area tag specified");
        return 0;
    }

    /* Get all FileFix subscribers for this area */
    subscriber_count = echofix_get_subscribers(ECHOFIX_TYPE_FILEFIX, area_tag,
                                                subscribers, 32);

    if (subscriber_count == 0)
    {
        debug_printf("tic: No subscribers for fileecho %s", area_tag);
        return 0;
    }

    debug_printf("tic: Forwarding file %d to %d subscribers for %s",
                 file_id, subscriber_count, area_tag);

    /* Create TIC for each subscriber */
    for (i = 0; i < subscriber_count; i++)
    {
        _kernel_swi_regs regs;
        char password[32] = "";
        int count;
        int d;

        /* Find the password for this downlink */
        regs.r[0] = FTN_CONFIG_COUNT_DOWNLINKS;
        if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) == NULL)
        {
            count = regs.r[0];
            
            for (d = 0; d < count; d++)
            {
                regs.r[0] = FTN_CONFIG_GET_DOWNLINK;
                regs.r[1] = d + 1;
                if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) == NULL && regs.r[0] != 0)
                {
                    TIC_DOWNLINK_CFG *dl = (TIC_DOWNLINK_CFG *)regs.r[0];
                    FTN_ADDR dl_addr;
                    
                    if (ftn_string_to_addr(dl->address, &dl_addr))
                    {
                        if (ftn_addr_match(&subscribers[i], &dl_addr))
                        {
                            strncpy(password, dl->filefix_password, sizeof(password) - 1);
                            break;
                        }
                    }
                }
            }
        }

        if (tic_create_for_file(filebase_id, file_id, area_tag, 
                                &subscribers[i], password))
        {
            forwarded++;
        }
    }

    if (forwarded > 0)
    {
        ftnlog_printf("Forwarded file to %d/%d subscribers for %s",
                      forwarded, subscriber_count, area_tag);
    }

    return forwarded;
}

/* ******************************************************************************************************************************************************** */
/* Inbound Processing                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

int tic_process_single(const char *tic_path, const char *file_path)
{
    TIC_FILE tic;

    if (!tic_parse_file(tic_path, &tic))
    {
        tic_stats.tics_bad++;
        return 0;
    }

    tic_stats.tics_processed++;

    /* Verify CRC if specified */
    if (tic.crc != 0)
    {
        unsigned long actual_crc = tic_calculate_crc32(file_path);
        if (actual_crc != tic.crc)
        {
            debug_printf("tic: CRC mismatch for %s (expected %08lX, got %08lX)",
                         tic.filename, tic.crc, actual_crc);
            ftnlog_printf("TIC CRC mismatch: %s", tic.filename);
            tic_stats.tics_bad++;
            tic_free(&tic);
            return 0;
        }
    }

    /* Store the file */
    if (tic_store_file(&tic, file_path))
    {
        tic_stats.tics_good++;
        ftnlog_printf("Received file: %s -> %s", tic.filename, tic.area);
        tic_free(&tic);
        return 1;
    }

    tic_stats.tics_bad++;
    tic_free(&tic);
    return 0;
}

typedef struct
{
    int count;
} TIC_INBOUND_CONTEXT;

static void tic_process_zone_directory(const char *zone_path, int zone, void *ctx)
{
    _kernel_swi_regs regs;
    char tic_path[TIC_MAX_PATH];
    char file_path[TIC_MAX_PATH];
    char name_buffer[256];  /* Buffer for filename - must be word aligned */
    int context = 0;
    TIC_INBOUND_CONTEXT *scan = (TIC_INBOUND_CONTEXT *)ctx;

    /* Ensure buffer is word-aligned */
    char *buffer = (char *)(((unsigned int)name_buffer + 3) & ~3);

    debug_printf("tic: Processing inbound TIC zone %d from %s", zone, zone_path);

    do
    {
        regs.r[0] = 9;  /* OS_GBPB reason 9: read directory names only */
        regs.r[1] = (int)zone_path;
        regs.r[2] = (int)buffer;
        regs.r[3] = 1;
        regs.r[4] = context;
        regs.r[5] = 252;  /* Buffer size (256 - 4 for alignment) */
        regs.r[6] = (int)"*tic";  /* Match *tic files */

        if (_kernel_swi(0x0C, &regs, &regs) != NULL)
        {
            debug_printf("tic: OS_GBPB 9 failed for %s", zone_path);
            break;
        }

        context = regs.r[4];
        debug_printf("tic: OS_GBPB returned r3=%d r4=%d", regs.r[3], context);

        if (regs.r[3] > 0)
        {
            /* Found a TIC file */
            TIC_FILE tic;
            char *tic_name = buffer;  /* For reason 9, name is at start of buffer */
            int result;

            debug_printf("tic: Found TIC file: '%s'", tic_name);

            snprintf(tic_path, sizeof(tic_path), "%s.%s", zone_path, tic_name);
            debug_printf("tic: Full TIC path: '%s'", tic_path);

            if (tic_parse_file(tic_path, &tic))
            {
                char riscos_filename[TIC_MAX_FILENAME];
                tic_filename_to_riscos(tic.filename, riscos_filename, sizeof(riscos_filename));
                snprintf(file_path, sizeof(file_path), "%s.%s", zone_path, riscos_filename);

                debug_printf("tic: Looking for file %s (original: %s)", file_path, tic.filename);

                result = tic_process_single(tic_path, file_path);
                
                if (result)
                {
                    /* Success - move to Processed folder */
                    scan->count++;
                    tic_move_to_processed(zone_path, tic_name, tic.filename);
                }
                else
                {
                    /* Failure - move to Bad folder */
                    tic_move_to_bad(zone_path, tic_name, tic.filename);
                }

                tic_free(&tic);
            }
            else
            {
                /* Parse failed - move just the TIC file to Bad */
                tic_move_to_bad(zone_path, tic_name, NULL);
            }
        }
    } while (context != -1 && regs.r[3] > 0);
}

int tic_process_inbound(void)
{
    TIC_INBOUND_CONTEXT scan;

    scan.count = 0;

    debug_printf("tic: Processing inbound TIC files from %s", tic_inbound_path);

    ftn_enumerate_zone_directories(tic_inbound_path, tic_process_zone_directory, &scan);

    debug_printf("tic: Processed %d TIC files", scan.count);
    return scan.count;
}

/* ******************************************************************************************************************************************************** */
/* Statistics                                                                                                                                               */
/* ******************************************************************************************************************************************************** */

void tic_get_stats(TIC_STATS *stats)
{
    if (stats != NULL)
    {
        *stats = tic_stats;
    }
}

void tic_reset_stats(void)
{
    memset(&tic_stats, 0, sizeof(tic_stats));
}
