/* ******************************************************************************************************************************************************** */
/* FTN Mailer - BinkP Protocol Implementation                                                                                                               */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "binkp.h"
#include "mailer.h"
#include "queue.h"
#include "debug.h"
#include "ftnlog.h"
#include "md5.h"
#include "crypt.h"
#include "compress.h"

/* ******************************************************************************************************************************************************** */
/* C90 Compatibility - strtok_r implementation                                                                                                              */
/* ******************************************************************************************************************************************************** */

/*
 * Thread-safe strtok replacement for C90.
 * Not available in Norcroft C library.
 */
static char *strtok_r(char *str, const char *delim, char **saveptr)
{
    char *token;
    
    if (str == NULL)
    {
        str = *saveptr;
    }
    
    /* Skip leading delimiters */
    str += strspn(str, delim);
    if (*str == '\0')
    {
        *saveptr = str;
        return NULL;
    }
    
    /* Find end of token */
    token = str;
    str = strpbrk(token, delim);
    if (str == NULL)
    {
        /* No more delimiters - this is the last token */
        *saveptr = token + strlen(token);
    }
    else
    {
        /* Terminate token and point to next */
        *str = '\0';
        *saveptr = str + 1;
    }
    
    return token;
}

/* ******************************************************************************************************************************************************** */
/* Frame Building                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

int binkp_build_command(unsigned char *buffer, BINKP_COMMAND cmd, const char *arg)
{
    int arg_len = (arg != NULL) ? strlen(arg) : 0;
    int frame_len = 1 + arg_len;  /* command byte + argument */

    if (frame_len > BINKP_MAX_FRAME)
    {
        frame_len = BINKP_MAX_FRAME;
        arg_len = frame_len - 1;
    }

    /* Header: 2 bytes, big-endian, high bit set for command */
    buffer[0] = (unsigned char)(((frame_len >> 8) & 0x7F) | 0x80);
    buffer[1] = (unsigned char)(frame_len & 0xFF);

    /* Command byte */
    buffer[2] = (unsigned char)cmd;

    /* Argument */
    if (arg_len > 0)
    {
        memcpy(&buffer[3], arg, arg_len);
    }

    return 2 + frame_len;  /* header + payload */
}

int binkp_build_data(unsigned char *buffer, const unsigned char *data, int length)
{
    if (length > BINKP_MAX_FRAME)
    {
        length = BINKP_MAX_FRAME;
    }

    /* Header: 2 bytes, big-endian, high bit clear for data */
    buffer[0] = (unsigned char)((length >> 8) & 0x7F);
    buffer[1] = (unsigned char)(length & 0xFF);

    /* Data */
    if (length > 0)
    {
        memcpy(&buffer[2], data, length);
    }

    return 2 + length;
}

/* ******************************************************************************************************************************************************** */
/* Frame Parsing                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

int binkp_frame_complete(const unsigned char *buffer, int length)
{
    int frame_len;

    if (length < 2)
    {
        return 0;
    }

    frame_len = ((buffer[0] & 0x7F) << 8) | buffer[1];
    return (length >= 2 + frame_len);
}

int binkp_get_frame_length(const unsigned char *buffer)
{
    return ((buffer[0] & 0x7F) << 8) | buffer[1];
}

int binkp_parse_frame(const unsigned char *buffer, int length, BINKP_FRAME *frame)
{
    int frame_len;

    if (length < 2)
    {
        return 0;
    }

    frame->is_command = (buffer[0] & 0x80) != 0;
    frame_len = ((buffer[0] & 0x7F) << 8) | buffer[1];

    if (length < 2 + frame_len)
    {
        return 0;
    }

    if (frame->is_command && frame_len > 0)
    {
        frame->command = buffer[2];
        frame->length = frame_len - 1;
        frame->data = (unsigned char *)&buffer[3];
    }
    else
    {
        frame->command = 0;
        frame->length = frame_len;
        frame->data = (unsigned char *)&buffer[2];
    }

    return 2 + frame_len;
}

/* ******************************************************************************************************************************************************** */
/* Command Sending                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

static void binkp_queue_frame(MAILER_SESSION *session, const unsigned char *frame, int length)
{
    if (session->tx_length + length <= MAILER_BUFFER_SIZE)
    {
        memcpy(&session->tx_buffer[session->tx_length], frame, length);
        session->tx_length += length;
    }
    else
    {
        debug_printf("binkp: TX buffer overflow");
    }
}

void binkp_send_nul(MAILER_SESSION *session, const char *key, const char *value)
{
    unsigned char frame[512];
    char arg[256];
    int len;

    snprintf(arg, sizeof(arg), "%s %s", key, value);
    len = binkp_build_command(frame, BINKP_M_NUL, arg);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_NUL %s %s", key, value);
    ftnlog_printf(">> NUL: %s %s", key, value);
}

void binkp_send_adr(MAILER_SESSION *session)
{
    unsigned char frame[512];
    char arg[256];
    char addr_str[64];
    int i, len;

    arg[0] = '\0';

    for (i = 0; i < mailer.our_addr_count; i++)
    {
        ftn_addr_to_string(&mailer.our_addrs[i], addr_str, sizeof(addr_str));

        if (i > 0)
        {
            strncat(arg, " ", sizeof(arg) - strlen(arg) - 1);
        }
        strncat(arg, addr_str, sizeof(arg) - strlen(arg) - 1);
    }

    len = binkp_build_command(frame, BINKP_M_ADR, arg);
    binkp_queue_frame(session, frame, len);

    ftnlog_printf(">> ADR: %s", arg);
    debug_printf("binkp: >> M_ADR %s", arg);
}

void binkp_send_pwd(MAILER_SESSION *session)
{
    unsigned char frame[256];
    char pwd_arg[128];
    int len;

    if (session->cram_enabled && session->cram_challenge[0] != '\0')
    {
        /* Use CRAM-MD5 authentication */
        char cram_response[64];
        binkp_compute_cram_response(session->cram_challenge, session->password, 
                                    cram_response, sizeof(cram_response));
        snprintf(pwd_arg, sizeof(pwd_arg), "CRAM-MD5-%s", cram_response);
        len = binkp_build_command(frame, BINKP_M_PWD, pwd_arg);
        debug_printf("binkp: >> M_PWD CRAM-MD5-****");
        ftnlog_printf(">> PWD: CRAM-MD5 (encrypted)");
    }
    else
    {
        /* Plain text password */
        len = binkp_build_command(frame, BINKP_M_PWD, session->password);
        debug_printf("binkp: >> M_PWD ****");
        ftnlog_printf(">> PWD: (password sent)");
    }
    
    binkp_queue_frame(session, frame, len);
}

void binkp_send_ok(MAILER_SESSION *session, int secure)
{
    unsigned char frame[64];
    int len;

    len = binkp_build_command(frame, BINKP_M_OK, secure ? "secure" : "non-secure");
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_OK %s", secure ? "secure" : "non-secure");
    ftnlog_printf(">> OK: %s", secure ? "secure" : "non-secure");

    /* Enable encryption after M_OK if both sides support CRYPT */
    if ((session->crypt_flag & (BINKP_CRYPT_WE | BINKP_CRYPT_THEY)) == 
        (BINKP_CRYPT_WE | BINKP_CRYPT_THEY))
    {
        binkp_init_session_encryption(session);
    }
}

void binkp_send_err(MAILER_SESSION *session, const char *message)
{
    unsigned char frame[256];
    int len;

    len = binkp_build_command(frame, BINKP_M_ERR, message);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_ERR %s", message);
    ftnlog_printf(">> ERR: %s", message);
}

void binkp_send_bsy(MAILER_SESSION *session, const char *message)
{
    unsigned char frame[256];
    int len;

    len = binkp_build_command(frame, BINKP_M_BSY, message);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_BSY %s", message);
    ftnlog_printf(">> BSY: %s", message);
}

void binkp_send_eob(MAILER_SESSION *session)
{
    unsigned char frame[8];
    int len;

    len = binkp_build_command(frame, BINKP_M_EOB, NULL);
    binkp_queue_frame(session, frame, len);

    session->local_eob = 1;
    debug_printf("binkp: >> M_EOB");
    ftnlog_printf(">> EOB: End of batch");
}

void binkp_send_file(MAILER_SESSION *session, const char *filename, long size, time_t mtime, long offset)
{
    unsigned char frame[512];
    char arg[256];
    int len;

    snprintf(arg, sizeof(arg), "%s %ld %ld %ld", filename, size, (long)mtime, offset);
    len = binkp_build_command(frame, BINKP_M_FILE, arg);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_FILE %s", arg);
    ftnlog_printf(">> FILE: %s (%ld bytes)", filename, size);
}

void binkp_send_got(MAILER_SESSION *session, const char *filename, long size, time_t mtime)
{
    unsigned char frame[512];
    char arg[256];
    int len;

    snprintf(arg, sizeof(arg), "%s %ld %ld", filename, size, (long)mtime);
    len = binkp_build_command(frame, BINKP_M_GOT, arg);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_GOT %s", arg);
    ftnlog_printf(">> GOT: %s", filename);
}

void binkp_send_skip(MAILER_SESSION *session, const char *filename, long size, time_t mtime)
{
    unsigned char frame[512];
    char arg[256];
    int len;

    snprintf(arg, sizeof(arg), "%s %ld %ld", filename, size, (long)mtime);
    len = binkp_build_command(frame, BINKP_M_SKIP, arg);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_SKIP %s", arg);
    ftnlog_printf(">> SKIP: %s", filename);
}

void binkp_send_get(MAILER_SESSION *session, const char *filename, long size, long mtime, long offset)
{
    unsigned char frame[512];
    char arg[256];
    int len;

    /* M_GET format: filename size time offset */
    snprintf(arg, sizeof(arg), "%s %ld %ld %ld", filename, size, mtime, offset);
    len = binkp_build_command(frame, BINKP_M_GET, arg);
    binkp_queue_frame(session, frame, len);

    debug_printf("binkp: >> M_GET %s", arg);
    ftnlog_printf(">> GET: %s (offset %ld)", filename, offset);
}

/* Send M_GET for a file request (FREQ) - uses 0 0 0 for size/time/offset */
void binkp_send_get_freq(MAILER_SESSION *session, const char *filename)
{
    binkp_send_get(session, filename, 0, 0, 0);
    mailer_log("Requesting file: %s", filename);
}

/*
 * Process a .REQ file and send M_GET commands for each requested file.
 */
void binkp_process_req_file(MAILER_SESSION *session, const char *path)
{
    FILE *f;
    char line[256];

    debug_printf("binkp: Processing REQ file: %s", path);

    f = fopen(path, "r");
    if (f == NULL)
    {
        debug_printf("binkp: Failed to open REQ file: %s", path);
        return;
    }

    while (fgets(line, sizeof(line), f) != NULL)
    {
        char *p = line;
        char *nl;

        /* Remove trailing newline/carriage return */
        nl = strchr(p, '\n');
        if (nl != NULL) *nl = '\0';
        nl = strchr(p, '\r');
        if (nl != NULL) *nl = '\0';

        /* Skip empty lines and comments */
        while (*p == ' ' || *p == '\t') p++;
        if (*p == '\0' || *p == ';')
        {
            continue;
        }

        /* Send M_GET for this filename (file request) */
        binkp_send_get_freq(session, p);
    }

    fclose(f);
}

/* ******************************************************************************************************************************************************** */
/* Handshake                                                                                                                                                */
/* ******************************************************************************************************************************************************** */

void binkp_send_handshake(MAILER_SESSION *session)
{
    char buf[128];
    char opt_buf[256];
    char *p;

    /* Send system information */
    binkp_send_nul(session, "SYS", mailer.system_name);
    binkp_send_nul(session, "ZYZ", mailer.sysop);
    binkp_send_nul(session, "LOC", mailer.location);

    snprintf(buf, sizeof(buf), "%d", mailer.speed);
    binkp_send_nul(session, "NDL", buf);

    binkp_send_nul(session, "TIME", "");  /* TODO: Format time */
    binkp_send_nul(session, "VER", MAILER_NAME "/" MAILER_VERSION " binkp/" BINKP_VERSION);

    /* Build options string: NR ND NDA EXTCMD [GZ] [BZ2] [CRYPT] */
    p = opt_buf;
    p += sprintf(p, "%s %s %s %s", 
                 BINKP_OPT_NR, BINKP_OPT_ND, BINKP_OPT_NDA, BINKP_OPT_EXTCMD);
    
    /* Advertise compression if available */
    if (compress_available(COMPRESS_TYPE_GZ))
    {
        p += sprintf(p, " %s", BINKP_OPT_GZ);
        session->z_can_recv |= (1 << BINKP_COMPRESS_GZ);
        session->z_can_send |= (1 << BINKP_COMPRESS_GZ);
    }
    if (compress_available(COMPRESS_TYPE_BZ2))
    {
        p += sprintf(p, " %s", BINKP_OPT_BZ2);
        session->z_can_recv |= (1 << BINKP_COMPRESS_BZ2);
        session->z_can_send |= (1 << BINKP_COMPRESS_BZ2);
    }
    
    /* Advertise encryption if we have a password */
    if (session->password[0] != '\0')
    {
        p += sprintf(p, " %s", BINKP_OPT_CRYPT);
        session->crypt_flag |= BINKP_CRYPT_WE_WANT;
    }
    
    binkp_send_nul(session, "OPT", opt_buf);
    
    /* Mark that we requested NR and ND modes */
    session->nr_mode |= BINKP_WE_NR;
    session->nd_mode |= BINKP_WE_ND;
    session->nda_mode = 1;  /* We support asymmetric ND */
    session->extcmd = 1;    /* We support EXTCMD */

    /* Send TRF info (pending mail/files) */
    binkp_send_trf(session);

    /* Send our addresses */
    binkp_send_adr(session);

    if (session->direction == SESSION_DIR_OUTBOUND)
    {
        const char *pwd;

        /* Look up password for the node we're calling (target_addr, not remote_addr) */
        pwd = binkp_get_password_for_node(&session->target_addr);
        strncpy(session->password, pwd, sizeof(session->password) - 1);
        session->password[sizeof(session->password) - 1] = '\0';

        debug_printf("binkp: Using password '%s' for outbound session", 
                     session->password[0] ? "****" : "(empty)");

        /* We initiated, send password */
        session->state = SESSION_STATE_WAIT_OK;
        binkp_send_pwd(session);
    }
    else
    {
        /* We're answering, wait for their password */
        session->state = SESSION_STATE_WAIT_PWD;
    }
}

/* ******************************************************************************************************************************************************** */
/* Command Handlers                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

void binkp_handle_nul(MAILER_SESSION *session, const char *data)
{
    char key[32], value[256];
    const char *p;

    debug_printf("binkp: << M_NUL %s", data);
    ftnlog_printf("<< NUL: %s", data);

    /* Parse "KEY VALUE" format */
    p = strchr(data, ' ');
    if (p != NULL)
    {
        size_t key_len = p - data;
        if (key_len >= sizeof(key)) key_len = sizeof(key) - 1;
        strncpy(key, data, key_len);
        key[key_len] = '\0';
        strncpy(value, p + 1, sizeof(value) - 1);
        value[sizeof(value) - 1] = '\0';

        if (strcmp(key, "SYS") == 0)
        {
            strncpy(session->remote_system, value, sizeof(session->remote_system) - 1);
        }
        else if (strcmp(key, "ZYZ") == 0)
        {
            strncpy(session->remote_sysop, value, sizeof(session->remote_sysop) - 1);
        }
        else if (strcmp(key, "LOC") == 0)
        {
            strncpy(session->remote_location, value, sizeof(session->remote_location) - 1);
        }
        else if (strcmp(key, "OPT") == 0)
        {
            /* Parse options - space-separated words */
            char opt_copy[256];
            char *word, *saveptr;
            
            strncpy(opt_copy, value, sizeof(opt_copy) - 1);
            opt_copy[sizeof(opt_copy) - 1] = '\0';
            
            for (word = strtok_r(opt_copy, " ", &saveptr); word != NULL; 
                 word = strtok_r(NULL, " ", &saveptr))
            {
                /* CRAM-MD5 challenge */
                if (strncmp(word, BINKP_OPT_CRAM_MD5, strlen(BINKP_OPT_CRAM_MD5)) == 0)
                {
                    session->cram_enabled = 1;
                    if (word[strlen(BINKP_OPT_CRAM_MD5)] == '-')
                    {
                        strncpy(session->cram_challenge, 
                                word + strlen(BINKP_OPT_CRAM_MD5) + 1,
                                sizeof(session->cram_challenge) - 1);
                        session->cram_challenge[sizeof(session->cram_challenge) - 1] = '\0';
                        debug_printf("binkp: CRAM-MD5 challenge: %s", session->cram_challenge);
                    }
                }
                /* NR mode - remote requests non-reliable mode */
                else if (strcmp(word, BINKP_OPT_NR) == 0)
                {
                    session->nr_mode |= BINKP_THEY_NR;
                    debug_printf("binkp: Remote requests NR mode");
                    ftnlog_printf("   NR mode enabled (remote request)");
                }
                /* ND mode - remote requests no-dupes mode */
                else if (strcmp(word, BINKP_OPT_ND) == 0)
                {
                    session->nd_mode |= BINKP_THEY_ND;
                    debug_printf("binkp: Remote requests ND mode");
                    ftnlog_printf("   ND mode enabled (remote request)");
                }
                /* NDA - asymmetric ND supported */
                else if (strcmp(word, BINKP_OPT_NDA) == 0)
                {
                    session->nda_mode = 1;
                    debug_printf("binkp: Remote supports asymmetric ND mode");
                }
                /* EXTCMD - extended commands supported */
                else if (strcmp(word, BINKP_OPT_EXTCMD) == 0)
                {
                    session->extcmd = 1;
                    debug_printf("binkp: Remote supports EXTCMD mode");
                }
                /* GZ - GZip compression supported */
                else if (strcmp(word, BINKP_OPT_GZ) == 0)
                {
                    session->z_can_recv |= (1 << BINKP_COMPRESS_GZ);
                    debug_printf("binkp: Remote supports GZip compression");
                    ftnlog_printf("   Remote supports GZ compression");
                }
                /* BZ2 - BZip2 compression supported */
                else if (strcmp(word, BINKP_OPT_BZ2) == 0)
                {
                    session->z_can_recv |= (1 << BINKP_COMPRESS_BZ2);
                    debug_printf("binkp: Remote supports BZip2 compression");
                    ftnlog_printf("   Remote supports BZ2 compression");
                }
                /* CRYPT - encryption supported */
                else if (strcmp(word, BINKP_OPT_CRYPT) == 0)
                {
                    session->crypt_flag |= BINKP_CRYPT_THEY_WANT;
                    debug_printf("binkp: Remote supports encryption");
                    ftnlog_printf("   Remote supports CRYPT");
                }
            }
        }
        else if (strcmp(key, "TRF") == 0)
        {
            /* Parse TRF info: "mail_bytes file_bytes" */
            long mail_bytes = 0, file_bytes = 0;
            if (sscanf(value, "%ld %ld", &mail_bytes, &file_bytes) >= 1)
            {
                debug_printf("binkp: Remote has %ld mail bytes, %ld file bytes pending",
                             mail_bytes, file_bytes);
                ftnlog_printf("   Remote pending: %ld mail, %ld files", 
                              mail_bytes, file_bytes);
            }
        }
        else if (strcmp(key, "VER") == 0)
        {
            /* Parse version string to detect buggy implementations */
            /* Format: "software/version binkp/major.minor" */
            const char *binkp_ver = strstr(value, "binkp/");
            if (binkp_ver != NULL)
            {
                const char *dot = strchr(binkp_ver + 6, '.');
                if (dot != NULL)
                {
                    session->remote_major = atoi(binkp_ver + 6);
                    session->remote_minor = atoi(dot + 1);
                    debug_printf("binkp: Remote uses binkp/%d.%d", 
                                 session->remote_major, session->remote_minor);
                }
            }
            
            /* Check for buggy NR implementations in old binkd versions */
            if (strstr(value, "binkd/0.9/") != NULL ||
                strstr(value, "binkd/0.9.1/") != NULL ||
                strstr(value, "binkd/0.9.2/") != NULL ||
                strstr(value, "binkd/0.9.3/") != NULL ||
                strstr(value, "binkd/0.9.4/") != NULL)
            {
                session->buggy_nr = 1;
                debug_printf("binkp: Remote has buggy NR, using workaround");
                ftnlog_printf("   Remote has buggy NR implementation, using workaround");
            }
        }
    }
}

/*
 * Check if an address matches any uplink (primary address or alias).
 * Returns the uplink's primary address if found, NULL otherwise.
 * This is used to find which uplink a remote node belongs to when
 * they report multiple AKAs in M_ADR.
 */
static int binkp_find_uplink_for_address(const FTN_ADDR *addr, FTN_ADDR *uplink_primary_out)
{
    _kernel_swi_regs regs;
    int i, j;
    int uplink_count;

    /* FTN_UPLINK_CONFIG structure - matches Support/h/ftnconfig */
    typedef struct
    {
        int id;
        char address[64];
        char network[64];
        char host[64];
        int port;
        char password[32];
        char groups[64];
        int alias_count;
        char aliases[8][64];
    } UPLINK_CFG;

    /* Get uplink count from Support module */
    regs.r[0] = 7;  /* FTN_CONFIG_REASON_COUNT_UPLINKS */
    if (_kernel_swi(0x5AA86, &regs, &regs) != NULL)
    {
        return 0;
    }
    uplink_count = regs.r[0];

    /* Check each uplink */
    for (i = 1; i <= uplink_count; i++)
    {
        UPLINK_CFG *uplink;
        FTN_ADDR uplink_addr;

        regs.r[0] = 4;  /* FTN_CONFIG_REASON_GET_UPLINK */
        regs.r[1] = i;
        if (_kernel_swi(0x5AA86, &regs, &regs) != NULL || regs.r[0] == 0)
        {
            continue;
        }

        uplink = (UPLINK_CFG *)regs.r[0];

        /* Check primary address */
        if (ftn_string_to_addr(uplink->address, &uplink_addr) &&
            ftn_addr_match(&uplink_addr, addr))
        {
            if (uplink_primary_out != NULL)
            {
                *uplink_primary_out = uplink_addr;
            }
            return 1;
        }

        /* Check aliases */
        for (j = 0; j < uplink->alias_count; j++)
        {
            FTN_ADDR alias_addr;

            if (ftn_string_to_addr(uplink->aliases[j], &alias_addr) &&
                ftn_addr_match(&alias_addr, addr))
            {
                /* Return the primary address, not the alias */
                if (uplink_primary_out != NULL && 
                    ftn_string_to_addr(uplink->address, uplink_primary_out))
                {
                    /* Success */
                }
                return 1;
            }
        }
    }

    return 0;
}

void binkp_handle_adr(MAILER_SESSION *session, const char *data)
{
    char addr_str[64];
    const char *p = data;
    FTN_ADDR first_addr;
    FTN_ADDR matched_uplink;
    int found_uplink = 0;
    int first_saved = 0;

    debug_printf("binkp: << M_ADR %s", data);
    ftnlog_printf("<< ADR: %s", data);

    /* Parse space-separated address list */
    /* Check each address against our uplinks (including aliases) */
    while (*p != '\0')
    {
        FTN_ADDR addr;
        const char *end;
        size_t len;

        /* Skip spaces */
        while (*p == ' ') p++;
        if (*p == '\0') break;

        /* Extract next address */
        end = strchr(p, ' ');
        len = end ? (size_t)(end - p) : strlen(p);

        if (len >= sizeof(addr_str)) len = sizeof(addr_str) - 1;
        strncpy(addr_str, p, len);
        addr_str[len] = '\0';

        /* Parse the address */
        if (ftn_string_to_addr(addr_str, &addr))
        {
            /* Save first address as fallback */
            if (!first_saved)
            {
                first_addr = addr;
                first_saved = 1;
            }

            /* Check if this matches any of our uplinks */
            if (!found_uplink && binkp_find_uplink_for_address(&addr, &matched_uplink))
            {
                debug_printf("binkp: Address %s matches uplink %d:%d/%d.%d",
                             addr_str, matched_uplink.zone, matched_uplink.net,
                             matched_uplink.node, matched_uplink.point);
                session->remote_addr = matched_uplink;  /* Use the uplink's primary address */
                found_uplink = 1;
            }
        }

        /* Move to next address */
        p = end ? end : p + strlen(p);
    }

    /* If no uplink matched, use the first address */
    if (!found_uplink && first_saved)
    {
        session->remote_addr = first_addr;
        debug_printf("binkp: No uplink match, using first address");
    }

    ftnlog_printf("   Using: %d:%d/%d.%d%s",
                   session->remote_addr.zone, session->remote_addr.net,
                   session->remote_addr.node, session->remote_addr.point,
                   found_uplink ? " (matched uplink)" : "");

    mailer_log("Remote address: %d:%d/%d.%d",
               session->remote_addr.zone, session->remote_addr.net,
               session->remote_addr.node, session->remote_addr.point);
}

void binkp_handle_pwd(MAILER_SESSION *session, const char *data)
{
    const char *expected;
    int secure = 0;

    debug_printf("binkp: << M_PWD (hidden) state=%d", session->state);
    ftnlog_printf("<< PWD: (password received)");

    /* Look up expected password for this node */
    expected = binkp_get_password_for_node(&session->remote_addr);

    if (expected == NULL || *expected == '\0')
    {
        /* No password required */
        debug_printf("binkp: No password required, sending M_OK");
        session->authenticated = 1;
        binkp_send_ok(session, 0);
        session->state = SESSION_STATE_AUTHENTICATED;
    }
    else if (session->cram_enabled && data[0] == 'C' && data[1] == 'R' && data[2] == 'A' && data[3] == 'M')
    {
        /* CRAM-MD5 response */
        if (binkp_verify_cram_response(session->cram_challenge, expected, data))
        {
            session->authenticated = 1;
            secure = 1;
            binkp_send_ok(session, secure);
            session->state = SESSION_STATE_AUTHENTICATED;
        }
        else
        {
            binkp_send_err(session, "Bad password");
            session->state = SESSION_STATE_ERROR;
        }
    }
    else
    {
        /* Plain password */
        if (strcmp(data, expected) == 0)
        {
            debug_printf("binkp: Password matched, sending M_OK");
            ftnlog_printf(">> OK: Password accepted");
            session->authenticated = 1;
            binkp_send_ok(session, 0);
            session->state = SESSION_STATE_AUTHENTICATED;
        }
        else
        {
            debug_printf("binkp: Password mismatch");
            ftnlog_printf(">> ERR: Bad password");
            binkp_send_err(session, "Bad password");
            session->state = SESSION_STATE_ERROR;
        }
    }
}

void binkp_handle_ok(MAILER_SESSION *session, const char *data)
{
    ftnlog_printf("<< OK: %s", strstr(data, "secure") ? "Secure session" : "Non-secure");

    mailer_log("Session established, remote reports \"%s\"", 
               strstr(data, "secure") ? "secure" : "non-secure");

    session->authenticated = 1;
    session->state = SESSION_STATE_AUTHENTICATED;

    /* Enable encryption after M_OK if both sides support CRYPT */
    if ((session->crypt_flag & (BINKP_CRYPT_WE | BINKP_CRYPT_THEY)) == 
        (BINKP_CRYPT_WE | BINKP_CRYPT_THEY))
    {
        binkp_init_session_encryption(session);
    }

    /* Start file transfer phase */
    binkp_check_for_files(session);
}

void binkp_handle_err(MAILER_SESSION *session, const char *data)
{
    debug_printf("binkp: << M_ERR %s", data);
    ftnlog_printf("<< ERR: %s", data);
    mailer_log("Session error: %s", data);
    session->state = SESSION_STATE_ERROR;
}

void binkp_handle_bsy(MAILER_SESSION *session, const char *data)
{
    debug_printf("binkp: << M_BSY %s", data);
    ftnlog_printf("<< BSY: %s", data);
    mailer_log("Remote busy: %s", data);
    session->state = SESSION_STATE_CLOSING;
}

void binkp_handle_eob(MAILER_SESSION *session)
{
    debug_printf("binkp: << M_EOB");

    ftnlog_printf("<< EOB: End of batch");

    session->remote_eob = 1;

    /* If we've also sent EOB AND no file transfer in progress, try session restart */
    if (session->local_eob && session->remote_eob &&
        session->recv_file.state != TRANSFER_STATE_RECEIVING &&
        session->send_file.state != TRANSFER_STATE_SENDING)
    {
        /* BinkP 1.1 session restart: Check for new files before closing */
        binkp_try_session_restart(session);
    }
    else if (session->local_eob && session->remote_eob)
    {
        debug_printf("binkp: Both EOBs exchanged but transfer in progress, waiting...");
    }
}

/*
 * BinkP 1.1 Session Restart
 * 
 * After both sides exchange EOB, check if new files have been queued.
 * If so, reset EOB flags and continue the session with a new batch.
 * This allows a single connection to handle multiple batches of mail.
 */
void binkp_try_session_restart(MAILER_SESSION *session)
{
    int zone;
    int pending_files;
    
    /* Determine which zone we're working with */
    if (session->direction == SESSION_DIR_OUTBOUND)
    {
        zone = session->target_addr.zone;
    }
    else
    {
        zone = session->remote_addr.zone;
    }
    
    /* Check if there are new files queued for this zone */
    pending_files = queue_count_files_for_zone(zone);
    
    if (pending_files > 0)
    {
        /* New files available - restart the session */
        session->batch_number++;
        debug_printf("binkp: Session restart - batch %d, %d files pending", 
                     session->batch_number, pending_files);
        ftnlog_printf("Session restart: batch %d, %d files pending", 
                       session->batch_number, pending_files);
        mailer_log("Session restart (batch %d, %d new files)", 
                   session->batch_number, pending_files);
        
        /* Reset EOB flags for new batch */
        session->local_eob = 0;
        session->remote_eob = 0;
        
        /* Start sending new files */
        binkp_check_for_files(session);
    }
    else
    {
        /* No new files - session complete */
        debug_printf("binkp: Session complete (no files for restart)");
        ftnlog_printf("Session complete: sent %d, recv %d files (batch %d)",
                       session->files_sent, session->files_received, session->batch_number);
        mailer_log("Session complete (sent %d files/%ld bytes, recv %d files/%ld bytes)",
                   session->files_sent, session->bytes_sent,
                   session->files_received, session->bytes_received);
        session->state = SESSION_STATE_CLOSING;
    }
}

/* ******************************************************************************************************************************************************** */
/* File Transfer Handlers                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

/*
 * Check if a file has already been received in this session (ND mode).
 * Returns 1 if the file is a duplicate, 0 otherwise.
 */
int binkp_is_file_received(MAILER_SESSION *session, const char *filename, long size, time_t mtime)
{
    int i;
    char key[MAILER_PATH_SIZE];
    
    /* Build a key from filename, size, and mtime for comparison */
    snprintf(key, sizeof(key), "%s:%ld:%ld", filename, size, (long)mtime);
    
    for (i = 0; i < session->nd_received_count && i < 32; i++)
    {
        if (strcmp(session->nd_received_files[i], key) == 0)
        {
            return 1;  /* Duplicate found */
        }
    }
    return 0;
}

/*
 * Record a file as received for ND mode duplicate tracking.
 */
static void binkp_mark_file_received(MAILER_SESSION *session, const char *filename, long size, time_t mtime)
{
    if (session->nd_received_count < 32)
    {
        snprintf(session->nd_received_files[session->nd_received_count],
                 MAILER_PATH_SIZE, "%s:%ld:%ld", filename, size, (long)mtime);
        session->nd_received_count++;
    }
}

void binkp_handle_file(MAILER_SESSION *session, const char *data)
{
    char filename[128];
    long size, mtime, offset;

    /* If we receive a file, we're implicitly authenticated */
    if (session->state != SESSION_STATE_AUTHENTICATED && 
        session->state != SESSION_STATE_TRANSFER)
    {
        session->authenticated = 1;
        session->state = SESSION_STATE_AUTHENTICATED;
    }

    /* Parse: filename size time offset */
    if (sscanf(data, "%127s %ld %ld %ld", filename, &size, &mtime, &offset) >= 3)
    {
        ftnlog_printf("<< FILE: %s (%ld bytes, offset %ld)", filename, size, offset);
        
        /* ND mode: Check for duplicate file in this session */
        if ((session->nd_mode & BINKP_WE_ND) && 
            (session->nd_mode & BINKP_THEY_ND))
        {
            if (binkp_is_file_received(session, filename, size, (time_t)mtime))
            {
                debug_printf("binkp: ND mode - duplicate file %s, sending M_GOT", filename);
                ftnlog_printf(">> GOT: %s (ND duplicate)", filename);
                binkp_send_got(session, filename, size, (time_t)mtime);
                return;
            }
        }
        
        /* NR mode: offset -1 means sender is waiting for M_GET */
        if (offset == -1)
        {
            binkp_start_receive_file(session, filename, size, (time_t)mtime, 0);
            
            /* Send M_GET to tell sender where to start from */
            if (session->recv_file.state == TRANSFER_STATE_RECEIVING)
            {
                binkp_send_get(session, filename, size, mtime, 0);
            }
        }
        else
        {
            binkp_start_receive_file(session, filename, size, (time_t)mtime, offset);
        }
    }
}

void binkp_handle_got(MAILER_SESSION *session, const char *data)
{
    debug_printf("binkp: << M_GOT %s", data);
    ftnlog_printf("<< GOT: %s", data);

    /* Remote has received our file successfully */
    if (session->send_file.state == TRANSFER_STATE_SENDING)
    {
        ftnlog_printf("<< GOT: File sent successfully");
        binkp_finish_send_file(session);

        /* Check for more files to send */
        binkp_check_for_files(session);
    }
}

void binkp_handle_skip(MAILER_SESSION *session, const char *data)
{
    debug_printf("binkp: << M_SKIP %s", data);
    ftnlog_printf("<< SKIP: %s", data);

    /* Remote doesn't want this file */
    if (session->send_file.state == TRANSFER_STATE_SENDING)
    {
        binkp_finish_send_file(session);
        binkp_check_for_files(session);
    }
}

void binkp_handle_get(MAILER_SESSION *session, const char *data)
{
    char filename[128];
    long size, mtime, offset;
    FILE_TRANSFER *ft = &session->send_file;
    
    debug_printf("binkp: << M_GET %s", data);
    ftnlog_printf("<< GET: %s", data);
    
    /* Parse: filename size time offset */
    if (sscanf(data, "%127s %ld %ld %ld", filename, &size, &mtime, &offset) < 4)
    {
        debug_printf("binkp: M_GET parse failed");
        return;
    }
    
    /* Check if this is for the file we're currently sending */
    if (ft->state == TRANSFER_STATE_SENDING && 
        strcmp(ft->filename, filename) == 0 &&
        ft->size == size)
    {
        /* Seek to requested offset and continue sending */
        if (offset >= 0 && offset < ft->size && ft->file != NULL)
        {
            fseek(ft->file, offset, SEEK_SET);
            ft->offset = offset;
            
            debug_printf("binkp: Resuming send of %s from offset %ld", filename, offset);
            ftnlog_printf(">> FILE: %s (resume from %ld)", filename, offset);
            
            /* Re-send M_FILE with the new offset */
            binkp_send_file(session, ft->filename, ft->size, ft->mtime, offset);
        }
        else
        {
            debug_printf("binkp: M_GET invalid offset %ld (file size %ld)", offset, ft->size);
        }
    }
    /* Check if this is for a file we've already sent (NR mode - resend request) */
    else if (ft->state == TRANSFER_STATE_IDLE)
    {
        /* In NR mode, we might receive M_GET for a file we thought was sent.
         * This is a request to resend. We would need to re-queue or find the file.
         * For now, log it - full implementation would need file tracking. */
        debug_printf("binkp: M_GET for non-active file %s (NR mode resend?)", filename);
        ftnlog_printf(">> GET resend request for %s (not implemented)", filename);
    }
    else
    {
        debug_printf("binkp: M_GET for unknown file %s (current: %s)", 
                     filename, ft->filename);
    }
}

void binkp_handle_data(MAILER_SESSION *session, const unsigned char *data, int length)
{
    if (session->recv_file.state == TRANSFER_STATE_RECEIVING)
    {
        binkp_receive_file_data(session, data, length);
    }
    else
    {
        debug_printf("binkp: WARNING - Data frame but not receiving!");
    }
}

/* ******************************************************************************************************************************************************** */
/* Main Frame Handler                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void binkp_handle_frame(MAILER_SESSION *session, BINKP_FRAME *frame)
{
    if (frame->is_command)
    {
        /* Null-terminate command argument for string parsing */
        char arg[MAILER_BUFFER_SIZE];
        if (frame->length > 0 && frame->length < (int)sizeof(arg))
        {
            memcpy(arg, frame->data, frame->length);
            arg[frame->length] = '\0';
        }
        else
        {
            arg[0] = '\0';
        }

        switch (frame->command)
        {
            case BINKP_M_NUL:  binkp_handle_nul(session, arg); break;
            case BINKP_M_ADR:  binkp_handle_adr(session, arg); break;
            case BINKP_M_PWD:  binkp_handle_pwd(session, arg); break;
            case BINKP_M_OK:   binkp_handle_ok(session, arg); break;
            case BINKP_M_ERR:  binkp_handle_err(session, arg); break;
            case BINKP_M_BSY:  binkp_handle_bsy(session, arg); break;
            case BINKP_M_EOB:  binkp_handle_eob(session); break;
            case BINKP_M_FILE: binkp_handle_file(session, arg); break;
            case BINKP_M_GOT:  binkp_handle_got(session, arg); break;
            case BINKP_M_SKIP: binkp_handle_skip(session, arg); break;
            case BINKP_M_GET:  binkp_handle_get(session, arg); break;
            default:
                debug_printf("binkp: Unknown command %d: %s", frame->command, arg);
                ftnlog_printf("<< CMD[%d]: %s", frame->command, arg);
                break;
        }
    }
    else
    {
        /* Data frame */
        binkp_handle_data(session, frame->data, frame->length);
    }

    session->last_activity = time(NULL);
}

/* ******************************************************************************************************************************************************** */
/* File Transfer Implementation                                                                                                                             */
/* ******************************************************************************************************************************************************** */

/*
 * Create a directory, including any missing parent directories.
 * Similar to 'mkdir -p' behaviour - creates the full path hierarchy.
 */
static void ensure_directory_exists(const char *path)
{
    _kernel_swi_regs regs;
    char parent[MAILER_PATH_SIZE];
    char *last_dot;

    if (path == NULL || path[0] == '\0')
    {
        return;
    }

    /* First, try to create the directory directly */
    regs.r[0] = 8;  /* OS_File 8 = Create directory */
    regs.r[1] = (int)path;
    regs.r[4] = 0;  /* Default number of entries */

    if (_kernel_swi(OS_File, &regs, &regs) == NULL)
    {
        return;  /* Success or already exists */
    }

    /* Failed - try to create parent directory first */
    strncpy(parent, path, sizeof(parent) - 1);
    parent[sizeof(parent) - 1] = '\0';

    last_dot = strrchr(parent, '.');
    if (last_dot != NULL && last_dot != parent)
    {
        *last_dot = '\0';  /* Truncate to parent path */

        /* Recursively ensure parent exists */
        ensure_directory_exists(parent);

        /* Now try again to create the original directory */
        regs.r[0] = 8;
        regs.r[1] = (int)path;
        regs.r[4] = 0;
        _kernel_swi(OS_File, &regs, &regs);
    }
}

/*
 * Convert DOS-style filename (name.ext) to RISC OS style (nameEXT)
 * e.g., "138D7378.pkt" -> "138D7378pkt"
 */
static void filename_dos_to_riscos(const char *dos_name, char *riscos_name, size_t size)
{
    const char *dot;
    size_t base_len;

    dot = strrchr(dos_name, '.');
    if (dot != NULL && dot != dos_name)
    {
        /* Copy base name */
        base_len = dot - dos_name;
        if (base_len >= size) base_len = size - 1;
        strncpy(riscos_name, dos_name, base_len);
        riscos_name[base_len] = '\0';

        /* Append extension without dot */
        strncat(riscos_name, dot + 1, size - strlen(riscos_name) - 1);
    }
    else
    {
        /* No extension, just copy */
        strncpy(riscos_name, dos_name, size - 1);
        riscos_name[size - 1] = '\0';
    }
}

/*
 * Convert RISC OS filename (nameEXT) to DOS-style (name.ext)
 * Assumes last 3 characters are the extension if filename is > 3 chars
 * e.g., "138D7378pkt" -> "138D7378.pkt"
 */
static void filename_riscos_to_dos(const char *riscos_name, char *dos_name, size_t size)
{
    size_t len = strlen(riscos_name);

    if (len > 3)
    {
        /* Insert dot before last 3 characters */
        size_t base_len = len - 3;
        if (base_len >= size - 4) base_len = size - 5;

        strncpy(dos_name, riscos_name, base_len);
        dos_name[base_len] = '.';
        strncpy(dos_name + base_len + 1, riscos_name + len - 3, 3);
        dos_name[base_len + 4] = '\0';
    }
    else
    {
        /* Too short for extension, just copy */
        strncpy(dos_name, riscos_name, size - 1);
        dos_name[size - 1] = '\0';
    }
}

void binkp_start_receive_file(MAILER_SESSION *session, const char *filename, long size, time_t mtime, long offset)
{
    char path[MAILER_PATH_SIZE];
    char riscos_filename[MAILER_PATH_SIZE];
    char temp_dir[MAILER_PATH_SIZE];
    int zone = (session->remote_addr.zone > 0) ? session->remote_addr.zone : 2;

    /* Treat -1 (or any negative) offset as 0 - start from beginning */
    if (offset < 0) offset = 0;

    /* Convert DOS filename to RISC OS format */
    filename_dos_to_riscos(filename, riscos_filename, sizeof(riscos_filename));

    /* Ensure zone-specific temp inbound directory exists */
    ftn_format_zone_subpath(temp_dir, sizeof(temp_dir), mailer.inbound_path, zone, "Temp");
    ensure_directory_exists(temp_dir);

    /* Build temp path using RISC OS filename */
    snprintf(path, sizeof(path), "%s.%s", temp_dir, riscos_filename);

    session->recv_file.file = fopen(path, offset > 0 ? "ab" : "wb");
    if (session->recv_file.file == NULL)
    {
        debug_printf("binkp: Failed to create %s", path);
        binkp_send_skip(session, filename, size, mtime);
        return;
    }

    /* Store original DOS filename for protocol responses, RISC OS name for local path */
    strncpy(session->recv_file.filename, filename, sizeof(session->recv_file.filename) - 1);
    strncpy(session->recv_file.local_path, path, sizeof(session->recv_file.local_path) - 1);
    session->recv_file.size = size;
    session->recv_file.mtime = mtime;
    session->recv_file.offset = offset;
    session->recv_file.state = TRANSFER_STATE_RECEIVING;

    ftnstatus_start_transfer(0, filename);

    debug_printf("binkp: Receiving %s as %s (%ld bytes)", filename, riscos_filename, size);
    mailer_log("Receiving: %s (%ld bytes)", filename, size);
}

void binkp_receive_file_data(MAILER_SESSION *session, const unsigned char *data, int length)
{
    FILE_TRANSFER *ft = &session->recv_file;

    if (ft->file != NULL)
    {
        fwrite(data, 1, length, ft->file);
        ft->offset += length;
        session->bytes_received += length;

        ftnstatus_update_progress((int)((ft->offset * 100) / ft->size));

        /* Check if complete */
        if (ft->offset >= ft->size)
        {
            binkp_finish_receive_file(session);
        }
    }
}

void binkp_finish_receive_file(MAILER_SESSION *session)
{
    FILE_TRANSFER *ft = &session->recv_file;
    char final_path[MAILER_PATH_SIZE];
    char riscos_filename[MAILER_PATH_SIZE];
    char zone_path[MAILER_PATH_SIZE];
    int zone = (session->remote_addr.zone > 0) ? session->remote_addr.zone : 2;

    if (ft->file != NULL)
    {
        fclose(ft->file);
        ft->file = NULL;
    }

    /* ND mode: Mark file as received to prevent duplicates on session restart */
    if (session->nd_mode & BINKP_WE_ND)
    {
        binkp_mark_file_received(session, ft->filename, ft->size, ft->mtime);
    }

    /* Ensure zone-specific inbound directory exists */
    ftn_format_zone_path(zone_path, sizeof(zone_path), mailer.inbound_path, zone);
    ensure_directory_exists(zone_path);

    /* Convert DOS filename to RISC OS format for final path */
    filename_dos_to_riscos(ft->filename, riscos_filename, sizeof(riscos_filename));

    /* Move from temp to final inbound */
    snprintf(final_path, sizeof(final_path), "%s.%s", zone_path, riscos_filename);

    /* Rename temp file to final location */
    rename(ft->local_path, final_path);

    debug_printf("binkp: Received %s as %s (%ld bytes)", ft->filename, riscos_filename, ft->size);

    /* Acknowledge receipt using original DOS filename */
    binkp_send_got(session, ft->filename, ft->size, ft->mtime);

    ftnlog_printf(">> GOT: Received %s (%ld bytes)", ft->filename, ft->size);

    ft->state = TRANSFER_STATE_IDLE;
    session->files_received++;

    ftnstatus_end_transfer();

    mailer_log("Received: %s (%ld bytes)", ft->filename, ft->size);

    /* Check if session should complete/restart now that transfer is done */
    if (session->local_eob && session->remote_eob)
    {
        debug_printf("binkp: File received, both EOBs exchanged - checking for restart");
        binkp_try_session_restart(session);
    }
}

void binkp_start_send_file(MAILER_SESSION *session, const char *path)
{
    FILE_TRANSFER *ft = &session->send_file;
    _kernel_swi_regs regs;
    long fsize;
    const char *riscos_filename;
    char dos_filename[MAILER_PATH_SIZE];

    /* Get file size */
    regs.r[0] = 17;
    regs.r[1] = (int)path;
    _kernel_swi(OS_File, &regs, &regs);

    if (regs.r[0] != 1)
    {
        debug_printf("binkp: File not found: %s", path);
        return;
    }

    fsize = regs.r[4];

    /* Extract RISC OS filename (leaf name after last dot in path) */
    riscos_filename = strrchr(path, '.');
    riscos_filename = riscos_filename ? riscos_filename + 1 : path;

    /* Convert RISC OS filename to DOS format for remote end */
    filename_riscos_to_dos(riscos_filename, dos_filename, sizeof(dos_filename));

    ft->file = fopen(path, "rb");
    if (ft->file == NULL)
    {
        debug_printf("binkp: Failed to open %s", path);
        return;
    }

    /* Store DOS filename for protocol, local path for file access */
    strncpy(ft->filename, dos_filename, sizeof(ft->filename) - 1);
    strncpy(ft->local_path, path, sizeof(ft->local_path) - 1);
    ft->size = fsize;
    ft->mtime = time(NULL);  /* TODO: Get actual file time */
    ft->offset = 0;
    ft->state = TRANSFER_STATE_SENDING;

    /* NR mode: If both sides support NR, send with offset -1 to wait for M_GET.
     * Exception: Buggy old binkd versions don't handle NR properly. */
    if ((session->nr_mode & BINKP_WE_NR) && 
        (session->nr_mode & BINKP_THEY_NR) && 
        !session->buggy_nr)
    {
        /* NR mode: Send M_FILE with offset -1, wait for M_GET before sending data */
        binkp_send_file(session, dos_filename, ft->size, ft->mtime, -1);
        debug_printf("binkp: Sending %s in NR mode (waiting for M_GET)", dos_filename);
        ftnlog_printf(">> FILE: %s (%ld bytes, NR mode)", dos_filename, fsize);
    }
    else
    {
        /* Normal mode: Send M_FILE with offset 0 and start sending data immediately */
        binkp_send_file(session, dos_filename, ft->size, ft->mtime, 0);
        debug_printf("binkp: Sending %s as %s (%ld bytes)", riscos_filename, dos_filename, fsize);
        ftnlog_printf(">> FILE: %s (%ld bytes)", dos_filename, fsize);
    }
    
    mailer_log("Sending: %s (%ld bytes)", dos_filename, fsize);
    
    /* Update status window with transfer progress */
    ftnstatus_start_transfer(1, dos_filename);
}

void binkp_send_file_data(MAILER_SESSION *session)
{
    FILE_TRANSFER *ft = &session->send_file;
    unsigned char buffer[4096];
    unsigned char frame[4100];
    int bytes_read;
    int frame_len;

    if (ft->state != TRANSFER_STATE_SENDING || ft->file == NULL)
    {
        return;
    }

    /* In NR mode, don't send data until we've received M_GET (offset will be set).
     * We send M_FILE with offset -1, then wait. When M_GET arrives, it sets ft->offset
     * to the requested position. If offset is still 0 and we're in full NR mode,
     * check if we've had the M_GET response yet. */
    if ((session->nr_mode & BINKP_WE_NR) && 
        (session->nr_mode & BINKP_THEY_NR) && 
        !session->buggy_nr &&
        ft->offset == 0 && ftell(ft->file) == 0)
    {
        /* Still waiting for M_GET - check if file position indicates we got one */
        return;
    }

    /* Don't send if TX buffer is getting full */
    if (session->tx_length > MAILER_BUFFER_SIZE - 4100)
    {
        return;
    }

    bytes_read = fread(buffer, 1, sizeof(buffer), ft->file);
    if (bytes_read > 0)
    {
        frame_len = binkp_build_data(frame, buffer, bytes_read);
        binkp_queue_frame(session, frame, frame_len);
        ft->offset += bytes_read;
        session->bytes_sent += bytes_read;
        
        /* Update progress bar */
        if (ft->size > 0)
        {
            int percent = (int)((ft->offset * 100) / ft->size);
            ftnstatus_update_progress(percent);
        }
    }

    /* Check if complete */
    if (ft->offset >= ft->size || bytes_read <= 0)
    {
        /* Wait for M_GOT before finishing */
        debug_printf("binkp: File data sent, waiting for M_GOT");
    }
}

void binkp_finish_send_file(MAILER_SESSION *session)
{
    FILE_TRANSFER *ft = &session->send_file;
    QUEUE_NODE *node;

    if (ft->file != NULL)
    {
        fclose(ft->file);
        ft->file = NULL;
    }

    /* Use the queue node we stored when starting the transfer */
    node = (QUEUE_NODE *)ft->queue_node;
    if (node != NULL)
    {
        queue_mark_file_sent(node, ft->local_path);
        ft->queue_node = NULL;
    }
    else
    {
        debug_printf("binkp: WARNING - No queue node for sent file, cannot mark as sent");
    }

    ft->state = TRANSFER_STATE_IDLE;

    ftnstatus_end_transfer();

    debug_printf("binkp: Sent %s successfully", ft->filename);
    mailer_log("Sent: %s (%ld bytes)", ft->filename, ft->size);
    session->files_sent++;

    /* Check if session should complete/restart now that transfer is done */
    if (session->local_eob && session->remote_eob &&
        session->recv_file.state != TRANSFER_STATE_RECEIVING)
    {
        debug_printf("binkp: File sent, both EOBs exchanged - checking for restart");
        binkp_try_session_restart(session);
    }
}

/* ******************************************************************************************************************************************************** */
/* Session Processing                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void binkp_check_for_files(MAILER_SESSION *session)
{
    QUEUE_NODE *node;
    QUEUE_FILE *file;
    int zone;

    if (session->send_file.state != TRANSFER_STATE_IDLE)
    {
        return;  /* Already sending */
    }

    /* Determine which zone we're sending to.
     * For outbound: use target_addr (the uplink we called)
     * For inbound: use remote_addr (who connected to us) */
    if (session->direction == SESSION_DIR_OUTBOUND)
    {
        zone = session->target_addr.zone;
    }
    else
    {
        zone = session->remote_addr.zone;
    }

    debug_printf("binkp: Looking for files to send for zone %d", zone);
    ftnlog_printf("Checking outbound for zone %d", zone);

    /* Get the next file from ANY node in this zone */
    file = queue_get_next_file_for_zone(zone, &node);

    if (file == NULL)
    {
        int pending = queue_count_files_for_zone(zone);
        debug_printf("binkp: No files to send for zone %d (total pending: %d)", zone, pending);
        /* No files to send, send EOB */
        if (!session->local_eob)
        {
            binkp_send_eob(session);
        }
        return;
    }

    debug_printf("binkp: Found file for %d:%d/%d.%d: %s",
                 node->addr.zone, node->addr.net, node->addr.node, node->addr.point,
                 file->path);
    ftnlog_printf("Sending: %s -> %d:%d/%d.%d", 
                  file->name[0] ? file->name : file->path,
                  node->addr.zone, node->addr.net, node->addr.node, node->addr.point);

    if (file->type == QUEUE_FILE_REQ)
    {
        /* Process file request - parse REQ file and send M_GET commands */
        binkp_process_req_file(session, file->path);
        queue_mark_file_sent(node, file->path);
        /* Check for more files */
        binkp_check_for_files(session);
    }
    else
    {
        /* Remember which node this file belongs to for marking sent later */
        session->send_file.queue_node = node;
        binkp_start_send_file(session, file->path);
    }
}

void binkp_process_session(MAILER_SESSION *session)
{
    /* Continue sending file data if in progress */
    if (session->send_file.state == TRANSFER_STATE_SENDING)
    {
        binkp_send_file_data(session);
    }
}

/* ******************************************************************************************************************************************************** */
/* Authentication Helpers                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

/*
 * Convert hex string to binary data.
 * Returns number of bytes converted.
 */
static int hex_to_bin(const char *hex, unsigned char *bin, size_t max_len)
{
    size_t i;
    size_t hex_len = strlen(hex);
    size_t bin_len = hex_len / 2;
    
    if (bin_len > max_len) bin_len = max_len;
    
    for (i = 0; i < bin_len; i++) {
        unsigned int val;
        char tmp[3];
        tmp[0] = hex[i * 2];
        tmp[1] = hex[i * 2 + 1];
        tmp[2] = '\0';
        if (sscanf(tmp, "%x", &val) != 1) {
            return (int)i;
        }
        bin[i] = (unsigned char)val;
    }
    return (int)bin_len;
}

void binkp_generate_challenge(char *buffer, size_t size)
{
    /* Generate random challenge for CRAM-MD5 */
    snprintf(buffer, size, "%08lx%08lx", (long)time(NULL), (long)rand());
}

int binkp_verify_cram_response(const char *challenge, const char *password, const char *response)
{
    char expected[64];
    
    /* Compute expected response */
    binkp_compute_cram_response(challenge, password, expected, sizeof(expected));
    
    /* Compare (skip CRAM-MD5- prefix if present) */
    if (strncmp(response, "CRAM-MD5-", 9) == 0) {
        response += 9;
    }
    
    return strcmp(expected, response) == 0;
}

void binkp_compute_cram_response(const char *challenge, const char *password, char *response, size_t size)
{
    unsigned char challenge_bin[64];
    unsigned char digest[16];
    int challenge_len;
    int i;
    
    /* The challenge from BinkP is a hex string - convert to binary */
    challenge_len = hex_to_bin(challenge, challenge_bin, sizeof(challenge_bin));
    
    /* Compute HMAC-MD5 of challenge using password as key */
    HMAC_MD5((const unsigned char *)password, strlen(password),
             challenge_bin, challenge_len,
             digest);
    
    /* Convert digest to hex string */
    if (size >= 33) {
        for (i = 0; i < 16; i++) {
            sprintf(&response[i * 2], "%02x", digest[i]);
        }
        response[32] = '\0';
    } else {
        response[0] = '\0';
    }
    
    debug_printf("binkp: CRAM-MD5 digest computed: %s", response);
}

/*
 * Look up session password for a remote FTN address.
 * Searches uplink configurations for a matching address.
 * Returns pointer to static password buffer, or empty string if not found.
 */
const char *binkp_get_password_for_node(const FTN_ADDR *addr)
{
    _kernel_swi_regs regs;
    int i;
    char addr_str[64];
    static char password[32];

    /* Format address for comparison */
    ftn_addr_to_string(addr, addr_str, sizeof(addr_str));

    debug_printf("binkp: Looking up password for %s", addr_str);

    /* Get uplink count */
    regs.r[0] = 7;  /* FTN_CONFIG_REASON_COUNT_UPLINKS */
    if (_kernel_swi(0x5AA86, &regs, &regs) != NULL)
    {
        debug_printf("binkp: Failed to get uplink count");
        return "";
    }

    /* Search through uplinks */
    for (i = 1; i <= regs.r[0]; i++)
    {
        _kernel_swi_regs r2;

        r2.r[0] = 4;  /* FTN_CONFIG_REASON_GET_UPLINK */
        r2.r[1] = i;
        if (_kernel_swi(0x5AA86, &r2, &r2) == NULL && r2.r[0] != 0)
        {
            /* Uplink config structure - must match FTN_UPLINK_CONFIG in Support module */
            typedef struct
            {
                int id;
                char address[64];
                char network[64];
                char host[64];
                int port;
                char password[32];
                char groups[64];
            } UPLINK_CFG;

            UPLINK_CFG *uplink = (UPLINK_CFG *)r2.r[0];
            FTN_ADDR uplink_addr;

            /* Parse uplink address and compare */
            if (ftn_string_to_addr(uplink->address, &uplink_addr))
            {
                if (ftn_addr_match(addr, &uplink_addr))
                {
                    debug_printf("binkp: Found password for uplink %d (%s)", i, uplink->address);
                    strncpy(password, uplink->password, sizeof(password) - 1);
                    password[sizeof(password) - 1] = '\0';
                    return password;
                }
            }
        }
    }

    debug_printf("binkp: No uplink password found for %s", addr_str);
    return "";
}

/* ******************************************************************************************************************************************************** */
/* TRF Info (Pending Mail/Files)                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/*
 * Calculate pending mail and file bytes for TRF info.
 */
void binkp_calculate_pending(MAILER_SESSION *session)
{
    int zone;
    
    /* Determine which zone we're working with */
    if (session->direction == SESSION_DIR_OUTBOUND)
    {
        zone = session->target_addr.zone;
    }
    else
    {
        zone = session->remote_addr.zone;
    }
    
    /* Query queue for pending sizes */
    session->trf_mail_bytes = 0;
    session->trf_file_bytes = 0;
    
    /* Simple estimation based on file count - queue module would need
     * enhancement to provide exact byte counts. For now, use count * average. */
    {
        int file_count = queue_count_files_for_zone(zone);
        /* Estimate: average mail packet is ~2KB, average file is ~50KB */
        session->trf_mail_bytes = file_count * 2048;
        session->trf_file_bytes = 0;  /* Separate mail/file tracking not implemented */
    }
    
    debug_printf("binkp: Calculated TRF: %ld mail, %ld files",
                 session->trf_mail_bytes, session->trf_file_bytes);
}

/*
 * Send TRF info to remote.
 */
void binkp_send_trf(MAILER_SESSION *session)
{
    char buf[64];
    
    binkp_calculate_pending(session);
    
    snprintf(buf, sizeof(buf), "%ld %ld", 
             session->trf_mail_bytes, session->trf_file_bytes);
    binkp_send_nul(session, "TRF", buf);
    
    debug_printf("binkp: Sent TRF %s", buf);
    ftnlog_printf(">> TRF: %ld mail, %ld files", 
                   session->trf_mail_bytes, session->trf_file_bytes);
}

/* ******************************************************************************************************************************************************** */
/* M_SKIP During Receive                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

/*
 * Skip the file currently being received.
 * This sends M_SKIP and cleans up the partial receive state.
 */
void binkp_skip_current_file(MAILER_SESSION *session)
{
    FILE_TRANSFER *ft = &session->recv_file;
    
    if (ft->state != TRANSFER_STATE_RECEIVING)
    {
        debug_printf("binkp: skip_current_file called but not receiving");
        return;
    }
    
    debug_printf("binkp: Skipping current file: %s", ft->filename);
    ftnlog_printf(">> SKIP: %s (receiver initiated)", ft->filename);
    
    /* Send M_SKIP */
    binkp_send_skip(session, ft->filename, ft->size, ft->mtime);
    
    /* Close and remove partial file */
    if (ft->file != NULL)
    {
        fclose(ft->file);
        ft->file = NULL;
    }
    
    /* Remove the partial temp file */
    if (ft->local_path[0] != '\0')
    {
        remove(ft->local_path);
    }
    
    /* Reset state */
    ft->state = TRANSFER_STATE_IDLE;
    ft->filename[0] = '\0';
    ft->local_path[0] = '\0';
    ft->size = 0;
    ft->offset = 0;
    
    ftnstatus_end_transfer();
}

/* ******************************************************************************************************************************************************** */
/* Encryption Wrappers                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

/*
 * Initialize encryption for session after authentication.
 * Called after M_OK when both sides support CRYPT.
 */
void binkp_init_session_encryption(MAILER_SESSION *session)
{
    const char *password;
    
    /* Get password for this session's remote node */
    password = binkp_get_password_for_node(&session->remote_addr);
    
    if (password == NULL || password[0] == '\0')
    {
        debug_printf("binkp: Cannot enable encryption without password");
        return;
    }
    
    /* Initialize both encryption and decryption keys with the password */
    crypt_init_keys(session->crypt_keys_in, password);
    crypt_init_keys(session->crypt_keys_out, password);
    
    session->crypt_flag |= BINKP_CRYPT_ACTIVE;
    
    debug_printf("binkp: Encryption activated for session");
    ftnlog_printf("   Encryption activated");
}

/*
 * Initialize encryption for session.
 * Called after M_OK when both sides support CRYPT.
 */
void binkp_crypt_init(MAILER_SESSION *session, const char *password)
{
    if (password == NULL || password[0] == '\0')
    {
        debug_printf("binkp: Cannot init encryption without password");
        return;
    }
    
    /* Initialize both encryption and decryption keys */
    crypt_init_keys(session->crypt_keys_in, password);
    crypt_init_keys(session->crypt_keys_out, password);
    
    session->crypt_flag |= BINKP_CRYPT_ACTIVE;
    
    debug_printf("binkp: Encryption initialized");
    ftnlog_printf("   Encryption activated");
}

/*
 * Encrypt buffer using session keys.
 */
void binkp_encrypt_buf(unsigned char *buf, int len, unsigned long keys[3])
{
    crypt_encrypt_buf(buf, (unsigned int)len, keys);
}

/*
 * Decrypt buffer using session keys.
 */
void binkp_decrypt_buf(unsigned char *buf, int len, unsigned long keys[3])
{
    crypt_decrypt_buf(buf, (unsigned int)len, keys);
}

/* ******************************************************************************************************************************************************** */
/* Compression Wrappers                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/*
 * Initialize compression for sending.
 */
void binkp_compress_init(MAILER_SESSION *session, int type)
{
    session->z_send_type = type;
    session->z_send_len = 0;
    
    debug_printf("binkp: Compression init type %d", type);
}

/*
 * Deinitialize compression.
 */
void binkp_compress_deinit(MAILER_SESSION *session)
{
    session->z_send_type = BINKP_COMPRESS_NONE;
    session->z_send_len = 0;
}

/*
 * Compress data for transmission.
 * Returns bytes written to dst, or -1 on error.
 */
int binkp_compress_data(MAILER_SESSION *session, unsigned char *dst, int *dst_len,
                        const unsigned char *src, int src_len, int finish)
{
    if (session->z_send_type == BINKP_COMPRESS_NONE)
    {
        /* No compression - just copy */
        if (src_len > *dst_len) src_len = *dst_len;
        memcpy(dst, src, src_len);
        *dst_len = src_len;
        return 0;
    }
    
    /* Use compression library */
    return compress_data(session->z_send_type, NULL, dst, dst_len, src, src_len, finish);
}

/*
 * Initialize decompression for receiving.
 */
void binkp_decompress_init(MAILER_SESSION *session, int type)
{
    session->z_recv_type = type;
    session->z_recv_len = 0;
    
    debug_printf("binkp: Decompression init type %d", type);
}

/*
 * Deinitialize decompression.
 */
void binkp_decompress_deinit(MAILER_SESSION *session)
{
    session->z_recv_type = BINKP_COMPRESS_NONE;
    session->z_recv_len = 0;
}

/*
 * Decompress received data.
 * Returns bytes written to dst, or -1 on error.
 */
int binkp_decompress_data(MAILER_SESSION *session, unsigned char *dst, int *dst_len,
                          const unsigned char *src, int src_len)
{
    if (session->z_recv_type == BINKP_COMPRESS_NONE)
    {
        /* No compression - just copy */
        if (src_len > *dst_len) src_len = *dst_len;
        memcpy(dst, src, src_len);
        *dst_len = src_len;
        return 0;
    }
    
    /* Use decompression library */
    return decompress_data(session->z_recv_type, NULL, dst, dst_len, src, src_len);
}
