/* ******************************************************************************************************************************************************** */
/* FTN Mailer - Main Application                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.File.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"

/* TCPIP Includes */
#define COMPAT_INET4 1
#include "sys/types.h"
#include "sys/socket.h"
#include "socklib.h"
#include "inetlib.h"
#include "netinet/in.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netdb.h"

/* Our Includes */
#include "mailer.h"
#include "iconnames.h"
#include "binkp.h"
#include "queue.h"
#include "tosser.h"
#include "scanner.h"
#include "packer.h"
#include "tic.h"
#include "timer.h"
#include "debug.h"
#include "ftnlog.h"

/* ******************************************************************************************************************************************************** */
/* Global Variables                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

WIMP_STATE wimp;
MAILER_STATE mailer;
Desk_window_handle proginfo_window;
Desk_window_handle ftnstatus_window;
Desk_window_handle ftnlog_window;
Desk_window_handle ftnfreq_window;
Desk_menu_ptr mail_menu;
Desk_menu_ptr commands_menu;

/* Iconbar menu entries */
enum
{
    ICONBAR_MENU_INFO = 0,
    ICONBAR_MENU_MAIL,
    ICONBAR_MENU_COMMANDS,
    ICONBAR_MENU_QUIT
};

/* Mail submenu entries */
enum
{
    MAIL_MENU_POLL = 0,
    MAIL_MENU_TOSS,
    MAIL_MENU_SCAN
};

/* Commands submenu entries */
enum
{
    COMMANDS_MENU_FREQ = 0
};

/* ******************************************************************************************************************************************************** */
/* SWI Numbers                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

#define SWI_SUPPORT_FTN     0x5AA86
#define SWI_FILER_LOGGING   0x5AA40

/* Wimp message from Converse Server */
#define MESSAGE_LINE_BROADCAST  0x5AA00

/* ******************************************************************************************************************************************************** */
/* Utility Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

void ftn_addr_to_string(const FTN_ADDR *addr, char *buffer, size_t size)
{
    if (addr->point == 0)
    {
        snprintf(buffer, size, "%d:%d/%d", addr->zone, addr->net, addr->node);
    }
    else
    {
        snprintf(buffer, size, "%d:%d/%d.%d", addr->zone, addr->net, addr->node, addr->point);
    }

    if (addr->domain[0] != '\0')
    {
        size_t len = strlen(buffer);
        snprintf(buffer + len, size - len, "@%s", addr->domain);
    }
}

int ftn_string_to_addr(const char *str, FTN_ADDR *addr)
{
    const char *p = str;
    char *end;

    memset(addr, 0, sizeof(FTN_ADDR));

    /* Parse zone:net/node.point@domain */
    addr->zone = (int)strtol(p, &end, 10);
    if (*end != ':') return 0;
    p = end + 1;

    addr->net = (int)strtol(p, &end, 10);
    if (*end != '/') return 0;
    p = end + 1;

    addr->node = (int)strtol(p, &end, 10);
    p = end;

    if (*p == '.')
    {
        p++;
        addr->point = (int)strtol(p, &end, 10);
        p = end;
    }

    if (*p == '@')
    {
        p++;
        strncpy(addr->domain, p, sizeof(addr->domain) - 1);
    }

    return 1;
}

int ftn_addr_match(const FTN_ADDR *a, const FTN_ADDR *b)
{
    return (a->zone == b->zone &&
            a->net == b->net &&
            a->node == b->node &&
            a->point == b->point);
}

/* ******************************************************************************************************************************************************** */
/* Logging                                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

static void mailer_log_ftn(const char *format, ...)
{
    char buffer[512];
    va_list args;
    _kernel_swi_regs regs;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    /* Log via Filer module */
    regs.r[0] = 3;  /* FILER_LOG_CMD_FTN */
    regs.r[1] = (int)buffer;
    _kernel_swi(SWI_FILER_LOGGING, &regs, &regs);

    debug_printf("FTN: %s", buffer);
}

void mailer_log(const char *format, ...)
{
    char buffer[512];
    va_list args;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    mailer_log_ftn("%s", buffer);
}

/* ******************************************************************************************************************************************************** */
/* FTN Status Window                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

/*
 * Open the ftnstatus window positioned at bottom-left, just above iconbar.
 * Sets the operation text from the message tag.
 */
static void ftnstatus_open(const char *operation_msg_tag)
{
    char operation[64];
    Desk_window_state state;
    int win_width, win_height;
    
    /* Look up operation string from Messages file */
    Desk_Msgs_Lookup(operation_msg_tag, operation, sizeof(operation));
    
    /* Set operation text */
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_OPERATION, operation);
    
    /* Clear status */
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_STATUS, "");
    
    /* Position window at bottom-left, just above iconbar */
    Desk_Wimp_GetWindowState(ftnstatus_window, &state);
    win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
    win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
    
    state.openblock.screenrect.min.x = 16;
    state.openblock.screenrect.max.x = 16 + win_width;
    state.openblock.screenrect.min.y = 134;  /* Just above iconbar (128) + margin */
    state.openblock.screenrect.max.y = 134 + win_height;
    state.openblock.behind = -1;  /* Open at front */
    
    Desk_Wimp_OpenWindow(&state.openblock);
    
    /* Force a redraw so user sees it immediately */
    {
        Desk_event_pollblock event;
        Desk_event_pollmask mask;
        mask.value = 0;
        Desk_Wimp_Poll3(mask, &event, NULL);
    }
}

/*
 * Update the status text in the ftnstatus window.
 */
static void ftnstatus_update(const char *status)
{
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_STATUS, (char *)status);
    
    /* Force a redraw so user sees update */
    {
        Desk_event_pollblock event;
        Desk_event_pollmask mask;
        mask.value = 0;
        Desk_Wimp_Poll3(mask, &event, NULL);
    }
}

/*
 * Set the ftnstatus window to idle state.
 * Shows "Idle..." and "Waiting for connection."
 */
static void ftnstatus_set_idle(void)
{
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_OPERATION, "Idle...");
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_STATUS, "Waiting for connection.");
    
    /* Reset progress bar to minimum width */
    {
        Desk_icon_block icon;
        Desk_icon_createblock createblock;
        Desk_icon_handle new_icon;
        
        Desk_Wimp_GetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, &icon);
        icon.workarearect.max.x = icon.workarearect.min.x + 20;
        Desk_Wimp_SetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, 0, 0);
        Desk_Wimp_DeleteIcon(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER);
        
        createblock.window = ftnstatus_window;
        createblock.icondata = icon;
        Desk_Wimp_CreateIcon(&createblock, &new_icon);
    }
    
    /* Force a redraw so user sees update */
    {
        Desk_event_pollblock event;
        Desk_event_pollmask mask;
        mask.value = 0;
        Desk_Wimp_Poll3(mask, &event, NULL);
    }
}

/* Progress bar constants */
#define FTNSTATUS_PROGRESS_MIN_WIDTH 20
#define FTNSTATUS_PROGRESS_MAX_WIDTH 776

/*
 * Start a file transfer display.
 * Sets operation to "Transferring..." and status to direction + filename.
 */
void ftnstatus_start_transfer(int is_sending, const char *filename)
{
    char status[128];
    Desk_icon_block icon;
    
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_OPERATION, "Transferring...");
    
    snprintf(status, sizeof(status), "%s: %s", 
             is_sending ? "Sending" : "Receiving", filename);
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_STATUS, status);
    
    /* Reset progress bar to minimum */
    {
        Desk_icon_createblock createblock;
        Desk_icon_handle new_icon;
        
        Desk_Wimp_GetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, &icon);
        icon.workarearect.max.x = icon.workarearect.min.x + FTNSTATUS_PROGRESS_MIN_WIDTH;
        Desk_Wimp_SetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, 0, 0);
        Desk_Wimp_DeleteIcon(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER);
        
        createblock.window = ftnstatus_window;
        createblock.icondata = icon;
        Desk_Wimp_CreateIcon(&createblock, &new_icon);
    }
    
    /* Force redraw */
    {
        Desk_event_pollblock event;
        Desk_event_pollmask mask;
        mask.value = 0;
        Desk_Wimp_Poll3(mask, &event, NULL);
    }
}

/*
 * Update file transfer progress.
 * percent should be 0-100.
 */
void ftnstatus_update_progress(int percent)
{
    Desk_icon_block icon;
    Desk_icon_createblock createblock;
    Desk_icon_handle new_icon;
    int width;
    
    if (percent < 0) percent = 0;
    if (percent > 100) percent = 100;
    
    /* Calculate new width based on percentage */
    width = FTNSTATUS_PROGRESS_MIN_WIDTH + 
            ((FTNSTATUS_PROGRESS_MAX_WIDTH - FTNSTATUS_PROGRESS_MIN_WIDTH) * percent) / 100;
    
    /* Update the icon width */
    Desk_Wimp_GetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, &icon);
    icon.workarearect.max.x = icon.workarearect.min.x + width;
    Desk_Wimp_SetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, 0, 0);
    Desk_Wimp_DeleteIcon(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER);
    
    createblock.window = ftnstatus_window;
    createblock.icondata = icon;
    Desk_Wimp_CreateIcon(&createblock, &new_icon);
}

/*
 * End file transfer display, resetting progress bar.
 */
void ftnstatus_end_transfer(void)
{
    Desk_icon_block icon;
    Desk_icon_createblock createblock;
    Desk_icon_handle new_icon;
    
    /* Reset progress bar to minimum */
    Desk_Wimp_GetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, &icon);
    icon.workarearect.max.x = icon.workarearect.min.x + FTNSTATUS_PROGRESS_MIN_WIDTH;
    Desk_Wimp_SetIconState(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER, 0, 0);
    Desk_Wimp_DeleteIcon(ftnstatus_window, FTNSTATUS_PROGRESSCOUNTER);
    
    createblock.window = ftnstatus_window;
    createblock.icondata = icon;
    Desk_Wimp_CreateIcon(&createblock, &new_icon);
}

/*
 * Open the ftnstatus window in idle state at bottom-left.
 */
static void ftnstatus_open_idle(void)
{
    Desk_window_state state;
    int win_width, win_height;
    
    /* Set idle text */
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_OPERATION, "Idle...");
    Desk_Icon_SetText(ftnstatus_window, FTNSTATUS_STATUS, "Waiting for connection.");
    
    /* Position window at bottom-left, just above iconbar */
    Desk_Wimp_GetWindowState(ftnstatus_window, &state);
    win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
    win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
    
    state.openblock.screenrect.min.x = 16;
    state.openblock.screenrect.max.x = 16 + win_width;
    state.openblock.screenrect.min.y = 134;  /* Just above iconbar (128) + margin */
    state.openblock.screenrect.max.y = 134 + win_height;
    state.openblock.behind = -1;  /* Open at front */
    
    Desk_Wimp_OpenWindow(&state.openblock);
}

/* ******************************************************************************************************************************************************** */
/* FREQ (File Request) Functions                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/*
 * Create a .REQ file for file request.
 * The file is created in the outbound directory for the target FTN address.
 * Returns 1 on success, 0 on failure.
 */
static int ftnfreq_create_request(const char *filename, const char *address)
{
    FTN_ADDR dest_addr;
    char req_path[MAILER_PATH_SIZE];
    FILE *fp;

    /* Parse the FTN address */
    if (!ftn_string_to_addr(address, &dest_addr))
    {
        debug_printf("ftnfreq: Failed to parse address: %s", address);
        return 0;
    }

    debug_printf("ftnfreq: Parsed address: zone=%d net=%d node=%d point=%d",
                 dest_addr.zone, dest_addr.net, dest_addr.node, dest_addr.point);

    /* Ensure zone-specific outbound directories exist and build the REQ filename */
    queue_ensure_outbound_directories(&dest_addr);
    queue_format_outbound_name(req_path, sizeof(req_path), &dest_addr, "req");

    debug_printf("ftnfreq: Creating REQ file: %s", req_path);
    
    /* Create/append to the REQ file */
    fp = fopen(req_path, "a");
    if (fp == NULL)
    {
        debug_printf("ftnfreq: Failed to create REQ file: %s", req_path);
        return 0;
    }
    
    /* Write the filename to request (one per line) */
    fprintf(fp, "%s\n", filename);
    fclose(fp);
    
    /* Set filetype to text (0xFFF) */
    {
        _kernel_swi_regs fr;
        fr.r[0] = 18;  /* Set filetype */
        fr.r[1] = (int)req_path;
        fr.r[2] = 0xFFF;
        _kernel_swi(OS_File, &fr, &fr);
    }
    
    mailer_log("FREQ: Requested '%s' from %s", filename, address);
    ftnlog_printf("FREQ: %s from %s", filename, address);
    
    return 1;
}

/*
 * Handle click events in the FREQ window.
 */
static Desk_bool ftnfreq_handle_click(Desk_event_pollblock *event, void *ref)
{
    Desk_icon_handle icon;
    
    Desk_UNUSED(ref);
    
    if (event->data.mouse.window != ftnfreq_window)
        return Desk_bool_FALSE;
    
    icon = event->data.mouse.icon;
    
    if (icon == FTNFREQ_REQUEST)
    {
        char filename[128];
        char address[64];
        char *ptr;
        
        /* Get text from writable icons using GetTextPtr for indirected icons */
        ptr = Desk_Icon_GetTextPtr(ftnfreq_window, FTNFREQ_FILENAME);
        if (ptr != NULL)
        {
            strncpy(filename, ptr, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        else
        {
            filename[0] = '\0';
        }
        
        ptr = Desk_Icon_GetTextPtr(ftnfreq_window, FTNFREQ_FROMADDRESS);
        if (ptr != NULL)
        {
            strncpy(address, ptr, sizeof(address) - 1);
            address[sizeof(address) - 1] = '\0';
        }
        else
        {
            address[0] = '\0';
        }
        
        debug_printf("ftnfreq: FILENAME icon %d = '%s'", FTNFREQ_FILENAME, filename);
        debug_printf("ftnfreq: FROMADDRESS icon %d = '%s'", FTNFREQ_FROMADDRESS, address);
        
        if (filename[0] != '\0' && address[0] != '\0')
        {
            if (ftnfreq_create_request(filename, address))
            {
                /* Clear the filename field on success */
                Desk_Icon_SetText(ftnfreq_window, FTNFREQ_FILENAME, "");
                
                /* Close window */
                Desk_Window_Hide(ftnfreq_window);
            }
        }
        else
        {
            debug_printf("ftnfreq: Empty filename or address");
        }
        
        return Desk_bool_TRUE;
    }
    else if (icon == FTNFREQ_CANCEL)
    {
        /* Just close the window */
        Desk_Window_Hide(ftnfreq_window);;
        return Desk_bool_TRUE;
    }
    
    return Desk_bool_FALSE;
}

/* ******************************************************************************************************************************************************** */
/* Configuration                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

void mailer_load_config(void)
{
    _kernel_swi_regs regs;
    int i;

    debug_printf("mailer: Loading configuration from Support module");

    /* Get FTN config from Support module */
    regs.r[0] = 0;  /* FTN_CONFIG_REASON_GET_GLOBAL */
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) == NULL && regs.r[0] != 0)
    {
        /* FTN_GLOBAL_CONFIG structure */
        typedef struct
        {
            char sysop[64];
            char system[64];
            char location[64];
            char phone[64];
            int speed;
            char flags[64];
            char inbound[256];
            char outbound[256];
            char netmail[256];
            char badmail[256];
            char ticpath[256];
            long max_packet_size;
            int listen_port;
            int max_sessions;
            int connect_timeout;
            int session_timeout;
            int scan_interval;
            int toss_interval;
            int poll_interval;
            int retry_delay;
            int address_count;
            /* Followed by addresses and uplinks */
        } FTN_GLOBAL_CONFIG;

        FTN_GLOBAL_CONFIG *cfg = (FTN_GLOBAL_CONFIG *)regs.r[0];

        strncpy(mailer.sysop, cfg->sysop, sizeof(mailer.sysop) - 1);
        strncpy(mailer.system_name, cfg->system, sizeof(mailer.system_name) - 1);
        strncpy(mailer.location, cfg->location, sizeof(mailer.location) - 1);
        mailer.speed = cfg->speed;
        strncpy(mailer.flags, cfg->flags, sizeof(mailer.flags) - 1);
        strncpy(mailer.inbound_path, cfg->inbound, sizeof(mailer.inbound_path) - 1);
        strncpy(mailer.outbound_path, cfg->outbound, sizeof(mailer.outbound_path) - 1);
        strncpy(mailer.netmail_path, cfg->netmail, sizeof(mailer.netmail_path) - 1);
        strncpy(mailer.badmail_path, cfg->badmail, sizeof(mailer.badmail_path) - 1);
        if (cfg->ticpath[0] != '\0')
        {
            strncpy(mailer.tic_path, cfg->ticpath, sizeof(mailer.tic_path) - 1);
        }

        mailer.listen_port = (cfg->listen_port > 0) ? cfg->listen_port : BINKP_DEFAULT_PORT;

        if (cfg->max_sessions > 0 && cfg->max_sessions <= MAILER_MAX_SESSIONS)
        {
            mailer.max_sessions = cfg->max_sessions;
        }
        else
        {
            mailer.max_sessions = MAILER_MAX_SESSIONS;
        }

        mailer.connect_timeout = (cfg->connect_timeout > 0) ? cfg->connect_timeout : 60;
        mailer.session_timeout = (cfg->session_timeout > 0) ? cfg->session_timeout : 300;
        mailer.scan_interval = (cfg->scan_interval > 0) ? cfg->scan_interval : 60;
        mailer.toss_interval = cfg->toss_interval;  /* 0 = disabled */
        mailer.poll_interval = cfg->poll_interval;  /* 0 = disabled */
        mailer.retry_delay = (cfg->retry_delay > 0) ? cfg->retry_delay : 300;
        queue_set_scan_interval(mailer.scan_interval);

        debug_printf("mailer: System: %s, Sysop: %s", mailer.system_name, mailer.sysop);
        debug_printf("mailer: Inbound: %s", mailer.inbound_path);
        debug_printf("mailer: Outbound: %s", mailer.outbound_path);
        debug_printf("mailer: Netmail: %s", mailer.netmail_path);
        debug_printf("mailer: Badmail: %s", mailer.badmail_path);
        debug_printf("mailer: TIC path: %s", mailer.tic_path);
        debug_printf("mailer: Intervals: scan=%d, toss=%d, poll=%d",
                     mailer.scan_interval, mailer.toss_interval, mailer.poll_interval);

        /* Get addresses */
        for (i = 0; i < 8; i++)
        {
            regs.r[0] = 2;  /* FTN_CONFIG_REASON_GET_ADDRESS */
            regs.r[1] = i + 1;
            if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) == NULL && regs.r[0] != 0)
            {
                /* FTN_ADDRESS_CONFIG structure */
                typedef struct
                {
                    int id;
                    char network[64];
                    int zone, net, node, point;
                    char type[8];
                    char packet_password[32];
                    char areafix_password[32];
                } FTN_ADDRESS_CONFIG;

                FTN_ADDRESS_CONFIG *addr_cfg = (FTN_ADDRESS_CONFIG *)regs.r[0];

                if (addr_cfg->id > 0)
                {
                    mailer.our_addrs[mailer.our_addr_count].zone = addr_cfg->zone;
                    mailer.our_addrs[mailer.our_addr_count].net = addr_cfg->net;
                    mailer.our_addrs[mailer.our_addr_count].node = addr_cfg->node;
                    mailer.our_addrs[mailer.our_addr_count].point = addr_cfg->point;
                    strncpy(mailer.our_addrs[mailer.our_addr_count].domain, addr_cfg->network,
                            sizeof(mailer.our_addrs[mailer.our_addr_count].domain) - 1);
                    mailer.our_addr_count++;

                    debug_printf("mailer: Address %d: %d:%d/%d.%d@%s",
                                 addr_cfg->id, addr_cfg->zone, addr_cfg->net,
                                 addr_cfg->node, addr_cfg->point, addr_cfg->network);
                }
            }
        }
    }
    else
    {
        debug_printf("mailer: Failed to get FTN config from Support module");

        /* Set defaults */
        strcpy(mailer.system_name, "Converse BBS");
        strcpy(mailer.sysop, "Sysop");
        strcpy(mailer.location, "Unknown");
        mailer.speed = 115200;
        strcpy(mailer.inbound_path, "<Converse$Dir>.FTN.Inbound");
        strcpy(mailer.outbound_path, "<Converse$Dir>.FTN.Outbound");
        strcpy(mailer.netmail_path, "<Converse$Dir>.FTN.Netmail");
        strcpy(mailer.badmail_path, "<Converse$Dir>.FTN.Bad");
    }

    if (mailer.netmail_path[0] == '\0')
    {
        strcpy(mailer.netmail_path, "<Converse$Dir>.FTN.Netmail");
    }
    if (mailer.badmail_path[0] == '\0')
    {
        strcpy(mailer.badmail_path, "<Converse$Dir>.FTN.Bad");
    }

}

/* ******************************************************************************************************************************************************** */
/* Listener Management                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

int mailer_create_listener(void)
{
    struct sockaddr_in addr;
    int yes = 1;

    mailer.listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (mailer.listen_socket < 0)
    {
        debug_printf("mailer: Failed to create listener socket");
        return 0;
    }

    setsockopt(mailer.listen_socket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons((unsigned short)mailer.listen_port);

    if (bind(mailer.listen_socket, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        debug_printf("mailer: Failed to bind to port %d", mailer.listen_port);
        socketclose(mailer.listen_socket);
        mailer.listen_socket = -1;
        return 0;
    }

    if (listen(mailer.listen_socket, 5) < 0)
    {
        debug_printf("mailer: Failed to listen");
        socketclose(mailer.listen_socket);
        mailer.listen_socket = -1;
        return 0;
    }

    /* Set non-blocking */
    {
        int flags = 1;
        socketioctl(mailer.listen_socket, FIONBIO, &flags);
    }

    mailer.listener_active = 1;
    mailer_log_ftn("Listening on port %d", mailer.listen_port);

    return 1;
}

void mailer_destroy_listener(void)
{
    if (mailer.listen_socket >= 0)
    {
        socketclose(mailer.listen_socket);
        mailer.listen_socket = -1;
    }
    mailer.listener_active = 0;
}

void mailer_accept_connection(void)
{
    struct sockaddr_in client_addr;
    int client_addr_len = sizeof(client_addr);
    int client_socket;
    MAILER_SESSION *session;

    client_socket = accept(mailer.listen_socket,
                           (struct sockaddr *)&client_addr, &client_addr_len);

    if (client_socket < 0)
    {
        return;  /* No connection waiting */
    }

    session = mailer_allocate_session();
    if (session == NULL)
    {
        /* No free sessions */
        debug_printf("mailer: No free sessions, rejecting connection");

        /* Send BSY and close */
        {
            unsigned char frame[64];
            int len = binkp_build_command(frame, BINKP_M_BSY, "No free sessions");
            send(client_socket, frame, len, 0);
        }

        socketclose(client_socket);
        return;
    }

    /* Set non-blocking */
    {
        int flags = 1;
        socketioctl(client_socket, FIONBIO, &flags);
    }

    session->socket = client_socket;
    session->direction = SESSION_DIR_INBOUND;
    session->state = SESSION_STATE_WAIT_NUL;
    session->connect_time = time(NULL);
    session->last_activity = session->connect_time;

    /* Get remote hostname */
    strncpy(session->remote_hostname, inet_ntoa(client_addr.sin_addr),
            sizeof(session->remote_hostname) - 1);

    /* Open status window for incoming call */
    ftnstatus_open("ftn.incoming");
    ftnstatus_update(session->remote_hostname);
    ftnlog_printf("Incoming connection from %s", session->remote_hostname);

    mailer_log_ftn("Incoming connection from %s", session->remote_hostname);
    mailer.total_sessions++;

    /* Send our handshake */
    binkp_send_handshake(session);
}

/* ******************************************************************************************************************************************************** */
/* Session Management                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

MAILER_SESSION *mailer_allocate_session(void)
{
    int i;

    if (mailer.max_sessions <= 0)
    {
        mailer.max_sessions = 1;
    }

    if (mailer.active_sessions >= mailer.max_sessions)
    {
        debug_printf("mailer: Active session limit reached (%d)", mailer.max_sessions);
        return NULL;
    }

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        if (!mailer.sessions[i].active)
        {
            memset(&mailer.sessions[i], 0, sizeof(MAILER_SESSION));
            mailer.sessions[i].active = 1;
            mailer.sessions[i].socket = -1;
            mailer.active_sessions++;
            return &mailer.sessions[i];
        }
    }

    return NULL;
}

void mailer_free_session(MAILER_SESSION *session)
{
    if (session->socket >= 0)
    {
        socketclose(session->socket);
    }

    if (session->send_file.file != NULL)
    {
        fclose(session->send_file.file);
    }

    if (session->recv_file.file != NULL)
    {
        fclose(session->recv_file.file);
    }

    /* Update queue */
    queue_mark_node_busy(&session->remote_addr, 0);

    session->active = 0;
    mailer.active_sessions--;
}

void mailer_close_session(MAILER_SESSION *session, const char *reason)
{
    char addr_str[64];
    int received_files = session->files_received;
    FTN_ADDR remote_addr = session->remote_addr;  /* Save before freeing */

    ftn_addr_to_string(&session->remote_addr, addr_str, sizeof(addr_str));

    mailer_log_ftn("Session closed with %s: %s (sent %d files/%ld bytes, recv %d files/%ld bytes)",
            addr_str, reason,
            session->files_sent, session->bytes_sent,
            session->files_received, session->bytes_received);

    /* Update statistics */
    mailer.total_files_sent += session->files_sent;
    mailer.total_files_received += session->files_received;
    mailer.total_bytes_sent += session->bytes_sent;
    mailer.total_bytes_received += session->bytes_received;

    mailer_free_session(session);

    /* Schedule next poll for this node - don't poll again immediately */
    /* Wait 5 minutes (300 seconds) before polling this uplink again */
    {
        QUEUE_NODE *node = queue_find_node(&remote_addr);
        if (node != NULL)
        {
            int delay = (mailer.retry_delay > 0) ? mailer.retry_delay : 300;
            node->next_poll = time(NULL) + delay;
            debug_printf("mailer: Next poll for %s in %d seconds", addr_str, delay);
        }
    }

    /* Auto-toss if we received any files */
    if (received_files > 0)
    {
        int tossed = tosser_process_inbound();
        if (tossed > 0)
        {
            mailer_log_ftn("Auto-tossed %d messages", tossed);
        }
        
        /* Process TIC files for file distribution */
        tossed = tic_process_inbound();
        if (tossed > 0)
        {
            mailer_log_ftn("Processed %d TIC files", tossed);
        }
    }

    /* Reset status window to idle state */
    ftnstatus_set_idle();
}

/* ******************************************************************************************************************************************************** */
/* Session Processing                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

static void process_session_rx(MAILER_SESSION *session)
{
    fd_set readfds;
    struct timeval tv;
    int select_result;
    int bytes;
    int loops = 0;
    const int MAX_LOOPS = 10;  /* Prevent infinite loop */

    /* First check if data is available using select() */
    FD_ZERO(&readfds);
    FD_SET(session->socket, &readfds);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    
    select_result = select(session->socket + 1, &readfds, NULL, NULL, &tv);
    
    if (select_result < 0)
    {
        /* select() error */
        if (errno != EINTR)
        {
            debug_printf("mailer: select() error on rx: errno=%d (%s) state=%d", 
                         errno, _inet_err(), session->state);
        }
        return;
    }
    
    if (select_result == 0)
    {
        /* No data ready yet - this is normal for non-blocking */
        return;
    }

    /* Read all available data until EWOULDBLOCK (per RISC OS documentation) */
    while (loops < MAX_LOOPS)
    {
        loops++;
        
        /* Check if buffer has space */
        if (session->rx_length >= (int)sizeof(session->rx_buffer))
        {
            debug_printf("mailer: RX buffer full!");
            break;
        }
        
        /* Read data */
        bytes = socketread(session->socket,
                           &session->rx_buffer[session->rx_length],
                           sizeof(session->rx_buffer) - session->rx_length);

        if (bytes > 0)
        {
            session->rx_length += bytes;
            /* Continue reading - there may be more data */
        }
        else if (bytes == 0)
        {
            /* Connection closed by remote */
            ftnlog_printf("Remote closed connection");
            session->state = SESSION_STATE_CLOSING;
            return;
        }
        else
        {
            /* bytes < 0 - error or would-block */
            if (errno == EWOULDBLOCK || errno == EAGAIN)
            {
                /* No more data available - this is normal, exit the read loop */
                break;
            }
            else
            {
                /* Real error */
                debug_printf("mailer: Socket read error errno=%d (%s) state=%d", 
                             errno, _inet_err(), session->state);
                session->state = SESSION_STATE_ERROR;
                return;
            }
        }
    }

    /* Process complete frames */
    while (session->rx_length > 0 && binkp_frame_complete(session->rx_buffer, session->rx_length))
    {
        BINKP_FRAME frame;
        int consumed = binkp_parse_frame(session->rx_buffer, session->rx_length, &frame);

        if (consumed > 0)
        {
            binkp_handle_frame(session, &frame);

            /* Remove processed data from buffer */
            if (consumed < session->rx_length)
            {
                memmove(session->rx_buffer, &session->rx_buffer[consumed],
                        session->rx_length - consumed);
            }
            session->rx_length -= consumed;
        }
        else
        {
            break;
        }
    }
}

static void process_session_tx(MAILER_SESSION *session)
{
    fd_set writefds;
    struct timeval tv;
    int select_result;
    int bytes;

    if (session->tx_length <= session->tx_offset)
    {
        return;  /* Nothing to send */
    }

    /* First check if socket is ready for writing using select() */
    FD_ZERO(&writefds);
    FD_SET(session->socket, &writefds);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    
    select_result = select(session->socket + 1, NULL, &writefds, NULL, &tv);
    if (select_result <= 0)
    {
        /* Not ready or error */
        if (select_result < 0 && errno != EINTR)
        {
            debug_printf("mailer: select() error on tx: errno=%d (%s)", errno, _inet_err());
        }
        return;
    }

    /* Socket is ready - send data */
    bytes = socketwrite(session->socket,
                        &session->tx_buffer[session->tx_offset],
                        session->tx_length - session->tx_offset);

    if (bytes > 0)
    {
        session->tx_offset += bytes;

        /* Reset buffer if all sent */
        if (session->tx_offset >= session->tx_length)
        {
            session->tx_offset = 0;
            session->tx_length = 0;
        }
    }
    else if (errno != EWOULDBLOCK && errno != EAGAIN)
    {
        debug_printf("mailer: Socket write error errno=%d (%s)", errno, _inet_err());
        session->state = SESSION_STATE_ERROR;
    }
}

void mailer_process_sessions(void)
{
    int i;

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        MAILER_SESSION *session = &mailer.sessions[i];

        if (!session->active)
        {
            continue;
        }

        /* Handle based on state */
        switch (session->state)
        {
            case SESSION_STATE_CONNECTING:
                /* Use select() to check if socket is ready for writing (connection complete) */
                {
                    fd_set writefds, exceptfds;
                    struct timeval tv;
                    int select_result;
                    
                    FD_ZERO(&writefds);
                    FD_ZERO(&exceptfds);
                    FD_SET(session->socket, &writefds);
                    FD_SET(session->socket, &exceptfds);
                    
                    /* Zero timeout for non-blocking check */
                    tv.tv_sec = 0;
                    tv.tv_usec = 0;
                    
                    select_result = select(session->socket + 1, NULL, &writefds, &exceptfds, &tv);
                    
                    if (select_result > 0)
                    {
                        if (FD_ISSET(session->socket, &exceptfds))
                        {
                            /* Exception - connection failed */
                            debug_printf("mailer: select() reports exception on socket");
                            ftnlog_printf("Connection failed to %s", session->remote_hostname);
                            session->state = SESSION_STATE_ERROR;
                        }
                        else if (FD_ISSET(session->socket, &writefds))
                        {
                            /* Socket is writable - check for connection error */
                            int so_error = 0;
                            socklen_t so_len = sizeof(so_error);
                            
                            if (getsockopt(session->socket, SOL_SOCKET, SO_ERROR, &so_error, &so_len) == 0 &&
                                so_error == 0)
                            {
                                /* Connected successfully - start handshake */
                                session->state = SESSION_STATE_WAIT_NUL;
                                session->last_activity = time(NULL);
                                ftnlog_printf("Connected to %s", session->remote_hostname);
                                mailer_log_ftn("Connected to %s", session->remote_hostname);

                                /* Start BinkP handshake */
                                binkp_send_handshake(session);
                            }
                            else
                            {
                                debug_printf("mailer: getsockopt SO_ERROR=%d", so_error);
                                ftnlog_printf("Connection failed to %s (err %d)", session->remote_hostname, so_error);
                                session->state = SESSION_STATE_ERROR;
                            }
                        }
                    }
                    else if (select_result < 0)
                    {
                        /* select() error */
                        debug_printf("mailer: select() error errno=%d (%s)", errno, _inet_err());
                        if (errno != EINTR)
                        {
                            session->state = SESSION_STATE_ERROR;
                        }
                    }
                    /* select_result == 0 means no change yet, keep waiting */
                }
                break;

            case SESSION_STATE_CLOSING:
            case SESSION_STATE_ERROR:
                {
                    const char *reason;
                    if (session->state == SESSION_STATE_ERROR) {
                        reason = "Error";
                    } else if (session->authenticated) {
                        reason = "Complete";
                    } else {
                        reason = "Auth failed";
                    }
                    mailer_close_session(session, reason);
                }
                break;

            default:
                /* Process I/O */
                process_session_rx(session);
                process_session_tx(session);

                /* BinkP session processing */
                binkp_process_session(session);
                break;
        }
    }
}

void mailer_check_timeouts(void)
{
    int i;
    time_t now = time(NULL);

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        MAILER_SESSION *session = &mailer.sessions[i];

        if (!session->active)
        {
            continue;
        }

        /* Abort stalled outbound connects before they consume the session budget */
        if (session->state == SESSION_STATE_CONNECTING)
        {
            if (mailer.connect_timeout > 0 && now - session->connect_time > mailer.connect_timeout)
            {
                const char *host = (session->remote_hostname[0] != '\0') ? session->remote_hostname : "unknown";
                mailer_log_ftn("Connect timeout waiting for %s", host);
                ftnlog_printf("Connect timeout: %s", host);
                session->state = SESSION_STATE_ERROR;
            }
            continue;
        }

        /* Check for session timeout */
        if (mailer.session_timeout > 0 && now - session->last_activity > mailer.session_timeout)
        {
            const char *host = (session->remote_hostname[0] != '\0') ? session->remote_hostname : "unknown";
            mailer_log_ftn("Session timeout (%s)", host);
            ftnlog_printf("Session timeout: %s", host);
            binkp_send_err(session, "Timeout");
            session->state = SESSION_STATE_ERROR;
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Outbound Polling                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int mailer_connect_to_node(const FTN_ADDR *addr, const char *hostname, int port)
{
    MAILER_SESSION *session;
    struct sockaddr_in server_addr;
    struct hostent *host;
    int sock;
    char addr_str[64];

    ftn_addr_to_string(addr, addr_str, sizeof(addr_str));

    session = mailer_allocate_session();
    if (session == NULL)
    {
        debug_printf("mailer: No free sessions for outbound");
        return 0;
    }

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0)
    {
        debug_printf("mailer: Failed to create socket");
        mailer_free_session(session);
        return 0;
    }

    /* Resolve hostname */
    host = gethostbyname(hostname);
    if (host == NULL)
    {
        debug_printf("mailer: Failed to resolve %s", hostname);
        socketclose(sock);
        mailer_free_session(session);
        return 0;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    memcpy(&server_addr.sin_addr, host->h_addr, host->h_length);
    server_addr.sin_port = htons(port);

    /* Set non-blocking before connect */
    {
        int flags = 1;
        socketioctl(sock, FIONBIO, &flags);
    }

    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        if (errno != EINPROGRESS && errno != EWOULDBLOCK)
        {
            debug_printf("mailer: Connect failed to %s:%d", hostname, port);
            socketclose(sock);
            mailer_free_session(session);
            return 0;
        }
    }

    session->socket = sock;
    session->direction = SESSION_DIR_OUTBOUND;
    session->state = SESSION_STATE_CONNECTING;
    session->remote_addr = *addr;
    session->target_addr = *addr;  /* Save target for password lookup */
    session->connect_time = time(NULL);
    session->last_activity = session->connect_time;
    strncpy(session->remote_hostname, hostname, sizeof(session->remote_hostname) - 1);

    /* Mark node as busy */
    queue_mark_node_busy(addr, 1);

    /* Log to connection window */
    ftnlog_printf("Connecting to %s:%d", hostname, port);
    ftnlog_printf("Node: %s", addr_str);

    mailer_log_ftn("Connecting to %s (%s:%d)", addr_str, hostname, port);
    mailer.total_sessions++;

    return 1;
}

/*
 * Poll all configured uplinks.
 * This connects to each uplink in sequence, waiting for each session
 * to complete before moving to the next.
 * Called on startup and when user clicks Poll menu.
 */
void mailer_poll_all_uplinks(void)
{
    int i;
    int poll_count = 0;

    /* Re-entry guard: prevent recursive calls during Wimp_Poll dispatch */
    if (mailer.polling_in_progress)
    {
        debug_printf("mailer: Poll already in progress, ignoring re-entry");
        return;
    }
    mailer.polling_in_progress = 1;

    debug_printf("mailer: Polling all uplinks... node_count=%d", outbound_queue.node_count);
    ftnlog_printf("Found %d nodes in queue", outbound_queue.node_count);

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        QUEUE_NODE *node = &outbound_queue.nodes[i];
        char addr_str[64];
        int zone_files;

        ftn_addr_to_string(&node->addr, addr_str, sizeof(addr_str));

        /* Only poll configured uplinks, not destination nodes */
        if (!node->is_uplink)
        {
            debug_printf("mailer: Skipping %s (not an uplink, just a destination)", addr_str);
            continue;
        }

        /* Skip nodes without hostname */
        if (node->hostname[0] == '\0')
        {
            ftnlog_printf("Skipping %s (no hostname)", addr_str);
            continue;
        }

        /* Count files for this node's zone */
        zone_files = queue_count_files_for_zone(node->addr.zone);
        ftnlog_printf("Uplink %s -> %s:%d (%d files in zone %d)", 
                      addr_str, node->hostname, node->port,
                      zone_files, node->addr.zone);

        /* Wait for any active session to complete */
        while (mailer.active_sessions > 0)
        {
            Desk_event_pollblock event;
            Desk_event_pollmask mask;
            mask.value = 0;
            Desk_Wimp_Poll3(mask, &event, NULL);
            Desk_Event_Process(&event);
        }

        /* Connect to this node */
        ftnlog_printf("Polling %s", addr_str);
        if (mailer_connect_to_node(&node->addr, node->hostname, node->port))
        {
            poll_count++;

            /* Wait for this session to complete */
            while (mailer.active_sessions > 0)
            {
                Desk_event_pollblock event;
                Desk_event_pollmask mask;
                mask.value = 0;
                Desk_Wimp_Poll3(mask, &event, NULL);
                Desk_Event_Process(&event);
            }
        }
        else
        {
            ftnlog_printf("Failed to connect to %s", addr_str);
        }
    }

    debug_printf("mailer: Poll complete, connected to %d nodes", poll_count);
    ftnlog_printf("Poll complete: %d nodes", poll_count);

    mailer.polling_in_progress = 0;
}

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/*
 * Create a directory, including any missing parent directories.
 * Similar to 'mkdir -p' behaviour - creates the full path hierarchy.
 */
static void ensure_directory_exists(const char *path)
{
    _kernel_swi_regs regs;
    char parent[MAILER_PATH_SIZE];
    char *last_dot;

    if (path == NULL || path[0] == '\0')
    {
        return;
    }

    /* First, try to create the directory directly */
    regs.r[0] = 8;  /* OS_File 8 = Create directory */
    regs.r[1] = (int)path;
    regs.r[4] = 0;  /* Default number of entries */

    if (_kernel_swi(OS_File, &regs, &regs) == NULL)
    {
        return;  /* Success or already exists */
    }

    /* Failed - try to create parent directory first */
    strncpy(parent, path, sizeof(parent) - 1);
    parent[sizeof(parent) - 1] = '\0';

    last_dot = strrchr(parent, '.');
    if (last_dot != NULL && last_dot != parent)
    {
        *last_dot = '\0';  /* Truncate to parent path */

        /* Recursively ensure parent exists */
        ensure_directory_exists(parent);

        /* Now try again to create the original directory */
        regs.r[0] = 8;
        regs.r[1] = (int)path;
        regs.r[4] = 0;
        _kernel_swi(OS_File, &regs, &regs);
    }
}

/*
 * Check if a path exists (file or directory).
 * Returns: 0 = not found, 1 = file, 2 = directory
 */
static int path_exists(const char *path)
{
    _kernel_swi_regs regs;

    regs.r[0] = 17;  /* OS_File 17 = Read catalogue info, no path */
    regs.r[1] = (int)path;

    if (_kernel_swi(OS_File, &regs, &regs) != NULL)
    {
        return 0;
    }

    return regs.r[0];  /* 0=not found, 1=file, 2=directory */
}

static void mailer_add_zone(int *zones, int *count, int zone)
{
    int i;

    if (zone <= 0)
    {
        zone = 2;
    }

    for (i = 0; i < *count; i++)
    {
        if (zones[i] == zone)
        {
            return;
        }
    }

    if (*count < 16)
    {
        zones[*count] = zone;
        (*count)++;
    }
}

static void mailer_create_directories(void)
{
    int zones[16];
    int zone_count = 0;
    int i;

    debug_printf("mailer: Creating FTN directory structure...");

    /* Create main FTN directories (zone-specific subdirs created in loop below) */
    ensure_directory_exists(mailer.inbound_path);
    ensure_directory_exists(mailer.outbound_path);
    ensure_directory_exists(mailer.tic_path);
    ensure_directory_exists(mailer.netmail_path);
    ensure_directory_exists(mailer.badmail_path);

    /* Collect zones we should provision (always include zone 2) */
    mailer_add_zone(zones, &zone_count, 2);
    for (i = 0; i < mailer.our_addr_count; i++)
    {
        mailer_add_zone(zones, &zone_count, mailer.our_addrs[i].zone);
    }

    /* Ensure inbound and outbound subdirectories for each zone */
    for (i = 0; i < zone_count; i++)
    {
        int zone = zones[i];
        char inbound_zone[MAILER_PATH_SIZE];
        char outbound_zone[MAILER_PATH_SIZE];
        char temp_path[MAILER_PATH_SIZE];
        char processed_path[MAILER_PATH_SIZE];
        char bad_path[MAILER_PATH_SIZE];

        /* Inbound zone directory and subdirs */
        ftn_format_zone_path(inbound_zone, sizeof(inbound_zone), mailer.inbound_path, zone);
        ftn_format_zone_subpath(temp_path, sizeof(temp_path), mailer.inbound_path, zone, "Temp");
        ftn_format_zone_subpath(processed_path, sizeof(processed_path), mailer.inbound_path, zone, "Processed");
        ftn_format_zone_subpath(bad_path, sizeof(bad_path), mailer.inbound_path, zone, "Bad");

        ensure_directory_exists(inbound_zone);
        ensure_directory_exists(temp_path);
        ensure_directory_exists(processed_path);
        ensure_directory_exists(bad_path);

        debug_printf("mailer:   Inbound zone %d: %s %s", zone, inbound_zone,
                     path_exists(inbound_zone) == 2 ? "(OK)" : "(FAILED)");
        debug_printf("mailer:     Temp: %s %s", temp_path,
                     path_exists(temp_path) == 2 ? "(OK)" : "(FAILED)");
        debug_printf("mailer:     Processed: %s %s", processed_path,
                     path_exists(processed_path) == 2 ? "(OK)" : "(FAILED)");
        debug_printf("mailer:     Bad: %s %s", bad_path,
                     path_exists(bad_path) == 2 ? "(OK)" : "(FAILED)");

        /* Outbound zone directory */
        ftn_format_zone_path(outbound_zone, sizeof(outbound_zone), mailer.outbound_path, zone);
        ensure_directory_exists(outbound_zone);

        debug_printf("mailer:   Outbound zone %d: %s %s", zone, outbound_zone,
                     path_exists(outbound_zone) == 2 ? "(OK)" : "(FAILED)");
    }

    /* Log other shared directories */
    debug_printf("mailer:   TIC: %s %s", mailer.tic_path,
                 path_exists(mailer.tic_path) == 2 ? "(OK)" : "(FAILED)");
    debug_printf("mailer:   Netmail: %s %s", mailer.netmail_path,
                 path_exists(mailer.netmail_path) == 2 ? "(OK)" : "(FAILED)");
    debug_printf("mailer:   Badmail: %s %s", mailer.badmail_path,
                 path_exists(mailer.badmail_path) == 2 ? "(OK)" : "(FAILED)");
}

void mailer_initialise(void)
{
    memset(&mailer, 0, sizeof(mailer));

    mailer.listen_socket = -1;
    mailer.listen_port = BINKP_DEFAULT_PORT;
    mailer.max_sessions = MAILER_MAX_SESSIONS;
    mailer.connect_timeout = 60;
    mailer.session_timeout = 300;
    mailer.scan_interval = 60;
    mailer.toss_interval = 0;   /* Disabled by default */
    mailer.poll_interval = 0;   /* Disabled by default */
    mailer.retry_delay = 300;
    strcpy(mailer.tic_path, "<Converse$Dir>.FTN.Tic");
    mailer.start_time = time(NULL);
    mailer.last_auto_toss = mailer.start_time;
    mailer.last_auto_poll = mailer.start_time;

    timer_initialise();
    queue_initialise();
    tosser_initialise();
    scanner_initialise();
    packer_initialise();
    tic_initialise();
    mailer_load_config();
    mailer_create_directories();
    tic_set_inbound_path(mailer.tic_path);
}

void mailer_finalise(void)
{
    int i;

    /* Close all sessions */
    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        if (mailer.sessions[i].active)
        {
            mailer_close_session(&mailer.sessions[i], "Shutdown");
        }
    }

    mailer_destroy_listener();
    tic_finalise();
    packer_finalise();
    scanner_finalise();
    tosser_finalise();
    queue_finalise();
    timer_finalise();

    mailer_log_ftn("Mailer shutdown");
}

/* ******************************************************************************************************************************************************** */
/* Wimp Handlers                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/* Forward declaration */
static Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref);

static Desk_bool wimp_handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
    (void)ref;

    if (event->data.mouse.button.data.select)
    {
        /* Open status window in idle state */
        ftnstatus_open_idle();
    }
    else if (event->data.mouse.button.data.adjust)
    {
        /* Open log window */
        ftnlog_open();
    }
    else if (event->data.mouse.button.data.menu)
    {
        Desk_Menu_Show(wimp.iconbar_menu_handle, event->data.mouse.pos.x, -1);
    }

    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref)
{
    (void)ref;

    debug_printf("mailer: Menu selection [0]=%d [1]=%d", 
                 event->data.selection[0], event->data.selection[1]);

    /* Check for submenu selection (Mail submenu) */
    if (event->data.selection[0] == ICONBAR_MENU_MAIL && event->data.selection[1] != -1)
    {
        debug_printf("mailer: Mail submenu selection %d", event->data.selection[1]);
        switch (event->data.selection[1])
        {
            case MAIL_MENU_POLL:
                /* Force poll now with status window */
                ftnstatus_open("ftn.polling");
                ftnstatus_update("Scanning outbound...");
                ftnlog_printf("Scanning outbound queue...");
                queue_scan_outbound();
                ftnstatus_update("Polling uplinks...");
                ftnlog_printf("Polling all uplinks...");
                mailer_poll_all_uplinks();
                ftnlog_printf("Poll complete");
                ftnstatus_set_idle();
                break;

            case MAIL_MENU_TOSS:
                /* Process inbound mail with status window */
                ftnstatus_open("ftn.tossing");
                ftnstatus_update("Scanning inbound...");
                ftnlog_printf("Scanning inbound directory...");
                tosser_set_status_callback(ftnstatus_update);
                {
                    int count = tosser_process_inbound();
                    int tic_count;
                    
                    tosser_set_status_callback(NULL);
                    if (count > 0)
                    {
                        char msg[64];
                        snprintf(msg, sizeof(msg), "Tossed %d messages", count);
                        ftnstatus_update(msg);
                        ftnlog_printf("%s", msg);
                        mailer_log("Tossed %d messages", count);
                    }
                    else
                    {
                        ftnstatus_update("No packets found");
                        ftnlog_printf("No packets found");
                    }
                    
                    /* Process TIC files */
                    ftnstatus_update("Processing TIC files...");
                    tic_count = tic_process_inbound();
                    if (tic_count > 0)
                    {
                        char msg[64];
                        snprintf(msg, sizeof(msg), "Received %d files", tic_count);
                        ftnstatus_update(msg);
                        ftnlog_printf("%s", msg);
                    }
                }
                ftnstatus_set_idle();
                break;

            case MAIL_MENU_SCAN:
                /* Scan messagebases for outbound mail */
                ftnstatus_open("ftn.scanning");
                ftnstatus_update("Scanning messagebases...");
                ftnlog_printf("Scanning for outbound mail...");
                {
                    int count = scanner_scan_outbound();
                    if (count > 0)
                    {
                        char msg[64];
                        snprintf(msg, sizeof(msg), "Packed %d messages", count);
                        ftnstatus_update(msg);
                        ftnlog_printf("%s", msg);
                        mailer_log("Packed %d messages for export", count);
                    }
                    else
                    {
                        ftnstatus_update("No outbound mail");
                        ftnlog_printf("No outbound mail found");
                    }
                }
                ftnstatus_set_idle();
                break;
        }
        return Desk_bool_TRUE;
    }

    /* Handle main menu selections */
    switch (event->data.selection[0])
    {
        case ICONBAR_MENU_INFO:
            /* Show info window - handled by Menu_Warn */
            break;

        case ICONBAR_MENU_MAIL:
            /* Submenu - no direct action */
            break;

        case ICONBAR_MENU_COMMANDS:
            /* Submenu - no direct action */
            break;

        case ICONBAR_MENU_QUIT:
            wimp.quit = Desk_bool_TRUE;
            break;
    }

    /* Handle Commands submenu selections */
    if (event->data.selection[0] == ICONBAR_MENU_COMMANDS &&
        event->data.selection[1] != -1)
    {
        switch (event->data.selection[1])
        {
            case COMMANDS_MENU_FREQ:
                /* Open FREQ window at bottom-right, above iconbar */
                {
                    Desk_window_state state;
                    int screen_width, win_width, win_height;
                    
                    /* Get screen size */
                    screen_width = Desk_screen_size.x;
                    
                    /* Get window size */
                    Desk_Wimp_GetWindowState(ftnfreq_window, &state);
                    win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
                    win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
                    
                    /* Position at bottom-right, above iconbar */
                    state.openblock.screenrect.max.x = screen_width - 16;
                    state.openblock.screenrect.min.x = screen_width - 16 - win_width;
                    state.openblock.screenrect.min.y = 134;  /* Just above iconbar */
                    state.openblock.screenrect.max.y = 134 + win_height;
                    state.openblock.behind = -1;  /* Open at front */
                    
                    Desk_Wimp_OpenWindow(&state.openblock);
                    
                    /* Set caret in the filename writable field */
                    Desk_Icon_SetCaret(ftnfreq_window, FTNFREQ_FILENAME);
                }
                break;
        }
    }

    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_window_open(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Wimp_OpenWindow(&event->data.openblock);
    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_window_close(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Window_Hide(event->data.openblock.window);
    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_poll(Desk_event_pollblock *event, void *ref)
{
    time_t now = time(NULL);

    Desk_UNUSED(event);
    Desk_UNUSED(ref);

    /* Accept incoming connections */
    if (mailer.listener_active)
    {
        mailer_accept_connection();
    }

    /* Process active sessions */
    mailer_process_sessions();

    /* Check for timeouts */
    mailer_check_timeouts();

    /* Periodically rescan outbound directories so new mail is noticed */
    if (outbound_queue.scan_interval > 0)
    {
        if (now - outbound_queue.last_scan >= outbound_queue.scan_interval)
        {
            queue_scan_outbound();
        }
    }

    /* Automatic toss: process inbound packets */
    if (mailer.toss_interval > 0 && mailer.active_sessions == 0)
    {
        if (now - mailer.last_auto_toss >= mailer.toss_interval)
        {
            debug_printf("mailer: Auto-toss triggered");
            ftnlog_printf("Auto-toss: processing inbound...");
            tosser_process_inbound();
            mailer.last_auto_toss = now;
        }
    }

    /* Automatic poll: connect to uplinks and exchange mail */
    if (mailer.poll_interval > 0 && mailer.active_sessions == 0 && !mailer.polling_in_progress)
    {
        if (now - mailer.last_auto_poll >= mailer.poll_interval)
        {
            debug_printf("mailer: Auto-poll triggered");
            ftnlog_printf("Auto-poll: connecting to uplinks...");
            /* Update timestamp BEFORE calling poll to prevent re-entry */
            mailer.last_auto_poll = now;
            queue_scan_outbound();
            mailer_poll_all_uplinks();
        }
    }

    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_broadcast_message(Desk_event_pollblock *event, void *ref)
{
    int reason;

    Desk_UNUSED(ref);

    if (event == NULL)
    {
        return Desk_bool_FALSE;
    }

    reason = event->data.message.data.words[0];

    /* Reason 0 = quit request from Server */
    if (reason == 0)
    {
        debug_printf("FTN Mailer: Received shutdown broadcast from Server");
        wimp.quit = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

/* ******************************************************************************************************************************************************** */
/* Wimp Setup                                                                                                                                               */
/* ******************************************************************************************************************************************************** */

static void create_iconbar_icon(void)
{
    wimp.iconbar_icon = Desk_Icon_BarIcon("!FTN", Desk_iconbar_RIGHT);
}

static void lookup_menu_string(const char *tag, char *buffer, size_t size, const char *fallback)
{
    /* Desk_Msgs_Lookup returns zero on success; populate fallback if it fails */
    if (Desk_Msgs_Lookup(tag, buffer, (int)size))
    {
        strncpy(buffer, fallback, size - 1);
        buffer[size - 1] = '\0';
    }
}

static void create_iconbar_menu(void)
{
    char iconbar_menu[100];
    char iconbar_menu_title[30];
    char mail_menu_items[100];
    char mail_menu_title[30];
    char commands_menu_items[100];
    char commands_menu_title[30];

    /* Create main iconbar menu */
    lookup_menu_string("ftn.ibmt", iconbar_menu_title, sizeof(iconbar_menu_title), "Mailer");
    lookup_menu_string("ftn.ibm", iconbar_menu, sizeof(iconbar_menu), "Info,Mail,Commands,Quit");
    wimp.iconbar_menu_handle = Desk_Menu_New(iconbar_menu_title, iconbar_menu);

    /* Create Mail submenu */
    lookup_menu_string("ftn.mailmt", mail_menu_title, sizeof(mail_menu_title), "Mail");
    lookup_menu_string("ftn.mailm", mail_menu_items, sizeof(mail_menu_items), "Poll,Toss,Scan");
    mail_menu = Desk_Menu_New(mail_menu_title, mail_menu_items);

    /* Create Commands submenu */
    lookup_menu_string("ftn.cmdmt", commands_menu_title, sizeof(commands_menu_title), "Commands");
    lookup_menu_string("ftn.cmdm", commands_menu_items, sizeof(commands_menu_items), "FREQ...");
    commands_menu = Desk_Menu_New(commands_menu_title, commands_menu_items);

    /* Attach Mail submenu to Mail item if both menus were created */
    if (wimp.iconbar_menu_handle != NULL && mail_menu != NULL)
    {
        Desk_Menu_AddSubMenu(wimp.iconbar_menu_handle, ICONBAR_MENU_MAIL, mail_menu);
    }

    /* Attach Commands submenu */
    if (wimp.iconbar_menu_handle != NULL && commands_menu != NULL)
    {
        Desk_Menu_AddSubMenu(wimp.iconbar_menu_handle, ICONBAR_MENU_COMMANDS, commands_menu);
    }
}

static void poll_idle(void)
{
    Desk_event_pollblock event;
    Desk_event_pollmask mask;
    int next_time;

    mask.value = 0;
    mask.data.null = Desk_bool_FALSE;  /* We want null events */

    next_time = timer_get_next_wakeup();

    Desk_Wimp_PollIdle3(mask, &event, next_time, NULL);
    Desk_Event_Process(&event);
}

/* ******************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int main(int argc, char *argv[])
{
    (void)argc;
    (void)argv;

    debug_printf("FTN Mailer starting");

    /* Initialise Wimp */
    Desk_Event_Initialise(MAILER_TASK_NAME);
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");
    Desk_Template_Initialise();
    Desk_Template_LoadFile("Templates");

    wimp.quit = Desk_bool_FALSE;

    /* Create UI elements */
    create_iconbar_icon();
    create_iconbar_menu();
    proginfo_window = Desk_Window_Create("proginfo", Desk_template_TITLEMIN);
    wimp.main_window = Desk_Window_Create("status", Desk_template_TITLEMIN);
    ftnstatus_window = Desk_Window_Create("ftnstatus", Desk_template_TITLEMIN);
    ftnlog_window = Desk_Window_Create("ftnlog", Desk_template_TITLEMIN);
    ftnfreq_window = Desk_Window_Create("ftnfreq", Desk_template_TITLEMIN);

    /* Initialise ftnlog module */
    ftnlog_initialise(ftnlog_window);

    /* Attach proginfo dialog as submenu of the Info entry */
    if (wimp.iconbar_menu_handle != NULL && proginfo_window != NULL)
    {
        Desk_Menu_AddSubMenu(wimp.iconbar_menu_handle, ICONBAR_MENU_INFO,
                             (Desk_menu_ptr)proginfo_window);
    }

    /* Register event handlers */
    Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, Desk_event_ANY,
                     wimp_handle_iconbar_click, NULL);
    Desk_Event_Claim(Desk_event_CLICK, ftnfreq_window, Desk_event_ANY,
                     ftnfreq_handle_click, NULL);
    Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_iconbar_menu_choice, NULL);
    Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_window_open, NULL);
    Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_window_close, NULL);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_poll, NULL);

    /* Register for shutdown broadcast from Server */
    Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_BROADCAST, Desk_event_ANY,
                        wimp_handle_broadcast_message, NULL);

    /* Initialise mailer */
    mailer_initialise();

    /* Create listener */
    mailer_create_listener();

    /* Initial queue scan and poll all uplinks */
    queue_scan_outbound();

    mailer_log_ftn("Mailer ready (%s %s)", MAILER_NAME, MAILER_VERSION);

    /* Poll all uplinks on startup */
    ftnlog_printf("Startup poll...");
    mailer_poll_all_uplinks();

    /* Update last_auto_poll to prevent immediate auto-poll after startup */
    mailer.last_auto_poll = time(NULL);

    /* Main loop */
    while (wimp.quit == Desk_bool_FALSE)
    {
        poll_idle();
    }

    /* Cleanup */
    mailer_finalise();
    Desk_Template_ClearAll();

    return 0;
}
