/* ******************************************************************************************************************************************************** */
/* FTN Mailer - Main Application                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.File.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"

/* TCPIP Includes */
#define COMPAT_INET4 1
#include "sys/types.h"
#include "sys/socket.h"
#include "socklib.h"
#include "inetlib.h"
#include "netinet/in.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netdb.h"

/* Our Includes */
#include "mailer.h"
#include "iconnames.h"
#include "binkp.h"
#include "queue.h"
#include "tosser.h"
#include "scanner.h"
#include "packer.h"
#include "tic.h"
#include "echofix.h"
#include "nodelist.h"
#include "ftnupload.h"
#include "timer.h"
#include "debug.h"
#include "ftnlog.h"
#include "crypt.h"

/* ******************************************************************************************************************************************************** */
/* Global Variables                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

WIMP_STATE wimp;
MAILER_STATE mailer;
Desk_window_handle proginfo_window;
Desk_window_handle ftnstatus_window;
Desk_window_handle ftnlog_window;
Desk_window_handle ftnfreq_window;
Desk_window_handle ftnupload_window;
Desk_menu_ptr mail_menu;
Desk_menu_ptr commands_menu;

/* Iconbar menu entries */
enum
{
    ICONBAR_MENU_INFO = 0,
    ICONBAR_MENU_MAIL,
    ICONBAR_MENU_COMMANDS,
    ICONBAR_MENU_QUIT
};

/* Mail submenu entries */
enum
{
    MAIL_MENU_POLL = 0,
    MAIL_MENU_TOSS,
    MAIL_MENU_SCAN
};

/* Commands submenu entries */
enum
{
    COMMANDS_MENU_FREQ = 0,
    COMMANDS_MENU_NODELIST
};

/* ******************************************************************************************************************************************************** */
/* SWI Numbers                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

#define SWI_SUPPORT_FTN     0x5AA86
#define SWI_FILER_LOGGING   0x5AA40

/* Wimp message from Converse Server */
#define MESSAGE_LINE_BROADCAST  0x5AA00

/* ******************************************************************************************************************************************************** */
/* Utility Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

void ftn_addr_to_string(const FTN_ADDR *addr, char *buffer, size_t size)
{
    if (addr->point == 0)
    {
        snprintf(buffer, size, "%d:%d/%d", addr->zone, addr->net, addr->node);
    }
    else
    {
        snprintf(buffer, size, "%d:%d/%d.%d", addr->zone, addr->net, addr->node, addr->point);
    }

    if (addr->domain[0] != '\0')
    {
        size_t len = strlen(buffer);
        snprintf(buffer + len, size - len, "@%s", addr->domain);
    }
}

int ftn_string_to_addr(const char *str, FTN_ADDR *addr)
{
    const char *p = str;
    char *end;

    memset(addr, 0, sizeof(FTN_ADDR));

    /* Parse zone:net/node.point@domain */
    addr->zone = (int)strtol(p, &end, 10);
    if (*end != ':') return 0;
    p = end + 1;

    addr->net = (int)strtol(p, &end, 10);
    if (*end != '/') return 0;
    p = end + 1;

    addr->node = (int)strtol(p, &end, 10);
    p = end;

    if (*p == '.')
    {
        p++;
        addr->point = (int)strtol(p, &end, 10);
        p = end;
    }

    if (*p == '@')
    {
        p++;
        strncpy(addr->domain, p, sizeof(addr->domain) - 1);
    }

    return 1;
}

int ftn_addr_match(const FTN_ADDR *a, const FTN_ADDR *b)
{
    return (a->zone == b->zone &&
            a->net == b->net &&
            a->node == b->node &&
            a->point == b->point);
}

/* ******************************************************************************************************************************************************** */
/* Logging                                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

static void mailer_log_ftn(const char *format, ...)
{
    char buffer[512];
    va_list args;
    _kernel_swi_regs regs;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    /* Log via Filer module */
    regs.r[0] = 3;  /* FILER_LOG_CMD_FTN */
    regs.r[1] = (int)buffer;
    _kernel_swi(SWI_FILER_LOGGING, &regs, &regs);

    debug_printf("FTN: %s", buffer);
}

void mailer_log(const char *format, ...)
{
    char buffer[512];
    va_list args;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    mailer_log_ftn("%s", buffer);
}

/* ******************************************************************************************************************************************************** */
/* FTN Status Window - Multi-Network Display                                                                                                                */
/* ******************************************************************************************************************************************************** */

/* Per-network icon text buffers */
typedef struct {
    char *num_text;         /* "0", "1", etc. */
    char *network_text;     /* "Zone 2 (FidoNet)" */
    char *activity_text;    /* "IN: Receiving file (45%)" */
    char *time_text;        /* "00:01:23" or "--" */
    time_t start_time;      /* When activity started (0 = idle) */
} FTNSTATUS_ROW;

static FTNSTATUS_ROW *ftnstatus_rows = NULL;
static int ftnstatus_row_count = 0;
static int ftnstatus_window_open = 0;
static NODELIST_NETWORK ftnstatus_networks[NODELIST_MAX_NETWORKS];

/* Legacy state for backward compatibility */
static int ftnstatus_legacy_network = 0;
static int ftnstatus_legacy_is_sending = 0;
static int ftnstatus_legacy_is_outbound = 1;    /* Direction: 1=outbound, 0=inbound */
static long ftnstatus_legacy_total = 0;
static char ftnstatus_legacy_filename[128];

/*
 * Calculate icon index for a given row and column.
 */
static int ftnstatus_icon_index(int row, int column)
{
    return FTNSTATUS_ICON_BASE + (row * FTNSTATUS_ICONS_PER_ROW) + column;
}

/*
 * Create dynamic icons for all network rows.
 * Follows the same pattern as Server's create_line_icons().
 */
static int ftnstatus_create_icons(void)
{
    int row;
    int y_base;
    int column_x;
    Desk_icon_createblock icon_create;
    Desk_icon_handle icon_handle;
    
    if (ftnstatus_row_count <= 0)
    {
        debug_printf("ftnstatus: No networks configured");
        return 0;
    }
    
    icon_create.window = ftnstatus_window;
    y_base = -((FTNSTATUS_TOP_STATIC_ROWS * FTNSTATUS_ICON_HEIGHT) + FTNSTATUS_PADDING);
    
    for (row = 0; row < ftnstatus_row_count; row++)
    {
        FTNSTATUS_ROW *r = &ftnstatus_rows[row];
        
        /* Allocate text buffers */
        r->num_text = malloc(8);
        r->network_text = malloc(64);
        r->activity_text = malloc(128);
        r->time_text = malloc(16);
        
        if (!r->num_text || !r->network_text || !r->activity_text || !r->time_text)
        {
            debug_printf("ftnstatus: Failed to allocate icon buffers");
            return 0;
        }
        
        /* Initialize text */
        snprintf(r->num_text, 8, "%d", row);
        snprintf(r->network_text, 64, "Zone %d (%s)", 
                 ftnstatus_networks[row].default_zone,
                 ftnstatus_networks[row].name);
        strcpy(r->activity_text, "Idle");
        strcpy(r->time_text, "--");
        r->start_time = 0;
        
        /* Calculate Y position for this row */
        icon_create.icondata.workarearect.max.y = y_base - (FTNSTATUS_ICON_HEIGHT * row);
        icon_create.icondata.workarearect.min.y = icon_create.icondata.workarearect.max.y - FTNSTATUS_ICON_HEIGHT;
        
        column_x = FTNSTATUS_COLUMN_START;
        
        /* Column 0: Number */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + FTNSTATUS_NUM_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = r->num_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 8;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + FTNSTATUS_COLUMN_GAP;
        
        /* Column 1: Network */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + FTNSTATUS_NETWORK_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = r->network_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 64;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + FTNSTATUS_COLUMN_GAP;
        
        /* Column 2: Activity */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + FTNSTATUS_ACTIVITY_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = r->activity_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 128;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
        
        column_x = icon_create.icondata.workarearect.max.x + FTNSTATUS_COLUMN_GAP;
        
        /* Column 3: Time */
        icon_create.icondata.flags.value = 0;
        icon_create.icondata.workarearect.min.x = column_x;
        icon_create.icondata.workarearect.max.x = column_x + FTNSTATUS_TIME_WIDTH;
        icon_create.icondata.flags.value = Desk_icon_TEXT |
                                           Desk_icon_VCENTRE |
                                           Desk_icon_HCENTRE |
                                           Desk_icon_INDIRECTED |
                                           Desk_icon_BORDER |
                                           Desk_icon_FILLED |
                                           (Desk_icon_FORECOLOUR * 7) |
                                           (Desk_icon_BACKCOLOUR * 1);
        icon_create.icondata.data.indirecttext.buffer = r->time_text;
        icon_create.icondata.data.indirecttext.validstring = "R2";
        icon_create.icondata.data.indirecttext.bufflen = 16;
        Desk_Wimp_CreateIcon(&icon_create, &icon_handle);
    }
    
    return 1;
}

/*
 * Free all dynamically allocated icon buffers.
 */
static void ftnstatus_free_icons(void)
{
    int i;
    
    if (ftnstatus_rows == NULL)
        return;
    
    for (i = 0; i < ftnstatus_row_count; i++)
    {
        if (ftnstatus_rows[i].num_text) free(ftnstatus_rows[i].num_text);
        if (ftnstatus_rows[i].network_text) free(ftnstatus_rows[i].network_text);
        if (ftnstatus_rows[i].activity_text) free(ftnstatus_rows[i].activity_text);
        if (ftnstatus_rows[i].time_text) free(ftnstatus_rows[i].time_text);
    }
    
    free(ftnstatus_rows);
    ftnstatus_rows = NULL;
    ftnstatus_row_count = 0;
}

/*
 * Set window extent based on number of network rows.
 * Follows the same pattern as Server's set_extent calculation.
 */
static void ftnstatus_set_extent(void)
{
    Desk_wimp_box extent;
    int total_height;
    int total_width;
    
    /* Calculate total height: (header rows + data rows) * row height + top padding + bottom padding */
    total_height = ((ftnstatus_row_count + FTNSTATUS_TOP_STATIC_ROWS) * FTNSTATUS_ICON_HEIGHT) + 
                   FTNSTATUS_PADDING + FTNSTATUS_BOTTOM_PADDING;
    
    /* Calculate total width: all columns + gaps between them */
    total_width = FTNSTATUS_COLUMN_START + 
                  FTNSTATUS_NUM_WIDTH + FTNSTATUS_COLUMN_GAP +
                  FTNSTATUS_NETWORK_WIDTH + FTNSTATUS_COLUMN_GAP +
                  FTNSTATUS_ACTIVITY_WIDTH + FTNSTATUS_COLUMN_GAP +
                  FTNSTATUS_TIME_WIDTH;
    
    extent.min.x = 0;
    extent.max.x = total_width;
    extent.min.y = -total_height;
    extent.max.y = 0;
    
    Desk_Wimp_SetExtent(ftnstatus_window, &extent);
}

/*
 * Initialise the FTN status window with dynamic network rows.
 * Called after template is loaded but before window is opened.
 */
int ftnstatus_initialise(void)
{
    /* Get configured networks */
    ftnstatus_row_count = nodelist_get_configured_networks(ftnstatus_networks, NODELIST_MAX_NETWORKS);
    
    if (ftnstatus_row_count <= 0)
    {
        debug_printf("ftnstatus: No networks configured, using 1 row");
        ftnstatus_row_count = 1;
        ftnstatus_networks[0].id = 0;
        ftnstatus_networks[0].active = 1;
        strcpy(ftnstatus_networks[0].name, "Default");
        ftnstatus_networks[0].default_zone = 0;
    }
    
    /* Allocate row structures */
    ftnstatus_rows = calloc(ftnstatus_row_count, sizeof(FTNSTATUS_ROW));
    if (ftnstatus_rows == NULL)
    {
        debug_printf("ftnstatus: Failed to allocate row structures");
        return 0;
    }
    
    /* Set window extent */
    ftnstatus_set_extent();
    
    /* Create dynamic icons */
    if (!ftnstatus_create_icons())
    {
        ftnstatus_free_icons();
        return 0;
    }
    
    debug_printf("ftnstatus: Initialised with %d network rows", ftnstatus_row_count);
    return 1;
}

/*
 * Finalise the FTN status window.
 */
void ftnstatus_finalise(void)
{
    ftnstatus_free_icons();
}

/*
 * Open the FTN status window at bottom-left of screen.
 */
void ftnstatus_open_window(void)
{
    Desk_window_state state;
    int win_width, win_height;
    
    /* Don't open if not initialised or already open */
    if (ftnstatus_rows == NULL || ftnstatus_window_open)
        return;
    
    /* Get current window state */
    Desk_Wimp_GetWindowState(ftnstatus_window, &state);
    win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
    win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
    
    /* Position at bottom-left, just above iconbar */
    state.openblock.screenrect.min.x = 16;
    state.openblock.screenrect.max.x = 16 + win_width;
    state.openblock.screenrect.min.y = 134;  /* Just above iconbar (128) + margin */
    state.openblock.screenrect.max.y = 134 + win_height;
    state.openblock.behind = -1;  /* Open at front */
    
    Desk_Wimp_OpenWindow(&state.openblock);
    ftnstatus_window_open = 1;
}

/*
 * Close the FTN status window.
 */
void ftnstatus_close_window(void)
{
    if (!ftnstatus_window_open)
        return;
    
    Desk_Wimp_CloseWindow(ftnstatus_window);
    ftnstatus_window_open = 0;
}

/*
 * Find network ID by zone number.
 * Returns -1 if not found.
 */
int ftnstatus_find_network_by_zone(int zone)
{
    int i;
    
    for (i = 0; i < ftnstatus_row_count; i++)
    {
        if (ftnstatus_networks[i].default_zone == zone)
            return i;
    }
    
    /* Default to first network if zone not found */
    return (ftnstatus_row_count > 0) ? 0 : -1;
}

/*
 * Update icon text and force redraw.
 */
static void ftnstatus_update_icon(int row, int column)
{
    Desk_icon_handle icon;
    
    if (ftnstatus_rows == NULL || row < 0 || row >= ftnstatus_row_count)
        return;
    
    icon = ftnstatus_icon_index(row, column);
    Desk_Wimp_SetIconState(ftnstatus_window, icon, 0, 0);
}

/*
 * Set activity text for a network.
 * is_outbound: 1 = outbound (OUT:), 0 = inbound (IN:)
 */
void ftnstatus_set_activity(int network_id, int is_outbound, const char *activity)
{
    FTNSTATUS_ROW *row;
    
    if (ftnstatus_rows == NULL || network_id < 0 || network_id >= ftnstatus_row_count)
        return;
    
    row = &ftnstatus_rows[network_id];
    
    /* Format with direction prefix */
    if (activity != NULL && activity[0] != '\0')
    {
        snprintf(row->activity_text, 128, "%s: %s", 
                 is_outbound ? "OUT" : "IN", activity);
        
        /* Start timer if not already running */
        if (row->start_time == 0)
        {
            row->start_time = time(NULL);
            strcpy(row->time_text, "00:00:00");
        }
    }
    else
    {
        strcpy(row->activity_text, "Idle");
        row->start_time = 0;
        strcpy(row->time_text, "--");
    }
    
    /* Auto-open window on activity */
    if (!ftnstatus_window_open && activity != NULL && activity[0] != '\0')
    {
        ftnstatus_open_window();
    }
    
    ftnstatus_update_icon(network_id, 2);  /* Activity column */
    ftnstatus_update_icon(network_id, 3);  /* Time column */
}

/*
 * Set activity text with percentage for a network.
 */
void ftnstatus_set_activity_percent(int network_id, int is_outbound, const char *activity, int percent)
{
    FTNSTATUS_ROW *row;
    
    if (ftnstatus_rows == NULL || network_id < 0 || network_id >= ftnstatus_row_count)
        return;
    
    row = &ftnstatus_rows[network_id];
    
    if (percent < 0) percent = 0;
    if (percent > 100) percent = 100;
    
    /* Format with direction prefix and percentage */
    snprintf(row->activity_text, 128, "%s: %s (%d%%)",
             is_outbound ? "OUT" : "IN", activity, percent);
    
    /* Start timer if not already running */
    if (row->start_time == 0)
    {
        row->start_time = time(NULL);
        strcpy(row->time_text, "00:00:00");
    }
    
    /* Auto-open window on activity */
    if (!ftnstatus_window_open)
    {
        ftnstatus_open_window();
    }
    
    ftnstatus_update_icon(network_id, 2);  /* Activity column */
}

/*
 * Clear a network row back to idle state.
 */
void ftnstatus_clear_network(int network_id)
{
    FTNSTATUS_ROW *row;
    
    if (ftnstatus_rows == NULL || network_id < 0 || network_id >= ftnstatus_row_count)
        return;
    
    row = &ftnstatus_rows[network_id];
    strcpy(row->activity_text, "Idle");
    row->start_time = 0;
    strcpy(row->time_text, "--");
    
    ftnstatus_update_icon(network_id, 2);  /* Activity column */
    ftnstatus_update_icon(network_id, 3);  /* Time column */
}

/*
 * Clear all networks to idle state.
 */
void ftnstatus_clear_all(void)
{
    int i;
    
    if (ftnstatus_rows == NULL)
        return;
    
    for (i = 0; i < ftnstatus_row_count; i++)
    {
        ftnstatus_clear_network(i);
    }
}

/*
 * Update elapsed time display for all active networks.
 * Call this from the main poll loop (every second or so).
 */
void ftnstatus_update_timers(void)
{
    int i;
    time_t now = time(NULL);
    
    if (ftnstatus_rows == NULL)
        return;
    
    for (i = 0; i < ftnstatus_row_count; i++)
    {
        FTNSTATUS_ROW *row = &ftnstatus_rows[i];
        
        if (row->start_time != 0)
        {
            int elapsed = (int)(now - row->start_time);
            int hours = elapsed / 3600;
            int minutes = (elapsed % 3600) / 60;
            int seconds = elapsed % 60;
            
            snprintf(row->time_text, 16, "%02d:%02d:%02d", hours, minutes, seconds);
            ftnstatus_update_icon(i, 3);  /* Time column */
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Legacy FTN Status Functions - Backward Compatibility                                                                                                     */
/* These map to the new multi-network display using network 0 by default.                                                                                   */
/* ******************************************************************************************************************************************************** */

/*
 * Set the session direction for legacy functions.
 * Call this when a session is established before calling transfer functions.
 */
void ftnstatus_set_session_direction(int is_outbound)
{
    ftnstatus_legacy_is_outbound = is_outbound;
}

/*
 * Start a file transfer display (legacy).
 */
void ftnstatus_start_transfer(int is_sending, const char *filename)
{
    ftnstatus_start_transfer_ex(is_sending, filename, 0);
}

/*
 * Start a file transfer display with size (legacy).
 * Note: is_sending indicates the direction of file transfer (1=sending, 0=receiving),
 * which is combined with session direction (outbound/inbound) for display.
 */
void ftnstatus_start_transfer_ex(int is_sending, const char *filename, long total_size)
{
    char activity[128];
    const char *direction = ftnstatus_legacy_is_outbound ? "OUT" : "IN";
    const char *action = is_sending ? "Sending" : "Receiving";
    
    /* Store for legacy progress updates */
    ftnstatus_legacy_is_sending = is_sending;
    ftnstatus_legacy_total = total_size;
    strncpy(ftnstatus_legacy_filename, filename, sizeof(ftnstatus_legacy_filename) - 1);
    ftnstatus_legacy_filename[sizeof(ftnstatus_legacy_filename) - 1] = '\0';
    
    /* Format activity with direction prefix */
    snprintf(activity, sizeof(activity), "%s: %s %s", direction, action, filename);
    
    /* Update the network row directly (bypass set_activity to avoid double prefix) */
    if (ftnstatus_rows != NULL && ftnstatus_legacy_network >= 0 && ftnstatus_legacy_network < ftnstatus_row_count)
    {
        FTNSTATUS_ROW *row = &ftnstatus_rows[ftnstatus_legacy_network];
        
        strncpy(row->activity_text, activity, 127);
        row->activity_text[127] = '\0';
        
        if (row->start_time == 0)
        {
            row->start_time = time(NULL);
            strcpy(row->time_text, "00:00:00");
        }
        
        if (!ftnstatus_window_open)
        {
            ftnstatus_open_window();
        }
        
        ftnstatus_update_icon(ftnstatus_legacy_network, 2);
        ftnstatus_update_icon(ftnstatus_legacy_network, 3);
    }
}

/*
 * Update file transfer progress (legacy).
 */
void ftnstatus_update_progress(int percent)
{
    char activity[128];
    const char *direction = ftnstatus_legacy_is_outbound ? "OUT" : "IN";
    const char *action = ftnstatus_legacy_is_sending ? "Sending" : "Receiving";
    
    if (percent < 0) percent = 0;
    if (percent > 100) percent = 100;
    
    /* Format activity with direction, action, filename and percentage */
    snprintf(activity, sizeof(activity), "%s: %s %s (%d%%)", 
             direction, action, ftnstatus_legacy_filename, percent);
    
    /* Update the network row directly */
    if (ftnstatus_rows != NULL && ftnstatus_legacy_network >= 0 && ftnstatus_legacy_network < ftnstatus_row_count)
    {
        FTNSTATUS_ROW *row = &ftnstatus_rows[ftnstatus_legacy_network];
        
        strncpy(row->activity_text, activity, 127);
        row->activity_text[127] = '\0';
        
        ftnstatus_update_icon(ftnstatus_legacy_network, 2);
    }
}

/*
 * Update file transfer progress with byte counts (legacy).
 */
void ftnstatus_update_progress_ex(long bytes_done, long total_size)
{
    int percent = 0;
    
    if (total_size > 0)
    {
        percent = (int)((bytes_done * 100) / total_size);
    }
    
    ftnstatus_update_progress(percent);
}

/*
 * Update connection display (legacy).
 * Note: Call ftnstatus_set_session_direction() before this to set IN/OUT.
 */
void ftnstatus_update_connection(const char *system_name, const FTN_ADDR *addr)
{
    char activity[128];
    const char *direction = ftnstatus_legacy_is_outbound ? "OUT" : "IN";
    
    if (addr != NULL)
    {
        char addr_str[64];
        ftn_addr_to_string(addr, addr_str, sizeof(addr_str));
        
        /* Find network by zone */
        ftnstatus_legacy_network = ftnstatus_find_network_by_zone(addr->zone);
        
        if (system_name != NULL && system_name[0] != '\0')
        {
            snprintf(activity, sizeof(activity), "%s: Connected to %s (%s)", 
                     direction, system_name, addr_str);
        }
        else
        {
            snprintf(activity, sizeof(activity), "%s: Connected to %s", 
                     direction, addr_str);
        }
        
        /* Update the network row directly */
        if (ftnstatus_rows != NULL && ftnstatus_legacy_network >= 0 && ftnstatus_legacy_network < ftnstatus_row_count)
        {
            FTNSTATUS_ROW *row = &ftnstatus_rows[ftnstatus_legacy_network];
            
            strncpy(row->activity_text, activity, 127);
            row->activity_text[127] = '\0';
            
            if (row->start_time == 0)
            {
                row->start_time = time(NULL);
                strcpy(row->time_text, "00:00:00");
            }
            
            if (!ftnstatus_window_open)
            {
                ftnstatus_open_window();
            }
            
            ftnstatus_update_icon(ftnstatus_legacy_network, 2);
            ftnstatus_update_icon(ftnstatus_legacy_network, 3);
        }
    }
}

/*
 * End file transfer display (legacy).
 */
void ftnstatus_end_transfer(void)
{
    ftnstatus_clear_network(ftnstatus_legacy_network);
}

/* ******************************************************************************************************************************************************** */
/* FREQ (File Request) Functions                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/*
 * Create a .REQ file for file request.
 * The file is created in the outbound directory for the target FTN address.
 * Password is optional - if provided, it's written as "filename !password" per FTN standard.
 * Returns 1 on success, 0 on failure.
 */
static int ftnfreq_create_request(const char *filename, const char *address, const char *password)
{
    FTN_ADDR dest_addr;
    char req_path[MAILER_PATH_SIZE];
    FILE *fp;

    /* Parse the FTN address */
    if (!ftn_string_to_addr(address, &dest_addr))
    {
        debug_printf("ftnfreq: Failed to parse address: %s", address);
        return 0;
    }

    debug_printf("ftnfreq: Parsed address: zone=%d net=%d node=%d point=%d",
                 dest_addr.zone, dest_addr.net, dest_addr.node, dest_addr.point);

    /* Ensure zone-specific outbound directories exist and build the REQ filename */
    queue_ensure_outbound_directories(&dest_addr);
    queue_format_outbound_name(req_path, sizeof(req_path), &dest_addr, "req");

    debug_printf("ftnfreq: Creating REQ file: %s", req_path);
    
    /* Create/append to the REQ file */
    fp = fopen(req_path, "a");
    if (fp == NULL)
    {
        debug_printf("ftnfreq: Failed to create REQ file: %s", req_path);
        return 0;
    }
    
    /* Write the filename to request, with optional password (FTN format: "filename !password") */
    if (password != NULL && password[0] != '\0')
    {
        fprintf(fp, "%s !%s\n", filename, password);
    }
    else
    {
        fprintf(fp, "%s\n", filename);
    }
    fclose(fp);
    
    /* Set filetype to text (0xFFF) */
    {
        _kernel_swi_regs fr;
        fr.r[0] = 18;  /* Set filetype */
        fr.r[1] = (int)req_path;
        fr.r[2] = 0xFFF;
        _kernel_swi(OS_File, &fr, &fr);
    }
    
    mailer_log("FREQ: Requested '%s' from %s", filename, address);
    ftnlog_printf("FREQ: %s from %s", filename, address);
    
    return 1;
}

/*
 * Handle click events in the FREQ window.
 */
static Desk_bool ftnfreq_handle_click(Desk_event_pollblock *event, void *ref)
{
    Desk_icon_handle icon;
    
    Desk_UNUSED(ref);
    
    if (event->data.mouse.window != ftnfreq_window)
        return Desk_bool_FALSE;
    
    icon = event->data.mouse.icon;
    
    if (icon == FTNFREQ_REQUEST)
    {
        char filename[128];
        char address[64];
        char password[64];
        char *ptr;
        
        /* Get text from writable icons using GetTextPtr for indirected icons */
        ptr = Desk_Icon_GetTextPtr(ftnfreq_window, FTNFREQ_FILENAME);
        if (ptr != NULL)
        {
            strncpy(filename, ptr, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        else
        {
            filename[0] = '\0';
        }
        
        ptr = Desk_Icon_GetTextPtr(ftnfreq_window, FTNFREQ_FROMADDRESS);
        if (ptr != NULL)
        {
            strncpy(address, ptr, sizeof(address) - 1);
            address[sizeof(address) - 1] = '\0';
        }
        else
        {
            address[0] = '\0';
        }
        
        /* Get optional password */
        ptr = Desk_Icon_GetTextPtr(ftnfreq_window, FTNFREQ_PASSWORD);
        if (ptr != NULL)
        {
            strncpy(password, ptr, sizeof(password) - 1);
            password[sizeof(password) - 1] = '\0';
        }
        else
        {
            password[0] = '\0';
        }
        
        debug_printf("ftnfreq: FILENAME icon %d = '%s'", FTNFREQ_FILENAME, filename);
        debug_printf("ftnfreq: FROMADDRESS icon %d = '%s'", FTNFREQ_FROMADDRESS, address);
        debug_printf("ftnfreq: PASSWORD icon %d = '%s'", FTNFREQ_PASSWORD, password[0] ? "(set)" : "(empty)");
        
        if (filename[0] != '\0' && address[0] != '\0')
        {
            if (ftnfreq_create_request(filename, address, password))
            {
                /* Clear the filename field on success */
                Desk_Icon_SetText(ftnfreq_window, FTNFREQ_FILENAME, "");
                Desk_Icon_SetText(ftnfreq_window, FTNFREQ_PASSWORD, "");
                
                /* Close window */
                Desk_Window_Hide(ftnfreq_window);
            }
        }
        else
        {
            debug_printf("ftnfreq: Empty filename or address");
        }
        
        return Desk_bool_TRUE;
    }
    else if (icon == FTNFREQ_CANCEL)
    {
        /* Just close the window */
        Desk_Window_Hide(ftnfreq_window);;
        return Desk_bool_TRUE;
    }
    
    return Desk_bool_FALSE;
}

/* ******************************************************************************************************************************************************** */
/* Configuration                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

void mailer_load_config(void)
{
    _kernel_swi_regs regs;
    int i;

    debug_printf("mailer: Loading configuration from Support module");

    /* Get FTN config from Support module */
    regs.r[0] = 0;  /* FTN_CONFIG_REASON_GET_GLOBAL */
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) == NULL && regs.r[0] != 0)
    {
        /* FTN_GLOBAL_CONFIG structure */
        typedef struct
        {
            char sysop[64];
            char system[64];
            char location[64];
            char phone[64];
            int speed;
            char flags[64];
            char inbound[256];
            char outbound[256];
            char netmail[256];
            char freqpath[256];
            char freqexec[256];
            long max_packet_size;
            int listen_port;
            int max_sessions;
            int connect_timeout;
            int session_timeout;
            int scan_interval;
            int toss_interval;
            int poll_interval;
            int retry_delay;
            int address_count;
            /* Followed by addresses and uplinks */
        } FTN_GLOBAL_CONFIG;

        FTN_GLOBAL_CONFIG *cfg = (FTN_GLOBAL_CONFIG *)regs.r[0];

        strncpy(mailer.sysop, cfg->sysop, sizeof(mailer.sysop) - 1);
        strncpy(mailer.system_name, cfg->system, sizeof(mailer.system_name) - 1);
        strncpy(mailer.location, cfg->location, sizeof(mailer.location) - 1);
        mailer.speed = cfg->speed;
        strncpy(mailer.flags, cfg->flags, sizeof(mailer.flags) - 1);
        strncpy(mailer.inbound_path, cfg->inbound, sizeof(mailer.inbound_path) - 1);
        strncpy(mailer.outbound_path, cfg->outbound, sizeof(mailer.outbound_path) - 1);
        strncpy(mailer.netmail_path, cfg->netmail, sizeof(mailer.netmail_path) - 1);
        if (cfg->freqpath[0] != '\0')
        {
            strncpy(mailer.freq_path, cfg->freqpath, sizeof(mailer.freq_path) - 1);
        }
        if (cfg->freqexec[0] != '\0')
        {
            strncpy(mailer.freq_exec, cfg->freqexec, sizeof(mailer.freq_exec) - 1);
        }

        mailer.listen_port = (cfg->listen_port > 0) ? cfg->listen_port : BINKP_DEFAULT_PORT;

        if (cfg->max_sessions > 0 && cfg->max_sessions <= MAILER_MAX_SESSIONS)
        {
            mailer.max_sessions = cfg->max_sessions;
        }
        else
        {
            mailer.max_sessions = MAILER_MAX_SESSIONS;
        }

        mailer.connect_timeout = (cfg->connect_timeout > 0) ? cfg->connect_timeout : 60;
        mailer.session_timeout = (cfg->session_timeout > 0) ? cfg->session_timeout : 300;
        mailer.scan_interval = (cfg->scan_interval > 0) ? cfg->scan_interval : 60;
        mailer.toss_interval = cfg->toss_interval;  /* 0 = disabled */
        mailer.poll_interval = cfg->poll_interval;  /* 0 = disabled */
        mailer.retry_delay = (cfg->retry_delay > 0) ? cfg->retry_delay : 300;
        queue_set_scan_interval(mailer.scan_interval);

        debug_printf("mailer: System: %s, Sysop: %s", mailer.system_name, mailer.sysop);
        debug_printf("mailer: Inbound: %s", mailer.inbound_path);
        debug_printf("mailer: Outbound: %s", mailer.outbound_path);
        debug_printf("mailer: Netmail: %s", mailer.netmail_path);
        debug_printf("mailer: FREQ path: %s", mailer.freq_path);
        debug_printf("mailer: FREQ exec: %s", mailer.freq_exec);
        debug_printf("mailer: Intervals: scan=%d, toss=%d, poll=%d",
                     mailer.scan_interval, mailer.toss_interval, mailer.poll_interval);

        /* Get addresses */
        for (i = 0; i < 8; i++)
        {
            regs.r[0] = 2;  /* FTN_CONFIG_REASON_GET_ADDRESS */
            regs.r[1] = i + 1;
            if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) == NULL && regs.r[0] != 0)
            {
                /* FTN_ADDRESS_CONFIG structure (must match Support module) */
                typedef struct
                {
                    int id;
                    char network[64];
                    int zone, net, node, point;
                    char type[8];
                } FTN_ADDRESS_CONFIG;

                FTN_ADDRESS_CONFIG *addr_cfg = (FTN_ADDRESS_CONFIG *)regs.r[0];

                if (addr_cfg->id > 0)
                {
                    mailer.our_addrs[mailer.our_addr_count].zone = addr_cfg->zone;
                    mailer.our_addrs[mailer.our_addr_count].net = addr_cfg->net;
                    mailer.our_addrs[mailer.our_addr_count].node = addr_cfg->node;
                    mailer.our_addrs[mailer.our_addr_count].point = addr_cfg->point;
                    strncpy(mailer.our_addrs[mailer.our_addr_count].domain, addr_cfg->network,
                            sizeof(mailer.our_addrs[mailer.our_addr_count].domain) - 1);
                    mailer.our_addr_count++;

                    debug_printf("mailer: Address %d: %d:%d/%d.%d@%s",
                                 addr_cfg->id, addr_cfg->zone, addr_cfg->net,
                                 addr_cfg->node, addr_cfg->point, addr_cfg->network);
                }
            }
        }
    }
    else
    {
        debug_printf("mailer: Failed to get FTN config from Support module");

        /* Set defaults */
        strncpy(mailer.system_name, "Converse BBS", sizeof(mailer.system_name) - 1);
        mailer.system_name[sizeof(mailer.system_name) - 1] = '\0';
        strncpy(mailer.sysop, "Sysop", sizeof(mailer.sysop) - 1);
        mailer.sysop[sizeof(mailer.sysop) - 1] = '\0';
        strncpy(mailer.location, "Unknown", sizeof(mailer.location) - 1);
        mailer.location[sizeof(mailer.location) - 1] = '\0';
        mailer.speed = 115200;
        strncpy(mailer.inbound_path, "<Converse$Dir>.FTN.Inbound", sizeof(mailer.inbound_path) - 1);
        mailer.inbound_path[sizeof(mailer.inbound_path) - 1] = '\0';
        strncpy(mailer.outbound_path, "<Converse$Dir>.FTN.Outbound", sizeof(mailer.outbound_path) - 1);
        mailer.outbound_path[sizeof(mailer.outbound_path) - 1] = '\0';
        strncpy(mailer.netmail_path, "<Converse$Dir>.FTN.Netmail", sizeof(mailer.netmail_path) - 1);
        mailer.netmail_path[sizeof(mailer.netmail_path) - 1] = '\0';
    }

    if (mailer.netmail_path[0] == '\0')
    {
        strncpy(mailer.netmail_path, "<Converse$Dir>.FTN.Netmail", sizeof(mailer.netmail_path) - 1);
        mailer.netmail_path[sizeof(mailer.netmail_path) - 1] = '\0';
    }

}

/* ******************************************************************************************************************************************************** */
/* Listener Management                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

int mailer_create_listener(void)
{
    struct sockaddr_in addr;
    int yes = 1;

    mailer.listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (mailer.listen_socket < 0)
    {
        debug_printf("mailer: Failed to create listener socket");
        return 0;
    }

    setsockopt(mailer.listen_socket, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));

    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons((unsigned short)mailer.listen_port);

    if (bind(mailer.listen_socket, (struct sockaddr *)&addr, sizeof(addr)) < 0)
    {
        debug_printf("mailer: Failed to bind to port %d", mailer.listen_port);
        socketclose(mailer.listen_socket);
        mailer.listen_socket = -1;
        return 0;
    }

    if (listen(mailer.listen_socket, 5) < 0)
    {
        debug_printf("mailer: Failed to listen");
        socketclose(mailer.listen_socket);
        mailer.listen_socket = -1;
        return 0;
    }

    /* Set non-blocking */
    {
        int flags = 1;
        socketioctl(mailer.listen_socket, FIONBIO, &flags);
    }

    mailer.listener_active = 1;
    mailer_log_ftn("Listening on port %d", mailer.listen_port);

    return 1;
}

void mailer_destroy_listener(void)
{
    if (mailer.listen_socket >= 0)
    {
        socketclose(mailer.listen_socket);
        mailer.listen_socket = -1;
    }
    mailer.listener_active = 0;
}

void mailer_accept_connection(void)
{
    struct sockaddr_in client_addr;
    int client_addr_len = sizeof(client_addr);
    int client_socket;
    MAILER_SESSION *session;

    client_socket = accept(mailer.listen_socket,
                           (struct sockaddr *)&client_addr, &client_addr_len);

    if (client_socket < 0)
    {
        return;  /* No connection waiting */
    }

    session = mailer_allocate_session();
    if (session == NULL)
    {
        /* No free sessions */
        debug_printf("mailer: No free sessions, rejecting connection");

        /* Send BSY and close */
        {
            unsigned char frame[64];
            int len = binkp_build_command(frame, BINKP_M_BSY, "No free sessions");
            send(client_socket, frame, len, 0);
        }

        socketclose(client_socket);
        return;
    }

    /* Set non-blocking */
    {
        int flags = 1;
        socketioctl(client_socket, FIONBIO, &flags);
    }

    session->socket = client_socket;
    session->direction = SESSION_DIR_INBOUND;
    session->state = SESSION_STATE_WAIT_NUL;
    session->connect_time = time(NULL);
    session->last_activity = session->connect_time;

    /* Get remote hostname */
    strncpy(session->remote_hostname, inet_ntoa(client_addr.sin_addr),
            sizeof(session->remote_hostname) - 1);

    /* Update status window for incoming call - use network 0 for now (updated when authenticated) */
    ftnstatus_set_session_direction(0);  /* Inbound */
    {
        char activity[128];
        snprintf(activity, sizeof(activity), "Connecting from %s...", session->remote_hostname);
        ftnstatus_set_activity(0, 0, activity);  /* Inbound connection */
    }
    ftnlog_printf("Incoming connection from %s", session->remote_hostname);

    mailer_log_ftn("Incoming connection from %s", session->remote_hostname);
    mailer.total_sessions++;

    /* Send our handshake */
    binkp_send_handshake(session);
}

/* ******************************************************************************************************************************************************** */
/* Session Management                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

MAILER_SESSION *mailer_allocate_session(void)
{
    int i;

    if (mailer.max_sessions <= 0)
    {
        mailer.max_sessions = 1;
    }

    if (mailer.active_sessions >= mailer.max_sessions)
    {
        debug_printf("mailer: Active session limit reached (%d)", mailer.max_sessions);
        return NULL;
    }

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        if (!mailer.sessions[i].active)
        {
            memset(&mailer.sessions[i], 0, sizeof(MAILER_SESSION));
            mailer.sessions[i].active = 1;
            mailer.sessions[i].socket = -1;
            mailer.active_sessions++;
            return &mailer.sessions[i];
        }
    }

    return NULL;
}

void mailer_free_session(MAILER_SESSION *session)
{
    int i;

    if (session->socket >= 0)
    {
        socketclose(session->socket);
        session->socket = -1;
    }

    if (session->send_file.file != NULL)
    {
        fclose(session->send_file.file);
        session->send_file.file = NULL;
    }

    if (session->recv_file.file != NULL)
    {
        fclose(session->recv_file.file);
        session->recv_file.file = NULL;
        
        /* Clean up incomplete temp file from disk */
        if (session->recv_file.local_path[0] != '\0')
        {
            debug_printf("mailer: Cleaning up incomplete receive: %s", session->recv_file.local_path);
            mailer_log("Removing incomplete file: %s", session->recv_file.filename);
            remove(session->recv_file.local_path);
            session->recv_file.local_path[0] = '\0';
        }
    }

    /* Clean up sent files queue (NR mode) - close any open file handles */
    for (i = 0; i < session->sent_files_count; i++)
    {
        if (session->sent_files[i].file != NULL)
        {
            fclose(session->sent_files[i].file);
            session->sent_files[i].file = NULL;
        }
        /* Note: Files in sent queue are NOT marked as sent if session closes prematurely.
         * They will be resent in the next session, as per BinkD behavior. */
    }
    session->sent_files_count = 0;

    /* Update queue */
    queue_mark_node_busy(&session->remote_addr, 0);

    session->active = 0;
    mailer.active_sessions--;
}

void mailer_close_session(MAILER_SESSION *session, const char *reason)
{
    char addr_str[64];
    int received_files = session->files_received;
    FTN_ADDR remote_addr = session->remote_addr;  /* Save before freeing */

    ftn_addr_to_string(&session->remote_addr, addr_str, sizeof(addr_str));

    mailer_log_ftn("Session closed with %s: %s (sent %d files/%ld bytes, recv %d files/%ld bytes)",
            addr_str, reason,
            session->files_sent, session->bytes_sent,
            session->files_received, session->bytes_received);

    /* Update statistics */
    mailer.total_files_sent += session->files_sent;
    mailer.total_files_received += session->files_received;
    mailer.total_bytes_sent += session->bytes_sent;
    mailer.total_bytes_received += session->bytes_received;

    mailer_free_session(session);

    /* Schedule next poll for this node - don't poll again immediately */
    /* Wait 5 minutes (300 seconds) before polling this uplink again */
    {
        QUEUE_NODE *node = queue_find_node(&remote_addr);
        if (node != NULL)
        {
            int delay = (mailer.retry_delay > 0) ? mailer.retry_delay : 300;
            node->next_poll = time(NULL) + delay;
            debug_printf("mailer: Next poll for %s in %d seconds", addr_str, delay);
        }
    }

    /* Auto-toss if we received any files */
    if (received_files > 0)
    {
        int tossed = tosser_process_inbound();
        if (tossed > 0)
        {
            mailer_log_ftn("Auto-tossed %d messages", tossed);
        }
        
        /* Process TIC files for file distribution */
        tossed = tic_process_inbound();
        if (tossed > 0)
        {
            mailer_log_ftn("Processed %d TIC files", tossed);
        }
    }

    /* Reset status window to idle state */
    ftnstatus_clear_all();
}

/*
 * Check if an FTN address is busy (already has an active session).
 * Used to prevent multiple concurrent sessions to the same node.
 * The 'exclude' parameter allows excluding a specific session from the check
 * (e.g., the session making the check to see if others exist).
 * Returns 1 if busy (another session exists), 0 if not busy.
 */
int mailer_is_aka_busy(const FTN_ADDR *addr, MAILER_SESSION *exclude)
{
    int i;

    if (addr == NULL)
    {
        return 0;
    }

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        MAILER_SESSION *session = &mailer.sessions[i];

        /* Skip inactive sessions */
        if (!session->active)
        {
            continue;
        }

        /* Skip the excluded session */
        if (session == exclude)
        {
            continue;
        }

        /* Check if this session is for the same address */
        if (session->remote_addr.zone == addr->zone &&
            session->remote_addr.net == addr->net &&
            session->remote_addr.node == addr->node &&
            session->remote_addr.point == addr->point)
        {
            return 1;  /* AKA is busy */
        }
    }

    return 0;  /* AKA is not busy */
}

/* ******************************************************************************************************************************************************** */
/* Session Processing                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

static void process_session_rx(MAILER_SESSION *session)
{
    fd_set readfds;
    struct timeval tv;
    int select_result;
    int bytes;
    int loops = 0;
    const int MAX_LOOPS = 10;  /* Prevent infinite loop */

    /* First check if data is available using select() */
    FD_ZERO(&readfds);
    FD_SET(session->socket, &readfds);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    
    select_result = select(session->socket + 1, &readfds, NULL, NULL, &tv);
    
    if (select_result < 0)
    {
        /* select() error */
        if (errno != EINTR)
        {
            debug_printf("mailer: select() error on rx: errno=%d (%s) state=%d", 
                         errno, _inet_err(), session->state);
        }
        return;
    }
    
    if (select_result == 0)
    {
        /* No data ready yet - this is normal for non-blocking */
        return;
    }

    /* Read all available data until EWOULDBLOCK (per RISC OS documentation) */
    while (loops < MAX_LOOPS)
    {
        loops++;
        
        /* Check if buffer has space */
        if (session->rx_length >= (int)sizeof(session->rx_buffer))
        {
            debug_printf("mailer: RX buffer full!");
            break;
        }
        
        /* Read data */
        bytes = socketread(session->socket,
                           &session->rx_buffer[session->rx_length],
                           sizeof(session->rx_buffer) - session->rx_length);

        if (bytes > 0)
        {
            /* Decrypt incoming data if encryption is active */
            if (session->crypt_flag & BINKP_CRYPT_ACTIVE)
            {
                binkp_decrypt_buf(&session->rx_buffer[session->rx_length],
                                  bytes,
                                  session->crypt_keys_in);
            }

            session->rx_length += bytes;
            /* Continue reading - there may be more data */
        }
        else if (bytes == 0)
        {
            /* Connection closed by remote */
            ftnlog_printf("Remote closed connection");
            session->state = SESSION_STATE_CLOSING;
            return;
        }
        else
        {
            /* bytes < 0 - error or would-block */
            if (errno == EWOULDBLOCK || errno == EAGAIN)
            {
                /* No more data available - this is normal, exit the read loop */
                break;
            }
            else
            {
                /* Real error */
                debug_printf("mailer: Socket read error errno=%d (%s) state=%d", 
                             errno, _inet_err(), session->state);
                session->state = SESSION_STATE_ERROR;
                return;
            }
        }
    }

    /* Process complete frames */
    while (session->rx_length > 0 && binkp_frame_complete(session->rx_buffer, session->rx_length))
    {
        BINKP_FRAME frame;
        int consumed = binkp_parse_frame(session->rx_buffer, session->rx_length, &frame);

        if (consumed > 0)
        {
            binkp_handle_frame(session, &frame);

            /* Remove processed data from buffer */
            if (consumed < session->rx_length)
            {
                memmove(session->rx_buffer, &session->rx_buffer[consumed],
                        session->rx_length - consumed);
            }
            session->rx_length -= consumed;
            
            /* STATE GUARD: Stop processing if session state changed to error/closing.
             * Frame handlers can change state (e.g., M_ERR, M_BSY, authentication failure).
             * Continuing to process frames after error could cause issues.
             */
            if (session->state == SESSION_STATE_ERROR || 
                session->state == SESSION_STATE_CLOSING ||
                !session->active)
            {
                debug_printf("mailer: Session state changed during frame processing, stopping");
                break;
            }
        }
        else
        {
            break;
        }
    }
}

static void process_session_tx(MAILER_SESSION *session)
{
    fd_set writefds;
    struct timeval tv;
    int select_result;
    int bytes;
    int to_send;
    unsigned char send_buf[1024];

    if (session->tx_length <= session->tx_offset)
    {
        return;  /* Nothing to send */
    }

    /* First check if socket is ready for writing using select() */
    FD_ZERO(&writefds);
    FD_SET(session->socket, &writefds);
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    
    select_result = select(session->socket + 1, NULL, &writefds, NULL, &tv);
    if (select_result <= 0)
    {
        /* Not ready or error */
        if (select_result < 0 && errno != EINTR)
        {
            debug_printf("mailer: select() error on tx: errno=%d (%s)", errno, _inet_err());
        }
        return;
    }

    /* Prepare data to send - limit to buffer size */
    to_send = session->tx_length - session->tx_offset;
    if (to_send > (int)sizeof(send_buf))
    {
        to_send = (int)sizeof(send_buf);
    }

    /* Copy and optionally encrypt */
    if (session->crypt_flag & BINKP_CRYPT_ACTIVE)
    {
        /* Copy to temp buffer and encrypt */
        memcpy(send_buf, &session->tx_buffer[session->tx_offset], to_send);
        binkp_encrypt_buf(send_buf, to_send, session->crypt_keys_out);
        bytes = socketwrite(session->socket, send_buf, to_send);
    }
    else
    {
        /* Send directly without encryption */
        bytes = socketwrite(session->socket,
                            &session->tx_buffer[session->tx_offset], to_send);
    }

    if (bytes > 0)
    {
        session->tx_offset += bytes;

        /* Reset buffer if all sent */
        if (session->tx_offset >= session->tx_length)
        {
            session->tx_offset = 0;
            session->tx_length = 0;
        }
    }
    else if (errno != EWOULDBLOCK && errno != EAGAIN)
    {
        debug_printf("mailer: Socket write error errno=%d (%s)", errno, _inet_err());
        session->state = SESSION_STATE_ERROR;
    }
}

void mailer_process_sessions(void)
{
    int i;

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        MAILER_SESSION *session = &mailer.sessions[i];

        if (!session->active)
        {
            continue;
        }

        /* Handle based on state */
        switch (session->state)
        {
            case SESSION_STATE_CONNECTING:
                /* Use select() to check if socket is ready for writing (connection complete) */
                {
                    fd_set writefds, exceptfds;
                    struct timeval tv;
                    int select_result;
                    
                    FD_ZERO(&writefds);
                    FD_ZERO(&exceptfds);
                    FD_SET(session->socket, &writefds);
                    FD_SET(session->socket, &exceptfds);
                    
                    /* Zero timeout for non-blocking check */
                    tv.tv_sec = 0;
                    tv.tv_usec = 0;
                    
                    select_result = select(session->socket + 1, NULL, &writefds, &exceptfds, &tv);
                    
                    if (select_result > 0)
                    {
                        if (FD_ISSET(session->socket, &exceptfds))
                        {
                            /* Exception - connection failed */
                            debug_printf("mailer: select() reports exception on socket");
                            ftnlog_printf("Connection failed to %s", session->remote_hostname);
                            session->state = SESSION_STATE_ERROR;
                        }
                        else if (FD_ISSET(session->socket, &writefds))
                        {
                            /* Socket is writable - check for connection error */
                            int so_error = 0;
                            socklen_t so_len = sizeof(so_error);
                            
                            if (getsockopt(session->socket, SOL_SOCKET, SO_ERROR, &so_error, &so_len) == 0 &&
                                so_error == 0)
                            {
                                /* Connected successfully - start handshake */
                                session->state = SESSION_STATE_WAIT_NUL;
                                session->last_activity = time(NULL);
                                ftnlog_printf("Connected to %s", session->remote_hostname);
                                mailer_log_ftn("Connected to %s", session->remote_hostname);

                                /* Start BinkP handshake */
                                binkp_send_handshake(session);
                            }
                            else
                            {
                                debug_printf("mailer: getsockopt SO_ERROR=%d", so_error);
                                ftnlog_printf("Connection failed to %s (err %d)", session->remote_hostname, so_error);
                                session->state = SESSION_STATE_ERROR;
                            }
                        }
                    }
                    else if (select_result < 0)
                    {
                        /* select() error */
                        debug_printf("mailer: select() error errno=%d (%s)", errno, _inet_err());
                        if (errno != EINTR)
                        {
                            session->state = SESSION_STATE_ERROR;
                        }
                    }
                    /* select_result == 0 means no change yet, keep waiting */
                }
                break;

            case SESSION_STATE_CLOSING:
            case SESSION_STATE_ERROR:
                {
                    const char *reason;
                    if (session->state == SESSION_STATE_ERROR) {
                        reason = "Error";
                    } else if (session->authenticated) {
                        reason = "Complete";
                    } else {
                        reason = "Auth failed";
                    }
                    mailer_close_session(session, reason);
                }
                break;

            default:
                /* Process I/O */
                process_session_rx(session);
                process_session_tx(session);

                /* BinkP session processing */
                binkp_process_session(session);
                break;
        }
    }
}

void mailer_check_timeouts(void)
{
    int i;
    time_t now = time(NULL);

    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        MAILER_SESSION *session = &mailer.sessions[i];

        if (!session->active)
        {
            continue;
        }

        /* Abort stalled outbound connects before they consume the session budget */
        if (session->state == SESSION_STATE_CONNECTING)
        {
            if (mailer.connect_timeout > 0 && now - session->connect_time > mailer.connect_timeout)
            {
                const char *host = (session->remote_hostname[0] != '\0') ? session->remote_hostname : "unknown";
                mailer_log_ftn("Connect timeout waiting for %s", host);
                ftnlog_printf("Connect timeout: %s", host);
                session->state = SESSION_STATE_ERROR;
            }
            continue;
        }

        /* Check for session timeout */
        if (mailer.session_timeout > 0 && now - session->last_activity > mailer.session_timeout)
        {
            const char *host = (session->remote_hostname[0] != '\0') ? session->remote_hostname : "unknown";
            mailer_log_ftn("Session timeout (%s)", host);
            ftnlog_printf("Session timeout: %s", host);
            binkp_send_err(session, "Timeout");
            session->state = SESSION_STATE_ERROR;
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Outbound Polling                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int mailer_connect_to_node(const FTN_ADDR *addr, const char *hostname, int port, int is_uplink)
{
    MAILER_SESSION *session;
    struct sockaddr_in server_addr;
    struct hostent *host;
    int sock;
    char addr_str[64];

    ftn_addr_to_string(addr, addr_str, sizeof(addr_str));

    session = mailer_allocate_session();
    if (session == NULL)
    {
        debug_printf("mailer: No free sessions for outbound");
        return 0;
    }

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0)
    {
        debug_printf("mailer: Failed to create socket");
        mailer_free_session(session);
        return 0;
    }

    /* Resolve hostname */
    host = gethostbyname(hostname);
    if (host == NULL)
    {
        debug_printf("mailer: Failed to resolve %s", hostname);
        socketclose(sock);
        mailer_free_session(session);
        return 0;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    memcpy(&server_addr.sin_addr, host->h_addr, host->h_length);
    server_addr.sin_port = htons(port);

    /* Set non-blocking before connect */
    {
        int flags = 1;
        socketioctl(sock, FIONBIO, &flags);
    }

    if (connect(sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)
    {
        if (errno != EINPROGRESS && errno != EWOULDBLOCK)
        {
            debug_printf("mailer: Connect failed to %s:%d", hostname, port);
            socketclose(sock);
            mailer_free_session(session);
            return 0;
        }
    }

    session->socket = sock;
    session->direction = SESSION_DIR_OUTBOUND;
    session->state = SESSION_STATE_CONNECTING;
    session->remote_addr = *addr;
    session->target_addr = *addr;  /* Save target for password lookup */
    session->target_is_uplink = is_uplink;  /* Remember if this is an uplink for routing */
    session->connect_time = time(NULL);
    session->last_activity = session->connect_time;
    strncpy(session->remote_hostname, hostname, sizeof(session->remote_hostname) - 1);

    /* Mark node as busy */
    queue_mark_node_busy(addr, 1);

    /* Update status window for outbound connection */
    ftnstatus_set_session_direction(1);  /* Outbound */
    {
        char activity[128];
        int network_id = ftnstatus_find_network_by_zone(addr->zone);
        snprintf(activity, sizeof(activity), "Connecting to %s...", addr_str);
        ftnstatus_set_activity(network_id >= 0 ? network_id : 0, 1, activity);
    }

    /* Log to connection window */
    ftnlog_printf("Connecting to %s:%d%s", hostname, port, is_uplink ? " (uplink)" : "");
    ftnlog_printf("Node: %s", addr_str);

    mailer_log_ftn("Connecting to %s (%s:%d)%s", addr_str, hostname, port, is_uplink ? " [uplink]" : "");
    mailer.total_sessions++;

    return 1;
}

/*
 * Poll the next uplink that is ready for connection.
 * This is non-blocking - it starts a connection and returns immediately.
 * The session will be processed by the normal event loop.
 * Returns 1 if a connection was started, 0 if no nodes are ready.
 */
int mailer_poll_next_ready_node(void)
{
    QUEUE_NODE *node;
    char addr_str[64];

    /* Check if we have capacity for another session */
    if (mailer.active_sessions >= mailer.max_sessions)
    {
        return 0;  /* All session slots full */
    }

    /* Find the next node ready for polling */
    node = queue_get_next_poll_node();
    if (node == NULL)
    {
        return 0;  /* No nodes ready */
    }

    ftn_addr_to_string(&node->addr, addr_str, sizeof(addr_str));

    /* Skip nodes without hostname (safety check - queue_get_next_poll_node should already filter) */
    if (node->hostname[0] == '\0')
    {
        debug_printf("mailer: Skipping %s (no hostname)", addr_str);
        return 0;
    }

    /* Mark as busy BEFORE connecting to prevent immediate re-selection */
    queue_mark_node_busy(&node->addr, 1);

    /* Start non-blocking connection */
    ftnlog_printf("Connecting to %s (%s:%d)%s", addr_str, node->hostname, node->port,
                  node->is_uplink ? " [uplink]" : "");
    
    if (!mailer_connect_to_node(&node->addr, node->hostname, node->port, node->is_uplink))
    {
        ftnlog_printf("Failed to start connection to %s", addr_str);
        /* Mark as not busy and schedule retry */
        queue_mark_node_busy(&node->addr, 0);
        queue_schedule_retry(node, mailer.retry_delay > 0 ? mailer.retry_delay : 300);
        return 0;
    }

    return 1;  /* Connection started */
}

/*
 * Poll all configured uplinks.
 * This is now NON-BLOCKING - it starts connections to ready nodes
 * up to max_sessions and returns immediately.
 * Sessions are processed by the normal event loop.
 * Called on startup and when user clicks Poll menu.
 */
void mailer_poll_all_uplinks(void)
{
    int connections_started = 0;
    int max_to_start;

    /* Re-entry guard: prevent recursive calls during Wimp_Poll dispatch */
    if (mailer.polling_in_progress)
    {
        debug_printf("mailer: Poll already in progress, ignoring re-entry");
        return;
    }
    mailer.polling_in_progress = 1;

    debug_printf("mailer: Polling uplinks... active=%d, max=%d, nodes=%d",
                 mailer.active_sessions, mailer.max_sessions, outbound_queue.node_count);
    ftnlog_printf("Starting poll run (%d nodes in queue)", outbound_queue.node_count);

    /* Calculate how many connections we can start */
    max_to_start = mailer.max_sessions - mailer.active_sessions;
    if (max_to_start <= 0)
    {
        debug_printf("mailer: No session slots available");
        ftnlog_printf("All session slots busy (%d/%d)", mailer.active_sessions, mailer.max_sessions);
        mailer.polling_in_progress = 0;
        return;
    }

    /* Start connections to ready nodes (non-blocking) */
    while (connections_started < max_to_start)
    {
        if (!mailer_poll_next_ready_node())
        {
            break;  /* No more nodes ready */
        }
        connections_started++;
    }

    debug_printf("mailer: Started %d connections", connections_started);
    if (connections_started > 0)
    {
        ftnlog_printf("Started %d connection(s)", connections_started);
    }
    else
    {
        ftnlog_printf("No nodes ready for polling");
    }

    mailer.polling_in_progress = 0;
}

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/*
 * Create a directory, including any missing parent directories.
 * Similar to 'mkdir -p' behaviour - creates the full path hierarchy.
 */
static void ensure_directory_exists(const char *path)
{
    _kernel_swi_regs regs;
    char parent[MAILER_PATH_SIZE];
    char *last_dot;

    if (path == NULL || path[0] == '\0')
    {
        return;
    }

    /* First, try to create the directory directly */
    regs.r[0] = 8;  /* OS_File 8 = Create directory */
    regs.r[1] = (int)path;
    regs.r[4] = 0;  /* Default number of entries */

    if (_kernel_swi(OS_File, &regs, &regs) == NULL)
    {
        return;  /* Success or already exists */
    }

    /* Failed - try to create parent directory first */
    strncpy(parent, path, sizeof(parent) - 1);
    parent[sizeof(parent) - 1] = '\0';

    last_dot = strrchr(parent, '.');
    if (last_dot != NULL && last_dot != parent)
    {
        *last_dot = '\0';  /* Truncate to parent path */

        /* Recursively ensure parent exists */
        ensure_directory_exists(parent);

        /* Now try again to create the original directory */
        regs.r[0] = 8;
        regs.r[1] = (int)path;
        regs.r[4] = 0;
        _kernel_swi(OS_File, &regs, &regs);
    }
}

/*
 * Check if a path exists (file or directory).
 * Returns: 0 = not found, 1 = file, 2 = directory
 */
static int path_exists(const char *path)
{
    _kernel_swi_regs regs;

    regs.r[0] = 17;  /* OS_File 17 = Read catalogue info, no path */
    regs.r[1] = (int)path;

    if (_kernel_swi(OS_File, &regs, &regs) != NULL)
    {
        return 0;
    }

    return regs.r[0];  /* 0=not found, 1=file, 2=directory */
}

static void mailer_add_zone(int *zones, int *count, int zone)
{
    int i;

    if (zone <= 0)
    {
        zone = 2;
    }

    for (i = 0; i < *count; i++)
    {
        if (zones[i] == zone)
        {
            return;
        }
    }

    if (*count < 16)
    {
        zones[*count] = zone;
        (*count)++;
    }
}

static void mailer_create_directories(void)
{
    int zones[16];
    int zone_count = 0;
    int i;

    debug_printf("mailer: Creating FTN directory structure...");

    /* Create main FTN directories (zone-specific subdirs created in loop below) */
    ensure_directory_exists(mailer.inbound_path);
    ensure_directory_exists(mailer.outbound_path);
    ensure_directory_exists(mailer.netmail_path);

    /* Collect zones we should provision (always include zone 2) */
    mailer_add_zone(zones, &zone_count, 2);
    for (i = 0; i < mailer.our_addr_count; i++)
    {
        mailer_add_zone(zones, &zone_count, mailer.our_addrs[i].zone);
    }

    /* Ensure inbound and outbound subdirectories for each zone */
    for (i = 0; i < zone_count; i++)
    {
        int zone = zones[i];
        char inbound_zone[MAILER_PATH_SIZE];
        char outbound_zone[MAILER_PATH_SIZE];
        char temp_path[MAILER_PATH_SIZE];
        char processed_path[MAILER_PATH_SIZE];
        char bad_path[MAILER_PATH_SIZE];

        /* Inbound zone directory and subdirs */
        ftn_format_zone_path(inbound_zone, sizeof(inbound_zone), mailer.inbound_path, zone);
        ftn_format_zone_subpath(temp_path, sizeof(temp_path), mailer.inbound_path, zone, "Temp");
        ftn_format_zone_subpath(processed_path, sizeof(processed_path), mailer.inbound_path, zone, "Processed");
        ftn_format_zone_subpath(bad_path, sizeof(bad_path), mailer.inbound_path, zone, "Bad");

        ensure_directory_exists(inbound_zone);
        ensure_directory_exists(temp_path);
        ensure_directory_exists(processed_path);
        ensure_directory_exists(bad_path);

        debug_printf("mailer:   Inbound zone %d: %s %s", zone, inbound_zone,
                     path_exists(inbound_zone) == 2 ? "(OK)" : "(FAILED)");
        debug_printf("mailer:     Temp: %s %s", temp_path,
                     path_exists(temp_path) == 2 ? "(OK)" : "(FAILED)");
        debug_printf("mailer:     Processed: %s %s", processed_path,
                     path_exists(processed_path) == 2 ? "(OK)" : "(FAILED)");
        debug_printf("mailer:     Bad: %s %s", bad_path,
                     path_exists(bad_path) == 2 ? "(OK)" : "(FAILED)");

        /* Outbound zone directory */
        ftn_format_zone_path(outbound_zone, sizeof(outbound_zone), mailer.outbound_path, zone);
        ensure_directory_exists(outbound_zone);

        debug_printf("mailer:   Outbound zone %d: %s %s", zone, outbound_zone,
                     path_exists(outbound_zone) == 2 ? "(OK)" : "(FAILED)");
    }

    /* Log other shared directories */
    debug_printf("mailer:   Netmail: %s %s", mailer.netmail_path,
                 path_exists(mailer.netmail_path) == 2 ? "(OK)" : "(FAILED)");
}

void mailer_initialise(void)
{
    memset(&mailer, 0, sizeof(mailer));

    mailer.listen_socket = -1;
    mailer.listen_port = BINKP_DEFAULT_PORT;
    mailer.max_sessions = MAILER_MAX_SESSIONS;
    mailer.connect_timeout = 60;
    mailer.session_timeout = 300;
    mailer.scan_interval = 60;
    mailer.toss_interval = 0;   /* Disabled by default */
    mailer.poll_interval = 0;   /* Disabled by default */
    mailer.retry_delay = 300;
    mailer.start_time = time(NULL);
    mailer.last_auto_toss = mailer.start_time;
    mailer.last_auto_poll = mailer.start_time;

    timer_initialise();
    queue_initialise();
    tosser_initialise();
    scanner_initialise();
    packer_initialise();
    tic_initialise();
    echofix_initialise();
    nodelist_initialise();
    mailer_load_config();
    mailer_create_directories();
    
    /* Set TIC inbound path to main inbound (TIC files arrive with other files) */
    tic_set_inbound_path(mailer.inbound_path);
}

void mailer_finalise(void)
{
    int i;

    /* Close all sessions */
    for (i = 0; i < MAILER_MAX_SESSIONS; i++)
    {
        if (mailer.sessions[i].active)
        {
            mailer_close_session(&mailer.sessions[i], "Shutdown");
        }
    }

    mailer_destroy_listener();
    ftnstatus_finalise();
    nodelist_finalise();;
    tic_finalise();
    echofix_finalise();
    packer_finalise();
    scanner_finalise();
    tosser_finalise();
    queue_finalise();
    timer_finalise();

    mailer_log_ftn("Mailer shutdown");
}

/* ******************************************************************************************************************************************************** */
/* Wimp Handlers                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

/* Forward declaration */
static Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref);

static Desk_bool wimp_handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
    (void)ref;

    if (event->data.mouse.button.data.select)
    {
        /* Open/close status window */
        if (ftnstatus_window_open)
        {
            ftnstatus_close_window();
        }
        else
        {
            ftnstatus_open_window();
        }
    }
    else if (event->data.mouse.button.data.adjust)
    {
        /* Open log window */
        ftnlog_open();
    }
    else if (event->data.mouse.button.data.menu)
    {
        Desk_Menu_Show(wimp.iconbar_menu_handle, event->data.mouse.pos.x, -1);
    }

    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_iconbar_menu_choice(Desk_event_pollblock *event, void *ref)
{
    (void)ref;

    debug_printf("mailer: Menu selection [0]=%d [1]=%d", 
                 event->data.selection[0], event->data.selection[1]);

    /* Check for submenu selection (Mail submenu) */
    if (event->data.selection[0] == ICONBAR_MENU_MAIL && event->data.selection[1] != -1)
    {
        debug_printf("mailer: Mail submenu selection %d", event->data.selection[1]);
        switch (event->data.selection[1])
        {
            case MAIL_MENU_POLL:
                /* Force poll now */
                ftnstatus_set_activity(0, 1, "Polling uplinks...");
                ftnlog_printf("Scanning outbound queue...");
                queue_scan_outbound();
                ftnlog_printf("Polling all uplinks...");
                mailer_poll_all_uplinks();
                ftnlog_printf("Poll complete");
                ftnstatus_clear_network(0);
                break;

            case MAIL_MENU_TOSS:
                /* Process inbound mail */
                ftnstatus_set_activity(0, 0, "Tossing inbound...");
                ftnlog_printf("Scanning inbound directory...");
                {
                    int count = tosser_process_inbound();
                    int tic_count;
                    
                    if (count > 0)
                    {
                        ftnlog_printf("Tossed %d messages", count);
                        mailer_log("Tossed %d messages", count);
                    }
                    else
                    {
                        ftnlog_printf("No packets found");
                    }
                    
                    /* Process TIC files */
                    tic_count = tic_process_inbound();
                    if (tic_count > 0)
                    {
                        ftnlog_printf("Received %d files", tic_count);
                    }
                }
                ftnstatus_clear_network(0);
                break;

            case MAIL_MENU_SCAN:
                /* Scan messagebases for outbound mail */
                ftnstatus_set_activity(0, 1, "Scanning outbound...");
                ftnlog_printf("Scanning for outbound mail...");
                {
                    int count = scanner_scan_outbound();
                    if (count > 0)
                    {
                        ftnlog_printf("Packed %d messages", count);
                        mailer_log("Packed %d messages for export", count);
                    }
                    else
                    {
                        ftnlog_printf("No outbound mail found");
                    }
                }
                ftnstatus_clear_network(0);
                break;
        }
        return Desk_bool_TRUE;
    }

    /* Handle main menu selections */
    switch (event->data.selection[0])
    {
        case ICONBAR_MENU_INFO:
            /* Show info window - handled by Menu_Warn */
            break;

        case ICONBAR_MENU_MAIL:
            /* Submenu - no direct action */
            break;

        case ICONBAR_MENU_COMMANDS:
            /* Submenu - no direct action */
            break;

        case ICONBAR_MENU_QUIT:
            wimp.quit = Desk_bool_TRUE;
            break;
    }

    /* Handle Commands submenu selections */
    if (event->data.selection[0] == ICONBAR_MENU_COMMANDS &&
        event->data.selection[1] != -1)
    {
        switch (event->data.selection[1])
        {
            case COMMANDS_MENU_FREQ:
                /* Open FREQ window at bottom-right, above iconbar */
                {
                    Desk_window_state state;
                    int screen_width, win_width, win_height;
                    
                    /* Get screen size */
                    screen_width = Desk_screen_size.x;
                    
                    /* Get window size */
                    Desk_Wimp_GetWindowState(ftnfreq_window, &state);
                    win_width = state.openblock.screenrect.max.x - state.openblock.screenrect.min.x;
                    win_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
                    
                    /* Position at bottom-right, above iconbar */
                    state.openblock.screenrect.max.x = screen_width - 16;
                    state.openblock.screenrect.min.x = screen_width - 16 - win_width;
                    state.openblock.screenrect.min.y = 134;  /* Just above iconbar */
                    state.openblock.screenrect.max.y = 134 + win_height;
                    state.openblock.behind = -1;  /* Open at front */
                    
                    Desk_Wimp_OpenWindow(&state.openblock);
                    
                    /* Set caret in the filename writable field */
                    Desk_Icon_SetCaret(ftnfreq_window, FTNFREQ_FILENAME);
                }
                break;

            case COMMANDS_MENU_NODELIST:
                /* Open nodelist upload window */
                ftnupload_open_window();
                break;
        }
    }

    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_window_open(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Wimp_OpenWindow(&event->data.openblock);
    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_window_close(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);
    Desk_Window_Hide(event->data.openblock.window);
    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_poll(Desk_event_pollblock *event, void *ref)
{
    time_t now = time(NULL);

    Desk_UNUSED(event);
    Desk_UNUSED(ref);

    /* Accept incoming connections */
    if (mailer.listener_active)
    {
        mailer_accept_connection();
    }

    /* Process active sessions */
    mailer_process_sessions();

    /* Check for timeouts */
    mailer_check_timeouts();

    /* Update status window timers */
    ftnstatus_update_timers();

    /* Periodically rescan outbound directories so new mail is noticed */
    if (outbound_queue.scan_interval > 0)
    {
        if (now - outbound_queue.last_scan >= outbound_queue.scan_interval)
        {
            /* First pack any locally posted messages into outbound packets */
            int packed = scanner_scan_outbound();
            if (packed > 0)
            {
                debug_printf("mailer: Auto-scan packed %d messages", packed);
            }
            
            /* Then scan BSO directories for new/changed files */
            queue_scan_outbound();
        }
    }

    /* Automatic toss: process inbound packets when no sessions active */
    if (mailer.toss_interval > 0 && mailer.active_sessions == 0)
    {
        if (now - mailer.last_auto_toss >= mailer.toss_interval)
        {
            int tossed, tic_count;
            
            debug_printf("mailer: Auto-toss triggered");
            ftnlog_printf("Auto-toss: processing inbound...");
            
            tossed = tosser_process_inbound();
            if (tossed > 0)
            {
                ftnlog_printf("Auto-toss: tossed %d messages", tossed);
            }
            
            /* Also process TIC files for file distribution */
            tic_count = tic_process_inbound();
            if (tic_count > 0)
            {
                ftnlog_printf("Auto-toss: processed %d TIC files", tic_count);
            }
            
            mailer.last_auto_toss = now;
        }
    }

    /* Automatic poll: trigger a poll run at configured intervals */
    if (mailer.poll_interval > 0 && !mailer.polling_in_progress)
    {
        /* Check startup delay */
        if (mailer.startup_delay_until > 0 && now < mailer.startup_delay_until)
        {
            /* Still in startup delay period - skip poll */
        }
        else if (now - mailer.last_auto_poll >= mailer.poll_interval)
        {
            int packed;
            
            /* Clear startup delay once we've polled */
            mailer.startup_delay_until = 0;
            
            debug_printf("mailer: Auto-poll triggered");
            ftnlog_printf("Auto-poll: connecting to uplinks...");
            /* Update timestamp BEFORE calling poll to prevent re-entry */
            mailer.last_auto_poll = now;
            
            /* Pack any locally posted messages before polling */
            packed = scanner_scan_outbound();
            if (packed > 0)
            {
                ftnlog_printf("Auto-poll: packed %d messages", packed);
            }
            
            /* Scan BSO directories for outbound files */
            queue_scan_outbound();
            mailer_poll_all_uplinks();
        }
    }

    /* Opportunistic connections: if we have free session slots and nodes ready,
     * start a connection. This allows multiple simultaneous sessions and
     * picks up nodes that became ready since the last poll run.
     * Skip during startup delay period.
     */
    if (mailer.active_sessions < mailer.max_sessions && !mailer.polling_in_progress &&
        (mailer.startup_delay_until == 0 || now >= mailer.startup_delay_until))
    {
        mailer_poll_next_ready_node();
    }

    return Desk_bool_TRUE;
}

static Desk_bool wimp_handle_broadcast_message(Desk_event_pollblock *event, void *ref)
{
    int reason;

    Desk_UNUSED(ref);

    if (event == NULL)
    {
        return Desk_bool_FALSE;
    }

    reason = event->data.message.data.words[0];

    /* Reason 0 = quit request from Server */
    if (reason == 0)
    {
        debug_printf("FTN Mailer: Received shutdown broadcast from Server");
        wimp.quit = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

/* ******************************************************************************************************************************************************** */
/* Wimp Setup                                                                                                                                               */
/* ******************************************************************************************************************************************************** */

static void create_iconbar_icon(void)
{
    wimp.iconbar_icon = Desk_Icon_BarIcon("!FTN", Desk_iconbar_RIGHT);
}

static void lookup_menu_string(const char *tag, char *buffer, size_t size, const char *fallback)
{
    /* Desk_Msgs_Lookup returns zero on success; populate fallback if it fails */
    if (Desk_Msgs_Lookup(tag, buffer, (int)size))
    {
        strncpy(buffer, fallback, size - 1);
        buffer[size - 1] = '\0';
    }
}

static void create_iconbar_menu(void)
{
    char iconbar_menu[100];
    char iconbar_menu_title[30];
    char mail_menu_items[100];
    char mail_menu_title[30];
    char commands_menu_items[100];
    char commands_menu_title[30];

    /* Create main iconbar menu */
    lookup_menu_string("ftn.ibmt", iconbar_menu_title, sizeof(iconbar_menu_title), "Mailer");
    lookup_menu_string("ftn.ibm", iconbar_menu, sizeof(iconbar_menu), "Info,Mail,Misc,Quit");
    wimp.iconbar_menu_handle = Desk_Menu_New(iconbar_menu_title, iconbar_menu);

    /* Create Mail submenu */
    lookup_menu_string("ftn.mailmt", mail_menu_title, sizeof(mail_menu_title), "Mail");
    lookup_menu_string("ftn.mailm", mail_menu_items, sizeof(mail_menu_items), "Poll,Toss,Scan");
    mail_menu = Desk_Menu_New(mail_menu_title, mail_menu_items);

    /* Create Commands submenu */
    lookup_menu_string("ftn.cmdmt", commands_menu_title, sizeof(commands_menu_title), "Misc");
    lookup_menu_string("ftn.cmdm", commands_menu_items, sizeof(commands_menu_items), "FREQ...,Nodelist...");
    commands_menu = Desk_Menu_New(commands_menu_title, commands_menu_items);

    /* Attach Mail submenu to Mail item if both menus were created */
    if (wimp.iconbar_menu_handle != NULL && mail_menu != NULL)
    {
        Desk_Menu_AddSubMenu(wimp.iconbar_menu_handle, ICONBAR_MENU_MAIL, mail_menu);
    }

    /* Attach Commands submenu */
    if (wimp.iconbar_menu_handle != NULL && commands_menu != NULL)
    {
        Desk_Menu_AddSubMenu(wimp.iconbar_menu_handle, ICONBAR_MENU_COMMANDS, commands_menu);
    }
}

static void poll_idle(void)
{
    Desk_event_pollblock event;
    Desk_event_pollmask mask;
    int next_time;

    mask.value = 0;
    mask.data.null = Desk_bool_FALSE;  /* We want null events */

    next_time = timer_get_next_wakeup();

    Desk_Wimp_PollIdle3(mask, &event, next_time, NULL);
    Desk_Event_Process(&event);
}

/* ******************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int main(int argc, char *argv[])
{
    (void)argc;
    (void)argv;

    debug_printf("FTN Mailer starting");

    /* Initialise Wimp */
    Desk_Event_Initialise(MAILER_TASK_NAME);
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");
    Desk_Template_Initialise();
    Desk_Template_LoadFile("Templates");

    wimp.quit = Desk_bool_FALSE;

    /* Create UI elements */
    create_iconbar_icon();
    create_iconbar_menu();
    proginfo_window = Desk_Window_Create("proginfo", Desk_template_TITLEMIN);
    wimp.main_window = Desk_Window_Create("status", Desk_template_TITLEMIN);
    ftnstatus_window = Desk_Window_Create("ftnstatus", Desk_template_TITLEMIN);
    ftnlog_window = Desk_Window_Create("ftnlog", Desk_template_TITLEMIN);
    ftnfreq_window = Desk_Window_Create("ftnfreq", Desk_template_TITLEMIN);
    ftnupload_window = Desk_Window_Create("ftnupload", Desk_template_TITLEMIN);

    /* Initialise ftnstatus module - creates dynamic network row icons */
    ftnstatus_initialise();

    /* Initialise ftnlog module */
    ftnlog_initialise(ftnlog_window);

    /* Initialise ftnupload module (no longer uses progress bar) */
    ftnupload_initialise(ftnupload_window, 0, 0, 0);

    /* Attach proginfo dialog as submenu of the Info entry */
    if (wimp.iconbar_menu_handle != NULL && proginfo_window != NULL)
    {
        Desk_Menu_AddSubMenu(wimp.iconbar_menu_handle, ICONBAR_MENU_INFO,
                             (Desk_menu_ptr)proginfo_window);
    }

    /* Register event handlers */
    Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, Desk_event_ANY,
                     wimp_handle_iconbar_click, NULL);
    Desk_Event_Claim(Desk_event_CLICK, ftnfreq_window, Desk_event_ANY,
                     ftnfreq_handle_click, NULL);
    Desk_Event_Claim(Desk_event_CLICK, ftnupload_window, Desk_event_ANY,
                     ftnupload_handle_click, NULL);
    Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_iconbar_menu_choice, NULL);
    Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_window_open, NULL);
    Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_window_close, NULL);
    Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY,
                     Desk_Handler_NullRedraw, NULL);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY,
                     wimp_handle_poll, NULL);

    /* Register for shutdown broadcast from Server */
    Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_BROADCAST, Desk_event_ANY,
                        wimp_handle_broadcast_message, NULL);

    /* Register for DataLoad messages (drag and drop) */
    Desk_EventMsg_Claim(Desk_message_DATALOAD, Desk_event_ANY,
                        ftnupload_handle_dataload, NULL);

    /* Initialise mailer */
    mailer_initialise();

    /* Create listener */
    mailer_create_listener();

    /* Delay initial poll by 30 seconds to let everything initialise */
    mailer.startup_delay_until = time(NULL) + 30;
    mailer.last_auto_poll = time(NULL);
    mailer.last_auto_toss = time(NULL);

    mailer_log_ftn("Mailer ready (%s %s)", MAILER_NAME, MAILER_VERSION);
    ftnlog_printf("Initial poll in 30 seconds...");

    /* Main loop */
    while (wimp.quit == Desk_bool_FALSE)
    {
        poll_idle();
    }

    /* Cleanup */
    mailer_finalise();
    Desk_Template_ClearAll();

    return 0;
}
