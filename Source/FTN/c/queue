/* ******************************************************************************************************************************************************** */
/* FTN Mailer - Queue Implementation                                                                                                                        */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "queue.h"
#include "mailer.h"
#include "debug.h"
#include "ftnlog.h"

/* SWI numbers */
#define SWI_SUPPORT_FTN     0x5AA86

/* FTN config reasons */
#define FTN_CONFIG_GET_GLOBAL       0
#define FTN_CONFIG_COUNT_UPLINKS    7
#define FTN_CONFIG_GET_UPLINK       4

/* FTN config structure sizes */
#define Q_FTN_MAX_UPLINKS           16
#define Q_FTN_NAME_LEN              64
#define Q_FTN_PATH_LEN              256
#define Q_FTN_PASSWORD_LEN          32
#define Q_FTN_GROUPS_LEN            64
#define Q_FTN_MAX_ALIASES           8

/* FTN global config structures (must match Support module) */
typedef struct
{
    int id;
    char address[Q_FTN_NAME_LEN];
    char network[Q_FTN_NAME_LEN];
    char host[Q_FTN_NAME_LEN];
    int port;
    char password[Q_FTN_PASSWORD_LEN];
    char groups[Q_FTN_GROUPS_LEN];
    int alias_count;
    char aliases[Q_FTN_MAX_ALIASES][Q_FTN_NAME_LEN];
} Q_UPLINK_CFG;

typedef struct
{
    int id;
    char network[Q_FTN_NAME_LEN];
    int zone, net, node, point;
    char type[8];
    char packet_password[Q_FTN_PASSWORD_LEN];
    char areafix_password[Q_FTN_PASSWORD_LEN];
} Q_ADDRESS_CFG;

typedef struct
{
    char sysop[Q_FTN_NAME_LEN];
    char system[Q_FTN_NAME_LEN];
    char location[Q_FTN_NAME_LEN];
    char phone[Q_FTN_NAME_LEN];
    int speed;
    char flags[Q_FTN_GROUPS_LEN];
    char inbound[Q_FTN_PATH_LEN];
    char outbound[Q_FTN_PATH_LEN];
    char netmail[Q_FTN_PATH_LEN];
    char freqpath[Q_FTN_PATH_LEN];
    char freqexec[Q_FTN_PATH_LEN];
    long max_packet_size;
    int listen_port;
    int max_sessions;
    int connect_timeout;
    int session_timeout;
    int scan_interval;
    int toss_interval;
    int poll_interval;
    int retry_delay;
    int address_count;
    Q_ADDRESS_CFG addresses[8];
    int uplink_count;
    Q_UPLINK_CFG uplinks[Q_FTN_MAX_UPLINKS];
} Q_FTN_GLOBAL_CFG;

/* ******************************************************************************************************************************************************** */
/* Global Queue                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

OUTBOUND_QUEUE outbound_queue;

/* ******************************************************************************************************************************************************** */
/* Initialisation                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

void queue_initialise(void)
{
    memset(&outbound_queue, 0, sizeof(outbound_queue));
    outbound_queue.scan_interval = 60;  /* Scan every 60 seconds */
}

void queue_set_scan_interval(int seconds)
{
    if (seconds <= 0)
    {
        seconds = 60;
    }
    outbound_queue.scan_interval = seconds;
}

void queue_finalise(void)
{
    /* Nothing to clean up */
}

/* ******************************************************************************************************************************************************** */
/* BSO Path Helpers                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

/*
 * BSO (Binkley-Style Outbound) directory structure for RISC OS:
 * Note: RISC OS doesn't use file extensions, so we append them directly to filenames.
 * 
 * All zones use 3-digit hex subdirectories:
 * <outbound>.001            - Zone 1
 * <outbound>.002            - Zone 2
 * <outbound>.003            - Zone 3
 * 
 * Similarly for inbound:
 * <inbound>.001             - Zone 1
 * <inbound>.002             - Zone 2
 * <inbound>.003             - Zone 3
 * 
 * Within each zone directory (RISC OS style - no dots in filenames):
 * NNNNNNNNout              - Normal mail (net/node as 8 hex chars)
 * NNNNNNNNhut              - Hold mail
 * NNNNNNNNdut              - Direct mail
 * NNNNNNNNcut              - Crash mail
 * NNNNNNNNiut              - Immediate mail
 * NNNNNNNNflo              - Normal file attach list
 * NNNNNNNNhlo              - Hold file attach list
 * etc.
 * NNNNNNNNpnt              - Point directory
 * NNNNNNNNpnt.PPPPPPPP*    - Point files
 */

void queue_format_bso_path(char *buffer, size_t size, const FTN_ADDR *addr)
{
    char zone_dir[MAILER_PATH_SIZE];

    /* Get zone directory using shared helper */
    ftn_format_zone_path(zone_dir, sizeof(zone_dir), mailer.outbound_path, addr->zone);

    if (addr->point == 0)
    {
        snprintf(buffer, size, "%s.%04x%04x", zone_dir, addr->net, addr->node);
    }
    else
    {
        snprintf(buffer, size, "%s.%04x%04xpnt.%08x",
                 zone_dir, addr->net, addr->node, addr->point);
    }
}

void queue_format_outbound_name(char *buffer, size_t size, const FTN_ADDR *addr, const char *ext)
{
    char zone_dir[MAILER_PATH_SIZE];

    /* Get zone directory using shared helper */
    ftn_format_zone_path(zone_dir, sizeof(zone_dir), mailer.outbound_path, addr->zone);

    if (addr->point == 0)
    {
        /* Node: NNNNNNNNext (no dot before extension) */
        snprintf(buffer, size, "%s.%04x%04x%s",
                 zone_dir, addr->net, addr->node, ext);
    }
    else
    {
        /* Point: NNNNNNNNpnt.PPPPPPPPext */
        snprintf(buffer, size, "%s.%04x%04xpnt.%08x%s",
                 zone_dir, addr->net, addr->node, addr->point, ext);
    }
}

/* ******************************************************************************************************************************************************** */
/* Node Management                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

QUEUE_NODE *queue_find_node(const FTN_ADDR *addr)
{
    int i;

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        if (ftn_addr_match(&outbound_queue.nodes[i].addr, addr))
        {
            return &outbound_queue.nodes[i];
        }
    }

    return NULL;
}

/*
 * Find a queue node by checking both primary address and uplink aliases.
 * This is used when an uplink reports a different AKA than our config.
 * Returns the node if found, or NULL.
 */
QUEUE_NODE *queue_find_node_by_any_address(const FTN_ADDR *addr)
{
    _kernel_swi_regs regs;
    Q_FTN_GLOBAL_CFG *global;
    QUEUE_NODE *node;
    int i, j;

    /* First try exact match */
    node = queue_find_node(addr);
    if (node != NULL)
    {
        return node;
    }

    /* Get global FTN config */
    regs.r[0] = FTN_CONFIG_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }
    global = (Q_FTN_GLOBAL_CFG *)regs.r[0];

    /* Check each uplink's aliases by array index */
    for (i = 0; i < global->uplink_count; i++)
    {
        Q_UPLINK_CFG *uplink = &global->uplinks[i];
        FTN_ADDR uplink_addr;

        /* Check each alias */
        for (j = 0; j < uplink->alias_count; j++)
        {
            FTN_ADDR alias_addr;

            if (ftn_string_to_addr(uplink->aliases[j], &alias_addr) &&
                ftn_addr_match(&alias_addr, addr))
            {
                /* Found a match! Look up the queue node by primary address */
                if (ftn_string_to_addr(uplink->address, &uplink_addr))
                {
                    debug_printf("queue: Address %d:%d/%d.%d matched alias of uplink %s",
                                 addr->zone, addr->net, addr->node, addr->point,
                                 uplink->address);
                    return queue_find_node(&uplink_addr);
                }
            }
        }
    }

    return NULL;
}

QUEUE_NODE *queue_add_node(const FTN_ADDR *addr)
{
    QUEUE_NODE *node;

    if (outbound_queue.node_count >= QUEUE_MAX_NODES)
    {
        debug_printf("queue: Maximum nodes reached");
        return NULL;
    }

    node = &outbound_queue.nodes[outbound_queue.node_count++];
    memset(node, 0, sizeof(QUEUE_NODE));
    node->addr = *addr;
    node->port = BINKP_DEFAULT_PORT;

    return node;
}

void queue_remove_node(const FTN_ADDR *addr)
{
    int i;

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        if (ftn_addr_match(&outbound_queue.nodes[i].addr, addr))
        {
            /* Shift remaining nodes down */
            if (i < outbound_queue.node_count - 1)
            {
                memmove(&outbound_queue.nodes[i],
                        &outbound_queue.nodes[i + 1],
                        (outbound_queue.node_count - i - 1) * sizeof(QUEUE_NODE));
            }
            outbound_queue.node_count--;
            return;
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Helpers                                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

static int queue_directory_exists(const char *path)
{
    _kernel_swi_regs regs;

    if (path == NULL || *path == '\0')
    {
        return 0;
    }

    regs.r[0] = 17;  /* Read catalogue info */
    regs.r[1] = (int)path;
    if (_kernel_swi(OS_File, &regs, &regs) != NULL)
    {
        return 0;
    }

    return (regs.r[0] == 2);
}

static void queue_ensure_directory(const char *path)
{
    _kernel_swi_regs regs;

    if (path == NULL || *path == '\0')
    {
        return;
    }

    if (queue_directory_exists(path))
    {
        return;
    }

    regs.r[0] = 8;   /* Create directory */
    regs.r[1] = (int)path;
    regs.r[4] = 0;
    _kernel_swi(OS_File, &regs, &regs);
}

static int queue_strcasecmp(const char *s1, const char *s2)
{
    while (*s1 && *s2)
    {
        int c1 = tolower((unsigned char)*s1);
        int c2 = tolower((unsigned char)*s2);
        if (c1 != c2)
        {
            return c1 - c2;
        }
        s1++;
        s2++;
    }

    return tolower((unsigned char)*s1) - tolower((unsigned char)*s2);
}

static int queue_is_reserved_subdir(const char *name)
{
    static const char *reserved[] = { "temp", "processed", "bad" };
    int i;

    if (name == NULL || *name == '\0')
    {
        return 0;
    }

    for (i = 0; i < (int)(sizeof(reserved) / sizeof(reserved[0])); i++)
    {
        if (queue_strcasecmp(name, reserved[i]) == 0)
        {
            return 1;
        }
    }

    return 0;
}

static int queue_parse_zone_segment(const char *segment)
{
    char zone_str[4];
    int i;

    if (segment == NULL)
    {
        return 0;
    }

    for (i = 0; i < 3; i++)
    {
        if (segment[i] == '\0' || !isxdigit((unsigned char)segment[i]))
        {
            return 0;
        }
        zone_str[i] = tolower((unsigned char)segment[i]);
    }

    zone_str[3] = '\0';

    if (queue_is_reserved_subdir(zone_str))
    {
        return 0;
    }

    return (int)strtol(zone_str, NULL, 16);
}

void ftn_format_zone_path(char *buffer, size_t size, const char *base_path, int zone)
{
    int use_zone;

    if (buffer == NULL || size == 0)
    {
        return;
    }

    if (base_path == NULL || *base_path == '\0')
    {
        buffer[0] = '\0';
        return;
    }

    use_zone = (zone > 0) ? zone : 2;

    /* All zones use .XXX format (3-digit hex) */
    /* e.g., Outbound.001 for zone 1, Outbound.002 for zone 2, Inbound.003 for zone 3 */
    snprintf(buffer, size, "%s.%03x", base_path, use_zone);
}

void ftn_format_zone_subpath(char *buffer, size_t size, const char *base_path, int zone, const char *suffix)
{
    char zone_path[MAILER_PATH_SIZE];

    if (buffer == NULL || size == 0)
    {
        return;
    }

    if (suffix == NULL || *suffix == '\0')
    {
        ftn_format_zone_path(buffer, size, base_path, zone);
        return;
    }

    ftn_format_zone_path(zone_path, sizeof(zone_path), base_path, zone);

    if (zone_path[0] == '\0')
    {
        buffer[0] = '\0';
        return;
    }

    snprintf(buffer, size, "%s.%s", zone_path, suffix);
}

int ftn_extract_zone_from_path(const char *base_path, const char *full_path,
                               char *zone_path, size_t zone_path_size, int *zone_out)
{
    size_t base_len;
    int zone = 2;

    if (base_path == NULL || full_path == NULL)
    {
        return 0;
    }

    base_len = strlen(base_path);

    /* Check if full_path starts with base_path */
    if (strncmp(full_path, base_path, base_len) != 0)
    {
        return 0;
    }

    /* Check for zone suffix after base (e.g., Inbound.001) */
    if (full_path[base_len] == '.')
    {
        /* There's a child element - check if it's a zone directory */
        int candidate = queue_parse_zone_segment(full_path + base_len + 1);
        if (candidate > 0)
        {
            char next = full_path[base_len + 4];  /* After ".XXX" */
            if (next == '.' || next == '\0')
            {
                zone = candidate;
            }
        }
    }

    if (zone_out != NULL)
    {
        *zone_out = zone;
    }

    if (zone_path != NULL && zone_path_size > 0)
    {
        ftn_format_zone_path(zone_path, zone_path_size, base_path, zone);
    }

    return 1;
}

int ftn_enumerate_zone_directories(const char *base_path, FTN_ZONE_ENUM_CALLBACK callback, void *ctx)
{
    _kernel_swi_regs regs;
    char entry[256];
    int context = 0;
    int count = 0;

    if (base_path == NULL || callback == NULL)
    {
        return 0;
    }

    if (!queue_directory_exists(base_path))
    {
        return 0;
    }

    /* Enumerate all zone subdirectories (no special case for zone 2) */
    do
    {
        regs.r[0] = 9;
        regs.r[1] = (int)base_path;
        regs.r[2] = (int)entry;
        regs.r[3] = 1;
        regs.r[4] = context;
        regs.r[5] = sizeof(entry);
        regs.r[6] = (int)"*";

        if (_kernel_swi(OS_GBPB, &regs, &regs) != NULL)
        {
            break;
        }

        context = regs.r[4];

        if (regs.r[3] > 0)
        {
            int zone = queue_parse_zone_segment(entry);
            if (zone > 0)
            {
                char path[MAILER_PATH_SIZE];

                snprintf(path, sizeof(path), "%s.%s", base_path, entry);

                if (queue_directory_exists(path))
                {
                    callback(path, zone, ctx);
                    count++;
                }
            }
        }
    }
    while (context != -1);

    return count;
}

static void queue_get_zone_directory(char *buffer, size_t size, const FTN_ADDR *addr)
{
    int zone = (addr != NULL) ? addr->zone : 2;
    ftn_format_zone_path(buffer, size, mailer.outbound_path, zone);
}

void queue_ensure_outbound_directories(const FTN_ADDR *addr)
{
    char dir[MAILER_PATH_SIZE];

    if (addr == NULL)
    {
        return;
    }

    queue_get_zone_directory(dir, sizeof(dir), addr);
    queue_ensure_directory(dir);

    if (addr->point != 0)
    {
        queue_get_zone_directory(dir, sizeof(dir), addr);
        snprintf(dir + strlen(dir), sizeof(dir) - strlen(dir), ".%04x%04xpnt",
                 addr->net, addr->node);
        queue_ensure_directory(dir);
    }
}

/* ******************************************************************************************************************************************************** */
/* File Management                                                                                                                                          */
/* ******************************************************************************************************************************************************** */

int queue_add_file(QUEUE_NODE *node, const char *path, QUEUE_FILE_TYPE type, QUEUE_FLAVOUR flavour)
{
    QUEUE_FILE *file;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int objtype;
    long fsize;

    if (node->file_count >= QUEUE_MAX_FILES)
    {
        debug_printf("queue: Maximum files for node reached");
        return 0;
    }

    /* Get file info */
    regs.r[0] = 17;  /* Read catalogue info, no path */
    regs.r[1] = (int)path;
    err = _kernel_swi(OS_File, &regs, &regs);

    if (err != NULL || regs.r[0] == 0)
    {
        debug_printf("queue: File not found: %s", path);
        return 0;
    }

    objtype = regs.r[0];
    fsize = regs.r[4];

    if (objtype != 1)
    {
        /* Not a file */
        return 0;
    }

    file = &node->files[node->file_count++];
    memset(file, 0, sizeof(QUEUE_FILE));
    file->type = type;
    file->flavour = flavour;
    strncpy(file->path, path, sizeof(file->path) - 1);
    file->size = fsize;
    file->mtime = time(NULL);  /* TODO: Get actual file time */

    /* Extract filename from path */
    {
        const char *p = strrchr(path, '.');
        if (p != NULL)
        {
            strncpy(file->name, p + 1, sizeof(file->name) - 1);
        }
        else
        {
            strncpy(file->name, path, sizeof(file->name) - 1);
        }
    }

    node->total_size += fsize;

    /* Update max flavour */
    if (flavour > node->max_flavour)
    {
        node->max_flavour = flavour;
    }

    debug_printf("queue: Added file %s (%ld bytes) for %d:%d/%d.%d",
                 file->name, fsize,
                 node->addr.zone, node->addr.net, node->addr.node, node->addr.point);

    return 1;
}

void queue_remove_file(QUEUE_NODE *node, const char *path)
{
    int i;

    for (i = 0; i < node->file_count; i++)
    {
        if (strcmp(node->files[i].path, path) == 0)
        {
            node->total_size -= node->files[i].size;

            if (i < node->file_count - 1)
            {
                memmove(&node->files[i],
                        &node->files[i + 1],
                        (node->file_count - i - 1) * sizeof(QUEUE_FILE));
            }
            node->file_count--;
            return;
        }
    }
}

void queue_mark_file_sent(QUEUE_NODE *node, const char *path)
{
    int i;

    for (i = 0; i < node->file_count; i++)
    {
        if (strcmp(node->files[i].path, path) == 0)
        {
            QUEUE_FILE *file = &node->files[i];

            if (file->delete_after)
            {
                _kernel_swi_regs regs;
                regs.r[0] = 6;  /* Delete */
                regs.r[1] = (int)path;
                _kernel_swi(OS_File, &regs, &regs);
                debug_printf("queue: Deleted sent file: %s", path);
            }
            else if (file->truncate_after)
            {
                FILE *f = fopen(path, "w");
                if (f != NULL)
                {
                    fclose(f);
                }
                debug_printf("queue: Truncated sent file: %s", path);
            }

            queue_remove_file(node, path);
            return;
        }
    }
}

QUEUE_FILE *queue_get_next_file(QUEUE_NODE *node)
{
    int i;
    QUEUE_FILE *best = NULL;

    /* Return highest priority file first */
    for (i = 0; i < node->file_count; i++)
    {
        if (best == NULL || node->files[i].flavour > best->flavour)
        {
            best = &node->files[i];
        }
    }

    return best;
}

/*
 * Get the next file to send for a given zone.
 * This searches ALL queue nodes in the specified zone and returns
 * the highest priority file from any of them.
 * Also returns the node containing the file via node_out.
 */
QUEUE_FILE *queue_get_next_file_for_zone(int zone, QUEUE_NODE **node_out)
{
    int i;
    QUEUE_FILE *best_file = NULL;
    QUEUE_NODE *best_node = NULL;

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        QUEUE_NODE *node = &outbound_queue.nodes[i];
        QUEUE_FILE *file;

        /* Skip nodes not in this zone */
        if (node->addr.zone != zone)
        {
            continue;
        }

        /* Skip nodes with no files */
        if (node->file_count == 0)
        {
            continue;
        }

        /* Get best file from this node */
        file = queue_get_next_file(node);
        if (file != NULL)
        {
            /* Compare with current best */
            if (best_file == NULL || file->flavour > best_file->flavour)
            {
                best_file = file;
                best_node = node;
            }
        }
    }

    if (node_out != NULL)
    {
        *node_out = best_node;
    }

    return best_file;
}

/*
 * Count total files pending for a zone.
 */
int queue_count_files_for_zone(int zone)
{
    int i;
    int count = 0;

    debug_printf("queue: Counting files for zone %d (node_count=%d)", zone, outbound_queue.node_count);

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        debug_printf("queue:   Node %d: %d:%d/%d.%d has %d files",
                     i, outbound_queue.nodes[i].addr.zone,
                     outbound_queue.nodes[i].addr.net,
                     outbound_queue.nodes[i].addr.node,
                     outbound_queue.nodes[i].addr.point,
                     outbound_queue.nodes[i].file_count);

        if (outbound_queue.nodes[i].addr.zone == zone)
        {
            count += outbound_queue.nodes[i].file_count;
        }
    }

    debug_printf("queue: Total files for zone %d: %d", zone, count);
    return count;
}

/*
 * Count total files and bytes pending for a specific address.
 * Returns file count, stores total bytes in *total_bytes.
 */
int queue_count_files_for_address(const FTN_ADDR *addr, long *total_bytes)
{
    QUEUE_NODE *node;
    
    if (total_bytes != NULL)
    {
        *total_bytes = 0;
    }
    
    /* Find the node for this address */
    node = queue_find_node_by_any_address(addr);
    if (node == NULL)
    {
        return 0;
    }
    
    if (total_bytes != NULL)
    {
        *total_bytes = node->total_size;
    }
    
    return node->file_count;
}

/* ******************************************************************************************************************************************************** */
/* FLO File Parsing                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int queue_parse_flo_file(QUEUE_NODE *node, const char *path, QUEUE_FLAVOUR flavour)
{
    FILE *f;
    char line[MAILER_PATH_SIZE];
    int count = 0;

    f = fopen(path, "r");
    if (f == NULL)
    {
        return 0;
    }

    while (fgets(line, sizeof(line), f) != NULL)
    {
        char *p = line;
        int delete_after = 0;
        int truncate_after = 0;
        QUEUE_FILE *file;

        /* Remove trailing newline */
        {
            char *nl = strchr(p, '\n');
            if (nl != NULL) *nl = '\0';
            nl = strchr(p, '\r');
            if (nl != NULL) *nl = '\0';
        }

        /* Skip empty lines */
        if (*p == '\0')
        {
            continue;
        }

        /* Check for delete/truncate prefix */
        if (*p == '^')
        {
            delete_after = 1;
            p++;
        }
        else if (*p == '#')
        {
            truncate_after = 1;
            p++;
        }
        else if (*p == '~')
        {
            /* Already sent, skip */
            continue;
        }

        /* Add file to queue */
        if (queue_add_file(node, p, QUEUE_FILE_FLOENTRY, flavour))
        {
            file = &node->files[node->file_count - 1];
            file->delete_after = delete_after;
            file->truncate_after = truncate_after;
            count++;
        }
    }

    fclose(f);
    return count;
}

/* ******************************************************************************************************************************************************** */
/* Outbound Scanning                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

/*
 * Parse FTN address from BSO hex filename (e.g., "00fa0009" = net 250, node 9)
 */
static int parse_bso_hex_addr(const char *name, int zone, FTN_ADDR *addr)
{
    unsigned int net;
    unsigned int node;
    int len;

    if (name == NULL || addr == NULL)
    {
        return 0;
    }

    len = strlen(name);

    /* Must be at least 8 hex chars for net/node */
    if (len < 8)
    {
        return 0;
    }

    if (sscanf(name, "%04x%04x", &net, &node) != 2)
    {
        return 0;
    }

    memset(addr, 0, sizeof(FTN_ADDR));
    addr->zone = zone;
    addr->net = (int)net;
    addr->node = (int)node;
    addr->point = 0;

    return 1;
}

/*
 * Get flavour from RISC OS style extension (last 3 chars of filename)
 * e.g., "00fa0009out" -> NORMAL, "00fa0009cut" -> CRASH
 * Also handles packet files: "00fa0009xxxxxxxxpkt" (net/node + timestamp + pkt)
 */
static int get_flavour_from_name(const char *name, QUEUE_FLAVOUR *flavour, int *is_flo, int *is_pkt, int *is_req)
{
    int len = strlen(name);
    const char *ext;
    const char *suffix;

    *is_flo = 0;
    *is_pkt = 0;
    *is_req = 0;

    if (len < 11)  /* 8 hex + 3 ext minimum */
    {
        return 0;
    }

    /* First check for packet files ending in "pkt" (format: NNNNNNNNxxxxxxxxpkt) */
    /* These are 19 chars: 8 hex net/node + 8 hex timestamp + 3 char "pkt" */
    if (len >= 19)
    {
        suffix = name + len - 3;  /* Last 3 chars */
        if ((suffix[0] == 'p' || suffix[0] == 'P') && 
            (suffix[1] == 'k' || suffix[1] == 'K') && 
            (suffix[2] == 't' || suffix[2] == 'T'))
        {
            *flavour = QUEUE_FLAVOUR_NORMAL;
            *is_pkt = 1;
            return 1;
        }
    }

    ext = name + 8;  /* Extension starts after 8 hex digits for BSO files */

    /* Check for request files (.req) */
    if ((ext[0] == 'r' || ext[0] == 'R') && (ext[1] == 'e' || ext[1] == 'E') && (ext[2] == 'q' || ext[2] == 'Q'))
    {
        *flavour = QUEUE_FLAVOUR_NORMAL;
        *is_req = 1;
        return 1;
    }

    /* Check for packet files (.?ut) */
    if ((ext[0] == 'o' || ext[0] == 'O') && (ext[1] == 'u' || ext[1] == 'U') && (ext[2] == 't' || ext[2] == 'T'))
    {
        *flavour = QUEUE_FLAVOUR_NORMAL;
        return 1;
    }
    if ((ext[0] == 'h' || ext[0] == 'H') && (ext[1] == 'u' || ext[1] == 'U') && (ext[2] == 't' || ext[2] == 'T'))
    {
        *flavour = QUEUE_FLAVOUR_HOLD;
        return 1;
    }
    if ((ext[0] == 'd' || ext[0] == 'D') && (ext[1] == 'u' || ext[1] == 'U') && (ext[2] == 't' || ext[2] == 'T'))
    {
        *flavour = QUEUE_FLAVOUR_DIRECT;
        return 1;
    }
    if ((ext[0] == 'c' || ext[0] == 'C') && (ext[1] == 'u' || ext[1] == 'U') && (ext[2] == 't' || ext[2] == 'T'))
    {
        *flavour = QUEUE_FLAVOUR_CRASH;
        return 1;
    }
    if ((ext[0] == 'i' || ext[0] == 'I') && (ext[1] == 'u' || ext[1] == 'U') && (ext[2] == 't' || ext[2] == 'T'))
    {
        *flavour = QUEUE_FLAVOUR_IMMEDIATE;
        return 1;
    }

    /* Check for flow files (.?lo) */
    if ((ext[0] == 'f' || ext[0] == 'F') && (ext[1] == 'l' || ext[1] == 'L') && (ext[2] == 'o' || ext[2] == 'O'))
    {
        *flavour = QUEUE_FLAVOUR_NORMAL;
        *is_flo = 1;
        return 1;
    }
    if ((ext[0] == 'h' || ext[0] == 'H') && (ext[1] == 'l' || ext[1] == 'L') && (ext[2] == 'o' || ext[2] == 'O'))
    {
        *flavour = QUEUE_FLAVOUR_HOLD;
        *is_flo = 1;
        return 1;
    }
    if ((ext[0] == 'd' || ext[0] == 'D') && (ext[1] == 'l' || ext[1] == 'L') && (ext[2] == 'o' || ext[2] == 'O'))
    {
        *flavour = QUEUE_FLAVOUR_DIRECT;
        *is_flo = 1;
        return 1;
    }
    if ((ext[0] == 'c' || ext[0] == 'C') && (ext[1] == 'l' || ext[1] == 'L') && (ext[2] == 'o' || ext[2] == 'O'))
    {
        *flavour = QUEUE_FLAVOUR_CRASH;
        *is_flo = 1;
        return 1;
    }
    if ((ext[0] == 'i' || ext[0] == 'I') && (ext[1] == 'l' || ext[1] == 'L') && (ext[2] == 'o' || ext[2] == 'O'))
    {
        *flavour = QUEUE_FLAVOUR_IMMEDIATE;
        *is_flo = 1;
        return 1;
    }

    return 0;
}

/*
 * Look up uplink info for a node address to get hostname and port.
 * Returns 1 if found, 0 if not.
 */
static int lookup_uplink_for_node(const FTN_ADDR *addr, char *hostname, size_t host_size, int *port)
{
    _kernel_swi_regs regs;
    Q_FTN_GLOBAL_CFG *global;
    int i;

    /* Get global FTN config */
    regs.r[0] = FTN_CONFIG_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }
    global = (Q_FTN_GLOBAL_CFG *)regs.r[0];

    /* Check each uplink by array index */
    for (i = 0; i < global->uplink_count; i++)
    {
        Q_UPLINK_CFG *uplink = &global->uplinks[i];
        FTN_ADDR uplink_addr;

        /* Parse the uplink address */
        if (ftn_string_to_addr(uplink->address, &uplink_addr))
        {
            /* Check if this uplink handles our zone/net */
            /* Uplink addresses are typically hubs like 2:250/0 */
            if (uplink_addr.zone == addr->zone)
            {
                /* Found matching zone - use this uplink */
                if (uplink->host[0] != '\0')
                {
                    strncpy(hostname, uplink->host, host_size - 1);
                    hostname[host_size - 1] = '\0';
                    *port = (uplink->port > 0) ? uplink->port : BINKP_DEFAULT_PORT;
                    return 1;
                }
            }
        }
    }

    return 0;
}

/*
 * Scan a single zone directory for outbound mail.
 * Zone directory format: <outbound> for zone 2, <outbound>xxx for other zones
 * where xxx is 3-digit hex zone number.
 */
static int scan_zone_directory(const char *path, int zone)
{
    _kernel_swi_regs regs;
    char buffer[280];
    int count = 0;
    int context = 0;
    int read_count;
    int entries_seen = 0;

    debug_printf("queue: ---- Scanning zone %d: %s ----", zone, path);
    ftnlog_printf("  Zone %d: %s", zone, path);

    /* Use OS_GBPB 12 to enumerate directory with info */
    do
    {
        regs.r[0] = 12;  /* Read directory entries with info */
        regs.r[1] = (int)path;
        regs.r[2] = (int)buffer;
        regs.r[3] = 1;  /* Read 1 entry at a time */
        regs.r[4] = context;
        regs.r[5] = sizeof(buffer);
        regs.r[6] = (int)"*";  /* Match all */

        if (_kernel_swi(OS_GBPB, &regs, &regs) != NULL)
        {
            debug_printf("queue: OS_GBPB failed on zone directory");
            break;
        }

        context = regs.r[4];
        read_count = regs.r[3];

        if (read_count > 0)
        {
            /* OS_GBPB 12 buffer format:
             * Offset 0:  Load address (4 bytes)
             * Offset 4:  Exec address (4 bytes)
             * Offset 8:  Length (4 bytes)
             * Offset 12: Attributes (4 bytes)
             * Offset 16: Object type (4 bytes)
             * Offset 20: File type (4 bytes)
             * Offset 24: Name (null-terminated string)
             */
            const char *name = buffer + 24;  /* Name starts at offset 24 */
            int objtype = *((int *)(buffer + 16));
            FTN_ADDR addr;
            QUEUE_FLAVOUR flavour;
            int is_flo;
            int is_pkt;
            int is_req;
            int len = strlen(name);

            entries_seen++;
            debug_printf("queue: [%d] '%s' len=%d type=%d", entries_seen, name, len, objtype);
            ftnlog_printf("    File: %s (type=%d)", name, objtype);

            /* Skip directories (point directories would be objtype 2) */
            if (objtype == 1)  /* Regular file */
            {
                int addr_ok = parse_bso_hex_addr(name, zone, &addr);
                int flav_ok = get_flavour_from_name(name, &flavour, &is_flo, &is_pkt, &is_req);

                debug_printf("queue:   -> addr_ok=%d flav_ok=%d", addr_ok, flav_ok);

                /* Try to parse as BSO filename */
                if (addr_ok && flav_ok)
                {
                    QUEUE_NODE *node;
                    char filepath[MAILER_PATH_SIZE];

                    debug_printf("queue: QUEUING: %s -> %d:%d/%d (flo=%d pkt=%d req=%d)",
                                 name, addr.zone, addr.net, addr.node, is_flo, is_pkt, is_req);
                    ftnlog_printf("    -> Queued for %d:%d/%d", addr.zone, addr.net, addr.node);

                    snprintf(filepath, sizeof(filepath), "%s.%s", path, name);

                    /* Find or create node in queue */
                    node = queue_find_node(&addr);
                    if (node == NULL)
                    {
                        node = queue_add_node(&addr);
                        if (node != NULL)
                        {
                            debug_printf("queue: Created node for %d:%d/%d.%d",
                                         addr.zone, addr.net, addr.node, addr.point);
                            /* Look up uplink for hostname/port */
                            if (!lookup_uplink_for_node(&addr, node->hostname,
                                    sizeof(node->hostname), &node->port))
                            {
                                /* No uplink found - can't poll this node */
                                debug_printf("queue: No uplink for %d:%d/%d",
                                             addr.zone, addr.net, addr.node);
                            }
                            else
                            {
                                debug_printf("queue: Node %d:%d/%d -> %s:%d",
                                             addr.zone, addr.net, addr.node,
                                             node->hostname, node->port);
                            }
                        }
                    }

                    if (node != NULL)
                    {
                        if (is_flo)
                        {
                            /* Parse FLO file for file list */
                            int files = queue_parse_flo_file(node, filepath, flavour);
                            debug_printf("queue: Parsed %s: %d files", name, files);
                            count += files;
                        }
                        else if (is_req)
                        {
                            /* File request - add as REQ type, delete after sending */
                            if (queue_add_file(node, filepath, QUEUE_FILE_REQ, flavour))
                            {
                                node->files[node->file_count - 1].delete_after = 1;
                                debug_printf("queue: Added REQ file %s", name);
                                count++;
                            }
                        }
                        else
                        {
                            /* Direct packet file (BSO .?ut or .pkt) */
                            QUEUE_FILE_TYPE ftype = QUEUE_FILE_PKT;
                            if (queue_add_file(node, filepath, ftype, flavour))
                            {
                                /* Mark .pkt files for deletion after sending */
                                if (is_pkt)
                                {
                                    node->files[node->file_count - 1].delete_after = 1;
                                }
                                count++;
                            }
                        }
                    }
                }
                else
                {
                    debug_printf("queue:   -> SKIPPED (addr_ok=%d flav_ok=%d)", addr_ok, flav_ok);
                }
            }
            else
            {
                debug_printf("queue:   -> SKIPPED (not a file, type=%d)", objtype);
            }
        }
    } while (context != -1);

    debug_printf("queue: ---- Zone %d scan complete: %d entries, %d files queued ----", zone, entries_seen, count);
    ftnlog_printf("  Zone %d: %d files queued", zone, count);

    return count;
}

void queue_scan_outbound(void)
{
    _kernel_swi_regs regs;
    char buffer[280];
    int context = 0;
    int read_count;
    int total_files = 0;
    int dirs_found = 0;
    int dirs_valid = 0;

    debug_printf("queue: ========================================");
    debug_printf("queue: SCANNING OUTBOUND: %s", mailer.outbound_path);
    ftnlog_printf("Scanning outbound: %s", mailer.outbound_path);

    /* Check if outbound path exists */
    regs.r[0] = 17;  /* OS_File 17 = Read catalogue info */
    regs.r[1] = (int)mailer.outbound_path;
    if (_kernel_swi(OS_File, &regs, &regs) != NULL || regs.r[0] != 2)
    {
        debug_printf("queue: ERROR - Outbound path does not exist or is not a directory!");
        ftnlog_printf("ERROR: Outbound path not found!");
        return;
    }

    debug_printf("queue: Outbound path exists, clearing queue...");

    /* Clear existing queue */
    outbound_queue.node_count = 0;

    /* Scan all zone subdirectories within the outbound directory */
    /* Zone directories are named with 3-digit hex: 001, 002, 003, etc. */
    do
    {
        regs.r[0] = 12;  /* Read entries with info */
        regs.r[1] = (int)mailer.outbound_path;
        regs.r[2] = (int)buffer;
        regs.r[3] = 1;
        regs.r[4] = context;
        regs.r[5] = sizeof(buffer);
        regs.r[6] = (int)"*";

        if (_kernel_swi(OS_GBPB, &regs, &regs) != NULL)
        {
            debug_printf("queue: OS_GBPB failed on outbound directory");
            break;
        }

        context = regs.r[4];
        read_count = regs.r[3];

        if (read_count > 0)
        {
            /* OS_GBPB 12 buffer format:
             * Offset 0:  Load (4), Offset 4: Exec (4), Offset 8: Length (4)
             * Offset 12: Attrs (4), Offset 16: Object type (4), Offset 20: File type (4)
             * Offset 24: Name (null-terminated string)
             */
            const char *name = buffer + 24;  /* Name starts at offset 24 */
            int objtype = *((int *)(buffer + 16));

            debug_printf("queue: Found entry '%s' type=%d", name, objtype);

            /* Looking for zone subdirectories (3 hex digit names) */
            if (objtype == 2)  /* Directory */
            {
                int zone;
                dirs_found++;

                zone = queue_parse_zone_segment(name);
                debug_printf("queue: Dir '%s' parsed as zone=%d", name, zone);

                if (zone > 0)
                {
                    char zone_path[MAILER_PATH_SIZE];
                    int files;

                    dirs_valid++;
                    snprintf(zone_path, sizeof(zone_path), "%s.%s", mailer.outbound_path, name);
                    files = scan_zone_directory(zone_path, zone);
                    total_files += files;
                    debug_printf("queue: Zone %d (%s): %d files", zone, zone_path, files);
                }
            }
        }
    } while (context != -1);

    debug_printf("queue: Enumerated %d dirs, %d valid zone dirs", dirs_found, dirs_valid);

    outbound_queue.last_scan = time(NULL);

    /* Add configured uplinks as poll targets for checking incoming mail */
    queue_add_uplinks_for_poll();

    debug_printf("queue: Scan complete: %d nodes, %d files",
                 outbound_queue.node_count, total_files);
    queue_dump_status();
}

/* ******************************************************************************************************************************************************** */
/* Polling                                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

QUEUE_NODE *queue_get_next_poll_node(void)
{
    int i;
    time_t now = time(NULL);
    QUEUE_NODE *best = NULL;

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        QUEUE_NODE *node = &outbound_queue.nodes[i];

        /* Skip if busy */
        if (node->busy)
        {
            continue;
        }

        /* Skip if no hostname configured */
        if (node->hostname[0] == '\0')
        {
            continue;
        }

        /* Skip if not time to poll yet */
        if (node->next_poll > now)
        {
            continue;
        }

        /* Prefer nodes with outbound mail, then by priority */
        if (best == NULL)
        {
            best = node;
        }
        else if (node->file_count > 0 && best->file_count == 0)
        {
            /* Prefer nodes with mail to send */
            best = node;
        }
        else if (node->file_count > 0 && best->file_count > 0 &&
                 node->max_flavour > best->max_flavour)
        {
            /* Among nodes with mail, prefer higher priority */
            best = node;
        }
    }

    return best;
}

/*
 * Add all configured uplinks as poll targets.
 * This ensures we connect to uplinks to check for incoming mail
 * even if we have nothing to send.
 */
void queue_add_uplinks_for_poll(void)
{
    _kernel_swi_regs regs;
    Q_FTN_GLOBAL_CFG *global;
    int i;

    /* Get global FTN config */
    regs.r[0] = FTN_CONFIG_GET_GLOBAL;
    if (_kernel_swi(SWI_SUPPORT_FTN, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        debug_printf("queue: Failed to get FTN config from Support module");
        return;
    }
    global = (Q_FTN_GLOBAL_CFG *)regs.r[0];

    if (global->uplink_count == 0)
    {
        debug_printf("queue: No uplinks configured in Support module - check FTN config was loaded");
    }
    else
    {
        debug_printf("queue: Adding %d uplinks for polling", global->uplink_count);
    }

    /* Add each uplink as a poll target by array index */
    for (i = 0; i < global->uplink_count; i++)
    {
        Q_UPLINK_CFG *uplink = &global->uplinks[i];
        FTN_ADDR uplink_addr;
        QUEUE_NODE *node;

        /* Skip uplinks without host configured */
        if (uplink->host[0] == '\0')
        {
            debug_printf("queue: Uplink %d has no host, skipping", uplink->id);
            continue;
        }

        /* Parse the uplink address */
        if (!ftn_string_to_addr(uplink->address, &uplink_addr))
        {
            debug_printf("queue: Failed to parse uplink address: %s", uplink->address);
            continue;
        }

        /* Check if this node is already in the queue */
        node = queue_find_node(&uplink_addr);
        if (node == NULL)
        {
            /* Add new node for this uplink */
            node = queue_add_node(&uplink_addr);
            if (node == NULL)
            {
                debug_printf("queue: Failed to add uplink node");
                continue;
            }
        }

        /* Update/set hostname and port */
        strncpy(node->hostname, uplink->host, sizeof(node->hostname) - 1);
        node->hostname[sizeof(node->hostname) - 1] = '\0';
        node->port = (uplink->port > 0) ? uplink->port : BINKP_DEFAULT_PORT;
        node->is_uplink = 1;  /* Mark this node as a configured uplink */

        debug_printf("queue: Added uplink %d:%d/%d.%d -> %s:%d",
                     uplink_addr.zone, uplink_addr.net, uplink_addr.node, uplink_addr.point,
                     node->hostname, node->port);
    }
}

void queue_schedule_retry(QUEUE_NODE *node, int delay_seconds)
{
    node->next_poll = time(NULL) + delay_seconds;
    node->retry_count++;

    debug_printf("queue: Scheduled retry for %d:%d/%d.%d in %d seconds (attempt %d)",
                 node->addr.zone, node->addr.net, node->addr.node, node->addr.point,
                 delay_seconds, node->retry_count);
}

void queue_mark_node_busy(const FTN_ADDR *addr, int busy)
{
    QUEUE_NODE *node = queue_find_node(addr);

    if (node != NULL)
    {
        node->busy = busy;
        if (!busy)
        {
            node->retry_count = 0;
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Status                                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

int queue_get_pending_count(void)
{
    int i, count = 0;

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        count += outbound_queue.nodes[i].file_count;
    }

    return count;
}

long queue_get_pending_size(void)
{
    int i;
    long size = 0;

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        size += outbound_queue.nodes[i].total_size;
    }

    return size;
}

void queue_dump_status(void)
{
    int i;

    debug_printf("queue: %d nodes, %d files, %ld bytes pending",
                 outbound_queue.node_count,
                 queue_get_pending_count(),
                 queue_get_pending_size());

    ftnlog_printf("Queue: %d nodes, %d files pending",
                  outbound_queue.node_count,
                  queue_get_pending_count());

    for (i = 0; i < outbound_queue.node_count; i++)
    {
        QUEUE_NODE *node = &outbound_queue.nodes[i];

        debug_printf("queue:   %d:%d/%d.%d - %d files, %ld bytes, %s",
                     node->addr.zone, node->addr.net, node->addr.node, node->addr.point,
                     node->file_count, node->total_size,
                     node->busy ? "BUSY" : "ready");

        if (node->file_count > 0)
        {
            ftnlog_printf("  %d:%d/%d.%d: %d files",
                          node->addr.zone, node->addr.net, node->addr.node, node->addr.point,
                          node->file_count);
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Poll File Creation                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

int queue_create_poll_file(const FTN_ADDR *addr, QUEUE_FLAVOUR flavour)
{
    char path[MAILER_PATH_SIZE];
    const char *ext;
    FILE *f;

    switch (flavour)
    {
        case QUEUE_FLAVOUR_CRASH:     ext = "clo"; break;
        case QUEUE_FLAVOUR_DIRECT:    ext = "dlo"; break;
        case QUEUE_FLAVOUR_HOLD:      ext = "hlo"; break;
        case QUEUE_FLAVOUR_IMMEDIATE: ext = "ilo"; break;
        default:                      ext = "flo"; break;
    }

    queue_ensure_outbound_directories(addr);
    queue_format_outbound_name(path, sizeof(path), addr, ext);

    /* Create empty poll file */
    f = fopen(path, "w");
    if (f == NULL)
    {
        debug_printf("queue: Failed to create poll file: %s", path);
        return 0;
    }

    fclose(f);
    debug_printf("queue: Created poll file: %s", path);

    return 1;
}
