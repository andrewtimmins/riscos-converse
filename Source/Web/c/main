/* ******************************************************************************************************************************************************** */
/* Web Server - Main Module                                                                                                                                 */
/* ******************************************************************************************************************************************************** */

/* Standard ANSI Includes */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

/* OS Includes */
#include "kernel.h"
#include "swis.h"

/* Desk Includes */
#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Handler.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Menu.h"
#include "C:Desk.Screen.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Template.h"
#include "C:Desk.Dialog.h"
#include "C:Desk.Dialog2.h"
#include "C:Desk.Error.h"

/* TCPIP Includes */
#define COMPAT_INET4 1
#include "sys/types.h"
#include "sys/socket.h"
#include "socklib.h"
#include "inetlib.h"
#include "netinet/in.h"
#include "sys/ioctl.h"
#include "sys/errno.h"
#include "netdb.h"

/* Our Includes */
#include "main.h"
#include "http.h"
#include "template.h"
#include "session.h"
#include "debug.h"
#include "version.h"

/* ******************************************************************************************************************************************************** */
/* Global Variables                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

WIMP_STATE wimp;
CLIENT_SLOT clients[WEB_MAX_CLIENTS];
int listen_socket = -1;
int listen_port = WEB_DEFAULT_PORT;
int active_clients = 0;

static char docroot[256] = WEB_DOCROOT;
static Desk_dialog2_block *proginfo_window;

/* Menu indices */
enum
{
    ICONBAR_MENU_INFO = 0,
    ICONBAR_MENU_QUIT
};

/* Error messages */
static char error_bind[100];
static char error_listen[100];

/* ******************************************************************************************************************************************************** */
/* SWI Numbers                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

#define SWI_OS_READMONOTONICTIME 0x00000042
#define POLL_IDLE_DELAY 1  /* centiseconds between null polls (10ms) */

/* Wimp message from Converse Server */
#define MESSAGE_LINE_BROADCAST  0x5AA00

/* Filer logging SWI */
#define SWI_FILER_LOGGING       0x5AA40
#define FILER_LOG_CMD_WEB       4

/* Filer filebase SWI */
#define SWI_FILER_FILEBASE      0x5AA43
#define FILER_FILEBASE_CMD_FILE_INFO    11

/* ******************************************************************************************************************************************************** */
/* Utility Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

static void display_error(const char *message)
{
    Desk_Error_Report(1, (char *)message);
}

static void web_log(const char *format, ...)
{
    char buffer[256];
    va_list args;
    _kernel_swi_regs regs;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    regs.r[0] = FILER_LOG_CMD_WEB;
    regs.r[1] = (int)buffer;
    _kernel_swi(SWI_FILER_LOGGING, &regs, &regs);

    debug_printf("Web: %s\n", buffer);
}

/* ******************************************************************************************************************************************************** */
/* Wimp Event Handlers                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

static Desk_bool handle_iconbar_click(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;

    Desk_UNUSED(event);

    if (event->data.mouse.button.data.menu)
    {
        Desk_Menu_Show(w->iconbar_menu, event->data.mouse.pos.x, -1);
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_menu_selection(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;

    switch (event->data.selection[0])
    {
        case ICONBAR_MENU_QUIT:
            w->quit = Desk_bool_TRUE;
            break;
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_null_event(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(event);
    Desk_UNUSED(ref);

    check_listener();
    poll_clients();

    return Desk_bool_TRUE;
}

static Desk_bool handle_broadcast_message(Desk_event_pollblock *event, void *ref)
{
    WIMP_STATE *w = (WIMP_STATE *)ref;
    int reason;

    if (event == NULL)
    {
        return Desk_bool_FALSE;
    }

    reason = event->data.message.data.words[0];

    /* Reason 0 = quit */
    if (reason == 0)
    {
        debug_printf("Web: Received broadcast quit message\n");
        w->quit = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

static Desk_bool handle_open_proginfo(Desk_event_pollblock *event, void *ref)
{
    if (event->data.message.data.menuwarn.selection[0] != ICONBAR_MENU_INFO)
    {
        return Desk_bool_FALSE;
    }

    Desk_Dialog2_OpenDialogMenuLeaf(event, (Desk_dialog2_block *)ref);
    Desk_Icon_SetText(proginfo_window->window, 0, app_name);  /* PROGINFO_VERSION = 5 */
    Desk_Icon_SetText(proginfo_window->window, 5, wimp_version);  /* PROGINFO_VERSION = 5 */
    Desk_Icon_SetText(proginfo_window->window, 6, app_purpose);  /* PROGINFO_VERSION = 5 */

    return Desk_bool_TRUE;
}

static void poll_idle(void)
{
    _kernel_swi_regs regs;
    Desk_event_pollblock event;
    int earliest;

    /* Get current monotonic time and add delay */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    earliest = regs.r[0] + POLL_IDLE_DELAY;

    /* Poll with idle time */
    Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
    Desk_Event_Process(&event);
}

/* ******************************************************************************************************************************************************** */
/* Networking Functions                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

void create_listener(int port)
{
    int args[2];
    struct sockaddr_in saddr;
    int bind_result;

    /* Create the socket */
    listen_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_socket < 0)
    {
        display_error("Failed to create socket");
        return;
    }

    debug_printf("web: created socket %d\n", listen_socket);

    /* Allow address reuse */
    args[0] = 1;
    setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, &args, sizeof(int));

    /* Set linger time */
    args[0] = 1;
    args[1] = 10;
    setsockopt(listen_socket, SOL_SOCKET, SO_LINGER, &args, (sizeof(int) * 2));

    /* Bind to port on all interfaces */
    memset(&saddr, 0, sizeof(saddr));
    saddr.sin_family = AF_INET;
    saddr.sin_port = htons(port);
    saddr.sin_addr.s_addr = htonl(INADDR_ANY);

    bind_result = bind(listen_socket, (struct sockaddr *)&saddr, sizeof(saddr));
    debug_printf("web: bind to port %d result=%d, INADDR_ANY=0x%08X\n", 
                 port, bind_result, (unsigned int)htonl(INADDR_ANY));

    if (bind_result != 0)
    {
        debug_printf("web: bind failed, errno=%d\n", errno);
        socketclose(listen_socket);
        listen_socket = -1;
        display_error(error_bind);
        return;
    }

    /* Make non-blocking */
    args[0] = 1;
    socketioctl(listen_socket, FIONBIO, &args[0]);

    /* Start listening */
    if (listen(listen_socket, 5) != 0)
    {
        debug_printf("web: listen failed, errno=%d\n", errno);
        socketclose(listen_socket);
        listen_socket = -1;
        display_error(error_listen);
        return;
    }

    listen_port = port;
    web_log("Listening on port %d", port);
    debug_printf("web: now listening on port %d, socket %d\n", port, listen_socket);
}

void destroy_listener(void)
{
    int i;

    /* Close all client connections */
    for (i = 0; i < WEB_MAX_CLIENTS; i++)
    {
        if (clients[i].socket > 0)
        {
            close_client(i);
        }
    }

    /* Close listening socket */
    if (listen_socket >= 0)
    {
        socketclose(listen_socket);
        listen_socket = -1;
    }

    web_log("Server stopped");
}

void check_listener(void)
{
    struct sockaddr_in saddr;
    int namelen = sizeof(saddr);
    int new_socket;
    int slot;
    fd_set readfds;
    struct timeval timeout;

    if (listen_socket < 0)
    {
        return;
    }

    /* Check for incoming connection */
    FD_ZERO(&readfds);
    FD_SET(listen_socket, &readfds);
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;

    if (select(listen_socket + 1, &readfds, NULL, NULL, &timeout) <= 0)
    {
        return;
    }

    if (!FD_ISSET(listen_socket, &readfds))
    {
        return;
    }

    /* Accept connection */
    memset(&saddr, 0, sizeof(saddr));
    new_socket = accept(listen_socket, (struct sockaddr *)&saddr, &namelen);
    if (new_socket < 0)
    {
        return;
    }

    /* Find free client slot */
    slot = -1;
    for (slot = 0; slot < WEB_MAX_CLIENTS; slot++)
    {
        if (clients[slot].socket == 0)
        {
            break;
        }
    }

    if (slot >= WEB_MAX_CLIENTS)
    {
        /* No free slots - send error and close */
        http_send_error(new_socket, 503, "Server busy");
        shutdown(new_socket, 0);
        socketclose(new_socket);
        web_log("Connection rejected - server busy");
        return;
    }

    /* Allocate initial receive buffer */
    clients[slot].recv_buffer = malloc(WEB_SMALL_BUFFER_SIZE);
    if (clients[slot].recv_buffer == NULL)
    {
        http_send_error(new_socket, 503, "Server out of memory");
        shutdown(new_socket, 0);
        socketclose(new_socket);
        web_log("Connection rejected - out of memory");
        return;
    }
    clients[slot].recv_buffer_size = WEB_SMALL_BUFFER_SIZE;

    /* Set up client slot */
    {
        int nonblock = 1;
        socketioctl(new_socket, FIONBIO, &nonblock);
    }

    clients[slot].socket = new_socket;
    clients[slot].state = CLIENT_STATE_CONNECTED;
    clients[slot].connected = clock();
    clients[slot].recv_len = 0;
    clients[slot].content_length = 0;
    strncpy(clients[slot].remote_addr, inet_ntoa(saddr.sin_addr), sizeof(clients[slot].remote_addr) - 1);
    clients[slot].remote_addr[sizeof(clients[slot].remote_addr) - 1] = '\0';
    active_clients++;

    web_log("Connection from %s", clients[slot].remote_addr);
}

void close_client(int slot)
{
    if (slot < 0 || slot >= WEB_MAX_CLIENTS)
    {
        return;
    }

    if (clients[slot].socket > 0)
    {
        shutdown(clients[slot].socket, 0);
        socketclose(clients[slot].socket);
    }

    /* Free dynamic buffer */
    if (clients[slot].recv_buffer != NULL)
    {
        free(clients[slot].recv_buffer);
        clients[slot].recv_buffer = NULL;
    }
    clients[slot].recv_buffer_size = 0;

    clients[slot].socket = 0;
    clients[slot].state = CLIENT_STATE_FREE;
    clients[slot].recv_len = 0;
    clients[slot].content_length = 0;

    if (active_clients > 0)
    {
        active_clients--;
    }
}

void poll_clients(void)
{
    int i;
    clock_t now = clock();
    clock_t timeout_ticks = (clock_t)(WEB_CLIENT_TIMEOUT * CLOCKS_PER_SEC);

    for (i = 0; i < WEB_MAX_CLIENTS; i++)
    {
        int bytes_read;
        int space_available;

        if (clients[i].socket == 0)
        {
            continue;
        }

        /* Check for timeout */
        if ((now - clients[i].connected) > timeout_ticks)
        {
            web_log("Timeout: %s", clients[i].remote_addr);
            close_client(i);
            continue;
        }

        /* Calculate space available in buffer */
        space_available = clients[i].recv_buffer_size - clients[i].recv_len - 1;
        if (space_available <= 0)
        {
            /* Buffer full - this shouldn't happen if expansion worked */
            http_send_error(clients[i].socket, HTTP_STATUS_BAD_REQUEST, "Request too large");
            close_client(i);
            continue;
        }

        /* Try to receive data */
        bytes_read = socketread(clients[i].socket,
                                clients[i].recv_buffer + clients[i].recv_len,
                                space_available);

        if (bytes_read < 0)
        {
            /* No data available or error */
            int err = errno;
            if (err != EWOULDBLOCK && err != EAGAIN)
            {
                close_client(i);
            }
            continue;
        }

        if (bytes_read == 0)
        {
            /* Connection closed by client */
            close_client(i);
            continue;
        }

        clients[i].recv_len += bytes_read;
        clients[i].recv_buffer[clients[i].recv_len] = '\0';
        clients[i].state = CLIENT_STATE_RECEIVING;

        /* Check if we have a complete request */
        {
            char *header_end = strstr(clients[i].recv_buffer, "\r\n\r\n");
            char *header_end_lf = strstr(clients[i].recv_buffer, "\n\n");
            int header_len = 0;
            int body_start = 0;
            
            if (header_end != NULL)
            {
                header_len = (int)(header_end - clients[i].recv_buffer);
                body_start = header_len + 4;
            }
            else if (header_end_lf != NULL)
            {
                header_len = (int)(header_end_lf - clients[i].recv_buffer);
                body_start = header_len + 2;
            }
            
            if (header_len > 0)
            {
                /* Headers complete - check if this is a POST with Content-Length */
                char *cl_header = strstr(clients[i].recv_buffer, "Content-Length:");
                if (cl_header == NULL)
                {
                    cl_header = strstr(clients[i].recv_buffer, "content-length:");
                }
                
                if (cl_header != NULL && cl_header < (clients[i].recv_buffer + header_len))
                {
                    /* Has Content-Length - might need larger buffer */
                    long content_len = atol(cl_header + 15);
                    long total_needed = body_start + content_len + 1;
                    int body_received = clients[i].recv_len - body_start;
                    
                    /* Check size limit */
                    if (content_len > WEB_MAX_UPLOAD_SIZE)
                    {
                        http_send_error(clients[i].socket, HTTP_STATUS_BAD_REQUEST, 
                                       "Upload too large (max 2MB)");
                        close_client(i);
                        continue;
                    }
                    
                    /* Expand buffer if needed */
                    if (total_needed > clients[i].recv_buffer_size)
                    {
                        char *new_buffer = realloc(clients[i].recv_buffer, (size_t)total_needed);
                        if (new_buffer == NULL)
                        {
                            http_send_error(clients[i].socket, HTTP_STATUS_SERVER_ERROR, 
                                           "Server out of memory");
                            close_client(i);
                            continue;
                        }
                        clients[i].recv_buffer = new_buffer;
                        clients[i].recv_buffer_size = (int)total_needed;
                    }
                    
                    if (body_received >= content_len)
                    {
                        /* Full request received */
                        handle_client_request(i);
                    }
                    /* else keep waiting for body */
                }
                else
                {
                    /* No Content-Length - request is complete (GET/HEAD) */
                    handle_client_request(i);
                }
            }
            else if (clients[i].recv_len >= clients[i].recv_buffer_size - 1)
            {
                /* Buffer full but no complete headers - bad request */
                http_send_error(clients[i].socket, HTTP_STATUS_BAD_REQUEST, "Request headers too large");
                close_client(i);
            }
        }
    }
}

/* ******************************************************************************************************************************************************** */
/* Download Handling                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

/* FILE_RECORD field offsets for extracting data */
#define FILE_RECORD_OFFSET_ID           0
#define FILE_RECORD_OFFSET_FILEBASEID   4
#define FILE_RECORD_OFFSET_AREAID       8
#define FILE_RECORD_OFFSET_DELETED      12
#define FILE_RECORD_OFFSET_ACCESSLEVEL  16
#define FILE_RECORD_OFFSET_KEYS         20
#define FILE_RECORD_OFFSET_NAME         148  /* 20 + 128 (keys) */
#define FILE_RECORD_OFFSET_UPLOADEDBY   212  /* 148 + 64 (name) */
#define FILE_RECORD_OFFSET_UPLOADDATE   216
#define FILE_RECORD_OFFSET_DESC         220
#define FILE_RECORD_OFFSET_FILESIZE     476  /* 220 + 256 (desc) */
#define FILE_RECORD_OFFSET_DOWNLOADS    480

/* Handle file download from filebase: /download/<base_id>/<file_id>/<filename> */
static int handle_download_request(int slot, const char *path)
{
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int base_id = 0;
    int file_id = 0;
    const char *p;
    char filepath[512];
    char *file_record;
    int *int_ptr;
    int area_id;
    int group;

    /* Skip /download/ prefix */
    p = path + 10;  /* strlen("/download/") */

    /* Parse base_id */
    while (*p && *p != '/')
    {
        if (*p >= '0' && *p <= '9')
        {
            base_id = base_id * 10 + (*p - '0');
        }
        else
        {
            http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Invalid base ID");
            close_client(slot);
            return -1;
        }
        p++;
    }

    if (*p != '/')
    {
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Invalid download URL");
        close_client(slot);
        return -1;
    }
    p++;

    /* Parse file_id */
    while (*p && *p != '/')
    {
        if (*p >= '0' && *p <= '9')
        {
            file_id = file_id * 10 + (*p - '0');
        }
        else
        {
            http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Invalid file ID");
            close_client(slot);
            return -1;
        }
        p++;
    }

    debug_printf("Web: Download request - base=%d file=%d\n", base_id, file_id);

    /* Use Filer SWI to get file record */
    /* FILER_FILEBASE_CMD_FILE_INFO (11): R0=11, R1=base_id, R2=file_id -> R0=FILE_RECORD* or -1 */
    regs.r[0] = FILER_FILEBASE_CMD_FILE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = file_id;

    err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
    if (err != NULL || regs.r[0] == -1)
    {
        debug_printf("Web: Filer SWI failed for base=%d file=%d\n", base_id, file_id);
        http_send_error(clients[slot].socket, HTTP_STATUS_NOT_FOUND, "File not found in filebase");
        web_log("%s GET /download/%d/%d - 404 Not Found", clients[slot].remote_addr, base_id, file_id);
        close_client(slot);
        return 0;
    }

    /* Get pointer to FILE_RECORD */
    file_record = (char *)regs.r[0];

    /* Check if file is deleted */
    int_ptr = (int *)(file_record + FILE_RECORD_OFFSET_DELETED);
    if (*int_ptr != 0)
    {
        debug_printf("Web: File %d in base %d is deleted\n", file_id, base_id);
        http_send_error(clients[slot].socket, HTTP_STATUS_NOT_FOUND, "File not found");
        web_log("%s GET /download/%d/%d - 404 Deleted", clients[slot].remote_addr, base_id, file_id);
        close_client(slot);
        return 0;
    }

    /* Get area_id for path construction */
    int_ptr = (int *)(file_record + FILE_RECORD_OFFSET_AREAID);
    area_id = *int_ptr;

    /* Build file path
       Path format: <Converse$Dir>.FileBases.<base_id>.Files[.A<area>].G<group>.<file_id>
       Group = (file_id - 1) / 60, formatted as G00, G01 etc */
    group = (file_id - 1) / 60;

    if (area_id > 0)
    {
        snprintf(filepath, sizeof(filepath), "<Converse$Dir>.FileBases.%04d.Files.A%04d.G%02d.%06d",
                 base_id, area_id, group, file_id);
    }
    else
    {
        snprintf(filepath, sizeof(filepath), "<Converse$Dir>.FileBases.%04d.Files.G%02d.%06d",
                 base_id, group, file_id);
    }

    debug_printf("Web: Serving file from: %s\n", filepath);

    /* Serve the file */
    {
        int result = http_send_file(clients[slot].socket, filepath);
        char *filename = file_record + FILE_RECORD_OFFSET_NAME;

        if (result >= 0)
        {
            web_log("%s GET /download/%d/%d/%s - 200 OK", clients[slot].remote_addr, base_id, file_id, filename);
        }
        else
        {
            web_log("%s GET /download/%d/%d - 500 Error", clients[slot].remote_addr, base_id, file_id);
        }
    }

    close_client(slot);
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Authentication Handlers                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

/* Filer userdb SWI */
#define SWI_FILER_USERDB        0x5AA41
#define FILER_USERDB_CMD_AUTH   4

/* USER_RECORD field offsets */
#define USER_RECORD_OFFSET_ID           0
#define USER_RECORD_OFFSET_USERNAME     4
#define USER_RECORD_OFFSET_REALNAME     36
#define USER_RECORD_OFFSET_KEYS         196
#define USER_RECORD_OFFSET_SYSOP        600
#define USER_RECORD_OFFSET_ACCESSLEVEL  640

/*
 * Handle POST /login
 * Expects form fields: username, password
 */
static void handle_login_post(int slot, HTTP_REQUEST *req)
{
    char username[32];
    char password[32];
    char cookie_header[256];
    _kernel_swi_regs regs;
    int auth_result;
    char *user_record;
    
    if (req->body == NULL || req->body_len == 0)
    {
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Missing form data");
        close_client(slot);
        return;
    }
    
    /* Parse form fields */
    if (!http_parse_form_field(req->body, req->body_len, "username", username, sizeof(username)) ||
        !http_parse_form_field(req->body, req->body_len, "password", password, sizeof(password)))
    {
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Missing username or password");
        close_client(slot);
        return;
    }
    
    debug_printf("Web: Login attempt for user: %s\n", username);
    
    /* Authenticate via Filer SWI */
    regs.r[0] = FILER_USERDB_CMD_AUTH;
    regs.r[1] = (int)username;
    regs.r[2] = (int)password;
    
    if (_kernel_swi(SWI_FILER_USERDB, &regs, &regs) != NULL)
    {
        debug_printf("Web: Filer SWI failed\n");
        http_send_error(clients[slot].socket, HTTP_STATUS_SERVER_ERROR, "Authentication service unavailable");
        close_client(slot);
        return;
    }
    
    auth_result = regs.r[0];
    user_record = (char *)regs.r[1];
    
    if (auth_result != 0 || user_record == NULL)
    {
        /* Authentication failed - redirect back to login with error */
        debug_printf("Web: Login failed for %s (result %d)\n", username, auth_result);
        web_log("%s POST /login - 401 Failed (%s)", clients[slot].remote_addr, username);
        http_send_redirect(clients[slot].socket, "/login?error=1", NULL);
        close_client(slot);
        return;
    }
    
    /* Authentication successful - create session */
    {
        WEB_SESSION *session;
        int user_id;
        char *realname;
        char *keys;
        int access_level;
        int sysop;
        int *int_ptr;
        
        int_ptr = (int *)(user_record + USER_RECORD_OFFSET_ID);
        user_id = *int_ptr;
        
        realname = user_record + USER_RECORD_OFFSET_REALNAME;
        keys = user_record + USER_RECORD_OFFSET_KEYS;
        
        int_ptr = (int *)(user_record + USER_RECORD_OFFSET_ACCESSLEVEL);
        access_level = *int_ptr;
        
        int_ptr = (int *)(user_record + USER_RECORD_OFFSET_SYSOP);
        sysop = *int_ptr;
        
        session = session_create(user_id, username, realname, access_level, sysop, keys);
        
        if (session == NULL)
        {
            debug_printf("Web: Failed to create session for %s\n", username);
            http_send_error(clients[slot].socket, HTTP_STATUS_SERVER_ERROR, "Session creation failed");
            close_client(slot);
            return;
        }
        
        /* Build Set-Cookie header */
        session_build_cookie(session, cookie_header, sizeof(cookie_header));
        
        /* Redirect to home page with session cookie */
        web_log("%s POST /login - 302 OK (%s)", clients[slot].remote_addr, username);
        http_send_redirect(clients[slot].socket, "/", cookie_header);
    }
    
    close_client(slot);
}

/* Filer filebase SWIs */
#define SWI_FILER_FILEBASE              0x5AA43
#define FILER_FILEBASE_CMD_BEGIN_UPLOAD 3
#define FILER_FILEBASE_CMD_UPLOAD_BLOCK 4
#define FILER_FILEBASE_CMD_END_UPLOAD   12

/*
 * Handle POST /upload
 * Expects multipart form with: filebase, area, description, file
 */
static void handle_upload_post(int slot, HTTP_REQUEST *req)
{
    char token[SESSION_TOKEN_LEN + 1];
    WEB_SESSION *session;
    char boundary[HTTP_MAX_BOUNDARY];
    HTTP_MULTIPART_PART part;
    const char *pos;
    const char *body_end;
    
    /* Form fields */
    int filebase_id = 0;
    int area_id = 0;
    char description[256] = "";
    char filename[128] = "";
    const char *file_data = NULL;
    int file_len = 0;
    
    _kernel_swi_regs regs;
    int file_id;
    
    /* Check user is logged in */
    if (!session_parse_cookie(req->cookie, token, sizeof(token)))
    {
        http_send_redirect(clients[slot].socket, "/login", NULL);
        close_client(slot);
        return;
    }
    
    session = session_lookup(token);
    if (session == NULL)
    {
        http_send_redirect(clients[slot].socket, "/login", NULL);
        close_client(slot);
        return;
    }
    
    debug_printf("Web: Upload attempt by user %s\n", session->username);
    
    /* Check for multipart content type */
    if (!http_is_multipart(req->content_type))
    {
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Expected multipart form data");
        close_client(slot);
        return;
    }
    
    /* Get boundary */
    if (!http_get_multipart_boundary(req->content_type, boundary, sizeof(boundary)))
    {
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Missing multipart boundary");
        close_client(slot);
        return;
    }
    
    debug_printf("Web: Multipart boundary: %s\n", boundary);
    
    /* Parse multipart parts */
    if (req->body == NULL || req->body_len == 0)
    {
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Missing form data");
        close_client(slot);
        return;
    }
    
    pos = req->body;
    body_end = req->body + req->body_len;
    
    while ((pos = http_parse_multipart_part(pos, body_end, boundary, &part)) != NULL)
    {
        debug_printf("Web: Part name='%s' filename='%s' len=%d\n", 
                     part.name, part.filename, part.data_len);
        
        if (strcmp(part.name, "filebase") == 0 && part.data != NULL)
        {
            filebase_id = atoi(part.data);
        }
        else if (strcmp(part.name, "area") == 0 && part.data != NULL)
        {
            area_id = atoi(part.data);
        }
        else if (strcmp(part.name, "description") == 0 && part.data != NULL)
        {
            size_t len = (size_t)part.data_len;
            if (len >= sizeof(description))
            {
                len = sizeof(description) - 1;
            }
            strncpy(description, part.data, len);
            description[len] = '\0';
        }
        else if (strcmp(part.name, "file") == 0 && part.filename[0] != '\0')
        {
            strncpy(filename, part.filename, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
            file_data = part.data;
            file_len = part.data_len;
        }
    }
    
    /* Validate required fields */
    if (filebase_id <= 0 || filename[0] == '\0' || file_data == NULL || file_len <= 0)
    {
        debug_printf("Web: Upload validation failed: fb=%d fn='%s' len=%d\n", 
                     filebase_id, filename, file_len);
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, 
                       "Missing required fields (filebase and file)");
        close_client(slot);
        return;
    }
    
    debug_printf("Web: Uploading '%s' (%d bytes) to filebase %d area %d\n",
                 filename, file_len, filebase_id, area_id);
    
    /* Build FILE_RECORD for upload
     * We'll create a minimal one - the Filer will fill in the rest
     */
    {
        char file_record[512];
        int temp_int;
        long temp_long;
        memset(file_record, 0, sizeof(file_record));
        
        /* id = 0 (will be assigned) */
        /* filebaseid = filebase_id */
        temp_int = filebase_id;
        memcpy(file_record + 4, &temp_int, sizeof(int));
        /* filebaseareaid = area_id */
        temp_int = area_id;
        memcpy(file_record + 8, &temp_int, sizeof(int));
        /* deleted = 0 */
        /* accesslevel = 0 */
        /* keys at offset 20 - empty */
        /* name at offset 148 */
        strncpy(file_record + 148, filename, 63);
        /* uploadedby at offset 212 */
        temp_int = session->user_id;
        memcpy(file_record + 212, &temp_int, sizeof(int));
        /* uploaddate at offset 216 */
        temp_int = (int)time(NULL);
        memcpy(file_record + 216, &temp_int, sizeof(int));
        /* description at offset 220 */
        strncpy(file_record + 220, description, 255);
        /* filesize at offset 476 */
        temp_long = file_len;
        memcpy(file_record + 476, &temp_long, sizeof(long));
        /* downloads at offset 480 = 0 */
        
        /* Call Filer to begin upload */
        regs.r[0] = FILER_FILEBASE_CMD_BEGIN_UPLOAD;
        regs.r[1] = filebase_id;
        regs.r[2] = (int)file_record;
        
        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] <= 0)
        {
            debug_printf("Web: Begin upload failed\n");
            http_send_error(clients[slot].socket, HTTP_STATUS_SERVER_ERROR, "Upload failed - could not create file record");
            close_client(slot);
            return;
        }
        
        file_id = regs.r[0];
        debug_printf("Web: File record created with ID %d\n", file_id);
        
        /* Upload the file data */
        regs.r[0] = FILER_FILEBASE_CMD_UPLOAD_BLOCK;
        regs.r[1] = filebase_id;
        regs.r[2] = file_id;
        regs.r[3] = (int)file_data;
        regs.r[4] = file_len;
        
        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            debug_printf("Web: Upload block failed\n");
            http_send_error(clients[slot].socket, HTTP_STATUS_SERVER_ERROR, "Upload failed - could not write file data");
            close_client(slot);
            return;
        }
        
        debug_printf("Web: File data written successfully\n");
        
        /* Close the file handle */
        regs.r[0] = FILER_FILEBASE_CMD_END_UPLOAD;
        regs.r[1] = filebase_id;
        regs.r[2] = file_id;
        _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
        
        debug_printf("Web: File handle closed\n");
    }
    
    web_log("%s POST /upload - 302 OK (%s, %d bytes)", 
            clients[slot].remote_addr, filename, file_len);
    
    /* Redirect back to upload page with success message */
    http_send_redirect(clients[slot].socket, "/upload?success=1", NULL);
    close_client(slot);
}

/*
 * Handle GET /api/areas?filebase=N
 * Returns JSON array of areas for a filebase
 */
static void handle_api_areas(int slot, HTTP_REQUEST *req)
{
    char *query;
    int filebase_id = 0;
    char json[4096];
    char *p;
    int area_index;
    int first = 1;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    
    /* Parse filebase ID from query string */
    query = strchr(req->path, '?');
    if (query != NULL)
    {
        query++;
        if (strncmp(query, "filebase=", 9) == 0)
        {
            filebase_id = atoi(query + 9);
        }
    }
    
    if (filebase_id <= 0)
    {
        http_send_headers(clients[slot].socket, HTTP_STATUS_OK, "application/json", 2);
        http_send_data(clients[slot].socket, "[]", 2);
        close_client(slot);
        return;
    }
    
    /* Build JSON array of areas */
    p = json;
    *p++ = '[';
    
    for (area_index = 0; area_index < 100; area_index++)
    {
        char *area_rec;
        int area_id;
        char *area_name;
        char escaped_name[128];
        char *src, *dst;
        
        regs.r[0] = 9;  /* FILER_FILEBASE_CMD_ENUMERATE_AREAS */
        regs.r[1] = filebase_id;
        regs.r[2] = area_index;
        err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
        if (err != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }
        
        area_rec = (char *)regs.r[0];
        memcpy(&area_id, area_rec + 0, sizeof(int));  /* FILEBASE_AREA_RECORD.id */
        area_name = area_rec + 140;         /* FILEBASE_AREA_RECORD.name at offset 140 (4+4+4+128) */
        
        /* JSON escape the name */
        dst = escaped_name;
        for (src = area_name; *src && dst < escaped_name + sizeof(escaped_name) - 2; src++)
        {
            if (*src == '"' || *src == '\\')
            {
                *dst++ = '\\';
            }
            *dst++ = *src;
        }
        *dst = '\0';
        
        if (!first)
        {
            *p++ = ',';
        }
        first = 0;
        
        p += sprintf(p, "{\"id\":%d,\"name\":\"%s\"}", area_id, escaped_name);
        
        if (p >= json + sizeof(json) - 100)
        {
            break;  /* Safety limit */
        }
    }
    
    *p++ = ']';
    *p = '\0';
    
    /* Send response */
    http_send_headers(clients[slot].socket, HTTP_STATUS_OK, "application/json", strlen(json));
    http_send_data(clients[slot].socket, json, strlen(json));
    close_client(slot);
}

/*
 * Handle GET /logout
 * Destroys session and clears cookie
 */
static void handle_logout(int slot, HTTP_REQUEST *req)
{
    char token[SESSION_TOKEN_LEN + 1];
    char cookie_header[256];
    
    /* Parse session token from cookie */
    if (session_parse_cookie(req->cookie, token, sizeof(token)))
    {
        debug_printf("Web: Logout, destroying session %s\n", token);
        session_destroy(token);
    }
    
    /* Build Set-Cookie to clear the cookie */
    session_build_clear_cookie(cookie_header, sizeof(cookie_header));
    
    /* Redirect to home page */
    web_log("%s GET /logout - 302 OK", clients[slot].remote_addr);
    http_send_redirect(clients[slot].socket, "/", cookie_header);
    close_client(slot);
}

/* ******************************************************************************************************************************************************** */
/* Request Handling                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

void handle_client_request(int slot)
{
    HTTP_REQUEST req;
    char filepath[512];
    int parse_result;

    if (slot < 0 || slot >= WEB_MAX_CLIENTS || clients[slot].socket == 0)
    {
        return;
    }

    clients[slot].state = CLIENT_STATE_SENDING;

    /* Parse the request */
    parse_result = http_parse_request(clients[slot].recv_buffer, clients[slot].recv_len, &req);

    if (parse_result < 0)
    {
        web_log("%s - 400 Bad Request", clients[slot].remote_addr);
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Invalid request");
        close_client(slot);
        return;
    }

    if (parse_result == 0)
    {
        /* Incomplete - shouldn't happen since we checked for end marker */
        return;
    }

    /* Handle POST for login */
    if (strcmp(req.method, "POST") == 0)
    {
        if (strcmp(req.path, "/login") == 0)
        {
            handle_login_post(slot, &req);
            return;
        }
        if (strcmp(req.path, "/upload") == 0)
        {
            handle_upload_post(slot, &req);
            return;
        }
        /* Other POST routes not supported */
        web_log("%s POST %s - 400 Method not supported", clients[slot].remote_addr, req.path);
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Method not supported for this path");
        close_client(slot);
        return;
    }

    /* Only support GET and HEAD for other routes */
    if (strcmp(req.method, "GET") != 0 && strcmp(req.method, "HEAD") != 0)
    {
        web_log("%s %s %s - 400 Method not supported", clients[slot].remote_addr, req.method, req.path);
        http_send_error(clients[slot].socket, HTTP_STATUS_BAD_REQUEST, "Method not supported");
        close_client(slot);
        return;
    }

    /* Handle logout */
    if (strcmp(req.path, "/logout") == 0)
    {
        handle_logout(slot, &req);
        return;
    }

    /* Check for API requests */
    if (strncmp(req.path, "/api/areas", 10) == 0)
    {
        handle_api_areas(slot, &req);
        return;
    }

    /* Check for download request - handle specially */
    if (strncmp(req.path, "/download/", 10) == 0)
    {
        handle_download_request(slot, req.path);
        return;
    }

    /* Validate path */
    if (!http_validate_path(req.path))
    {
        web_log("%s %s %s - 403 Forbidden", clients[slot].remote_addr, req.method, req.path);
        http_send_error(clients[slot].socket, HTTP_STATUS_FORBIDDEN, "Access denied");
        close_client(slot);
        return;
    }

    /* Build filesystem path */
    if (!http_build_filepath(docroot, req.path, filepath, sizeof(filepath)))
    {
        web_log("%s %s %s - 500 Path error", clients[slot].remote_addr, req.method, req.path);
        http_send_error(clients[slot].socket, HTTP_STATUS_SERVER_ERROR, "Path error");
        close_client(slot);
        return;
    }

    /* Check if file is HTML and might need template processing */
    {
        _kernel_swi_regs regs;
        _kernel_oserror *err;
        int object_type;
        int filetype;

        /* OS_File 17 - Read catalogue info */
        regs.r[0] = 17;
        regs.r[1] = (int)filepath;
        err = _kernel_swi(OS_File, &regs, &regs);

        if (err != NULL || regs.r[0] == 0)
        {
            /* File not found - try with index appended if path doesn't have extension */
            char alt_path[512];
            snprintf(alt_path, sizeof(alt_path), "%s.index", filepath);

            regs.r[0] = 17;
            regs.r[1] = (int)alt_path;
            err = _kernel_swi(OS_File, &regs, &regs);

            if (err == NULL && regs.r[0] == 1)
            {
                strcpy(filepath, alt_path);
            }
            else
            {
                web_log("%s %s %s - 404 Not Found", clients[slot].remote_addr, req.method, req.path);
                http_send_error(clients[slot].socket, HTTP_STATUS_NOT_FOUND, "File not found");
                close_client(slot);
                return;
            }
        }

        object_type = regs.r[0];

        /* If it's a directory, try index file */
        if (object_type == 2)
        {
            char dir_path[512];
            snprintf(dir_path, sizeof(dir_path), "%s.index", filepath);

            regs.r[0] = 17;
            regs.r[1] = (int)dir_path;
            err = _kernel_swi(OS_File, &regs, &regs);

            if (err == NULL && regs.r[0] == 1)
            {
                strcpy(filepath, dir_path);
                object_type = 1;
            }
            else
            {
                web_log("%s %s %s - 404 Directory", clients[slot].remote_addr, req.method, req.path);
                http_send_error(clients[slot].socket, HTTP_STATUS_NOT_FOUND, "Directory listing not supported");
                close_client(slot);
                return;
            }
        }

        /* Extract filetype */
        if ((regs.r[2] & 0xFFF00000) == 0xFFF00000)
        {
            filetype = (regs.r[2] >> 8) & 0xFFF;
        }
        else
        {
            filetype = -1;
        }

        /* Check if HTML file that might need template processing */
        if (filetype == 0xFAF) /* HTML */
        {
            long filesize = (long)regs.r[4];
            char *content;
            _kernel_swi_regs load_regs;
            WEB_SESSION *session = NULL;
            char token[SESSION_TOKEN_LEN + 1];

            /* Look up session from cookie */
            if (session_parse_cookie(req.cookie, token, sizeof(token)))
            {
                session = session_lookup(token);
            }
            
            /* Set session context for template processing */
            template_set_session(session);

            /* Load file into memory */
            content = malloc((size_t)filesize + 1);
            if (content != NULL)
            {
                load_regs.r[0] = 255; /* Load */
                load_regs.r[1] = (int)filepath;
                load_regs.r[2] = (int)content;
                load_regs.r[3] = 0;
                err = _kernel_swi(OS_File, &load_regs, &load_regs);

                if (err == NULL)
                {
                    content[filesize] = '\0';

                    /* Check for template tags */
                    if (template_has_tags(content, filesize))
                    {
                        char *processed;
                        long processed_len;

                        processed = template_process(content, filesize, &processed_len);
                        free(content);

                        if (processed != NULL)
                        {
                            http_send_headers(clients[slot].socket, HTTP_STATUS_OK,
                                            "text/html; charset=utf-8", processed_len);
                            http_send_data(clients[slot].socket, processed, processed_len);
                            web_log("%s %s %s - 200 OK (%ld bytes)", clients[slot].remote_addr, req.method, req.path, processed_len);
                            free(processed);
                            close_client(slot);
                            return;
                        }
                    }
                }
                free(content);
            }
        }
    }

    /* Serve the file directly */
    http_send_file(clients[slot].socket, filepath);
    web_log("%s %s %s - 200 OK", clients[slot].remote_addr, req.method, req.path);
    close_client(slot);
}

/* ******************************************************************************************************************************************************** */
/* Main Entry Point                                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int main(void)
{
    int i;
    char menu_title[32];
    char menu_items[64];

    /* Initialise client slots */
    for (i = 0; i < WEB_MAX_CLIENTS; i++)
    {
        memset(&clients[i], 0, sizeof(CLIENT_SLOT));
    }

    wimp.quit = Desk_bool_FALSE;

    /* Initialise debug */
    debug_initialise();
    debug_printf("Web: Starting...\n");

    /* Initialise sessions */
    session_initialise();

    /* Initialise Wimp */
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");

    /* Load error messages */
    Desk_Msgs_Lookup("web.bind", error_bind, sizeof(error_bind));
    Desk_Msgs_Lookup("web.listen", error_listen, sizeof(error_listen));

    if (error_bind[0] == '\0')
    {
        strcpy(error_bind, "Failed to bind to port");
    }
    if (error_listen[0] == '\0')
    {
        strcpy(error_listen, "Failed to listen on socket");
    }

    Desk_Event_Initialise("Web Server");
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();

    /* Set up event handlers */
    Desk_EventMsg_Claim(Desk_message_MODECHANGE, Desk_event_ANY, Desk_Handler_ModeChange, NULL);
    Desk_EventMsg_Claim((Desk_message_action)MESSAGE_LINE_BROADCAST, Desk_event_ANY, handle_broadcast_message, &wimp);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, handle_null_event, NULL);
    Desk_Event_Claim(Desk_event_MENU, Desk_event_ANY, Desk_event_ANY, handle_menu_selection, &wimp);

    /* Create iconbar icon */
    wimp.iconbar_icon = Desk_Icon_BarIcon("!web", Desk_iconbar_RIGHT);
    Desk_Event_Claim(Desk_event_CLICK, Desk_window_ICONBAR, wimp.iconbar_icon,
                     handle_iconbar_click, &wimp);

    /* Create iconbar menu */
    Desk_Msgs_Lookup("web.ibmt", menu_title, sizeof(menu_title));
    Desk_Msgs_Lookup("web.ibm", menu_items, sizeof(menu_items));

    if (menu_title[0] == '\0')
    {
        strcpy(menu_title, "Web");
    }
    if (menu_items[0] == '\0')
    {
        strcpy(menu_items, "Info,Quit");
    }

    wimp.iconbar_menu = Desk_Menu_New(menu_title, menu_items);

    /* Load templates and create proginfo window */
    Desk_Template_Initialise();
    Desk_Template_UseOutlineFonts();
    Desk_Template_LoadFile("Templates");

    proginfo_window = Desk_Dialog2_CreateDialogBlock("proginfo", -1, -1, NULL, NULL, NULL);
    Desk_Menu_Warn(wimp.iconbar_menu, ICONBAR_MENU_INFO, Desk_bool_TRUE, handle_open_proginfo, (void *)proginfo_window);

    /* Create listener */
    create_listener(listen_port);
    atexit(destroy_listener);

    web_log("Server started");

    /* Main event loop */
    while (wimp.quit == Desk_bool_FALSE)
    {
        poll_idle();
    }

    debug_printf("Web: Shutting down\n");
    session_finalise();
    debug_finalise();

    Desk_Template_ClearAll();

    return 0;
}
