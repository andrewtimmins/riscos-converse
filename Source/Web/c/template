/* ******************************************************************************************************************************************************** */
/* Web Server - Template Module                                                                                                                             */
/* ******************************************************************************************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "kernel.h"
#include "swis.h"

#include "template.h"
#include "debug.h"

/* Filer SWI numbers */
#define SWI_FILER_FILEBASE      0x5AA43

/* Filebase commands */
#define FILER_FILEBASE_CMD_INFO             2
#define FILER_FILEBASE_CMD_AREA_INFO        7
#define FILER_FILEBASE_CMD_ENUMERATE_BASES  8
#define FILER_FILEBASE_CMD_ENUMERATE_AREAS  9
#define FILER_FILEBASE_CMD_ENUMERATE_FILES  10
#define FILER_FILEBASE_CMD_FILE_INFO        11

/* Structure sizes from Filer/h/structs */
#define MAX_KEYS    128
#define MAX_NAME    64
#define MAX_DESC    256

/* ******************************************************************************************************************************************************** */
/* Filebase Structures (matching Filer/h/structs)                                                                                                           */
/* ******************************************************************************************************************************************************** */

typedef struct
{
    int id;
    int type;
    int accesslevel;
    char keys[MAX_KEYS];
    char name[MAX_NAME];
    char filebasedir[256];
} FILEBASE_RECORD;

typedef struct
{
    int id;
    int filebaseid;
    int accesslevel;
    char keys[MAX_KEYS];
    char name[MAX_NAME];
} FILEBASE_AREA_RECORD;

typedef struct
{
    int id;
    int filebaseid;
    int filebaseareaid;
    int deleted;
    int accesslevel;
    char keys[MAX_KEYS];
    char name[MAX_NAME];
    int uploadedby;
    long uploaddate;
    char description[MAX_DESC];
    long filesize;
    int downloads;
} FILE_RECORD;

/* ******************************************************************************************************************************************************** */
/* String Buffer Helper                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

typedef struct
{
    char *data;
    long length;
    long capacity;
} STRING_BUFFER;

static int buffer_init(STRING_BUFFER *buf, long initial_capacity)
{
    buf->data = malloc((size_t)initial_capacity);
    if (buf->data == NULL)
    {
        return 0;
    }
    buf->data[0] = '\0';
    buf->length = 0;
    buf->capacity = initial_capacity;
    return 1;
}

static int buffer_append(STRING_BUFFER *buf, const char *str, long len)
{
    long new_len;
    long new_capacity;
    char *new_data;

    if (len < 0)
    {
        len = (long)strlen(str);
    }

    new_len = buf->length + len;
    if (new_len + 1 > buf->capacity)
    {
        new_capacity = buf->capacity * 2;
        if (new_capacity < new_len + 1)
        {
            new_capacity = new_len + 256;
        }
        new_data = realloc(buf->data, (size_t)new_capacity);
        if (new_data == NULL)
        {
            return 0;
        }
        buf->data = new_data;
        buf->capacity = new_capacity;
    }

    memcpy(buf->data + buf->length, str, (size_t)len);
    buf->length = new_len;
    buf->data[buf->length] = '\0';
    return 1;
}

static void buffer_free(STRING_BUFFER *buf)
{
    if (buf->data != NULL)
    {
        free(buf->data);
        buf->data = NULL;
    }
    buf->length = 0;
    buf->capacity = 0;
}

/* ******************************************************************************************************************************************************** */
/* Template Tag Detection                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

int template_has_tags(const char *content, long content_len)
{
    const char *p;
    const char *end;

    if (content == NULL || content_len <= 0)
    {
        return 0;
    }

    end = content + content_len;
    p = content;

    while (p < end - 2)
    {
        if (p[0] == '{' && p[1] == '{')
        {
            return 1;
        }
        p++;
    }

    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Filebase Enumeration                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/* Callback context for enumeration */
typedef struct
{
    STRING_BUFFER *buf;
    int base_id;
    int area_id;
    int count;
} ENUM_CONTEXT;

static void format_filesize(long size, char *buffer, size_t buflen)
{
    if (size < 1024)
    {
        snprintf(buffer, buflen, "%ld B", size);
    }
    else if (size < 1024 * 1024)
    {
        snprintf(buffer, buflen, "%.1f KB", size / 1024.0);
    }
    else
    {
        snprintf(buffer, buflen, "%.1f MB", size / (1024.0 * 1024.0));
    }
}

static void html_escape(const char *src, char *dst, size_t dst_size)
{
    const char *s = src;
    char *d = dst;
    char *end = dst + dst_size - 1;

    while (*s && d < end)
    {
        switch (*s)
        {
            case '<':
                if (d + 4 <= end)
                {
                    strcpy(d, "&lt;");
                    d += 4;
                }
                break;
            case '>':
                if (d + 4 <= end)
                {
                    strcpy(d, "&gt;");
                    d += 4;
                }
                break;
            case '&':
                if (d + 5 <= end)
                {
                    strcpy(d, "&amp;");
                    d += 5;
                }
                break;
            case '"':
                if (d + 6 <= end)
                {
                    strcpy(d, "&quot;");
                    d += 6;
                }
                break;
            default:
                *d++ = *s;
                break;
        }
        s++;
    }
    *d = '\0';
}

char *template_generate_filebase_listing(long *out_len)
{
    STRING_BUFFER buf;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int base_index;
    int area_index;
    int file_index;
    char row[1024];
    char escaped_name[256];
    char escaped_desc[512];
    char size_str[32];
    int base_count = 0;

    if (!buffer_init(&buf, 4096))
    {
        return NULL;
    }

    /* Start HTML */
    buffer_append(&buf,
        "<div class=\"filebase-listing\">\n", -1);

    /* Enumerate filebases using ENUMERATE_BASES */
    for (base_index = 0; base_index < 100; base_index++)
    {
        FILEBASE_RECORD *base_rec;
        int base_id;
        int has_content = 0;

        /* Get filebase by index */
        regs.r[0] = FILER_FILEBASE_CMD_ENUMERATE_BASES;
        regs.r[1] = base_index;
        err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
        if (err != NULL || regs.r[0] == -1)
        {
            break; /* No more filebases */
        }

        base_rec = (FILEBASE_RECORD *)(regs.r[0]);
        if (base_rec == NULL)
        {
            continue;
        }

        base_id = base_rec->id;
        base_count++;

        /* Start filebase section */
        html_escape(base_rec->name, escaped_name, sizeof(escaped_name));
        snprintf(row, sizeof(row),
            "  <div class=\"filebase\">\n"
            "    <h3>%s</h3>\n",
            escaped_name);
        buffer_append(&buf, row, -1);

        /* Enumerate areas within this filebase */
        for (area_index = 0; area_index < 100; area_index++)
        {
            FILEBASE_AREA_RECORD *area_rec;
            int area_id;
            int has_files = 0;

            /* Get area by index */
            regs.r[0] = FILER_FILEBASE_CMD_ENUMERATE_AREAS;
            regs.r[1] = base_id;
            regs.r[2] = area_index;
            err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
            if (err != NULL || regs.r[0] == -1)
            {
                break; /* No more areas */
            }

            area_rec = (FILEBASE_AREA_RECORD *)(regs.r[0]);
            if (area_rec == NULL)
            {
                continue;
            }

            area_id = area_rec->id;
            has_content = 1;

            /* Start area section */
            html_escape(area_rec->name, escaped_name, sizeof(escaped_name));
            snprintf(row, sizeof(row),
                "    <div class=\"filearea\">\n"
                "      <h4>%s</h4>\n"
                "      <table class=\"file-table\">\n"
                "        <thead>\n"
                "          <tr>\n"
                "            <th>Name</th>\n"
                "            <th>Size</th>\n"
                "            <th>Description</th>\n"
                "            <th>Downloads</th>\n"
                "            <th>Download</th>\n"
                "          </tr>\n"
                "        </thead>\n"
                "        <tbody>\n",
                escaped_name);
            buffer_append(&buf, row, -1);

            /* Enumerate files in this area */
            for (file_index = 0; file_index < 1000; file_index++)
            {
                FILE_RECORD *file_rec;

                regs.r[0] = FILER_FILEBASE_CMD_ENUMERATE_FILES;
                regs.r[1] = base_id;
                regs.r[2] = area_id;
                regs.r[3] = file_index;
                err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
                if (err != NULL || regs.r[0] == -1)
                {
                    break; /* No more files in this area */
                }

                file_rec = (FILE_RECORD *)(regs.r[0]);
                if (file_rec == NULL || file_rec->deleted)
                {
                    continue;
                }

                /* Check file belongs to this area */
                if (file_rec->filebaseareaid != area_id)
                {
                    continue;
                }

                has_files = 1;

                html_escape(file_rec->name, escaped_name, sizeof(escaped_name));
                html_escape(file_rec->description, escaped_desc, sizeof(escaped_desc));
                format_filesize(file_rec->filesize, size_str, sizeof(size_str));

                snprintf(row, sizeof(row),
                    "          <tr>\n"
                    "            <td>%s</td>\n"
                    "            <td>%s</td>\n"
                    "            <td>%s</td>\n"
                    "            <td>%d</td>\n"
                    "            <td><a href=\"/download/%d/%d/%s\">Download</a></td>\n"
                    "          </tr>\n",
                    escaped_name,
                    size_str,
                    escaped_desc,
                    file_rec->downloads,
                    base_id,
                    file_rec->id,
                    escaped_name);
                buffer_append(&buf, row, -1);
            }

            if (!has_files)
            {
                buffer_append(&buf,
                    "          <tr><td colspan=\"5\"><em>No files in this area</em></td></tr>\n", -1);
            }

            /* End area section */
            buffer_append(&buf,
                "        </tbody>\n"
                "      </table>\n"
                "    </div>\n", -1);
        }

        /* Also show files not in any area (area_id = 0) */
        {
            int has_uncat_files = 0;
            int first_uncat = 1;

            for (file_index = 0; file_index < 1000; file_index++)
            {
                FILE_RECORD *file_rec;

                regs.r[0] = FILER_FILEBASE_CMD_ENUMERATE_FILES;
                regs.r[1] = base_id;
                regs.r[2] = 0; /* area_id = 0 means all files */
                regs.r[3] = file_index;
                err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
                if (err != NULL || regs.r[0] == -1)
                {
                    break;
                }

                file_rec = (FILE_RECORD *)(regs.r[0]);
                if (file_rec == NULL || file_rec->deleted)
                {
                    continue;
                }

                /* Only show files with no area (area_id = 0) */
                if (file_rec->filebaseareaid != 0)
                {
                    continue;
                }

                /* Start uncategorized section on first file */
                if (first_uncat)
                {
                    buffer_append(&buf,
                        "    <div class=\"filearea\">\n"
                        "      <h4>Uncategorized</h4>\n"
                        "      <table class=\"file-table\">\n"
                        "        <thead>\n"
                        "          <tr>\n"
                        "            <th>Name</th>\n"
                        "            <th>Size</th>\n"
                        "            <th>Description</th>\n"
                        "            <th>Downloads</th>\n"
                        "            <th>Download</th>\n"
                        "          </tr>\n"
                        "        </thead>\n"
                        "        <tbody>\n", -1);
                    first_uncat = 0;
                    has_content = 1;
                }

                has_uncat_files = 1;

                html_escape(file_rec->name, escaped_name, sizeof(escaped_name));
                html_escape(file_rec->description, escaped_desc, sizeof(escaped_desc));
                format_filesize(file_rec->filesize, size_str, sizeof(size_str));

                snprintf(row, sizeof(row),
                    "          <tr>\n"
                    "            <td>%s</td>\n"
                    "            <td>%s</td>\n"
                    "            <td>%s</td>\n"
                    "            <td>%d</td>\n"
                    "            <td><a href=\"/download/%d/%d/%s\">Download</a></td>\n"
                    "          </tr>\n",
                    escaped_name,
                    size_str,
                    escaped_desc,
                    file_rec->downloads,
                    base_id,
                    file_rec->id,
                    escaped_name);
                buffer_append(&buf, row, -1);
            }

            /* Close uncategorized section if we started it */
            if (!first_uncat)
            {
                buffer_append(&buf,
                    "        </tbody>\n"
                    "      </table>\n"
                    "    </div>\n", -1);
            }
        }

        if (!has_content)
        {
            buffer_append(&buf, "    <p><em>No areas or files</em></p>\n", -1);
        }

        /* End filebase section */
        buffer_append(&buf, "  </div>\n", -1);
    }

    if (base_count == 0)
    {
        buffer_append(&buf, "  <p><em>No filebases available</em></p>\n", -1);
    }

    /* End HTML */
    buffer_append(&buf, "</div>\n", -1);

    if (out_len != NULL)
    {
        *out_len = buf.length;
    }

    debug_printf("Template: Generated filebase listing (%ld bytes, %d bases)\n",
                 buf.length, base_count);

    return buf.data;
}

/* ******************************************************************************************************************************************************** */
/* Template Processing                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

char *template_process(const char *content, long content_len, long *out_len)
{
    STRING_BUFFER buf;
    const char *p;
    const char *end;
    const char *tag_start;
    const char *tag_end;
    size_t filebase_tag_len;

    if (content == NULL || content_len <= 0)
    {
        return NULL;
    }

    /* Quick check - if no tags, just duplicate the content */
    if (!template_has_tags(content, content_len))
    {
        char *result = malloc((size_t)content_len + 1);
        if (result != NULL)
        {
            memcpy(result, content, (size_t)content_len);
            result[content_len] = '\0';
            if (out_len != NULL)
            {
                *out_len = content_len;
            }
        }
        return result;
    }

    if (!buffer_init(&buf, content_len + 1024))
    {
        return NULL;
    }

    filebase_tag_len = strlen(TEMPLATE_TAG_FILEBASE);
    p = content;
    end = content + content_len;

    while (p < end)
    {
        /* Look for {{ */
        tag_start = p;
        while (tag_start < end - 1 && !(tag_start[0] == '{' && tag_start[1] == '{'))
        {
            tag_start++;
        }

        /* Copy content before tag */
        if (tag_start > p)
        {
            buffer_append(&buf, p, tag_start - p);
        }

        if (tag_start >= end - 1)
        {
            /* No more tags */
            break;
        }

        /* Find closing }} */
        tag_end = tag_start + 2;
        while (tag_end < end - 1 && !(tag_end[0] == '}' && tag_end[1] == '}'))
        {
            tag_end++;
        }

        if (tag_end >= end - 1)
        {
            /* Unclosed tag - copy literally */
            buffer_append(&buf, tag_start, end - tag_start);
            break;
        }

        /* Check for known tags */
        if ((size_t)(tag_end + 2 - tag_start) == filebase_tag_len &&
            strncmp(tag_start, TEMPLATE_TAG_FILEBASE, filebase_tag_len) == 0)
        {
            /* Replace with filebase listing */
            char *listing;
            long listing_len;

            listing = template_generate_filebase_listing(&listing_len);
            if (listing != NULL)
            {
                buffer_append(&buf, listing, listing_len);
                free(listing);
            }
            else
            {
                buffer_append(&buf, "<!-- Error generating filebase listing -->", -1);
            }
        }
        else
        {
            /* Unknown tag - copy literally */
            buffer_append(&buf, tag_start, tag_end + 2 - tag_start);
        }

        p = tag_end + 2;
    }

    if (out_len != NULL)
    {
        *out_len = buf.length;
    }

    debug_printf("Template: Processed content (%ld -> %ld bytes)\n", content_len, buf.length);

    return buf.data;
}
