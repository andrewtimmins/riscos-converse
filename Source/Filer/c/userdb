/* ******************************************************************************************************************************************************** */
/* Filer Module                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "cache.h"
#include "structs.h"
#include "userdb.h"
#include "logging.h"
#include "misc.h"
#include "encrypt.h"
#include "debug.h"

#define USERDB_LOG_ENTRY_LENGTH 256

static USER_RECORD userdb_cached_record;

static void userdb_encrypt_payload(USER_RECORD *record);
static void userdb_decrypt_payload(USER_RECORD *record);
static void userdb_normalise_strings(USER_RECORD *record);
static void userdb_log_event(const char *message, int user_id);
static USER_RECORD *userdb_find_record_by_username(const char *username);
static int userdb_string_casecmp(const char *lhs, const char *rhs);

/* ******************************************************************************************************************************************************** */
/* User Database Routines                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

int userdb_get_next_id(void)
{
    FILE *file = fopen(USERIDX, "r+b");
    int last_id = 0;
    
    if (file == NULL) {
        file = fopen(USERIDX, "w+b");
        if (file == NULL) {
            return 0;
        }
    } else {
        if (fread(&last_id, sizeof(int), 1, file) != 1) {
            last_id = 0;
            fseek(file, 0, SEEK_SET);
        }
    }
    
    last_id++;
    (void)(fseek(file, 0, SEEK_SET));
    fwrite(&last_id, sizeof(int), 1, file);

    fclose(file);
    return last_id;
}

int userdb_add_record(USER_RECORD *user_record)
{
    USER_RECORD stored_record;
    USER_RECORD cache_record;
    FILE *file;

    if (user_record == NULL) {
        return 0;
    }
    file = fopen(USERDB, "ab");
    if (file == NULL) {
        return 0;
    }

    stored_record = *user_record;
    stored_record.id = userdb_get_next_id();
    userdb_normalise_strings(&stored_record);

    /* Keep a copy for cache before encryption */
    cache_record = stored_record;

    userdb_log_event("Created new user: #%d", stored_record.id);

    userdb_encrypt_payload(&stored_record);

    if (fwrite(&stored_record, sizeof(USER_RECORD), 1, file) != 1) {
        fclose(file);
        return 0;
    }

    fclose(file);

    /* Add to cache (using unencrypted copy) */
    userdb_cache_add_user(&cache_record);

    return cache_record.id;
}

int userdb_update_record(int user_id, USER_RECORD *updated_user_record)
{
    USER_RECORD stored_record = {0};
    USER_RECORD cache_record;
    FILE *file;
    long position;

    if (updated_user_record == NULL || user_id <= 0) {
        return 0;
    }
    file = fopen(USERDB, "r+b");
    if (file == NULL) {
        return 0;
    }

    /* Direct seek: record N is at position (N-1) * sizeof(USER_RECORD) */
    position = ((long)(user_id - 1)) * (long)sizeof(USER_RECORD);

    if (fseek(file, position, SEEK_SET) != 0 ||
        fread(&stored_record, sizeof(USER_RECORD), 1, file) != 1 ||
        stored_record.id != user_id)
    {
        fclose(file);
        return 0;
    }

    {
        USER_RECORD working = *updated_user_record;
        working.id = user_id;
        userdb_normalise_strings(&working);

        /* Keep unencrypted copy for cache */
        cache_record = working;

        userdb_encrypt_payload(&working);

        if (fseek(file, position, SEEK_SET) != 0 ||
            fwrite(&working, sizeof(USER_RECORD), 1, file) != 1) {
            fclose(file);
            return 0;
        }

        fclose(file);

        /* Update cache */
        userdb_cache_update_user(&cache_record);

        userdb_log_event("Updated user: #%d", user_id);
        return 1;
    }
}

int userdb_update_history(int user_id, const USER_HISTORY *history)
{
    USER_RECORD stored_record = {0};
    USER_RECORD cache_record;
    FILE *file;
    long position;

    if (history == NULL || user_id <= 0) {
        return 0;
    }
    file = fopen(USERDB, "r+b");
    if (file == NULL) {
        return 0;
    }

    /* Direct seek: record N is at position (N-1) * sizeof(USER_RECORD) */
    position = ((long)(user_id - 1)) * (long)sizeof(USER_RECORD);

    if (fseek(file, position, SEEK_SET) != 0 ||
        fread(&stored_record, sizeof(USER_RECORD), 1, file) != 1 ||
        stored_record.id != user_id)
    {
        fclose(file);
        return 0;
    }

    /* Decrypt the record to work with it */
    userdb_decrypt_payload(&stored_record);
    
    /* Update just the history portion */
    stored_record.user_history = *history;

    /* Keep unencrypted copy for cache */
    cache_record = stored_record;
    
    /* Re-encrypt and write back */
    userdb_encrypt_payload(&stored_record);

    if (fseek(file, position, SEEK_SET) != 0 ||
        fwrite(&stored_record, sizeof(USER_RECORD), 1, file) != 1) {
        fclose(file);
        return 0;
    }

    fclose(file);

    /* Update cache */
    userdb_cache_update_user(&cache_record);

    {
        char log_msg[128];
        snprintf(log_msg, sizeof(log_msg), "Updated history for user: #%d (mb=%d/%d fb=%d/%d)", 
            user_id, history->messagebase, history->messagebasearea,
            history->filebase, history->filebasearea);
        log_system(log_msg);
    }
    return 1;
}

int userdb_update_stats(int user_id, const USER_STATS *stats)
{
    USER_RECORD stored_record = {0};
    USER_RECORD cache_record;
    FILE *file;
    long position;

    if (stats == NULL || user_id <= 0) {
        return 0;
    }
    file = fopen(USERDB, "r+b");
    if (file == NULL) {
        return 0;
    }

    /* Direct seek: record N is at position (N-1) * sizeof(USER_RECORD) */
    position = ((long)(user_id - 1)) * (long)sizeof(USER_RECORD);

    if (fseek(file, position, SEEK_SET) != 0 ||
        fread(&stored_record, sizeof(USER_RECORD), 1, file) != 1 ||
        stored_record.id != user_id)
    {
        fclose(file);
        return 0;
    }

    /* Decrypt the record to work with it */
    userdb_decrypt_payload(&stored_record);
    
    /* Update just the stats portion */
    stored_record.user_stats = *stats;

    /* Keep unencrypted copy for cache */
    cache_record = stored_record;
    
    /* Re-encrypt and write back */
    userdb_encrypt_payload(&stored_record);

    if (fseek(file, position, SEEK_SET) != 0 ||
        fwrite(&stored_record, sizeof(USER_RECORD), 1, file) != 1) {
        fclose(file);
        return 0;
    }

    fclose(file);

    /* Update cache */
    userdb_cache_update_user(&cache_record);

    {
        char log_msg[128];
        snprintf(log_msg, sizeof(log_msg), "Updated stats for user: #%d", user_id);
        log_system(log_msg);
    }
    return 1;
}
 
USER_RECORD *userdb_search_record(int user_id)
{
    const USER_RECORD *cached;

    /* Try cache first - O(1) lookup */
    cached = userdb_cache_find_user(user_id);
    if (cached != NULL)
    {
        userdb_cached_record = *cached;
        userdb_log_event("Found user: #%d", user_id);
        return &userdb_cached_record;
    }

    /* Not in cache - use direct seek by ID for O(1) disk lookup */
    debug_printf("userdb_search_record: user %d not in cache, using direct seek", user_id);
    
    if (user_id > 0)
    {
        FILE *file = fopen(USERDB, "rb");
        USER_RECORD record;
        long position;

        if (file == NULL) {
            return 0;
        }

        /* Direct seek: record N is at position (N-1) * sizeof(USER_RECORD) */
        position = ((long)(user_id - 1)) * (long)sizeof(USER_RECORD);

        if (fseek(file, position, SEEK_SET) == 0 &&
            fread(&record, sizeof(USER_RECORD), 1, file) == 1 &&
            record.id == user_id)
        {
            fclose(file);

            userdb_cached_record = record;
            userdb_decrypt_payload(&userdb_cached_record);
            userdb_normalise_strings(&userdb_cached_record);
            userdb_log_event("Found user: #%d", user_id);

            /* Add to cache for next time */
            userdb_cache_add_user(&userdb_cached_record);

            return &userdb_cached_record;
        }

        fclose(file);
    }
    return 0;
}

USER_RECORD *userdb_find_username(const char *username)
{
    return userdb_find_record_by_username(username);
}

int userdb_delete_record(int user_id)
{
    /* Soft delete: set deleted flag in-place using direct seek */
    FILE *file;
    USER_RECORD record;
    long position;

    if (user_id <= 0)
    {
        return 0;
    }

    file = fopen(USERDB, "r+b");
    if (file == NULL)
    {
        return 0;
    }

    /* Direct seek: record N is at position (N-1) * sizeof(USER_RECORD) */
    position = ((long)(user_id - 1)) * (long)sizeof(USER_RECORD);

    if (fseek(file, position, SEEK_SET) != 0 ||
        fread(&record, sizeof(USER_RECORD), 1, file) != 1 ||
        record.id != user_id)
    {
        fclose(file);
        return 0;
    }

    /* Decrypt to modify, set deleted flag, re-encrypt */
    userdb_decrypt_payload(&record);
    record.user_flags.deleted = 1;
    userdb_encrypt_payload(&record);

    /* Seek back and write updated record */
    if (fseek(file, position, SEEK_SET) != 0 ||
        fwrite(&record, sizeof(USER_RECORD), 1, file) != 1)
    {
        fclose(file);
        return 0;
    }

    fclose(file);

    /* Remove from cache */
    userdb_cache_delete_user(user_id);
    userdb_log_event("Deleted user: #%d", user_id);
    return 1;
}

USER_RECORD *userdb_authenticate(const char *username, const char *password, FILER_USERDB_AUTH_RESULT *result)
{
    const USER_RECORD *cached;

    debug_printf("userdb_authenticate: username='%s'", username != NULL ? username : "(null)");

    if (result != NULL)
    {
        *result = FILER_USERDB_AUTH_NO_USER;
    }

    if (username == NULL || password == NULL || *username == '\0')
    {
        debug_printf("userdb_authenticate: null/empty username or password");
        return NULL;
    }

    /* Try cache first - O(1) lookup by username */
    cached = userdb_cache_find_username(username);
    if (cached != NULL)
    {
        debug_printf("userdb_authenticate: found user %d in cache", cached->id);

        if (cached->user_flags.lockedout != 0)
        {
            debug_printf("userdb_authenticate: user is locked out");
            if (result != NULL)
            {
                *result = FILER_USERDB_AUTH_LOCKED;
            }
            return NULL;
        }

        if (strcmp(cached->password, password) != 0)
        {
            debug_printf("userdb_authenticate: password mismatch");
            if (result != NULL)
            {
                *result = FILER_USERDB_AUTH_BAD_PASSWORD;
            }
            return NULL;
        }

        /* Password matches */
        debug_printf("userdb_authenticate: password correct, success");
        if (result != NULL)
        {
            *result = FILER_USERDB_AUTH_SUCCESS;
        }

        userdb_cached_record = *cached;
        userdb_log_event("Authenticated user: #%d", cached->id);
        return &userdb_cached_record;
    }

    /* Not in cache - fallback to file scan */
    debug_printf("userdb_authenticate: user not in cache, falling back to file");

    {
        FILE *file;
        USER_RECORD record;
        int record_count = 0;

        file = fopen(USERDB, "rb");
        if (file == NULL)
        {
            debug_printf("userdb_authenticate: failed to open %s", USERDB);
            return NULL;
        }

        while (fread(&record, sizeof(USER_RECORD), 1, file) == 1)
        {
            record_count++;
            userdb_decrypt_payload(&record);
            userdb_normalise_strings(&record);

            if (record.user_flags.deleted != 0)
            {
                continue;
            }

            if (userdb_string_casecmp(record.username, username) == 0)
            {
                debug_printf("userdb_authenticate: found matching user id=%d", record.id);
                fclose(file);

                /* Add to cache for next time */
                userdb_cache_add_user(&record);

                if (record.user_flags.lockedout != 0)
                {
                    debug_printf("userdb_authenticate: user is locked out");
                    if (result != NULL)
                    {
                        *result = FILER_USERDB_AUTH_LOCKED;
                    }
                    return NULL;
                }

                if (strcmp(record.password, password) != 0)
                {
                    debug_printf("userdb_authenticate: password mismatch");
                    if (result != NULL)
                    {
                        *result = FILER_USERDB_AUTH_BAD_PASSWORD;
                    }
                    return NULL;
                }

                debug_printf("userdb_authenticate: password correct, success");
                if (result != NULL)
                {
                    *result = FILER_USERDB_AUTH_SUCCESS;
                }

                userdb_cached_record = record;
                userdb_log_event("Authenticated user: #%d", record.id);
                return &userdb_cached_record;
            }
        }

        debug_printf("userdb_authenticate: user not found after %d records", record_count);
        fclose(file);
    }
    return NULL;
}

static void userdb_encrypt_payload(USER_RECORD *record)
{
    if (record == NULL) {
        return;
    }

    /* Use user ID as nonce for per-record unique encryption */
    encrypt_decrypt_ex((char *)record + offsetof(USER_RECORD, username), 
                       sizeof(USER_RECORD) - offsetof(USER_RECORD, username),
                       (unsigned int)record->id);
}

static void userdb_decrypt_payload(USER_RECORD *record)
{
    /* CTR mode is symmetric - encrypt and decrypt are the same operation */
    userdb_encrypt_payload(record);
}

static void userdb_normalise_strings(USER_RECORD *record)
{
    if (record == NULL) {
        return;
    }

    null_terminate_string(record->username, sizeof(record->username));
    null_terminate_string(record->realname, sizeof(record->realname));
    null_terminate_string(record->email, sizeof(record->email));
    null_terminate_string(record->password, sizeof(record->password));
    null_terminate_string(record->keys, sizeof(record->keys));
    null_terminate_string(record->userdir, sizeof(record->userdir));
}

static void userdb_log_event(const char *message, int user_id)
{
    char log_entry[USERDB_LOG_ENTRY_LENGTH];

    if (message == NULL) {
        return;
    }

    snprintf(log_entry, sizeof(log_entry), message, user_id);
    log_system(log_entry);
}

static int userdb_string_casecmp(const char *lhs, const char *rhs)
{
    unsigned char a;
    unsigned char b;

    if (lhs == NULL || rhs == NULL)
    {
        return (lhs == rhs) ? 0 : (lhs == NULL ? -1 : 1);
    }

    do
    {
        a = (unsigned char)tolower((unsigned char)*lhs++);
        b = (unsigned char)tolower((unsigned char)*rhs++);
        if (a != b)
        {
            return (int)a - (int)b;
        }
    } while (a != '\0' && b != '\0');

    return (int)a - (int)b;
}

static USER_RECORD *userdb_find_record_by_username(const char *username)
{
    const USER_RECORD *cached;

    if (username == NULL || *username == '\0')
    {
        return NULL;
    }

    /* Try cache first - O(1) lookup */
    cached = userdb_cache_find_username(username);
    if (cached != NULL)
    {
        userdb_cached_record = *cached;
        userdb_log_event("Found user: #%d", userdb_cached_record.id);
        return &userdb_cached_record;
    }

    /* Not in cache - fallback to file scan */
    debug_printf("userdb_find_record_by_username: '%s' not in cache, falling back to file", username);

    {
        FILE *file;
        USER_RECORD record;

        file = fopen(USERDB, "rb");
        if (file == NULL)
        {
            return NULL;
        }

        while (fread(&record, sizeof(USER_RECORD), 1, file) == 1)
        {
            userdb_decrypt_payload(&record);
            userdb_normalise_strings(&record);

            if (record.user_flags.deleted != 0)
            {
                continue;
            }

            if (userdb_string_casecmp(record.username, username) == 0)
            {
                fclose(file);
                userdb_cached_record = record;
                userdb_log_event("Found user: #%d", record.id);
                
                /* Add to cache for next time */
                userdb_cache_add_user(&userdb_cached_record);
                
                return &userdb_cached_record;
            }
        }

        fclose(file);
    }
    return NULL;
}
