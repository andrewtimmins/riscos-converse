#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "kernel.h"

enum
{
  FILER_SWI_LOGGING = 0
};

enum
{
  FILER_LOG_CMD_SYSTEM = 0,
  FILER_LOG_CMD_LINE,
  FILER_LOG_CMD_CALL,
  FILER_LOG_CMD_FTN,
  FILER_LOG_CMD_WEB
};

#define CONVERSE_FILER_BASE 0x5AA40
#define SWI_CONVERSE_FILER_LOGGING (CONVERSE_FILER_BASE + FILER_SWI_LOGGING)

/* Thin wrappers over the ConverseFiler_Logging SWI **************************************/

static _kernel_oserror *filer_log_system(const char *message, int *status_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_LOG_CMD_SYSTEM;
  regs.r[1] = (int)(uintptr_t)message;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
  if (!error && status_out)
  {
    *status_out = regs.r[0];
  }
  return error;
}

static _kernel_oserror *filer_log_line(int line_id, const char *message, int *status_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_LOG_CMD_LINE;
  regs.r[1] = line_id;
  regs.r[2] = (int)(uintptr_t)message;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
  if (!error && status_out)
  {
    *status_out = regs.r[0];
  }
  return error;
}

static _kernel_oserror *filer_log_call(int line_id, int user_id, int status_id, int *status_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_LOG_CMD_CALL;
  regs.r[1] = line_id;
  regs.r[2] = user_id;
  regs.r[3] = status_id;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
  if (!error && status_out)
  {
    *status_out = regs.r[0];
  }
  return error;
}

static _kernel_oserror *filer_log_ftn(const char *message, int *status_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_LOG_CMD_FTN;
  regs.r[1] = (int)(uintptr_t)message;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
  if (!error && status_out)
  {
    *status_out = regs.r[0];
  }
  return error;
}

static _kernel_oserror *filer_log_web(const char *message, int *status_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_LOG_CMD_WEB;
  regs.r[1] = (int)(uintptr_t)message;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
  if (!error && status_out)
  {
    *status_out = regs.r[0];
  }
  return error;
}

/* Utility helpers ***********************************************************************/

static const char *program_leaf(const char *path)
{
  const char *leaf = path;
  const char *scan = path;
  if (path == NULL)
  {
    return "logging";
  }

  while (*scan != '\0')
  {
    if (*scan == '.' || *scan == '/' || *scan == '\\' || *scan == ':')
    {
      leaf = scan + 1;
    }
    ++scan;
  }

  return (*leaf != '\0') ? leaf : path;
}

static void print_usage(const char *invocation)
{
  const char *prog = program_leaf(invocation);
  fprintf(stderr,
          "Usage:\n"
          "  %s system <text...>\n"
          "  %s line <line> <text...>\n"
          "  %s ftn <text...>\n"
          "  %s web <text...>\n"
          "  %s call <line> <user> <status_id>\n",
          prog,
          prog,
          prog,
          prog,
          prog);
  fprintf(stderr, "Status ids: 0=Answered, 1=Hungup, 2=Aborted, 3=Rejected\n");
}

static char *join_text(int first_arg, int argc, char **argv)
{
  size_t length = 1; /* For the terminator. */
  int i;

  if (first_arg >= argc)
  {
    char *empty = (char *)malloc(1);
    if (empty)
    {
      empty[0] = '\0';
    }
    return empty;
  }

  for (i = first_arg; i < argc; ++i)
  {
    length += strlen(argv[i]) + 1;
  }

  char *buffer = (char *)malloc(length);
  if (buffer == NULL)
  {
    return NULL;
  }

  buffer[0] = '\0';
  for (i = first_arg; i < argc; ++i)
  {
    strcat(buffer, argv[i]);
    if (i + 1 < argc)
    {
      strcat(buffer, " ");
    }
  }

  return buffer;
}

static int handle_status(const char *operation, _kernel_oserror *error, int status)
{
  if (error)
  {
    fprintf(stderr, "%s failed: %s\n", operation, error->errmess);
    return error->errnum ? error->errnum : 1;
  }

  if (status != 0)
  {
    fprintf(stderr, "%s returned %d (module rejected the request).\n", operation, status);
    return 1;
  }

  printf("%s logged successfully.\n", operation);
  return 0;
}

/* Entry point *************************************************************************/

int main(int argc, char **argv)
{
  const char *mode;
  int status = -1;

  if (argc < 3)
  {
    print_usage(argv[0]);
    return 1;
  }

  mode = argv[1];

  if (strcmp(mode, "system") == 0)
  {
    char *message = join_text(2, argc, argv);
    int rc;
    if (message == NULL)
    {
      fprintf(stderr, "Unable to allocate message buffer.\n");
      return 1;
    }

    rc = handle_status("System log",
                       filer_log_system(message, &status),
                       status);
    free(message);
    return rc;
  }
  else if (strcmp(mode, "line") == 0)
  {
    int line;
    char *message;
    int rc;

    if (argc < 4)
    {
      print_usage(argv[0]);
      return 1;
    }

    line = atoi(argv[2]);
    message = join_text(3, argc, argv);
    if (message == NULL)
    {
      fprintf(stderr, "Unable to allocate message buffer.\n");
      return 1;
    }

    status = -1;
    rc = handle_status("Line log",
                       filer_log_line(line, message, &status),
                       status);
    free(message);
    return rc;
  }
  else if (strcmp(mode, "ftn") == 0)
  {
    char *message = join_text(2, argc, argv);
    int rc;
    if (message == NULL)
    {
      fprintf(stderr, "Unable to allocate message buffer.\n");
      return 1;
    }

    rc = handle_status("FTN log",
                       filer_log_ftn(message, &status),
                       status);
    free(message);
    return rc;
  }
  else if (strcmp(mode, "web") == 0)
  {
    char *message = join_text(2, argc, argv);
    int rc;
    if (message == NULL)
    {
      fprintf(stderr, "Unable to allocate message buffer.\n");
      return 1;
    }

    rc = handle_status("Web log",
                       filer_log_web(message, &status),
                       status);
    free(message);
    return rc;
  }
  else if (strcmp(mode, "call") == 0)
  {
    int line;
    int user;
    int call_status;

    if (argc < 5)
    {
      print_usage(argv[0]);
      return 1;
    }

    line = atoi(argv[2]);
    user = atoi(argv[3]);
    call_status = atoi(argv[4]);

    status = -1;
    return handle_status("Call log",
                         filer_log_call(line, user, call_status, &status),
                         status);
  }

  print_usage(argv[0]);
  return 1;
}
