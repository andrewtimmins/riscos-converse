#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "structs.h"

/* Simple command-line utility that exercises the ConverseFiler messagebase SWIs. */

#define CONVERSE_FILER_BASE 0x16F00
#define SWI_CONVERSE_FILER_MESSAGEBASE (CONVERSE_FILER_BASE + FILER_SWI_MESSAGEBASE)
#define TRANSFER_BUFFER 4096

static const char *program_leaf(const char *path)
{
  const char *leaf = path;
  const char *scan = path;

  if (path == NULL)
  {
    return "messagebase";
  }

  while (*scan != '\0')
  {
    if (*scan == '.' || *scan == '/' || *scan == '\\' || *scan == ':')
    {
      leaf = scan + 1;
    }
    ++scan;
  }

  return (*leaf != '\0') ? leaf : path;
}

static void copy_field(char *dest, size_t dest_bytes, const char *src)
{
  if (dest == NULL || dest_bytes == 0)
  {
    return;
  }

  dest[0] = '\0';
  if (src == NULL)
  {
    return;
  }

  strncpy(dest, src, dest_bytes - 1);
  dest[dest_bytes - 1] = '\0';
}

static int parse_int(const char *text, int *value_out)
{
  char *end = NULL;
  long value;

  if (text == NULL || *text == '\0')
  {
    return 0;
  }

  value = strtol(text, &end, 10);
  if (end == NULL || *end != '\0')
  {
    return 0;
  }

  if (value_out != NULL)
  {
    *value_out = (int)value;
  }
  return 1;
}

static int require_int(const char *text, const char *name, int *value_out)
{
  if (!parse_int(text, value_out))
  {
    fprintf(stderr, "%s must be numeric.\n", name);
    return 0;
  }
  return 1;
}

static char *join_text(int first_arg, int argc, char **argv)
{
  size_t length = 1;
  int i;

  if (first_arg >= argc)
  {
    char *empty = (char *)malloc(1);
    if (empty)
    {
      empty[0] = '\0';
    }
    return empty;
  }

  for (i = first_arg; i < argc; ++i)
  {
    length += strlen(argv[i]) + 1;
  }

  char *buffer = (char *)malloc(length);
  if (buffer == NULL)
  {
    return NULL;
  }

  buffer[0] = '\0';
  for (i = first_arg; i < argc; ++i)
  {
    strcat(buffer, argv[i]);
    if (i + 1 < argc)
    {
      strcat(buffer, " ");
    }
  }

  return buffer;
}

static void print_usage(const char *invocation)
{
  const char *prog = program_leaf(invocation);
  fprintf(stderr,
          "Usage:\n"
          "  %s create <name> [type] [access] [keys]\n"
          "  %s update <id> <name> [type] [access] [keys]\n"
          "  %s info <id>\n"
            "  %s area <base> <name...>\n"
          "  %s import <base> <area> <host path> <type> <subject...>\n"
          "  %s download <base> <message> <target path> [chunk]\n",
          prog,
          prog,
          prog,
          prog,
          prog,
          prog);
}

static _kernel_oserror *messagebase_create(MESSAGEBASE_RECORD *record, int *new_id)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_CREATE;
  regs.r[1] = (int)(uintptr_t)record;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (!error && new_id)
  {
    *new_id = regs.r[0];
  }
  return error;
}

static _kernel_oserror *messagebase_update(int base_id, MESSAGEBASE_RECORD *record, int *status_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_UPDATE;
  regs.r[1] = base_id;
  regs.r[2] = (int)(uintptr_t)record;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (!error && status_out)
  {
    *status_out = regs.r[0];
  }
  return error;
}

static _kernel_oserror *messagebase_info(int base_id, MESSAGEBASE_RECORD *record_out, int *found_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_INFO;
  regs.r[1] = base_id;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (error)
  {
    return error;
  }

  if (regs.r[0] <= 0)
  {
    if (found_out)
    {
      *found_out = 0;
    }
    return NULL;
  }

  if (record_out)
  {
    memcpy(record_out, (const void *)(uintptr_t)regs.r[0], sizeof(MESSAGEBASE_RECORD));
  }
  if (found_out)
  {
    *found_out = 1;
  }
  return NULL;
}

static _kernel_oserror *messagebase_store_area(int base_id, MESSAGEBASE_AREA *record, int *assigned_id)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_STORE_AREA;
  regs.r[1] = base_id;
  regs.r[2] = (int)(uintptr_t)record;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (!error && assigned_id)
  {
    *assigned_id = regs.r[0];
  }
  return error;
}

static _kernel_oserror *messagebase_begin_upload(int base_id, MESSAGE_RECORD *record, int *message_id)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_BEGIN_UPLOAD;
  regs.r[1] = base_id;
  regs.r[2] = (int)(uintptr_t)record;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (!error && message_id)
  {
    *message_id = regs.r[0];
  }
  return error;
}

static _kernel_oserror *messagebase_upload_block(int base_id, int message_id, const void *data, size_t length, int *written)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_UPLOAD_BLOCK;
  regs.r[1] = base_id;
  regs.r[2] = message_id;
  regs.r[3] = (int)(uintptr_t)data;
  regs.r[4] = (int)length;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (!error && written)
  {
    *written = regs.r[0];
  }
  return error;
}

static _kernel_oserror *messagebase_download_block(int base_id, int message_id, void *buffer, long offset, size_t length, int *read_out)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_MESSAGEBASE_CMD_DOWNLOAD_BLOCK;
  regs.r[1] = base_id;
  regs.r[2] = message_id;
  regs.r[3] = (int)(uintptr_t)buffer;
  regs.r[4] = (int)offset;
  regs.r[5] = (int)length;
  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_FILER_MESSAGEBASE, &regs, &regs);
  if (!error && read_out)
  {
    *read_out = regs.r[0];
  }
  return error;
}

static int command_create(int argc, char **argv)
{
  MESSAGEBASE_RECORD record;
  int new_id = -1;
  _kernel_oserror *error;

  if (argc < 3)
  {
    print_usage(argv[0]);
    return 1;
  }

  memset(&record, 0, sizeof(record));
  copy_field(record.name, sizeof(record.name), argv[2]);
  record.type = (argc >= 4) ? atoi(argv[3]) : 0;
  record.accesslevel = (argc >= 5) ? atoi(argv[4]) : 0;
  copy_field(record.keys, sizeof(record.keys), (argc >= 6) ? argv[5] : "");

  error = messagebase_create(&record, &new_id);
  if (error)
  {
    fprintf(stderr, "Create failed: %s\n", error->errmess);
    return error->errnum ? error->errnum : 1;
  }

  if (new_id < 0)
  {
    fprintf(stderr, "Create failed (module rejected request).\n");
    return 1;
  }

  printf("Created messagebase #%d (%s -> %s).\n", new_id, record.name, record.messagebasedir);
  return 0;
}

static int command_update(int argc, char **argv)
{
  MESSAGEBASE_RECORD record;
  int base_id;
  int status = -1;
  _kernel_oserror *error;
  int found = 0;

  if (argc < 4)
  {
    print_usage(argv[0]);
    return 1;
  }

  if (!require_int(argv[2], "Base id", &base_id))
  {
    return 1;
  }

  error = messagebase_info(base_id, &record, &found);
  if (error)
  {
    fprintf(stderr, "Info failed: %s\n", error->errmess);
    return error->errnum ? error->errnum : 1;
  }

  if (!found)
  {
    fprintf(stderr, "Messagebase #%d not found.\n", base_id);
    return 1;
  }

  copy_field(record.name, sizeof(record.name), argv[3]);
  if (argc >= 5)
  {
    record.type = atoi(argv[4]);
  }
  if (argc >= 6)
  {
    record.accesslevel = atoi(argv[5]);
  }
  if (argc >= 7)
  {
    copy_field(record.keys, sizeof(record.keys), argv[6]);
  }

  error = messagebase_update(base_id, &record, &status);
  if (error)
  {
    fprintf(stderr, "Update failed: %s\n", error->errmess);
    return error->errnum ? error->errnum : 1;
  }

  if (status != 0)
  {
    fprintf(stderr, "Update rejected (code %d).\n", status);
    return 1;
  }

  printf("Updated messagebase #%d.\n", base_id);
  return 0;
}

static int command_info(int argc, char **argv)
{
  MESSAGEBASE_RECORD record;
  _kernel_oserror *error;
  int base_id;
  int found = 0;

  if (argc < 3)
  {
    print_usage(argv[0]);
    return 1;
  }

  if (!require_int(argv[2], "Base id", &base_id))
  {
    return 1;
  }

  error = messagebase_info(base_id, &record, &found);
  if (error)
  {
    fprintf(stderr, "Info failed: %s\n", error->errmess);
    return error->errnum ? error->errnum : 1;
  }

  if (!found)
  {
    fprintf(stderr, "Messagebase #%d not found.\n", base_id);
    return 1;
  }

  printf("Messagebase #%d\n", record.id);
  printf("  Name     : %s\n", record.name);
  printf("  Dir      : %s\n", record.messagebasedir);
  printf("  Type     : %d\n", record.type);
  printf("  Access   : %d\n", record.accesslevel);
  printf("  Keys     : %s\n", record.keys);
  return 0;
}

static int command_area(int argc, char **argv)
{
  MESSAGEBASE_RECORD record;
  MESSAGEBASE_AREA area_record;
  int base_id;
  int found = 0;
  _kernel_oserror *error;
  char *area_name = NULL;
  int assigned_id = -1;
  int rc = 1;

  if (argc < 4)
  {
    print_usage(argv[0]);
    return 1;
  }

  if (!require_int(argv[2], "Base id", &base_id))
  {
    return 1;
  }

  area_name = join_text(3, argc, argv);
  if (area_name == NULL)
  {
    fprintf(stderr, "Unable to allocate area name buffer.\n");
    return 1;
  }

  if (*area_name == '\0')
  {
    fprintf(stderr, "Area name required.\n");
    goto cleanup;
  }

  error = messagebase_info(base_id, &record, &found);
  if (error)
  {
    fprintf(stderr, "Info failed: %s\n", error->errmess);
    rc = error->errnum ? error->errnum : 1;
    goto cleanup;
  }

  if (!found)
  {
    fprintf(stderr, "Messagebase #%d not found.\n", base_id);
    goto cleanup;
  }

  memset(&area_record, 0, sizeof(area_record));
  copy_field(area_record.name, sizeof(area_record.name), area_name);
  copy_field(area_record.tag, sizeof(area_record.tag), area_name);
  area_record.daystokeep = 0;
  area_record.akause = 0;
  area_record.areatype = 0;

  error = messagebase_store_area(base_id, &area_record, &assigned_id);
  if (error)
  {
    fprintf(stderr, "Unable to store area metadata: %s\n", error->errmess);
    rc = error->errnum ? error->errnum : 1;
    goto cleanup;
  }

  if (assigned_id <= 0)
  {
    fprintf(stderr, "Module rejected area creation.\n");
    goto cleanup;
  }

  printf("Created area #%d for base %d named \"%s\".\n", assigned_id, base_id, area_record.name);
  rc = 0;

cleanup:
  free(area_name);
  return rc;
}

static int stream_upload(int base_id, int message_id, const char *host_path)
{
  FILE *source = fopen(host_path, "rb");
  unsigned char buffer[TRANSFER_BUFFER];
  long total = 0;

  if (source == NULL)
  {
    fprintf(stderr, "Unable to open %s for reading.\n", host_path);
    return 1;
  }

  while (1)
  {
    size_t read = fread(buffer, 1, sizeof(buffer), source);
    if (read == 0)
    {
      if (ferror(source))
      {
        fprintf(stderr, "Read error from %s.\n", host_path);
        fclose(source);
        return 1;
      }
      break;
    }

    int written = 0;
    _kernel_oserror *error = messagebase_upload_block(base_id, message_id, buffer, read, &written);
    if (error)
    {
      fprintf(stderr, "Upload block failed: %s\n", error->errmess);
      fclose(source);
      return error->errnum ? error->errnum : 1;
    }

    if (written != (int)read)
    {
      fprintf(stderr, "Short write (%d/%zu).\n", written, read);
      fclose(source);
      return 1;
    }

    total += written;
  }

  fclose(source);
  printf("Uploaded %ld bytes.\n", total);
  return 0;
}

static int command_import(int argc, char **argv)
{
  MESSAGE_RECORD record;
  int base_id;
  int area_id;
  int type;
  int message_id = -1;
  char *subject = NULL;
  int rc;

  if (argc < 6)
  {
    print_usage(argv[0]);
    return 1;
  }

  if (!require_int(argv[2], "Base id", &base_id) || !require_int(argv[3], "Area id", &area_id) || !require_int(argv[5], "Message type", &type))
  {
    return 1;
  }

  subject = join_text(6, argc, argv);
  if (subject == NULL)
  {
    fprintf(stderr, "Unable to allocate subject buffer.\n");
    return 1;
  }
  if (*subject == '\0')
  {
    fprintf(stderr, "Subject text required.\n");
    free(subject);
    return 1;
  }

  memset(&record, 0, sizeof(record));
  record.type = type;
  record.messagebaseareaid = area_id;
  record.accesslevel = 0;
  record.sentby = 0;
  record.receivedby = 0;
  record.sent = time(NULL);
  copy_field(record.subject, sizeof(record.subject), subject);

  _kernel_oserror *error = messagebase_begin_upload(base_id, &record, &message_id);
  if (error)
  {
    fprintf(stderr, "Begin upload failed: %s\n", error->errmess);
    free(subject);
    return error->errnum ? error->errnum : 1;
  }

  if (message_id < 0)
  {
    fprintf(stderr, "Module rejected upload request.\n");
    free(subject);
    return 1;
  }

  rc = stream_upload(base_id, message_id, argv[4]);
  free(subject);
  if (rc != 0)
  {
    return rc;
  }

  printf("Stored as message #%d in base %d (area %d).\n", message_id, base_id, area_id);
  return 0;
}

static int command_download(int argc, char **argv)
{
  int base_id;
  int message_id;
  int chunk = TRANSFER_BUFFER;
  long offset = 0;
  unsigned char *buffer;
  FILE *target;
  int rc = 0;

  if (argc < 5)
  {
    print_usage(argv[0]);
    return 1;
  }

  if (!require_int(argv[2], "Base id", &base_id) || !require_int(argv[3], "Message id", &message_id))
  {
    return 1;
  }

  if (argc >= 6)
  {
    if (!require_int(argv[5], "Chunk size", &chunk) || chunk <= 0)
    {
      fprintf(stderr, "Chunk size must be positive.\n");
      return 1;
    }
  }

  buffer = (unsigned char *)malloc((size_t)chunk);
  if (buffer == NULL)
  {
    fprintf(stderr, "Unable to allocate %d byte buffer.\n", chunk);
    return 1;
  }

  target = fopen(argv[4], "wb");
  if (target == NULL)
  {
    fprintf(stderr, "Unable to open %s for writing.\n", argv[4]);
    free(buffer);
    return 1;
  }

  while (1)
  {
    int read = 0;
    _kernel_oserror *error = messagebase_download_block(base_id, message_id, buffer, offset, (size_t)chunk, &read);
    if (error)
    {
      fprintf(stderr, "Download block failed: %s\n", error->errmess);
      rc = error->errnum ? error->errnum : 1;
      break;
    }

    if (read <= 0)
    {
      printf("Download complete (%ld bytes).\n", offset);
      break;
    }

    if (fwrite(buffer, 1, (size_t)read, target) != (size_t)read)
    {
      fprintf(stderr, "Unable to write to %s.\n", argv[4]);
      rc = 1;
      break;
    }

    offset += read;
  }

  fclose(target);
  free(buffer);
  return rc;
}

int main(int argc, char **argv)
{
  if (argc < 2)
  {
    print_usage(argv[0]);
    return 1;
  }

  if (strcmp(argv[1], "create") == 0)
  {
    return command_create(argc, argv);
  }
  if (strcmp(argv[1], "update") == 0)
  {
    return command_update(argc, argv);
  }
  if (strcmp(argv[1], "info") == 0)
  {
    return command_info(argc, argv);
  }
  if (strcmp(argv[1], "area") == 0)
  {
    return command_area(argc, argv);
  }
  if (strcmp(argv[1], "import") == 0)
  {
    return command_import(argc, argv);
  }
  if (strcmp(argv[1], "download") == 0)
  {
    return command_download(argc, argv);
  }

  print_usage(argv[0]);
  return 1;
}
