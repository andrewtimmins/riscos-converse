/* ******************************************************************************************************************************************************** */
/* LineTask Filebase Support                                                                                                                                */
/*                                                                                                                                                          */
/* Provides filebase browsing and file transfer capabilities via the Filer module SWIs.                                                                     */
/* ******************************************************************************************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "filebase.h"
#include "debug.h"

/* ******************************************************************************************************************************************************** */
/* Session Management                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void filebase_session_init(filebase_session *session)
{
    if (session == NULL)
    {
        return;
    }

    memset(session, 0, sizeof(filebase_session));
    session->current_filebase = 0;
    session->current_area = 0;
    session->user_accesslevel = 0;
    session->user_keys[0] = '\0';
}

void filebase_session_reset(filebase_session *session)
{
    if (session == NULL)
    {
        return;
    }

    session->current_filebase = 0;
    session->current_area = 0;
}

void filebase_session_set_access(filebase_session *session, int accesslevel, const char *keys)
{
    if (session == NULL)
    {
        return;
    }

    session->user_accesslevel = accesslevel;

    if (keys != NULL)
    {
        strncpy(session->user_keys, keys, sizeof(session->user_keys) - 1);
        session->user_keys[sizeof(session->user_keys) - 1] = '\0';
    }
    else
    {
        session->user_keys[0] = '\0';
    }
}

/* ******************************************************************************************************************************************************** */
/* SWI Wrappers                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

int filebase_get_info(int base_id, LINETASK_FILEBASE_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_RECORD *result;
    _kernel_oserror *err;

    debug_printf("filebase_get_info: base_id=%d\n", base_id);

    if (base_id <= 0 || record_out == NULL)
    {
        debug_printf("filebase_get_info: invalid params, returning 0\n");
        return 0;
    }

    regs.r[0] = FILEBASE_CMD_INFO;
    regs.r[1] = base_id;

    err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
    if (err != NULL)
    {
        debug_printf("filebase_get_info: SWI error: %s\n", err->errmess);
        return 0;
    }

    debug_printf("filebase_get_info: SWI returned R0=%d\n", regs.r[0]);

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        debug_printf("filebase_get_info: not found (R0=%d)\n", regs.r[0]);
        return 0;
    }

    /* Copy from module's cache to our buffer */
    result = (LINETASK_FILEBASE_RECORD *)regs.r[0];
    debug_printf("filebase_get_info: found record name='%s' id=%d\n", result->name, result->id);
    memcpy(record_out, result, sizeof(LINETASK_FILEBASE_RECORD));

    return 1;
}

int filebase_get_area_info(int base_id, int area_id, LINETASK_FILEBASE_AREA_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_AREA_RECORD *result;

    if (base_id <= 0 || area_id <= 0 || record_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILEBASE_CMD_AREA_INFO;
    regs.r[1] = base_id;
    regs.r[2] = area_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    result = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];
    memcpy(record_out, result, sizeof(LINETASK_FILEBASE_AREA_RECORD));

    return 1;
}

int filebase_download_block(int base_id, int file_id, void *buffer, long offset, int length)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || file_id <= 0 || buffer == NULL || length <= 0)
    {
        return -1;
    }

    regs.r[0] = FILEBASE_CMD_DOWNLOAD_BLOCK;
    regs.r[1] = base_id;
    regs.r[2] = file_id;
    regs.r[3] = (int)buffer;
    regs.r[4] = offset;
    regs.r[5] = length;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns bytes read or -1 on error */
}

/* ******************************************************************************************************************************************************** */
/* Access Control                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/*
 * Check if user has access to a resource.
 * Returns 1 if access granted, 0 if denied.
 *
 * Access is granted if:
 * - user_level >= required_level, AND
 * - All required_keys are present in user_keys (or required_keys is empty)
 */
int filebase_check_access(int required_level, const char *required_keys,
                          int user_level, const char *user_keys)
{
    /* Check access level */
    if (user_level < required_level)
    {
        return 0;
    }

    /* Check keys - each character in required_keys must be in user_keys */
    if (required_keys != NULL && required_keys[0] != '\0')
    {
        const char *rk;

        if (user_keys == NULL || user_keys[0] == '\0')
        {
            /* User has no keys but keys are required */
            return 0;
        }

        for (rk = required_keys; *rk != '\0'; rk++)
        {
            if (*rk == ' ' || *rk == ',')
            {
                continue; /* Skip separators */
            }

            if (strchr(user_keys, *rk) == NULL)
            {
                return 0; /* Required key not found */
            }
        }
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Formatting Helpers                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void filebase_format_size(long bytes, char *buffer, int buffer_size)
{
    if (buffer == NULL || buffer_size <= 0)
    {
        return;
    }

    if (bytes < 1024)
    {
        snprintf(buffer, buffer_size, "%ld B", bytes);
    }
    else if (bytes < 1024L * 1024L)
    {
        snprintf(buffer, buffer_size, "%ld KB", bytes / 1024L);
    }
    else if (bytes < 1024L * 1024L * 1024L)
    {
        snprintf(buffer, buffer_size, "%ld.%ld MB", 
                 bytes / (1024L * 1024L),
                 (bytes % (1024L * 1024L)) * 10 / (1024L * 1024L));
    }
    else
    {
        snprintf(buffer, buffer_size, "%ld.%ld GB",
                 bytes / (1024L * 1024L * 1024L),
                 (bytes % (1024L * 1024L * 1024L)) * 10 / (1024L * 1024L * 1024L));
    }
}

void filebase_format_date(long timestamp, char *buffer, int buffer_size)
{
    time_t t;
    struct tm *tm_info;

    if (buffer == NULL || buffer_size <= 0)
    {
        return;
    }

    if (timestamp == 0)
    {
        snprintf(buffer, buffer_size, "Unknown");
        return;
    }

    t = (time_t)timestamp;
    tm_info = localtime(&t);

    if (tm_info != NULL)
    {
        snprintf(buffer, buffer_size, "%04d-%02d-%02d",
                 tm_info->tm_year + 1900,
                 tm_info->tm_mon + 1,
                 tm_info->tm_mday);
    }
    else
    {
        snprintf(buffer, buffer_size, "Invalid");
    }
}

/* ******************************************************************************************************************************************************** */
/* Listing Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

/*
 * Enumerate filebases via SWI.
 */
int filebase_list_bases(filebase_session *session, 
                        void (*output)(void *ctx, const char *text), 
                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_RECORD *record;
    char line[256];
    int count = 0;          /* entries stored for display */
    int total_count = 0;    /* total entries enumerated */
    int index = 0;
    /* Collect entries for side-by-side (two-column) rendering */
    #define MAX_FILEBASE_ENTRIES 256
    struct base_entry
    {
        int id;
        char name[64];
        char access[16];
    } entries[MAX_FILEBASE_ENTRIES];

    if (output == NULL)
    {
        return 0;
    }

    debug_printf("filebase_list_bases: enumerating via SWI\n");

    while (1)
    {
        _kernel_oserror *err;

        regs.r[0] = FILEBASE_CMD_ENUMERATE_BASES;
        regs.r[1] = index;

        debug_printf("filebase_list_bases: calling SWI 0x%X cmd=%d index=%d\n", 
                     SWI_FILER_FILEBASE, FILEBASE_CMD_ENUMERATE_BASES, index);

        err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
        if (err != NULL)
        {
            debug_printf("filebase_list_bases: SWI error: %s\n", err->errmess);
            break;
        }

        debug_printf("filebase_list_bases: SWI returned R0=%d\n", regs.r[0]);

        if (regs.r[0] == -1)
        {
            debug_printf("filebase_list_bases: end of list at index %d\n", index);
            break;
        }

        record = (LINETASK_FILEBASE_RECORD *)regs.r[0];
        if (record == NULL)
        {
            debug_printf("filebase_list_bases: null record pointer\n");
            break;
        }

        debug_printf("filebase_list_bases: got record id=%d name='%s'\n", record->id, record->name);

        /* Check user access */
        if (session != NULL)
        {
            debug_printf("filebase_list_bases: checking access - fb_level=%d fb_keys='%s' user_level=%d user_keys='%s'\n",
                         record->accesslevel, record->keys, session->user_accesslevel, session->user_keys);
            if (!filebase_check_access(record->accesslevel, record->keys,
                                       session->user_accesslevel, session->user_keys))
            {
                debug_printf("filebase_list_bases: access denied for id=%d\n", record->id);
                index++;
                continue; /* Skip inaccessible filebases */
            }
        }

        if (count < MAX_FILEBASE_ENTRIES)
        {
            entries[count].id = record->id;
            snprintf(entries[count].access, sizeof(entries[count].access), "%d", record->accesslevel);
            strncpy(entries[count].name, record->name, sizeof(entries[count].name) - 1);
            entries[count].name[sizeof(entries[count].name) - 1] = '\0';
            count++;
        }
        total_count++;
        index++;
    }

    if (total_count == 0)
    {
        output(ctx, "[No filebases available]\r\n");
    }
    else
    {
        int i = 0;
        output(ctx, "\r\n");
        output(ctx, "\033[1;37m #   Name                         Acc     #   Name                         Acc\033[0m\r\n");
        output(ctx, "\033[1;30m---- --------------------------- ------ ---- --------------------------- ------\033[0m\r\n");

        while (i < count)
        {
            int has_right = (i + 1 < count);
            if (has_right)
            {
                snprintf(line, sizeof(line),
                         "\033[1;33m%3d\033[0m %-27.27s %6.6s   \033[1;33m%3d\033[0m %-27.27s %6.6s\r\n",
                         entries[i].id, entries[i].name, entries[i].access,
                         entries[i + 1].id, entries[i + 1].name, entries[i + 1].access);
                i += 2;
            }
            else
            {
                snprintf(line, sizeof(line),
                         "\033[1;33m%3d\033[0m %-27.27s %6.6s\r\n",
                         entries[i].id, entries[i].name, entries[i].access);
                i++;
            }
            output(ctx, line);
        }

        snprintf(line, sizeof(line), "\r\n\033[1;30m%d filebase(s) listed.\033[0m\r\n", total_count);
        output(ctx, line);
    }

    return total_count;
}

int filebase_list_areas(filebase_session *session,
                        void (*output)(void *ctx, const char *text),
                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_AREA_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    char line[256];
    int count = 0;          /* entries stored for display */
    int total_count = 0;    /* total entries enumerated */
    int index = 0;
    /* Collect entries to render side-by-side */
    #define MAX_FB_AREA_ENTRIES 256
    struct area_entry
    {
        int id;
        char name[64];
        char access[16];
    } entries[MAX_FB_AREA_ENTRIES];

    if (output == NULL || session == NULL)
    {
        return 0;
    }

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected. Use FILEBASE SELECT <id> first.]\r\n");
        return 0;
    }

    /* Get the filebase info for display */
    if (!filebase_get_info(session->current_filebase, &base_record))
    {
        output(ctx, "\r\n[Invalid filebase selected.]\r\n");
        return 0;
    }

    /* Add "root" area option */
    entries[count].id = 0;
    strncpy(entries[count].name, "[Root - All Files]", sizeof(entries[count].name) - 1);
    entries[count].name[sizeof(entries[count].name) - 1] = '\0';
    strncpy(entries[count].access, "0", sizeof(entries[count].access) - 1);
    entries[count].access[sizeof(entries[count].access) - 1] = '\0';
    count++;
    total_count++;

    /* Enumerate areas via SWI */
    while (1)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_filebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record_ptr = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];

        /* Check user access */
        if (!filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                   session->user_accesslevel, session->user_keys))
        {
            index++;
            continue;
        }

        if (count < MAX_FB_AREA_ENTRIES)
        {
            entries[count].id = record_ptr->id;
            snprintf(entries[count].access, sizeof(entries[count].access), "%d", record_ptr->accesslevel);
            strncpy(entries[count].name, record_ptr->name, sizeof(entries[count].name) - 1);
            entries[count].name[sizeof(entries[count].name) - 1] = '\0';
            count++;
        }
        total_count++;
        index++;
    }

    snprintf(line, sizeof(line), "\r\n\033[1;36mAreas in: %s\033[0m\r\n", base_record.name);
    output(ctx, line);
    output(ctx, "\033[1;37m #   Name                         Acc     #   Name                         Acc\033[0m\r\n");
    output(ctx, "\033[1;30m---- --------------------------- ------ ---- --------------------------- ------\033[0m\r\n");

    {
        int i = 0;
        while (i < count)
        {
            int has_right = (i + 1 < count);
            if (has_right)
            {
                snprintf(line, sizeof(line),
                         "\033[1;33m%3d\033[0m %-27.27s %6.6s   \033[1;33m%3d\033[0m %-27.27s %6.6s\r\n",
                         entries[i].id, entries[i].name, entries[i].access,
                         entries[i + 1].id, entries[i + 1].name, entries[i + 1].access);
                i += 2;
            }
            else
            {
                snprintf(line, sizeof(line),
                         "\033[1;33m%3d\033[0m %-27.27s %6.6s\r\n",
                         entries[i].id, entries[i].name, entries[i].access);
                i++;
            }
            output(ctx, line);
        }
    }

    snprintf(line, sizeof(line), "\r\n\033[1;30m%d area(s) listed.\033[0m\r\n", total_count);
    output(ctx, line);

    return total_count;
}

int filebase_list_files(filebase_session *session,
                        void (*output)(void *ctx, const char *text),
                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    char line[256];
    char size_str[32];
    char date_str[32];
    int count = 0;
    int index = 0;

    if (output == NULL || session == NULL)
    {
        return 0;
    }

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected. Use FILEBASE SELECT <id> first.]\r\n");
        return 0;
    }

    /* Get the filebase info for display */
    if (!filebase_get_info(session->current_filebase, &base_record))
    {
        output(ctx, "\r\n[Invalid filebase selected.]\r\n");
        return 0;
    }

    if (session->current_area > 0)
    {
        LINETASK_FILEBASE_AREA_RECORD area_record;
        if (filebase_get_area_info(session->current_filebase, session->current_area, &area_record))
        {
            snprintf(line, sizeof(line), "\r\n\033[1;36mFiles in: %s > %s\033[0m\r\n", 
                     base_record.name, area_record.name);
        }
        else
        {
            snprintf(line, sizeof(line), "\r\n\033[1;36mFiles in: %s\033[0m\r\n", base_record.name);
        }
    }
    else
    {
        snprintf(line, sizeof(line), "\r\n\033[1;36mFiles in: %s\033[0m\r\n", base_record.name);
    }
    output(ctx, line);

    output(ctx, "\033[1;37m  ID  Name                           Size       Date       DLs\033[0m\r\n");
    output(ctx, "\033[1;30m----- ------------------------------ ---------- ---------- ---\033[0m\r\n");

    /* Enumerate files via SWI - Filer handles area filtering and skips deleted */
    while (1)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        /* Check user access */
        if (!filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                   session->user_accesslevel, session->user_keys))
        {
            index++;
            continue;
        }

        filebase_format_size(record_ptr->filesize, size_str, sizeof(size_str));
        filebase_format_date(record_ptr->uploaddate, date_str, sizeof(date_str));

        snprintf(line, sizeof(line), "\033[1;33m%5d\033[0m %-30.30s %10s %10s %3d\r\n",
                 record_ptr->id, record_ptr->name, size_str, date_str, record_ptr->downloads);
        output(ctx, line);
        count++;
        index++;
    }

    if (count == 0)
    {
        output(ctx, "[No files available]\r\n");
    }
    else
    {
        snprintf(line, sizeof(line), "\r\n\033[1;30m%d file(s) listed.\033[0m\r\n", count);
        output(ctx, line);
    }

    return count;
}

int filebase_show_file_info(filebase_session *session,
                            int file_id,
                            void (*output)(void *ctx, const char *text),
                            void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    char line[256];
    char size_str[32];
    char date_str[32];

    if (output == NULL || session == NULL || file_id <= 0)
    {
        return 0;
    }

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected.]\r\n");
        return 0;
    }

    /* Get filebase info */
    if (!filebase_get_info(session->current_filebase, &base_record))
    {
        output(ctx, "\r\n[Invalid filebase.]\r\n");
        return 0;
    }

    /* Get file record via SWI */
    regs.r[0] = FILEBASE_CMD_FILE_INFO;
    regs.r[1] = session->current_filebase;
    regs.r[2] = file_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        output(ctx, "\r\n[File database error.]\r\n");
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        output(ctx, "\r\n[File not found.]\r\n");
        return 0;
    }

    record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

    /* Check if deleted */
    if (record_ptr->deleted)
    {
        output(ctx, "\r\n[File not found.]\r\n");
        return 0;
    }

    /* Check access */
    if (!filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                               session->user_accesslevel, session->user_keys))
    {
        output(ctx, "\r\n[Access denied.]\r\n");
        return 0;
    }

    /* Display file information */
    filebase_format_size(record_ptr->filesize, size_str, sizeof(size_str));
    filebase_format_date(record_ptr->uploaddate, date_str, sizeof(date_str));

    output(ctx, "\r\n\033[1;36m=== File Information ===\033[0m\r\n\r\n");

    snprintf(line, sizeof(line), "\033[1;37mFile ID:\033[0m      %d\r\n", record_ptr->id);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mFilename:\033[0m     %s\r\n", record_ptr->name);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mSize:\033[0m         %s (%ld bytes)\r\n", size_str, record_ptr->filesize);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mUploaded:\033[0m     %s\r\n", date_str);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mDownloads:\033[0m    %d\r\n", record_ptr->downloads);
    output(ctx, line);

    if (record_ptr->description[0] != '\0')
    {
        output(ctx, "\r\n\033[1;37mDescription:\033[0m\r\n");
        snprintf(line, sizeof(line), "  %s\r\n", record_ptr->description);
        output(ctx, line);
    }

    output(ctx, "\r\n");

    return 1;
}

int filebase_get_file_size(int base_id, int file_id, long *size_out)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;

    if (base_id <= 0 || file_id <= 0 || size_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILEBASE_CMD_FILE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = file_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

    if (record_ptr->deleted)
    {
        return 0;
    }

    *size_out = record_ptr->filesize;
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Upload Operations                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

int filebase_begin_upload(int base_id, int area_id, const char *filename, 
                          const char *description, int uploaded_by,
                          int accesslevel, const char *keys)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD record;

    if (base_id <= 0 || filename == NULL || filename[0] == '\0')
    {
        return -1;
    }

    /* Prepare file record */
    memset(&record, 0, sizeof(record));
    record.filebaseid = base_id;
    record.filebaseareaid = area_id;
    record.accesslevel = accesslevel;
    record.uploadedby = uploaded_by;
    record.deleted = 0;
    record.filesize = 0;
    record.downloads = 0;

    strncpy(record.name, filename, sizeof(record.name) - 1);
    record.name[sizeof(record.name) - 1] = '\0';

    if (description != NULL)
    {
        strncpy(record.description, description, sizeof(record.description) - 1);
        record.description[sizeof(record.description) - 1] = '\0';
    }

    if (keys != NULL)
    {
        strncpy(record.keys, keys, sizeof(record.keys) - 1);
        record.keys[sizeof(record.keys) - 1] = '\0';
    }

    /* Call Filer SWI to begin upload */
    regs.r[0] = FILEBASE_CMD_BEGIN_UPLOAD;
    regs.r[1] = base_id;
    regs.r[2] = (int)&record;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns file ID or -1 on error */
}

int filebase_upload_block(int base_id, int file_id, const void *data, int length)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || file_id <= 0 || data == NULL || length <= 0)
    {
        return -1;
    }

    regs.r[0] = FILEBASE_CMD_UPLOAD_BLOCK;
    regs.r[1] = base_id;
    regs.r[2] = file_id;
    regs.r[3] = (int)data;
    regs.r[4] = length;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns bytes written or -1 on error */
}

int filebase_get_temp_upload_path(int base_id, int line, char *path, int path_size)
{
    if (path == NULL || path_size <= 0)
    {
        return 0;
    }

    /* Use Converse temp directory for uploads in progress */
    snprintf(path, path_size, "<Converse$Dir>.Temp.Upload_%d_%d", base_id, line);
    return 1;
}

int filebase_register_upload(int base_id, int area_id, const char *temp_path,
                             const char *filename, const char *description,
                             int uploaded_by, int accesslevel, const char *keys)
{
    _kernel_swi_regs regs;
    int file_id;
    FILE *temp_file;
    FILE *dest_file;
    long file_size;
    char buffer[1024];
    size_t bytes_read;
    LINETASK_FILE_RECORD record;

    if (base_id <= 0 || temp_path == NULL || filename == NULL)
    {
        return -1;
    }

    /* Get temp file size */
    temp_file = fopen(temp_path, "rb");
    if (temp_file == NULL)
    {
        return -1;
    }
    fseek(temp_file, 0, SEEK_END);
    file_size = ftell(temp_file);
    fseek(temp_file, 0, SEEK_SET);

    if (file_size <= 0)
    {
        fclose(temp_file);
        return -1;
    }

    /* Begin the upload to get a file ID */
    file_id = filebase_begin_upload(base_id, area_id, filename, description,
                                     uploaded_by, accesslevel, keys);
    if (file_id <= 0)
    {
        fclose(temp_file);
        return -1;
    }

    /* Copy temp file to filebase using upload block SWI */
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), temp_file)) > 0)
    {
        if (filebase_upload_block(base_id, file_id, buffer, (int)bytes_read) < 0)
        {
            fclose(temp_file);
            /* TODO: Delete the partial file record */
            return -1;
        }
    }

    fclose(temp_file);

    /* Remove temp file */
    remove(temp_path);

    return file_id;
}
