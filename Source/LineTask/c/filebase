/* ******************************************************************************************************************************************************** */
/* LineTask Filebase Support                                                                                                                                */
/*                                                                                                                                                          */
/* Provides filebase browsing and file transfer capabilities via the Filer module SWIs.                                                                     */
/* ******************************************************************************************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "filebase.h"
#include "debug.h"

/* ******************************************************************************************************************************************************** */
/* Session Management                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void filebase_session_init(filebase_session *session)
{
    if (session == NULL)
    {
        return;
    }

    memset(session, 0, sizeof(filebase_session));
    session->current_filebase = 0;
    session->current_area = 0;
    session->user_accesslevel = 0;
    session->user_keys[0] = '\0';
}

void filebase_session_reset(filebase_session *session)
{
    if (session == NULL)
    {
        return;
    }

    session->current_filebase = 0;
    session->current_area = 0;
}

void filebase_session_set_access(filebase_session *session, int accesslevel, const char *keys)
{
    if (session == NULL)
    {
        return;
    }

    session->user_accesslevel = accesslevel;

    if (keys != NULL)
    {
        strncpy(session->user_keys, keys, sizeof(session->user_keys) - 1);
        session->user_keys[sizeof(session->user_keys) - 1] = '\0';
    }
    else
    {
        session->user_keys[0] = '\0';
    }
}

/* ******************************************************************************************************************************************************** */
/* SWI Wrappers                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

int filebase_get_info(int base_id, LINETASK_FILEBASE_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_RECORD *result;
    _kernel_oserror *err;

    debug_printf("filebase_get_info: base_id=%d\n", base_id);

    if (base_id <= 0 || record_out == NULL)
    {
        debug_printf("filebase_get_info: invalid params, returning 0\n");
        return 0;
    }

    regs.r[0] = FILEBASE_CMD_INFO;
    regs.r[1] = base_id;

    err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
    if (err != NULL)
    {
        debug_printf("filebase_get_info: SWI error: %s\n", err->errmess);
        return 0;
    }

    debug_printf("filebase_get_info: SWI returned R0=%d\n", regs.r[0]);

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        debug_printf("filebase_get_info: not found (R0=%d)\n", regs.r[0]);
        return 0;
    }

    /* Copy from module's cache to our buffer */
    result = (LINETASK_FILEBASE_RECORD *)regs.r[0];
    debug_printf("filebase_get_info: found record name='%s' id=%d\n", result->name, result->id);
    memcpy(record_out, result, sizeof(LINETASK_FILEBASE_RECORD));

    return 1;
}

int filebase_get_area_info(int base_id, int area_id, LINETASK_FILEBASE_AREA_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_AREA_RECORD *result;

    if (base_id <= 0 || area_id <= 0 || record_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILEBASE_CMD_AREA_INFO;
    regs.r[1] = base_id;
    regs.r[2] = area_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    result = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];
    memcpy(record_out, result, sizeof(LINETASK_FILEBASE_AREA_RECORD));

    return 1;
}

int filebase_download_block(int base_id, int file_id, void *buffer, long offset, int length)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || file_id <= 0 || buffer == NULL || length <= 0)
    {
        return -1;
    }

    regs.r[0] = FILEBASE_CMD_DOWNLOAD_BLOCK;
    regs.r[1] = base_id;
    regs.r[2] = file_id;
    regs.r[3] = (int)buffer;
    regs.r[4] = offset;
    regs.r[5] = length;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns bytes read or -1 on error */
}

/* ******************************************************************************************************************************************************** */
/* Access Control                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/*
 * Check if user has access to a resource.
 * Returns 1 if access granted, 0 if denied.
 *
 * Access is granted if:
 * - user_level >= required_level, AND
 * - All required_keys are present in user_keys (or required_keys is empty)
 */
int filebase_check_access(int required_level, const char *required_keys,
                          int user_level, const char *user_keys)
{
    /* Check access level */
    if (user_level < required_level)
    {
        return 0;
    }

    /* Check keys - each character in required_keys must be in user_keys */
    if (required_keys != NULL && required_keys[0] != '\0')
    {
        const char *rk;

        if (user_keys == NULL || user_keys[0] == '\0')
        {
            /* User has no keys but keys are required */
            return 0;
        }

        for (rk = required_keys; *rk != '\0'; rk++)
        {
            if (*rk == ' ' || *rk == ',')
            {
                continue; /* Skip separators */
            }

            if (strchr(user_keys, *rk) == NULL)
            {
                return 0; /* Required key not found */
            }
        }
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Formatting Helpers                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void filebase_format_size(long bytes, char *buffer, int buffer_size)
{
    if (buffer == NULL || buffer_size <= 0)
    {
        return;
    }

    if (bytes < 1024)
    {
        snprintf(buffer, buffer_size, "%ld B", bytes);
    }
    else if (bytes < 1024L * 1024L)
    {
        snprintf(buffer, buffer_size, "%ld KB", bytes / 1024L);
    }
    else if (bytes < 1024L * 1024L * 1024L)
    {
        snprintf(buffer, buffer_size, "%ld.%ld MB", 
                 bytes / (1024L * 1024L),
                 (bytes % (1024L * 1024L)) * 10 / (1024L * 1024L));
    }
    else
    {
        snprintf(buffer, buffer_size, "%ld.%ld GB",
                 bytes / (1024L * 1024L * 1024L),
                 (bytes % (1024L * 1024L * 1024L)) * 10 / (1024L * 1024L * 1024L));
    }
}

void filebase_format_date(long timestamp, char *buffer, int buffer_size)
{
    time_t t;
    struct tm *tm_info;

    if (buffer == NULL || buffer_size <= 0)
    {
        return;
    }

    if (timestamp == 0)
    {
        snprintf(buffer, buffer_size, "Unknown");
        return;
    }

    t = (time_t)timestamp;
    tm_info = localtime(&t);

    if (tm_info != NULL)
    {
        snprintf(buffer, buffer_size, "%04d-%02d-%02d",
                 tm_info->tm_year + 1900,
                 tm_info->tm_mon + 1,
                 tm_info->tm_mday);
    }
    else
    {
        snprintf(buffer, buffer_size, "Invalid");
    }
}

/* ******************************************************************************************************************************************************** */
/* Listing Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

/*
 * Enumerate filebases via SWI.
 */
int filebase_list_bases(filebase_session *session, 
                        void (*output)(void *ctx, const char *text), 
                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_RECORD *record;
    char line[256];
    int count = 0;          /* entries stored for display */
    int total_count = 0;    /* total entries enumerated */
    int index = 0;
    /* Collect entries for side-by-side (two-column) rendering */
    #define MAX_FILEBASE_ENTRIES 64
    struct base_entry
    {
        int id;
        char name[64];
        char type[16];
    } entries[MAX_FILEBASE_ENTRIES];

    if (output == NULL)
    {
        return 0;
    }

    while (1)
    {
        _kernel_oserror *err;

        regs.r[0] = FILEBASE_CMD_ENUMERATE_BASES;
        regs.r[1] = index;

        err = _kernel_swi(SWI_FILER_FILEBASE, &regs, &regs);
        if (err != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record = (LINETASK_FILEBASE_RECORD *)regs.r[0];
        if (record == NULL)
        {
            break;
        }

        /* Check user access */
        if (session != NULL)
        {
            if (!filebase_check_access(record->accesslevel, record->keys,
                                       session->user_accesslevel, session->user_keys))
            {
                index++;
                continue; /* Skip inaccessible filebases */
            }
        }

        {
            const char *type_str;
            char *p;

            /* Determine type string based on filebase type */
            switch (record->type)
            {
                case 0:  type_str = "Normal"; break;
                case 1:  type_str = "User Dir"; break;
                default: type_str = "Other"; break;
            }

            if (count < MAX_FILEBASE_ENTRIES)
            {
                entries[count].id = record->id;
                strncpy(entries[count].name, record->name, sizeof(entries[count].name) - 1);
                entries[count].name[sizeof(entries[count].name) - 1] = '\0';
                /* Strip any control characters from name */
                for (p = entries[count].name; *p != '\0'; p++)
                {
                    if (*p < 32) *p = ' ';
                }
                strncpy(entries[count].type, type_str, sizeof(entries[count].type) - 1);
                entries[count].type[sizeof(entries[count].type) - 1] = '\0';
                count++;
            }
        }
        total_count++;
        index++;
    }

    if (total_count == 0)
    {
        output(ctx, "[No filebases available]\r\n");
    }
    else
    {
        int i = 0;
        /* Blue bar header with white text - exactly 80 chars */
        output(ctx, "\033[1;37;44m Available Filebases                                                            \033[0m\r\n");
        output(ctx, "\r\n");
        /* Yellow column headers - centered (8 space indent) */
        output(ctx, "        \033[1;33m#   Name                 Type    #   Name                 Type\033[0m\r\n");

        while (i < count)
        {
            int has_right = (i + 1 < count);
            if (has_right)
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type,
                         entries[i + 1].id, entries[i + 1].name, entries[i + 1].type);
                i += 2;
            }
            else
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type);
                i++;
            }
            output(ctx, line);
        }
    }

    return total_count;
}

int filebase_list_areas(filebase_session *session,
                        void (*output)(void *ctx, const char *text),
                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_AREA_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    char line[256];
    int count = 0;          /* entries stored for display */
    int total_count = 0;    /* total entries enumerated */
    int index = 0;
    /* Collect entries to render side-by-side */
    #define MAX_FB_AREA_ENTRIES 64
    struct area_entry
    {
        int id;
        char name[64];
        char type[16];
    } entries[MAX_FB_AREA_ENTRIES];

    if (output == NULL || session == NULL)
    {
        return 0;
    }

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected. Use FILEBASE SELECT <id> first.]\r\n");
        return 0;
    }

    /* Get the filebase info for display */
    if (!filebase_get_info(session->current_filebase, &base_record))
    {
        output(ctx, "\r\n[Invalid filebase selected.]\r\n");
        return 0;
    }

    /* Add "root" area option */
    entries[count].id = 0;
    strncpy(entries[count].name, "[All Files]", sizeof(entries[count].name) - 1);
    entries[count].name[sizeof(entries[count].name) - 1] = '\0';
    strncpy(entries[count].type, "Root", sizeof(entries[count].type) - 1);
    entries[count].type[sizeof(entries[count].type) - 1] = '\0';
    count++;
    total_count++;

    /* Enumerate areas via SWI */
    while (1)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_filebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record_ptr = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];

        /* Check user access */
        if (!filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                   session->user_accesslevel, session->user_keys))
        {
            index++;
            continue;
        }

        {
            char *p;
            if (count < MAX_FB_AREA_ENTRIES)
            {
                entries[count].id = record_ptr->id;
                strncpy(entries[count].name, record_ptr->name, sizeof(entries[count].name) - 1);
                entries[count].name[sizeof(entries[count].name) - 1] = '\0';
                /* Strip any control characters from name */
                for (p = entries[count].name; *p != '\0'; p++)
                {
                    if (*p < 32) *p = ' ';
                }
                strncpy(entries[count].type, "Area", sizeof(entries[count].type) - 1);
                entries[count].type[sizeof(entries[count].type) - 1] = '\0';
                count++;
            }
        }
        total_count++;
        index++;
    }

    /* Blue bar header with white text - exactly 80 chars */
    snprintf(line, sizeof(line), "\033[1;37;44m Areas in: %-69.69s\033[0m\r\n", base_record.name);
    output(ctx, line);
    output(ctx, "\r\n");
    /* Yellow column headers - centered (8 space indent) */
    output(ctx, "        \033[1;33m#   Name                 Type    #   Name                 Type\033[0m\r\n");

    {
        int i = 0;
        while (i < count)
        {
            int has_right = (i + 1 < count);
            if (has_right)
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type,
                         entries[i + 1].id, entries[i + 1].name, entries[i + 1].type);
                i += 2;
            }
            else
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type);
                i++;
            }
            output(ctx, line);
        }
    }

    return total_count;
}

int filebase_list_files(filebase_session *session,
                        void (*output)(void *ctx, const char *text),
                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    char line[256];
    char size_str[32];
    char date_str[32];
    int count = 0;
    int index = 0;

    if (output == NULL || session == NULL)
    {
        return 0;
    }

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected. Use FILEBASE SELECT <id> first.]\r\n");
        return 0;
    }

    /* Get the filebase info for display */
    if (!filebase_get_info(session->current_filebase, &base_record))
    {
        output(ctx, "\r\n[Invalid filebase selected.]\r\n");
        return 0;
    }

    if (session->current_area > 0)
    {
        LINETASK_FILEBASE_AREA_RECORD area_record;
        if (filebase_get_area_info(session->current_filebase, session->current_area, &area_record))
        {
            snprintf(line, sizeof(line), "\r\n\033[1;36mFiles in: %s > %s\033[0m\r\n", 
                     base_record.name, area_record.name);
        }
        else
        {
            snprintf(line, sizeof(line), "\r\n\033[1;36mFiles in: %s\033[0m\r\n", base_record.name);
        }
    }
    else
    {
        snprintf(line, sizeof(line), "\r\n\033[1;36mFiles in: %s\033[0m\r\n", base_record.name);
    }
    output(ctx, line);

    output(ctx, "\033[1;37m  ID  Name                           Size       Date       DLs\033[0m\r\n");
    output(ctx, "\033[1;30m----- ------------------------------ ---------- ---------- ---\033[0m\r\n");

    /* Enumerate files via SWI - Filer handles area filtering and skips deleted */
    while (1)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        /* Check user access */
        if (!filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                   session->user_accesslevel, session->user_keys))
        {
            index++;
            continue;
        }

        filebase_format_size(record_ptr->filesize, size_str, sizeof(size_str));
        filebase_format_date(record_ptr->uploaddate, date_str, sizeof(date_str));

        snprintf(line, sizeof(line), "\033[1;33m%5d\033[0m %-30.30s %10s %10s %3d\r\n",
                 record_ptr->id, record_ptr->name, size_str, date_str, record_ptr->downloads);
        output(ctx, line);
        count++;
        index++;
    }

    if (count == 0)
    {
        output(ctx, "[No files available]\r\n");
    }
    else
    {
        snprintf(line, sizeof(line), "\r\n\033[1;30m%d file(s) listed.\033[0m\r\n", count);
        output(ctx, line);
    }

    return count;
}

int filebase_show_file_info(filebase_session *session,
                            int file_id,
                            void (*output)(void *ctx, const char *text),
                            void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    char line[256];
    char size_str[32];
    char date_str[32];

    if (output == NULL || session == NULL || file_id <= 0)
    {
        return 0;
    }

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected.]\r\n");
        return 0;
    }

    /* Get filebase info */
    if (!filebase_get_info(session->current_filebase, &base_record))
    {
        output(ctx, "\r\n[Invalid filebase.]\r\n");
        return 0;
    }

    /* Get file record via SWI */
    regs.r[0] = FILEBASE_CMD_FILE_INFO;
    regs.r[1] = session->current_filebase;
    regs.r[2] = file_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        output(ctx, "\r\n[File database error.]\r\n");
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        output(ctx, "\r\n[File not found.]\r\n");
        return 0;
    }

    record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

    /* Check if deleted */
    if (record_ptr->deleted)
    {
        output(ctx, "\r\n[File not found.]\r\n");
        return 0;
    }

    /* Check access */
    if (!filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                               session->user_accesslevel, session->user_keys))
    {
        output(ctx, "\r\n[Access denied.]\r\n");
        return 0;
    }

    /* Display file information */
    filebase_format_size(record_ptr->filesize, size_str, sizeof(size_str));
    filebase_format_date(record_ptr->uploaddate, date_str, sizeof(date_str));

    output(ctx, "\r\n\033[1;36m=== File Information ===\033[0m\r\n\r\n");

    snprintf(line, sizeof(line), "\033[1;37mFile ID:\033[0m      %d\r\n", record_ptr->id);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mFilename:\033[0m     %s\r\n", record_ptr->name);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mSize:\033[0m         %s (%ld bytes)\r\n", size_str, record_ptr->filesize);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mUploaded:\033[0m     %s\r\n", date_str);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mDownloads:\033[0m    %d\r\n", record_ptr->downloads);
    output(ctx, line);

    if (record_ptr->description[0] != '\0')
    {
        output(ctx, "\r\n\033[1;37mDescription:\033[0m\r\n");
        snprintf(line, sizeof(line), "  %s\r\n", record_ptr->description);
        output(ctx, line);
    }

    output(ctx, "\r\n");

    return 1;
}

int filebase_get_file_size(int base_id, int file_id, long *size_out)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;

    if (base_id <= 0 || file_id <= 0 || size_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILEBASE_CMD_FILE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = file_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

    if (record_ptr->deleted)
    {
        return 0;
    }

    *size_out = record_ptr->filesize;
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Upload Operations                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

int filebase_begin_upload(int base_id, int area_id, const char *filename, 
                          const char *description, int uploaded_by,
                          int accesslevel, const char *keys)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD record;

    if (base_id <= 0 || filename == NULL || filename[0] == '\0')
    {
        return -1;
    }

    /* Prepare file record */
    memset(&record, 0, sizeof(record));
    record.filebaseid = base_id;
    record.filebaseareaid = area_id;
    record.accesslevel = accesslevel;
    record.uploadedby = uploaded_by;
    record.deleted = 0;
    record.filesize = 0;
    record.downloads = 0;

    strncpy(record.name, filename, sizeof(record.name) - 1);
    record.name[sizeof(record.name) - 1] = '\0';

    if (description != NULL)
    {
        strncpy(record.description, description, sizeof(record.description) - 1);
        record.description[sizeof(record.description) - 1] = '\0';
    }

    if (keys != NULL)
    {
        strncpy(record.keys, keys, sizeof(record.keys) - 1);
        record.keys[sizeof(record.keys) - 1] = '\0';
    }

    /* Call Filer SWI to begin upload */
    regs.r[0] = FILEBASE_CMD_BEGIN_UPLOAD;
    regs.r[1] = base_id;
    regs.r[2] = (int)&record;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns file ID or -1 on error */
}

int filebase_upload_block(int base_id, int file_id, const void *data, int length)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || file_id <= 0 || data == NULL || length <= 0)
    {
        return -1;
    }

    regs.r[0] = FILEBASE_CMD_UPLOAD_BLOCK;
    regs.r[1] = base_id;
    regs.r[2] = file_id;
    regs.r[3] = (int)data;
    regs.r[4] = length;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns bytes written or -1 on error */
}

int filebase_end_upload(int base_id, int file_id)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || file_id <= 0)
    {
        return -1;
    }

    regs.r[0] = FILEBASE_CMD_END_UPLOAD;
    regs.r[1] = base_id;
    regs.r[2] = file_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return 0;
}

int filebase_get_temp_upload_path(int base_id, int line, char *path, int path_size)
{
    if (path == NULL || path_size <= 0)
    {
        return 0;
    }

    /* Use Converse temp directory for uploads in progress */
    snprintf(path, path_size, "<Converse$Dir>.Temp.Upload_%d_%d", base_id, line);
    return 1;
}

int filebase_register_upload(int base_id, int area_id, const char *temp_path,
                             const char *filename, const char *description,
                             int uploaded_by, int accesslevel, const char *keys)
{
    _kernel_swi_regs regs;
    int file_id;
    FILE *temp_file;
    FILE *dest_file;
    long file_size;
    char buffer[1024];
    size_t bytes_read;
    LINETASK_FILE_RECORD record;

    if (base_id <= 0 || temp_path == NULL || filename == NULL)
    {
        return -1;
    }

    /* Get temp file size */
    temp_file = fopen(temp_path, "rb");
    if (temp_file == NULL)
    {
        return -1;
    }
    fseek(temp_file, 0, SEEK_END);
    file_size = ftell(temp_file);
    fseek(temp_file, 0, SEEK_SET);

    if (file_size <= 0)
    {
        fclose(temp_file);
        return -1;
    }

    /* Begin the upload to get a file ID */
    file_id = filebase_begin_upload(base_id, area_id, filename, description,
                                     uploaded_by, accesslevel, keys);
    if (file_id <= 0)
    {
        fclose(temp_file);
        return -1;
    }

    /* Copy temp file to filebase using upload block SWI */
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), temp_file)) > 0)
    {
        if (filebase_upload_block(base_id, file_id, buffer, (int)bytes_read) < 0)
        {
            fclose(temp_file);
            /* TODO: Delete the partial file record */
            return -1;
        }
    }

    fclose(temp_file);

    /* End upload - flush and close cached file handle */
    filebase_end_upload(base_id, file_id);

    /* Remove temp file */
    remove(temp_path);

    return file_id;
}

/* ******************************************************************************************************************************************************** */
/* Continuous File Browser                                                                                                                                  */
/* ******************************************************************************************************************************************************** */

/* Safety limit for enumeration loops to prevent infinite loops on corrupted data */
#define MAX_ENUM_ITERATIONS 100000

/* ============================================================
 * HELPER FUNCTIONS - Sequential Enumeration
 * ============================================================ */

int filebase_count_files(filebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    int count = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        /* Skip deleted files */
        if (!record_ptr->deleted)
        {
            /* Check access */
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                count++;
            }
        }

        index++;
    }

    return count;
}

int filebase_get_first_file_id(filebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        if (!record_ptr->deleted)
        {
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                return record_ptr->id;
            }
        }

        index++;
    }

    return 0;
}

int filebase_get_last_file_id(filebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    int last_id = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        if (!record_ptr->deleted)
        {
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                last_id = record_ptr->id;
            }
        }

        index++;
    }

    return last_id;
}

int filebase_get_next_file_id(filebase_session *session, int current_id)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    int found_current = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        if (!record_ptr->deleted)
        {
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                if (found_current)
                    return record_ptr->id;
                
                if (record_ptr->id == current_id)
                    found_current = 1;
            }
        }

        index++;
    }

    return 0;
}

int filebase_get_prev_file_id(filebase_session *session, int current_id)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    int prev_id = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        if (!record_ptr->deleted)
        {
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                if (record_ptr->id == current_id)
                    return prev_id;
                
                prev_id = record_ptr->id;
            }
        }

        index++;
    }

    return 0;
}

int filebase_get_file_position(filebase_session *session, int file_id)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    int position = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        if (!record_ptr->deleted)
        {
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                position++;
                if (record_ptr->id == file_id)
                    return position;
            }
        }

        index++;
    }

    return 0;
}

int filebase_get_next_area_id(filebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_AREA_RECORD *record_ptr;
    int found_current = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    /* Special case: if current_area is 0 (root), return first area */
    if (session->current_area == 0)
        found_current = 1;

    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_filebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];

        if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                 session->user_accesslevel, session->user_keys))
        {
            if (found_current)
                return record_ptr->id;
            
            if (record_ptr->id == session->current_area)
                found_current = 1;
        }

        index++;
    }

    return 0;
}

int filebase_get_prev_area_id(filebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_FILEBASE_AREA_RECORD *record_ptr;
    int prev_id = 0;
    int index = 0;

    if (session == NULL || session->current_filebase <= 0)
        return 0;

    /* Build list and find previous */
    while (index < MAX_ENUM_ITERATIONS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_filebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];

        if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                 session->user_accesslevel, session->user_keys))
        {
            if (record_ptr->id == session->current_area)
                return prev_id;
            
            prev_id = record_ptr->id;
        }

        index++;
    }

    /* If we're at first area, wrap to root (0) */
    if (session->current_area != 0 && prev_id == 0)
        return 0;

    return 0;
}

/* ============================================================
 * VIEWER CORE FUNCTIONS
 * ============================================================ */

int filebase_viewer_init(filebase_session *session, int file_id)
{
    if (session == NULL)
        return 0;

    memset(&session->viewer, 0, sizeof(session->viewer));
    session->viewer.phase = FILE_VIEW_IDLE;
    session->viewer.file_id = file_id;
    session->viewer.reading_direction = FILE_READER_DIR_FORWARD;

    return 1;
}

int filebase_viewer_close(filebase_session *session)
{
    if (session == NULL)
        return 0;

    /* Restore saved selection if we were switching areas */
    if (session->viewer.saved_filebase > 0 || session->viewer.saved_area > 0)
    {
        session->current_filebase = session->viewer.saved_filebase;
        session->current_area = session->viewer.saved_area;
    }

    memset(&session->viewer, 0, sizeof(session->viewer));
    session->viewer.phase = FILE_VIEW_IDLE;

    return 1;
}

int filebase_viewer_is_active(filebase_session *session)
{
    if (session == NULL)
        return 0;

    return (session->viewer.phase != FILE_VIEW_IDLE);
}

int filebase_enter_browser(filebase_session *session,
                           void (*output)(void *ctx, const char *text),
                           void *ctx)
{
    int start_file_id;

    if (session == NULL || output == NULL)
        return 0;

    if (session->current_filebase <= 0)
    {
        output(ctx, "\r\n[No filebase selected]\r\n");
        return 0;
    }

    /* Count total files */
    session->viewer.total_files = filebase_count_files(session);

    if (session->viewer.total_files == 0)
    {
        output(ctx, "\r\n[No files available in this filebase/area]\r\n");
        return 0;
    }

    /* Start at first file */
    start_file_id = filebase_get_first_file_id(session);

    if (start_file_id <= 0)
    {
        output(ctx, "\r\n[No accessible files found]\r\n");
        return 0;
    }

    /* Initialize viewer state */
    filebase_viewer_init(session, start_file_id);
    session->viewer.file_position = 1;

    /* Show first file */
    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_show_file(filebase_session *session,
                              void (*output)(void *ctx, const char *text),
                              void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    LINETASK_FILEBASE_RECORD base_record;
    LINETASK_FILEBASE_AREA_RECORD area_record;
    char line[256];
    char size_str[32];
    char date_str[32];
    char uploader_name[64];
    const char *months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    struct tm *tm_info;

    if (session == NULL || output == NULL)
        return 0;

    if (session->viewer.file_id <= 0)
        return 0;

    /* Get file record */
    regs.r[0] = FILEBASE_CMD_FILE_INFO;
    regs.r[1] = session->current_filebase;
    regs.r[2] = session->viewer.file_id;

    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
        return 0;

    if (regs.r[0] == 0 || regs.r[0] == -1)
        return 0;

    record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

    /* Get filebase and area names */
    if (!filebase_get_info(session->current_filebase, &base_record))
        return 0;

    /* Format size and date */
    filebase_format_size(record_ptr->filesize, size_str, sizeof(size_str));

    tm_info = localtime(&record_ptr->uploaddate);
    if (tm_info != NULL)
    {
        snprintf(date_str, sizeof(date_str), "%02d %s %02d %02d:%02d:%02d",
                 tm_info->tm_mday,
                 months[tm_info->tm_mon],
                 tm_info->tm_year % 100,
                 tm_info->tm_hour,
                 tm_info->tm_min,
                 tm_info->tm_sec);
    }
    else
    {
        strncpy(date_str, "Unknown", sizeof(date_str) - 1);
    }

    /* Get uploader name */
    if (record_ptr->uploadedby > 0)
    {
        _kernel_swi_regs name_regs;
        name_regs.r[0] = 3; /* USERDB_CMD_SEARCH */
        name_regs.r[1] = record_ptr->uploadedby;
        
        if (_kernel_swi(0x5AA41, &name_regs, &name_regs) == NULL && name_regs.r[0] != 0)
        {
            char *record = (char *)name_regs.r[0];
            char *realname = record + 4 + 32; /* Offset to realname */
            strncpy(uploader_name, realname, sizeof(uploader_name) - 1);
            uploader_name[sizeof(uploader_name) - 1] = '\0';
        }
        else
        {
            snprintf(uploader_name, sizeof(uploader_name), "User #%d", record_ptr->uploadedby);
        }
    }
    else
    {
        strncpy(uploader_name, "System", sizeof(uploader_name) - 1);
    }

    /* Display file header in structured format (matching messagebase style) */
    output(ctx, "\r\n\r\n");

    /* Area line: Show area name if selected, otherwise filebase name */
    if (session->current_area > 0)
    {
        if (filebase_get_area_info(session->current_filebase, session->current_area, &area_record))
        {
            snprintf(line, sizeof(line), "\033[1;36mArea     :\033[0m \033[1;32m%s\033[0m \033[1;33m(%03d)\033[0m\r\n",
                     area_record.name, session->current_area);
        }
        else
        {
            snprintf(line, sizeof(line), "\033[1;36mFilebase :\033[0m \033[1;32m%s\033[0m\r\n",
                     base_record.name);
        }
    }
    else
    {
        snprintf(line, sizeof(line), "\033[1;36mFilebase :\033[0m \033[1;32m%s\033[0m\r\n",
                 base_record.name);
    }
    output(ctx, line);

    /* File line: #ID (Downloaded N times, size) */
    snprintf(line, sizeof(line), "\033[1;36mFile     :\033[0m \033[1;37m#%06d\033[0m (Downloaded %d times, %s)\r\n",
             record_ptr->id, record_ptr->downloads, size_str);
    output(ctx, line);

    /* Date line: DD Mon YY HH:MM:SS */
    snprintf(line, sizeof(line), "\033[1;36mDate     :\033[0m %s\r\n", date_str);
    output(ctx, line);

    /* Uploader line */
    snprintf(line, sizeof(line), "\033[1;36mUploader :\033[0m \033[1;33m%s\033[0m\r\n", uploader_name);
    output(ctx, line);

    /* Filename line */
    snprintf(line, sizeof(line), "\033[1;36mFilename :\033[0m \033[1;37m%s\033[0m\r\n", record_ptr->name);
    output(ctx, line);

    /* Description line */
    snprintf(line, sizeof(line), "\033[1;36mInfo     :\033[0m %s\r\n",
             record_ptr->description[0] ? record_ptr->description : "(No description)");
    output(ctx, line);

    /* Blank line before prompt */
    output(ctx, "\r\n");

    session->viewer.phase = FILE_VIEW_DISPLAY;

    return 1;
}

int filebase_viewer_show_prompt(filebase_session *session,
                                void (*output)(void *ctx, const char *text),
                                void *ctx)
{
    char line[256];
    const char *dir_str;

    if (session == NULL || output == NULL)
        return 0;

    dir_str = (session->viewer.reading_direction == FILE_READER_DIR_BACKWARD) ? "<<" : ">>";

    session->viewer.phase = FILE_VIEW_PROMPT;

    output(ctx, "\r\n");

    /* Show search mode indicator if active */
    if (session->viewer.search_mode)
    {
        snprintf(line, sizeof(line),
                 "\033[1;44;37m SEARCH: Result %d of %d for '%s' \033[0m\r\n",
                 session->viewer.search_result_index + 1,
                 session->viewer.search_result_count,
                 session->viewer.search_term);
        output(ctx, line);
    }

    /* Line 1: Basic navigation */
    snprintf(line, sizeof(line),
             "\033[1;32mRead Files:\033[0m [\033[1;36mCR\033[0m/\033[1;36mSPC\033[0m] Next  "
             "[\033[1;33mF\033[0m]orward  [\033[1;33mB\033[0m]ackward  "
             "[\033[1;33mC\033[0m]urrent  [\033[1;33mD\033[0m]ownload\r\n");
    output(ctx, line);

    /* Line 2: Area navigation */
    snprintf(line, sizeof(line),
             "\033[1;32mDir: %s\033[0m    [\033[1;33mS\033[0m]tart of area  "
             "[\033[1;33mE\033[0m]nd of area\r\n",
             dir_str);
    output(ctx, line);

    /* Line 3: Search and exit */
    if (session->viewer.search_mode)
    {
        snprintf(line, sizeof(line),
                 "           [\033[1;33m+\033[0m] Next area  [\033[1;33m-\033[0m] Previous area  "
                 "[\033[1;33mX\033[0m] Exit search  [\033[1;31mA\033[0m]bort  Select: ");
    }
    else
    {
        snprintf(line, sizeof(line),
                 "           [\033[1;33m+\033[0m] Next area  [\033[1;33m-\033[0m] Previous area  "
                 "[\033[1;33mZ\033[0m] Search  [\033[1;31mA\033[0m]bort  Select: ");
    }
    output(ctx, line);

    return 1;
}

/* ============================================================
 * INPUT HANDLER
 * ============================================================ */

int filebase_viewer_handle_input(filebase_session *session, char input,
                                 void (*output)(void *ctx, const char *text),
                                 void *ctx)
{
    if (session == NULL)
        return FILEVIEWER_ACTION_INVALID;

    switch (input)
    {
        case '\r':
        case '\n':
        case ' ':
        case 'n':
        case 'N':
            /* Next file based on direction */
            if (session->viewer.reading_direction == FILE_READER_DIR_FORWARD)
                return FILEVIEWER_ACTION_NEXT;
            else
                return FILEVIEWER_ACTION_PREV;

        case 'f':
        case 'F':
            /* Set direction forward */
            session->viewer.reading_direction = FILE_READER_DIR_FORWARD;
            output(ctx, "\r\n[Direction: Forward >>]\r\n");
            filebase_viewer_show_prompt(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case 'b':
        case 'B':
            /* Set direction backward */
            session->viewer.reading_direction = FILE_READER_DIR_BACKWARD;
            output(ctx, "\r\n[Direction: Backward <<]\r\n");
            filebase_viewer_show_prompt(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case 'c':
        case 'C':
            /* Re-display current file */
            filebase_viewer_show_current(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case 's':
        case 'S':
            /* Go to start of area */
            filebase_viewer_goto_start(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case 'e':
        case 'E':
            /* Go to end of area */
            filebase_viewer_goto_end(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case 'd':
        case 'D':
            /* Download current file */
            return FILEVIEWER_ACTION_DOWNLOAD;

        case '+':
        case '=':
            /* Next area */
            filebase_viewer_next_area(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case '-':
        case '_':
            /* Previous area */
            filebase_viewer_prev_area(session, output, ctx);
            return FILEVIEWER_ACTION_CONTINUE;

        case 'z':
        case 'Z':
        case '/':
            /* Start search */
            return filebase_viewer_start_search(session, output, ctx);

        case 'x':
        case 'X':
            /* Exit search mode */
            if (session->viewer.search_mode)
            {
                filebase_viewer_exit_search_mode(session, output, ctx);
                return FILEVIEWER_ACTION_CONTINUE;
            }
            return FILEVIEWER_ACTION_INVALID;

        case 'a':
        case 'A':
        case 'q':
        case 'Q':
        case 27: /* ESC */
            /* Quit browser */
            return FILEVIEWER_ACTION_QUIT;

        default:
            /* Invalid input */
            return FILEVIEWER_ACTION_INVALID;
    }
}

/* ============================================================
 * NAVIGATION FUNCTIONS
 * ============================================================ */

int filebase_viewer_goto_next(filebase_session *session,
                              void (*output)(void *ctx, const char *text),
                              void *ctx)
{
    int next_id;

    if (session == NULL || output == NULL)
        return 0;

    /* If in search mode, navigate search results */
    if (session->viewer.search_mode && session->viewer.search_result_count > 0)
    {
        session->viewer.search_result_index++;
        if (session->viewer.search_result_index >= session->viewer.search_result_count)
        {
            output(ctx, "\r\n[End of search results]\r\n");
            session->viewer.search_result_index = session->viewer.search_result_count - 1;
            filebase_viewer_show_prompt(session, output, ctx);
            return 1;
        }
        
        session->viewer.file_id = session->viewer.search_results[session->viewer.search_result_index];
        filebase_viewer_show_file(session, output, ctx);
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    /* Normal navigation */
    next_id = filebase_get_next_file_id(session, session->viewer.file_id);

    if (next_id <= 0)
    {
        output(ctx, "\r\n[No more files in this area]\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->viewer.file_id = next_id;
    session->viewer.file_position++;

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_goto_prev(filebase_session *session,
                              void (*output)(void *ctx, const char *text),
                              void *ctx)
{
    int prev_id;

    if (session == NULL || output == NULL)
        return 0;

    /* If in search mode, navigate search results */
    if (session->viewer.search_mode && session->viewer.search_result_count > 0)
    {
        session->viewer.search_result_index--;
        if (session->viewer.search_result_index < 0)
        {
            output(ctx, "\r\n[Start of search results]\r\n");
            session->viewer.search_result_index = 0;
            filebase_viewer_show_prompt(session, output, ctx);
            return 1;
        }
        
        session->viewer.file_id = session->viewer.search_results[session->viewer.search_result_index];
        filebase_viewer_show_file(session, output, ctx);
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    /* Normal navigation */
    prev_id = filebase_get_prev_file_id(session, session->viewer.file_id);

    if (prev_id <= 0)
    {
        output(ctx, "\r\n[Already at first file]\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->viewer.file_id = prev_id;
    session->viewer.file_position--;

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_goto_start(filebase_session *session,
                               void (*output)(void *ctx, const char *text),
                               void *ctx)
{
    int first_id;

    if (session == NULL || output == NULL)
        return 0;

    first_id = filebase_get_first_file_id(session);

    if (first_id <= 0)
    {
        output(ctx, "\r\n[No files in this area]\r\n");
        return 0;
    }

    session->viewer.file_id = first_id;
    session->viewer.file_position = 1;

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_goto_end(filebase_session *session,
                             void (*output)(void *ctx, const char *text),
                             void *ctx)
{
    int last_id;

    if (session == NULL || output == NULL)
        return 0;

    last_id = filebase_get_last_file_id(session);

    if (last_id <= 0)
    {
        output(ctx, "\r\n[No files in this area]\r\n");
        return 0;
    }

    session->viewer.file_id = last_id;
    session->viewer.file_position = session->viewer.total_files;

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_show_current(filebase_session *session,
                                 void (*output)(void *ctx, const char *text),
                                 void *ctx)
{
    if (session == NULL || output == NULL)
        return 0;

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_next_area(filebase_session *session,
                              void (*output)(void *ctx, const char *text),
                              void *ctx)
{
    int next_area_id;
    int first_file_id;
    LINETASK_FILEBASE_AREA_RECORD area_record;
    char line[128];

    if (session == NULL || output == NULL)
        return 0;

    next_area_id = filebase_get_next_area_id(session);

    if (next_area_id <= 0)
    {
        output(ctx, "\r\n[No more areas]\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    /* Switch to next area */
    session->current_area = next_area_id;

    /* Get area name */
    if (filebase_get_area_info(session->current_filebase, next_area_id, &area_record))
    {
        snprintf(line, sizeof(line), "\r\n[Switched to area: %s]\r\n", area_record.name);
        output(ctx, line);
    }

    /* Find first file in new area */
    first_file_id = filebase_get_first_file_id(session);

    if (first_file_id <= 0)
    {
        output(ctx, "[No files in this area]\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->viewer.file_id = first_file_id;
    session->viewer.file_position = 1;
    session->viewer.total_files = filebase_count_files(session);

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_prev_area(filebase_session *session,
                              void (*output)(void *ctx, const char *text),
                              void *ctx)
{
    int prev_area_id;
    int first_file_id;
    LINETASK_FILEBASE_AREA_RECORD area_record;
    char line[128];

    if (session == NULL || output == NULL)
        return 0;

    prev_area_id = filebase_get_prev_area_id(session);

    if (prev_area_id < 0)
    {
        output(ctx, "\r\n[Already at first area]\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    /* Switch to previous area */
    session->current_area = prev_area_id;

    /* Get area name */
    if (prev_area_id == 0)
    {
        output(ctx, "\r\n[Switched to root (all files)]\r\n");
    }
    else if (filebase_get_area_info(session->current_filebase, prev_area_id, &area_record))
    {
        snprintf(line, sizeof(line), "\r\n[Switched to area: %s]\r\n", area_record.name);
        output(ctx, line);
    }

    /* Find first file in new area */
    first_file_id = filebase_get_first_file_id(session);

    if (first_file_id <= 0)
    {
        output(ctx, "[No files in this area]\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->viewer.file_id = first_file_id;
    session->viewer.file_position = 1;
    session->viewer.total_files = filebase_count_files(session);

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

/* ============================================================
 * SEARCH FUNCTIONS
 * ============================================================ */

/* Case-insensitive substring search */
static int str_contains_ci(const char *haystack, const char *needle)
{
    const char *h, *n;
    char hc, nc;

    if (haystack == NULL || needle == NULL || needle[0] == '\0')
        return 0;

    while (*haystack)
    {
        h = haystack;
        n = needle;

        while (*h && *n)
        {
            hc = (*h >= 'A' && *h <= 'Z') ? (*h + 32) : *h;
            nc = (*n >= 'A' && *n <= 'Z') ? (*n + 32) : *n;

            if (hc != nc)
                break;

            h++;
            n++;
        }

        if (*n == '\0')
            return 1;

        haystack++;
    }

    return 0;
}

int filebase_viewer_start_search(filebase_session *session,
                                 void (*output)(void *ctx, const char *text),
                                 void *ctx)
{
    if (session == NULL || output == NULL)
        return FILEVIEWER_ACTION_INVALID;

    /* Prompt for search term - handled by script engine */
    output(ctx, "\r\n\033[1;36mSearch files (name/description): \033[0m");

    /* Return code to tell script to read search term */
    return FILEVIEWER_ACTION_INVALID;  /* Script will call do_search() */
}

int filebase_viewer_do_search(filebase_session *session,
                              const char *term,
                              void (*output)(void *ctx, const char *text),
                              void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_FILE_RECORD *record_ptr;
    char line[128];
    int index = 0;
    int match_count = 0;

    if (session == NULL || term == NULL || term[0] == '\0')
        return 0;

    /* Store search term */
    strncpy(session->viewer.search_term, term, sizeof(session->viewer.search_term) - 1);
    session->viewer.search_term[sizeof(session->viewer.search_term) - 1] = '\0';

    /* Clear previous results */
    session->viewer.search_result_count = 0;
    session->viewer.search_result_index = 0;

    output(ctx, "\r\n\033[1;33mSearching...\033[0m\r\n");

    /* Search all files in current filebase/area */
    while (index < MAX_ENUM_ITERATIONS && match_count < MAX_FILE_SEARCH_RESULTS)
    {
        regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
        regs.r[1] = session->current_filebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL)
            break;

        if (regs.r[0] == 0 || regs.r[0] == -1)
            break;

        record_ptr = (LINETASK_FILE_RECORD *)regs.r[0];

        /* Check access and not deleted */
        if (!record_ptr->deleted)
        {
            if (filebase_check_access(record_ptr->accesslevel, record_ptr->keys,
                                     session->user_accesslevel, session->user_keys))
            {
                /* Search in name and description */
                if (str_contains_ci(record_ptr->name, term) ||
                    str_contains_ci(record_ptr->description, term))
                {
                    session->viewer.search_results[match_count] = record_ptr->id;
                    match_count++;
                }
            }
        }

        index++;
    }

    session->viewer.search_result_count = match_count;

    if (match_count == 0)
    {
        output(ctx, "\033[1;31m[No files found matching search term]\033[0m\r\n");
        filebase_viewer_show_prompt(session, output, ctx);
        return 0;
    }

    /* Enter search mode and show first result */
    session->viewer.search_mode = 1;
    session->viewer.search_result_index = 0;
    session->viewer.file_id = session->viewer.search_results[0];

    snprintf(line, sizeof(line), "\033[1;32m[Found %d matching files]\033[0m\r\n", match_count);
    output(ctx, line);

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int filebase_viewer_exit_search_mode(filebase_session *session,
                                     void (*output)(void *ctx, const char *text),
                                     void *ctx)
{
    if (session == NULL || output == NULL)
        return 0;

    if (!session->viewer.search_mode)
        return 0;

    /* Exit search mode */
    session->viewer.search_mode = 0;
    session->viewer.search_result_count = 0;
    session->viewer.search_result_index = 0;
    session->viewer.search_term[0] = '\0';

    output(ctx, "\r\n[Exited search mode]\r\n");

    /* Update position in normal list */
    session->viewer.file_position = filebase_get_file_position(session, session->viewer.file_id);

    filebase_viewer_show_file(session, output, ctx);
    filebase_viewer_show_prompt(session, output, ctx);

    return 1;
}
