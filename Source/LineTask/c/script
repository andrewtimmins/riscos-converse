#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "debug.h"
#include "script.h"
#include "filebase.h"

#define SCRIPT_DEFAULT_INSTRUCTION_CAPACITY 32
#define SCRIPT_DEFAULT_LABEL_CAPACITY 16
#define SCRIPT_DEFAULT_VARIABLE_CAPACITY 8
#define SCRIPT_INPUT_BUFFER_CHUNK 64
#define SCRIPT_LITERAL_BUFFER_CHUNK 256
#define SCRIPT_MAX_INSTRUCTIONS_PER_POLL 1000  /* Prevent infinite loops from locking up */
#define SCRIPT_ANSI_DETECT_TIMEOUT_CS 300  /* 3 second timeout in centiseconds */

typedef struct script_buffer
{
    char *data;
    size_t length;
    size_t capacity;
} script_buffer;

typedef int (*script_text_handler)(script_state *state, const char *text, size_t length, int line_number, void *context);
typedef int (*script_command_handler)(script_state *state, const char *command_text, int line_number, void *context);

static void script_clear_program(script_state *state);
static void script_clear_variables(script_state *state);
static int script_load_file(script_state *state, const char *path);
static int script_parse_line(script_state *state, const char *line, int line_number);
static int script_build_instruction(script_state *state, char *line, int line_number, script_instruction *instruction);
static char *script_duplicate_string(const char *source);
static char *script_duplicate_range(const char *source, size_t length);
static int script_append_instruction(script_state *state, script_instruction *instr);
static int script_register_label(script_state *state, const char *name);
static void script_execute_instruction(script_state *state, script_instruction *instruction);
static void script_expand_macros(script_state *state, const char *input, char *buffer, size_t length);
static int script_expand_macros_to_buffer(script_state *state, const char *input, script_buffer *buffer, int translate_newlines);
static int script_emit_macro_replacement(script_state *state, const char *macro_name, script_buffer *buffer);
static void script_translate_escapes(char *text);
static void script_set_error(script_state *state, const char *fmt, ...);
static void script_reset_input(script_state *state);
static void script_write_output(script_state *state, const char *text);
static void script_set_variable_value(script_state *state, const char *name, const char *value);
static const char *script_get_variable_value(const script_state *state, const char *name);
static int script_parse_backtick_string(const char *input, size_t *consumed, char **output);
static char *script_trim(char *text);
static int script_is_empty_or_comment(const char *line);
static void script_free_instruction(script_instruction *instruction);
static void script_free_label(script_label *label);
static void script_free_variable(script_variable *variable);
static clock_t script_calculate_sleep_deadline(unsigned int milliseconds);
static int script_stringcasecmp(const char *lhs, const char *rhs);
static void script_apply_colour_change(script_state *state, const char *fg_text, const char *bg_text, int apply_fg, int apply_bg);
static void script_send_clear_screen(script_state *state);
static void script_move_cursor(script_state *state, const char *row_text, const char *col_text);
static void script_display_file(script_state *state, const char *source);
static void script_buffer_init(script_buffer *buffer);
static void script_buffer_free(script_buffer *buffer);
static void script_buffer_clear(script_buffer *buffer);
static int script_buffer_append_char(script_buffer *buffer, char ch);
static int script_buffer_append_string(script_buffer *buffer, const char *text);
static void script_buffer_trim_trailing_whitespace(script_buffer *buffer);
static int script_buffer_has_embedded_blocks(const char *buffer, size_t length);
static char *script_strip_block_comments(const char *buffer, size_t length);
static int script_parse_plain_lines(script_state *state, const char *buffer);
static int script_append_print_literal(script_state *state, const char *text, size_t length);
static int script_execute_inline_command(script_state *state, const char *command_text, int line_number);
static int script_skip_comment(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name);
static int script_process_embedded_block(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name, script_command_handler command_handler, void *context);
static int script_process_embedded_content(script_state *state, const char *buffer, size_t length, const char *source_name, script_text_handler text_handler, script_command_handler command_handler, void *context);
static int script_handle_embedded_text_as_instruction(script_state *state, const char *text, size_t length, int line_number, void *context);
static int script_handle_embedded_command_as_instruction(script_state *state, const char *command_text, int line_number, void *context);
static int script_handle_embedded_text_as_output(script_state *state, const char *text, size_t length, int line_number, void *context);
static int script_handle_embedded_command_as_output(script_state *state, const char *command_text, int line_number, void *context);

void script_initialise(script_state *state, const script_host *host)
{
    if (state == NULL)
    {
        return;
    }

    memset(state, 0, sizeof(*state));

    if (host != NULL)
    {
        state->host = *host;
    }

    state->instruction_capacity = SCRIPT_DEFAULT_INSTRUCTION_CAPACITY;
    state->instructions = (script_instruction *)calloc(state->instruction_capacity, sizeof(script_instruction));

    state->label_capacity = SCRIPT_DEFAULT_LABEL_CAPACITY;
    state->labels = (script_label *)calloc(state->label_capacity, sizeof(script_label));

    state->variable_capacity = SCRIPT_DEFAULT_VARIABLE_CAPACITY;
    state->variables = (script_variable *)calloc(state->variable_capacity, sizeof(script_variable));

    state->input_capacity = SCRIPT_INPUT_BUFFER_CHUNK;
    state->input_buffer = (char *)malloc(state->input_capacity);
    if (state->input_buffer != NULL)
    {
        state->input_buffer[0] = '\0';
    }

    state->status = SCRIPT_STATUS_IDLE;
}

void script_dispose(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    script_clear_program(state);
    script_clear_variables(state);

    free(state->instructions);
    state->instructions = NULL;
    state->instruction_count = 0;
    state->instruction_capacity = 0;

    {
        size_t i;
        for (i = 0; i < state->label_count; ++i)
        {
            script_free_label(&state->labels[i]);
        }
    }
    free(state->labels);
    state->labels = NULL;
    state->label_count = 0;
    state->label_capacity = 0;

    free(state->input_buffer);
    state->input_buffer = NULL;
    state->input_capacity = 0;
    state->input_length = 0;

    memset(state, 0, sizeof(*state));
}

int script_start(script_state *state, const char *path)
{
    if (state == NULL)
    {
        return 0;
    }

    script_stop(state);

    if (path == NULL)
    {
        script_set_error(state, "No script path specified");
        state->status = SCRIPT_STATUS_ERROR;
        return 0;
    }

    if (!script_load_file(state, path))
    {
        state->status = SCRIPT_STATUS_ERROR;
        return 0;
    }

    state->program_counter = 0;
    state->status = SCRIPT_STATUS_RUNNING;
    script_reset_input(state);
    return 1;
}

void script_stop(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    script_clear_program(state);
    /* NOTE: Do NOT clear variables here - they persist across script transitions
     * Variables are only cleared on session disconnect via script_reset_session
     */
    state->program_counter = 0;
    state->status = SCRIPT_STATUS_IDLE;
    script_reset_input(state);
}

void script_reset_session(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    script_stop(state);
    script_clear_variables(state);
}

void script_process(script_state *state)
{
    int instructions_executed = 0;

    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_SLEEP)
    {
        if ((clock_t)clock() >= state->sleep_deadline)
        {
            state->status = SCRIPT_STATUS_RUNNING;
        }
    }

    /* Check for ANSI detection timeout */
    if (state->status == SCRIPT_STATUS_WAIT_ANSI)
    {
        if ((clock_t)clock() >= state->ansi_deadline)
        {
            /* Timeout - no ANSI response, assume dumb terminal */
            debug_printf("ANSI detect: TIMEOUT - no response received\n");
            script_set_variable_value(state, state->ansi_result_var, "0");
            state->ansi_parse_state = 0;
            state->ansi_response_len = 0;
            state->status = SCRIPT_STATUS_RUNNING;
        }
    }

    while (state->status == SCRIPT_STATUS_RUNNING && state->program_counter < state->instruction_count)
    {
        script_instruction *instruction = &state->instructions[state->program_counter];
        state->program_counter++;
        script_execute_instruction(state, instruction);

        instructions_executed++;
        if (instructions_executed >= SCRIPT_MAX_INSTRUCTIONS_PER_POLL)
        {
            /* Yield to allow other tasks to run - prevents infinite loops from locking system */
            /* Script will continue on next poll */
            return;
        }
    }

    if (state->status == SCRIPT_STATUS_RUNNING && state->program_counter >= state->instruction_count)
    {
        state->status = SCRIPT_STATUS_COMPLETED;
    }
}

int script_handle_user_byte(script_state *state, unsigned char byte)
{
    if (state == NULL)
    {
        return 0;
    }

    if (state->status != SCRIPT_STATUS_WAIT_INPUT_CHAR && 
        state->status != SCRIPT_STATUS_WAIT_INPUT_LINE &&
        state->status != SCRIPT_STATUS_WAIT_LOGON_USERNAME &&
        state->status != SCRIPT_STATUS_WAIT_LOGON_PASSWORD &&
        state->status != SCRIPT_STATUS_WAIT_ANSI &&
        state->status != SCRIPT_STATUS_WAIT_CHAT_REASON &&
        state->status != SCRIPT_STATUS_WAIT_CHAT)
    {
        return 0;
    }

    /* Handle chat reason input */
    if (state->status == SCRIPT_STATUS_WAIT_CHAT_REASON)
    {
        /* Handle backspace */
        if (byte == 8 || byte == 127)
        {
            if (state->input_length > 0)
            {
                state->input_length--;
                state->input_buffer[state->input_length] = '\0';
                if (state->host.write_text != NULL)
                {
                    state->host.write_text(state->host.context, "\b \b");
                }
            }
            return 1;
        }

        /* Ignore LF */
        if (byte == '\n')
        {
            return 1;
        }

        /* CR - end of input */
        if (byte == '\r')
        {
            state->input_buffer[state->input_length] = '\0';
            if (state->host.write_text != NULL)
            {
                state->host.write_text(state->host.context, "\r\n");
            }

            /* Empty reason = cancel */
            if (state->input_length == 0)
            {
                script_write_output(state, "\r\n\033[1;33mChat request cancelled.\033[0m\r\n\r\n");
                state->status = SCRIPT_STATUS_RUNNING;
                script_process(state);
                return 1;
            }

            /* Have a reason - start pager via callback */
            if (state->host.start_chat_pager != NULL)
            {
                state->host.start_chat_pager(state->host.context, state->input_buffer);
            }
            /* Status will be set to WAIT_CHAT by the callback */
            return 1;
        }

        /* Accumulate character */
        if (state->input_length + 1 >= state->input_capacity)
        {
            size_t new_capacity = state->input_capacity + SCRIPT_INPUT_BUFFER_CHUNK;
            char *resized = (char *)realloc(state->input_buffer, new_capacity);
            if (resized == NULL)
            {
                script_set_error(state, "Out of memory expanding input buffer");
                state->status = SCRIPT_STATUS_ERROR;
                return 0;
            }
            state->input_buffer = resized;
            state->input_capacity = new_capacity;
        }

        state->input_buffer[state->input_length++] = (char)byte;
        if (state->host.write_text != NULL)
        {
            char echo[2] = { (char)byte, '\0' };
            state->host.write_text(state->host.context, echo);
        }
        return 1;
    }

    /* Handle ANSI detection response - looking for ESC[<row>;<col>R */
    if (state->status == SCRIPT_STATUS_WAIT_ANSI)
    {
        /* Debug: log each byte we receive during ANSI detection */
        debug_printf("ANSI detect: byte=0x%02X '%c' state=%d\n", 
                     byte, (byte >= 32 && byte < 127) ? byte : '.', state->ansi_parse_state);
        
        /* State machine to parse ANSI CPR response: ESC [ <digits> ; <digits> R */
        switch (state->ansi_parse_state)
        {
            case 0:  /* Waiting for ESC */
                if (byte == 0x1B)  /* ESC */
                {
                    state->ansi_parse_state = 1;
                    state->ansi_response_len = 0;
                }
                /* Ignore any other characters while waiting */
                break;

            case 1:  /* Got ESC, expecting [ */
                if (byte == '[')
                {
                    state->ansi_parse_state = 2;
                }
                else
                {
                    /* Not an ANSI sequence, reset */
                    state->ansi_parse_state = 0;
                }
                break;

            case 2:  /* Got ESC[, reading row digits or waiting for ; or R */
                if (byte >= '0' && byte <= '9')
                {
                    if (state->ansi_response_len < (int)sizeof(state->ansi_response) - 1)
                    {
                        state->ansi_response[state->ansi_response_len++] = (char)byte;
                    }
                }
                else if (byte == ';')
                {
                    state->ansi_parse_state = 3;
                }
                else if (byte == 'R')
                {
                    /* Complete! ESC[R or ESC[<row>R - still counts as ANSI */
                    debug_printf("ANSI detect: SUCCESS (got 'R' in state 2)\n");
                    script_set_variable_value(state, state->ansi_result_var, "1");
                    state->ansi_parse_state = 0;
                    state->ansi_response_len = 0;
                    state->status = SCRIPT_STATUS_RUNNING;
                    script_process(state);
                }
                else
                {
                    /* Unexpected character, reset */
                    state->ansi_parse_state = 0;
                    state->ansi_response_len = 0;
                }
                break;

            case 3:  /* Got semicolon, reading col digits */
                if (byte >= '0' && byte <= '9')
                {
                    if (state->ansi_response_len < (int)sizeof(state->ansi_response) - 1)
                    {
                        state->ansi_response[state->ansi_response_len++] = (char)byte;
                    }
                }
                else if (byte == 'R')
                {
                    /* Complete! ANSI terminal detected */
                    debug_printf("ANSI detect: SUCCESS (got 'R' in state 3)\n");
                    script_set_variable_value(state, state->ansi_result_var, "1");
                    state->ansi_parse_state = 0;
                    state->ansi_response_len = 0;
                    state->status = SCRIPT_STATUS_RUNNING;
                    script_process(state);
                }
                else
                {
                    /* Unexpected character, reset */
                    state->ansi_parse_state = 0;
                    state->ansi_response_len = 0;
                }
                break;
        }
        return 1;  /* Consumed the byte */
    }

    if (state->status == SCRIPT_STATUS_WAIT_INPUT_CHAR)
    {
        if (byte == '\r' || byte == '\n')
        {
            return 1;
        }

        state->input_buffer[0] = (char)byte;
        state->input_buffer[1] = '\0';
        state->input_length = 1;

        if (state->input_echo && state->host.write_text != NULL)
        {
            char echo[4];
            echo[0] = (char)byte;
            echo[1] = '\r';
            echo[2] = '\n';
            echo[3] = '\0';
            state->host.write_text(state->host.context, echo);
        }

        script_set_variable_value(state, state->input_target, state->input_buffer);
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    if (state->status == SCRIPT_STATUS_WAIT_INPUT_LINE)
    {
        /* Ignore LF - we complete on CR */
        if (byte == '\n')
        {
            return 1;
        }

        /* CR triggers end of input */
        if (byte == '\r')
        {
            state->input_buffer[state->input_length] = '\0';
            if (state->input_echo && state->host.write_text != NULL)
            {
                state->host.write_text(state->host.context, "\r\n");
            }
            script_set_variable_value(state, state->input_target, state->input_buffer);
            state->status = SCRIPT_STATUS_RUNNING;
            script_process(state);
            return 1;
        }

        /* Handle backspace (ASCII 8 or 127) */
        if (byte == 8 || byte == 127)
        {
            if (state->input_length > 0)
            {
                state->input_length--;
                state->input_buffer[state->input_length] = '\0';
                if (state->input_echo && state->host.write_text != NULL)
                {
                    state->host.write_text(state->host.context, "\b \b");
                }
            }
            return 1;
        }

        if (state->input_length + 1 >= state->input_capacity)
        {
            size_t new_capacity = state->input_capacity + SCRIPT_INPUT_BUFFER_CHUNK;
            char *resized = (char *)realloc(state->input_buffer, new_capacity);
            if (resized == NULL)
            {
                script_set_error(state, "Out of memory expanding input buffer");
                state->status = SCRIPT_STATUS_ERROR;
                return 0;
            }
            state->input_buffer = resized;
            state->input_capacity = new_capacity;
        }

        state->input_buffer[state->input_length++] = (char)byte;
        if (state->input_echo && state->host.write_text != NULL)
        {
            char echo[2] = { (char)byte, '\0' };
            state->host.write_text(state->host.context, echo);
        }
        return 1;
    }

    /* Handle LOGON username input */
    if (state->status == SCRIPT_STATUS_WAIT_LOGON_USERNAME)
    {
        /* Handle backspace (ASCII 8 or 127) */
        if (byte == 8 || byte == 127)
        {
            if (state->input_length > 0)
            {
                state->input_length--;
                state->input_buffer[state->input_length] = '\0';
                /* Echo backspace-space-backspace to erase character */
                if (state->host.write_text != NULL)
                {
                    state->host.write_text(state->host.context, "\b \b");
                }
            }
            return 1;
        }

        /* Ignore LF if we just processed CR */
        if (byte == '\n')
        {
            return 1;
        }

        /* CR triggers end of input */
        if (byte == '\r')
        {
            state->input_buffer[state->input_length] = '\0';
            if (state->host.write_text != NULL)
            {
                state->host.write_text(state->host.context, "\r\n");
            }

            /* Check if user typed NEW */
            if (script_stringcasecmp(state->input_buffer, "NEW") == 0)
            {
                /* User wants to register - start newuser script */
                if (state->host.start_newuser != NULL)
                {
                    state->host.start_newuser(state->host.context);
                }
                /* Don't set COMPLETED - start_newuser calls script_start which sets the status */
                return 1;
            }

            /* Store the username and prompt for password */
            strncpy(state->logon_username, state->input_buffer, sizeof(state->logon_username) - 1);
            state->logon_username[sizeof(state->logon_username) - 1] = '\0';

            script_write_output(state, "Password: ");
            state->input_echo = 0;  /* No echo for password */
            state->input_length = 0;
            if (state->input_buffer != NULL)
            {
                state->input_buffer[0] = '\0';
            }
            state->status = SCRIPT_STATUS_WAIT_LOGON_PASSWORD;
            return 1;
        }

        /* Accumulate username character */
        if (state->input_length + 1 >= state->input_capacity)
        {
            size_t new_capacity = state->input_capacity + SCRIPT_INPUT_BUFFER_CHUNK;
            char *resized = (char *)realloc(state->input_buffer, new_capacity);
            if (resized == NULL)
            {
                script_set_error(state, "Out of memory expanding input buffer");
                state->status = SCRIPT_STATUS_ERROR;
                return 0;
            }
            state->input_buffer = resized;
            state->input_capacity = new_capacity;
        }

        state->input_buffer[state->input_length++] = (char)byte;
        if (state->host.write_text != NULL)
        {
            char echo[2] = { (char)byte, '\0' };
            state->host.write_text(state->host.context, echo);
        }
        return 1;
    }

    /* Handle LOGON password input */
    if (state->status == SCRIPT_STATUS_WAIT_LOGON_PASSWORD)
    {
        /* Handle backspace (ASCII 8 or 127) */
        if (byte == 8 || byte == 127)
        {
            if (state->input_length > 0)
            {
                state->input_length--;
                state->input_buffer[state->input_length] = '\0';
                /* No echo for password backspace */
            }
            return 1;
        }

        /* Ignore LF if we just processed CR */
        if (byte == '\n')
        {
            return 1;
        }

        /* CR triggers end of input */
        if (byte == '\r')
        {
            int auth_result = 0;
            int authenticated = 0;

            state->input_buffer[state->input_length] = '\0';
            if (state->host.write_text != NULL)
            {
                state->host.write_text(state->host.context, "\r\n");
            }

            /* Attempt authentication */
            if (state->host.authenticate_user != NULL)
            {
                authenticated = state->host.authenticate_user(
                    state->host.context,
                    state->logon_username,
                    state->input_buffer,
                    &auth_result
                );
            }

            if (authenticated)
            {
                /* Success - run postlogon script */
                script_write_output(state, "\r\n\033[1;32mLogin successful!\033[0m\r\n\r\n");
                if (state->host.start_postlogon != NULL)
                {
                    state->host.start_postlogon(state->host.context);
                }
                /* Don't set COMPLETED - start_postlogon calls script_start which sets the status */
                return 1;
            }

            /* Authentication failed */
            state->logon_attempts++;

            if (auth_result == 1)
            {
                /* User not found */
                script_write_output(state, "\r\n\033[1;31mUsername not found.\033[0m\r\n");
            }
            else if (auth_result == 2)
            {
                /* Bad password */
                script_write_output(state, "\r\n\033[1;31mIncorrect password.\033[0m\r\n");
            }
            else if (auth_result == 3)
            {
                /* Account locked */
                script_write_output(state, "\r\n\033[1;31mAccount is locked.\033[0m\r\n");
                if (state->host.force_disconnect != NULL)
                {
                    state->host.force_disconnect(state->host.context);
                }
                state->status = SCRIPT_STATUS_COMPLETED;
                return 1;
            }
            else
            {
                /* Generic error */
                script_write_output(state, "\r\n\033[1;31mLogin failed.\033[0m\r\n");
            }

            /* Check retry limit */
            if (state->logon_attempts >= 3)
            {
                script_write_output(state, "\r\n\033[1;31mToo many failed attempts.\033[0m\r\n");
                if (state->host.force_disconnect != NULL)
                {
                    state->host.force_disconnect(state->host.context);
                }
                state->status = SCRIPT_STATUS_COMPLETED;
                return 1;
            }

            /* Allow retry - prompt for username again */
            script_write_output(state, "\r\nUsername: ");
            state->logon_username[0] = '\0';
            state->input_echo = 1;
            state->input_length = 0;
            if (state->input_buffer != NULL)
            {
                state->input_buffer[0] = '\0';
            }
            state->status = SCRIPT_STATUS_WAIT_LOGON_USERNAME;
            return 1;
        }

        /* Accumulate password character (no echo) */
        if (state->input_length + 1 >= state->input_capacity)
        {
            size_t new_capacity = state->input_capacity + SCRIPT_INPUT_BUFFER_CHUNK;
            char *resized = (char *)realloc(state->input_buffer, new_capacity);
            if (resized == NULL)
            {
                script_set_error(state, "Out of memory expanding input buffer");
                state->status = SCRIPT_STATUS_ERROR;
                return 0;
            }
            state->input_buffer = resized;
            state->input_capacity = new_capacity;
        }

        state->input_buffer[state->input_length++] = (char)byte;
        /* No echo for password */
        return 1;
    }

    return 0;
}

void script_notify_door_closed(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_DOOR)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
    }
}

void script_notify_transfer_complete(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_TRANSFER)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
    }
}

void script_notify_chat_ended(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_CHAT || 
        state->status == SCRIPT_STATUS_WAIT_CHAT_REASON)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
    }
}

script_status script_get_status(const script_state *state)
{
    if (state == NULL)
    {
        return SCRIPT_STATUS_ERROR;
    }

    return state->status;
}

const char *script_get_last_error(const script_state *state)
{
    if (state == NULL)
    {
        return "Invalid script state";
    }

    if (state->last_error[0] == '\0')
    {
        return "Unknown error";
    }

    return state->last_error;
}

const char *script_get_variable(const script_state *state, const char *name)
{
    return script_get_variable_value(state, name);
}

static void script_clear_program(script_state *state)
{
    size_t i;

    if (state->instructions != NULL)
    {
        for (i = 0; i < state->instruction_count; ++i)
        {
            script_free_instruction(&state->instructions[i]);
        }
    }

    state->instruction_count = 0;

    if (state->labels != NULL)
    {
        for (i = 0; i < state->label_count; ++i)
        {
            script_free_label(&state->labels[i]);
        }
    }
    state->label_count = 0;
}

static void script_clear_variables(script_state *state)
{
    size_t i;

    if (state->variables != NULL)
    {
        for (i = 0; i < state->variable_count; ++i)
        {
            script_free_variable(&state->variables[i]);
        }
    }
    state->variable_count = 0;
}

static int script_load_file(script_state *state, const char *path)
{
    FILE *fp;
    long file_size;
    size_t length;
    char *buffer = NULL;
    int result = 0;

    script_clear_program(state);

    fp = fopen(path, "rb");
    if (fp == NULL)
    {
        script_set_error(state, "Unable to open %s", path);
        return 0;
    }

    if (fseek(fp, 0, SEEK_END) != 0)
    {
        fclose(fp);
        script_set_error(state, "Unable to seek %s", path);
        return 0;
    }

    file_size = ftell(fp);
    if (file_size < 0)
    {
        fclose(fp);
        script_set_error(state, "Unable to determine size of %s", path);
        return 0;
    }

    if (fseek(fp, 0, SEEK_SET) != 0)
    {
        fclose(fp);
        script_set_error(state, "Unable to rewind %s", path);
        return 0;
    }

    length = (size_t)file_size;
    buffer = (char *)malloc(length + 1);
    if (buffer == NULL)
    {
        fclose(fp);
        script_set_error(state, "Out of memory loading %s", path);
        return 0;
    }

    if (length > 0 && fread(buffer, 1, length, fp) != length)
    {
        free(buffer);
        fclose(fp);
        script_set_error(state, "Failed to read %s", path);
        return 0;
    }

    buffer[length] = '\0';
    fclose(fp);

    if (script_buffer_has_embedded_blocks(buffer, length))
    {
        result = script_process_embedded_content(state, buffer, length, path, script_handle_embedded_text_as_instruction, script_handle_embedded_command_as_instruction, NULL);
    }
    else
    {
        char *stripped = script_strip_block_comments(buffer, length);
        if (stripped != NULL)
        {
            result = script_parse_plain_lines(state, stripped);
            free(stripped);
        }
        else
        {
            result = script_parse_plain_lines(state, buffer);
        }
    }

    free(buffer);

    if (!result)
    {
        script_clear_program(state);
    }

    return result;
}

static int script_parse_line(script_state *state, const char *line, int line_number)
{
    char *line_copy;
    char *trimmed;
    size_t len;
    script_instruction instruction;

    if (line == NULL)
    {
        return 1;
    }

    line_copy = script_duplicate_string(line);
    if (line_copy == NULL)
    {
        script_set_error(state, "Out of memory parsing line %d", line_number);
        return 0;
    }

    trimmed = script_trim(line_copy);
    if (*trimmed == '\0' || script_is_empty_or_comment(trimmed))
    {
        free(line_copy);
        return 1;
    }

    len = strlen(trimmed);
    if (len > 0 && trimmed[len - 1] == ':')
    {
        trimmed[len - 1] = '\0';
        trimmed = script_trim(trimmed);
        if (!script_register_label(state, trimmed))
        {
            script_set_error(state, "Unable to register label on line %d", line_number);
            free(line_copy);
            return 0;
        }
        free(line_copy);
        return 1;
    }

    memset(&instruction, 0, sizeof(instruction));
    if (!script_build_instruction(state, trimmed, line_number, &instruction))
    {
        free(line_copy);
        return 0;
    }

    free(line_copy);

    if (instruction.type == SCRIPT_CMD_NONE)
    {
        return 1;
    }

    if (!script_append_instruction(state, &instruction))
    {
        script_free_instruction(&instruction);
        script_set_error(state, "Too many instructions (line %d)", line_number);
        return 0;
    }

    return 1;
}

static int script_build_instruction(script_state *state, char *line, int line_number, script_instruction *instruction)
{
    char *token;
    char *line_after_cmd; /* Pointer to rest of line after command */
    size_t token_len;

    if (line == NULL || instruction == NULL)
    {
        return 0;
    }

    instruction->type = SCRIPT_CMD_NONE;

    /* Skip leading whitespace to find command start */
    while (*line && isspace((unsigned char)*line)) line++;
    
    /* Find end of first token (command) */
    token = line;
    while (*line && !isspace((unsigned char)*line)) line++;
    token_len = (size_t)(line - token);
    
    if (token_len == 0)
    {
        return 1;
    }
    
    /* Skip whitespace after command to find rest of line */
    while (*line && isspace((unsigned char)*line)) line++;
    line_after_cmd = line;
    
    /* Now use token_len to compare command names */
    /* We need to null-terminate for comparison, so use the original strtok approach
     * but save line_after_cmd first */
    
    /* Re-parse with strtok for other commands that need it */
    token = strtok(token, " \t");
    if (token == NULL)
    {
        return 1;
    }

    if (script_stringcasecmp(token, "label") == 0)
    {
        char *label_name = strtok(NULL, " \t");
        if (label_name == NULL)
        {
            script_set_error(state, "Missing label name on line %d", line_number);
            return 0;
        }
        if (!script_register_label(state, script_trim(label_name)))
        {
            script_set_error(state, "Unable to register label on line %d", line_number);
            return 0;
        }
        return 1;
    }

    if (script_stringcasecmp(token, "print") == 0)
    {
        char *rest = strtok(NULL, "");
        instruction->type = SCRIPT_CMD_PRINT;
        if (rest == NULL)
        {
            instruction->arg1 = script_duplicate_string("\r\n");
        }
        else
        {
            size_t consumed = 0;
            char *value = NULL;
            if (script_parse_backtick_string(rest, &consumed, &value))
            {
                instruction->arg1 = value;
            }
            else
            {
                instruction->arg1 = script_duplicate_string(script_trim(rest));
            }
        }
        return 1;
    }

    if (script_stringcasecmp(token, "goto") == 0)
    {
        char *label = strtok(NULL, " \t");
        if (label == NULL)
        {
            script_set_error(state, "Missing label for goto on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_GOTO;
        instruction->arg1 = script_duplicate_string(label);
        return 1;
    }

    if (script_stringcasecmp(token, "prompt") == 0)
    {
        char *var = strtok(NULL, " \t");
        char *mode = strtok(NULL, " \t");
        char *echo = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_PROMPT;
        instruction->arg1 = script_duplicate_string(var != NULL ? var : "selection");
        instruction->arg2 = script_duplicate_string(mode != NULL ? mode : "char");
        instruction->arg3 = script_duplicate_string(echo != NULL ? echo : "echo");
        return 1;
    }

    if (script_stringcasecmp(token, "if") == 0)
    {
        /* IF supports compound conditions with && (AND) and || (OR)
         * Syntax: if <expr1> [&& <expr2>]... [|| <expr3>]... goto <label>
         * Where each expr is: <var> <op> <value>
         * Operators: ==, !=, >, <, >=, <=
         * 
         * Store entire condition in arg1, label in arg2
         * 
         * Use line_after_cmd which points to the rest of the line after "if"
         */
        char *rest = line_after_cmd;
        char *goto_keyword;
        char *label_name;
        char *condition_text;
        char *search_pos;

        if (*rest == '\0')
        {
            script_set_error(state, "Malformed if statement on line %d", line_number);
            return 0;
        }

        /* Find the LAST occurrence of " goto " to handle compound conditions */
        goto_keyword = NULL;
        search_pos = rest;
        while ((search_pos = strstr(search_pos, " goto ")) != NULL)
        {
            goto_keyword = search_pos;
            search_pos += 6;
        }
        
        /* Also try just "goto " if condition starts right at goto (shouldn't happen) */
        if (goto_keyword == NULL && strncmp(rest, "goto ", 5) == 0)
        {
            goto_keyword = rest;
        }
        
        if (goto_keyword == NULL)
        {
            script_set_error(state, "If without goto on line %d", line_number);
            return 0;
        }

        /* Split at goto */
        if (goto_keyword == rest)
        {
            /* goto at start - no condition (shouldn't happen but handle it) */
            condition_text = "";
            label_name = script_trim(rest + 5);
        }
        else
        {
            *goto_keyword = '\0';
            condition_text = script_trim(rest);
            label_name = script_trim(goto_keyword + 6); /* skip " goto " */
        }

        instruction->type = SCRIPT_CMD_IF;
        instruction->arg1 = script_duplicate_string(condition_text);
        instruction->arg2 = script_duplicate_string(label_name);
        instruction->arg3 = NULL;
        instruction->arg4 = NULL;
        return 1;
    }

    if (script_stringcasecmp(token, "set") == 0)
    {
        char *var_name = strtok(NULL, " \t");
        char *value_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;
        if (var_name == NULL || value_text == NULL)
        {
            script_set_error(state, "Malformed set on line %d", line_number);
            return 0;
        }
        if (!script_parse_backtick_string(value_text, &consumed, &value_string))
        {
            value_string = script_duplicate_string(script_trim(value_text));
        }
        instruction->type = SCRIPT_CMD_SET;
        instruction->arg1 = script_duplicate_string(var_name);
        instruction->arg2 = value_string;
        return 1;
    }

    if (script_stringcasecmp(token, "call") == 0)
    {
        char *action = strtok(NULL, " \t");
        char *arg_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_CALL;
        instruction->arg1 = script_duplicate_string(action != NULL ? action : "");

        if (arg_text != NULL)
        {
            arg_text = script_trim(arg_text);

            /* For arcbbsdoor, parse door number first, then command */
            if (action != NULL && script_stringcasecmp(action, "arcbbsdoor") == 0)
            {
                char *door_num = strtok(arg_text, " \t");
                char *cmd_text = strtok(NULL, "");

                instruction->arg2 = script_duplicate_string(door_num != NULL ? door_num : "1");

                if (cmd_text != NULL)
                {
                    cmd_text = script_trim(cmd_text);
                    if (!script_parse_backtick_string(cmd_text, &consumed, &value_string))
                    {
                        value_string = script_duplicate_string(cmd_text);
                    }
                    instruction->arg3 = value_string;
                }
            }
            else
            {
                /* Standard call: arg2 is the command */
                if (!script_parse_backtick_string(arg_text, &consumed, &value_string))
                {
                    value_string = script_duplicate_string(arg_text);
                }
                instruction->arg2 = value_string;
            }
        }
        return 1;
    }

    if (script_stringcasecmp(token, "doing") == 0)
    {
        char *text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_DOING;

        if (text != NULL)
        {
            text = script_trim(text);
            if (!script_parse_backtick_string(text, &consumed, &value_string))
            {
                value_string = script_duplicate_string(text);
            }
            instruction->arg1 = value_string;
        }
        else
        {
            instruction->arg1 = script_duplicate_string("");
        }
        return 1;
    }

    if (script_stringcasecmp(token, "return") == 0 || script_stringcasecmp(token, "stop") == 0)
    {
        instruction->type = SCRIPT_CMD_RETURN;
        return 1;
    }

    if (script_stringcasecmp(token, "pause") == 0 || script_stringcasecmp(token, "sleep") == 0)
    {
        char *duration = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_PAUSE;
        instruction->arg1 = script_duplicate_string(duration != NULL ? duration : "0");
        return 1;
    }

    if (script_stringcasecmp(token, "type") == 0)
    {
        char *path_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        if (path_text == NULL)
        {
            script_set_error(state, "Missing filename for type on line %d", line_number);
            return 0;
        }

        path_text = script_trim(path_text);
        if (!script_parse_backtick_string(path_text, &consumed, &value_string))
        {
            value_string = script_duplicate_string(path_text);
        }

        instruction->type = SCRIPT_CMD_TYPE;
        instruction->arg1 = value_string;
        return 1;
    }

    if (script_stringcasecmp(token, "anykey") == 0)
    {
        char *var = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_ANYKEY;
        instruction->arg1 = script_duplicate_string(var != NULL ? var : "_key");
        return 1;
    }

    if (script_stringcasecmp(token, "fgbg") == 0)
    {
        char *fg = strtok(NULL, " \t");
        char *bg = strtok(NULL, " \t");
        if (fg == NULL || bg == NULL)
        {
            script_set_error(state, "Malformed fgbg on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_FGBG;
        instruction->arg1 = script_duplicate_string(fg);
        instruction->arg2 = script_duplicate_string(bg);
        return 1;
    }

    if (script_stringcasecmp(token, "fg") == 0)
    {
        char *fg = strtok(NULL, " \t");
        if (fg == NULL)
        {
            script_set_error(state, "Missing colour for fg on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_FG;
        instruction->arg1 = script_duplicate_string(fg);
        return 1;
    }

    if (script_stringcasecmp(token, "bg") == 0)
    {
        char *bg = strtok(NULL, " \t");
        if (bg == NULL)
        {
            script_set_error(state, "Missing colour for bg on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_BG;
        instruction->arg1 = script_duplicate_string(bg);
        return 1;
    }

    if (script_stringcasecmp(token, "cls") == 0)
    {
        instruction->type = SCRIPT_CMD_CLS;
        return 1;
    }

    if (script_stringcasecmp(token, "pos") == 0)
    {
        char *col = strtok(NULL, " \t");
        char *row = strtok(NULL, " \t");
        if (col == NULL || row == NULL)
        {
            script_set_error(state, "Malformed pos on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_POS;
        instruction->arg1 = script_duplicate_string(row);
        instruction->arg2 = script_duplicate_string(col);
        return 1;
    }

    if (script_stringcasecmp(token, "script") == 0)
    {
        char *path_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        if (path_text == NULL)
        {
            script_set_error(state, "Missing filename for script on line %d", line_number);
            return 0;
        }

        path_text = script_trim(path_text);
        if (!script_parse_backtick_string(path_text, &consumed, &value_string))
        {
            value_string = script_duplicate_string(path_text);
        }

        instruction->type = SCRIPT_CMD_SCRIPT;
        instruction->arg1 = value_string;
        return 1;
    }

    if (script_stringcasecmp(token, "logoff") == 0)
    {
        instruction->type = SCRIPT_CMD_LOGOFF;
        return 1;
    }

    if (script_stringcasecmp(token, "online") == 0)
    {
        instruction->type = SCRIPT_CMD_ONLINE;
        return 1;
    }

    if (script_stringcasecmp(token, "filebase") == 0)
    {
        char *subcmd = strtok(NULL, " \t");
        char *arg_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_FILEBASE;
        instruction->arg1 = script_duplicate_string(subcmd != NULL ? subcmd : "list");

        if (arg_text != NULL)
        {
            arg_text = script_trim(arg_text);
            if (!script_parse_backtick_string(arg_text, &consumed, &value_string))
            {
                value_string = script_duplicate_string(arg_text);
            }
            instruction->arg2 = value_string;
        }
        return 1;
    }

    if (script_stringcasecmp(token, "logon") == 0)
    {
        instruction->type = SCRIPT_CMD_LOGON;
        return 1;
    }

    if (script_stringcasecmp(token, "sendfile") == 0)
    {
        /* SENDFILE <file_id> [protocol]
         * protocol: xmodem, xmodem-crc, xmodem-1k, ymodem, ymodem-g (default: xmodem-crc)
         */
        char *file_id_str = strtok(NULL, " \t");
        char *protocol_str = strtok(NULL, " \t");

        instruction->type = SCRIPT_CMD_SENDFILE;
        instruction->arg1 = script_duplicate_string(file_id_str != NULL ? file_id_str : "0");
        instruction->arg2 = script_duplicate_string(protocol_str != NULL ? protocol_str : "xmodem-crc");
        return 1;
    }

    if (script_stringcasecmp(token, "receivefile") == 0)
    {
        /* RECEIVEFILE <filename> [protocol]
         * protocol: xmodem, xmodem-crc, xmodem-1k, ymodem, ymodem-g (default: xmodem-crc)
         */
        char *filename_str = strtok(NULL, " \t");
        char *protocol_str = strtok(NULL, " \t");

        instruction->type = SCRIPT_CMD_RECEIVEFILE;
        instruction->arg1 = script_duplicate_string(filename_str != NULL ? filename_str : "");
        instruction->arg2 = script_duplicate_string(protocol_str != NULL ? protocol_str : "xmodem-crc");
        return 1;
    }

    /* Math commands: add, sub, mul, div, mod
     * Syntax: add <result_var> <operand1> <operand2>
     */
    if (script_stringcasecmp(token, "add") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed add on line %d (usage: add result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_ADD;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "sub") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed sub on line %d (usage: sub result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_SUB;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "mul") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed mul on line %d (usage: mul result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_MUL;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "div") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed div on line %d (usage: div result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_DIV;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "mod") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed mod on line %d (usage: mod result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_MOD;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    /* Random: random <result_var> <min> <max> */
    if (script_stringcasecmp(token, "random") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *min_str = strtok(NULL, " \t");
        char *max_str = strtok(NULL, " \t");
        if (result == NULL || min_str == NULL || max_str == NULL)
        {
            script_set_error(state, "Malformed random on line %d (usage: random result min max)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_RANDOM;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(min_str);
        instruction->arg3 = script_duplicate_string(max_str);
        return 1;
    }

    /* String length: strlen <result_var> <string_var> */
    if (script_stringcasecmp(token, "strlen") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *source = strtok(NULL, " \t");
        if (result == NULL || source == NULL)
        {
            script_set_error(state, "Malformed strlen on line %d (usage: strlen result source)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_STRLEN;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(source);
        return 1;
    }

    /* Check if user has a key: haskey <result_var> <key> */
    if (script_stringcasecmp(token, "haskey") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *key = strtok(NULL, " \t");
        if (result == NULL || key == NULL)
        {
            script_set_error(state, "Malformed haskey on line %d (usage: haskey result key)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_HASKEY;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(key);
        return 1;
    }

    /* ANSI terminal detection: detectansi <result_var> [timeout_ms] */
    if (script_stringcasecmp(token, "detectansi") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *timeout = strtok(NULL, " \t");
        if (result == NULL)
        {
            script_set_error(state, "Malformed detectansi on line %d (usage: detectansi result [timeout_ms])", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_DETECTANSI;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(timeout != NULL ? timeout : "3000");
        return 1;
    }

    /* Sysop chat: sysopchat - prompts for reason then pages sysop */
    if (script_stringcasecmp(token, "sysopchat") == 0)
    {
        instruction->type = SCRIPT_CMD_SYSOPCHAT;
        return 1;
    }

    script_set_error(state, "Unknown command '%s' on line %d", token, line_number);
    return 0;
}

static char *script_duplicate_string(const char *source)
{
    char *copy;
    if (source == NULL)
    {
        return NULL;
    }
    copy = (char *)malloc(strlen(source) + 1);
    if (copy != NULL)
    {
        strcpy(copy, source);
    }
    return copy;
}

static int script_append_instruction(script_state *state, script_instruction *instr)
{
    if (state->instruction_count >= state->instruction_capacity)
    {
        size_t new_capacity = state->instruction_capacity + SCRIPT_DEFAULT_INSTRUCTION_CAPACITY;
        script_instruction *resized = (script_instruction *)realloc(state->instructions, new_capacity * sizeof(script_instruction));
        if (resized == NULL)
        {
            return 0;
        }
        state->instructions = resized;
        state->instruction_capacity = new_capacity;
    }

    state->instructions[state->instruction_count] = *instr;
    state->instruction_count++;
    return 1;
}

static int script_register_label(script_state *state, const char *name)
{
    if (name == NULL || *name == '\0')
    {
        return 0;
    }

    if (state->label_count >= state->label_capacity)
    {
        size_t new_capacity = state->label_capacity + SCRIPT_DEFAULT_LABEL_CAPACITY;
        script_label *resized = (script_label *)realloc(state->labels, new_capacity * sizeof(script_label));
        if (resized == NULL)
        {
            return 0;
        }
        state->labels = resized;
        state->label_capacity = new_capacity;
    }

    state->labels[state->label_count].name = script_duplicate_string(name);
    state->labels[state->label_count].instruction_index = state->instruction_count;
    state->label_count++;
    return 1;
}

static size_t script_find_label(const script_state *state, const char *name, int *found)
{
    if (found != NULL)
    {
        *found = 0;
    }

    size_t i;

    if (state == NULL || name == NULL)
    {
        return 0;
    }

    for (i = 0; i < state->label_count; ++i)
    {
        if (state->labels[i].name != NULL && script_stringcasecmp(state->labels[i].name, name) == 0)
        {
            if (found != NULL)
            {
                *found = 1;
            }
            return state->labels[i].instruction_index;
        }
    }

    return 0;
}

static script_variable *script_find_variable(script_state *state, const char *name, int create_if_missing)
{
    size_t i;

    if (state == NULL || name == NULL)
    {
        return NULL;
    }

    for (i = 0; i < state->variable_count; ++i)
    {
        if (script_stringcasecmp(state->variables[i].name, name) == 0)
        {
            return &state->variables[i];
        }
    }

    if (!create_if_missing)
    {
        return NULL;
    }

    if (state->variable_count >= state->variable_capacity)
    {
        size_t new_capacity = state->variable_capacity + SCRIPT_DEFAULT_VARIABLE_CAPACITY;
        script_variable *resized = (script_variable *)realloc(state->variables, new_capacity * sizeof(script_variable));
        if (resized == NULL)
        {
            return NULL;
        }
        state->variables = resized;
        state->variable_capacity = new_capacity;
    }

    memset(&state->variables[state->variable_count], 0, sizeof(script_variable));
    strncpy(state->variables[state->variable_count].name, name, sizeof(state->variables[state->variable_count].name) - 1);
    state->variables[state->variable_count].value = script_duplicate_string("");
    state->variable_count++;
    return &state->variables[state->variable_count - 1];
}

static void script_execute_instruction(script_state *state, script_instruction *instruction)
{
    if (state == NULL || instruction == NULL)
    {
        return;
    }

    switch (instruction->type)
    {
        case SCRIPT_CMD_PRINT:
        {
            char buffer[512];
            const char *text = instruction->arg1 != NULL ? instruction->arg1 : "";
            script_expand_macros(state, text, buffer, sizeof(buffer));
            script_translate_escapes(buffer);
            script_write_output(state, buffer);
        }
        break;

        case SCRIPT_CMD_GOTO:
        {
            size_t pc;
            int found = 0;
            pc = script_find_label(state, instruction->arg1, &found);
            if (!found)
            {
                script_set_error(state, "Unknown label '%s'", instruction->arg1 != NULL ? instruction->arg1 : "");
                state->status = SCRIPT_STATUS_ERROR;
            }
            else
            {
                state->program_counter = pc;
            }
        }
        break;

        case SCRIPT_CMD_PROMPT:
        {
            const char *var = instruction->arg1 != NULL ? instruction->arg1 : "selection";
            const char *mode = instruction->arg2 != NULL ? instruction->arg2 : "char";
            const char *echo = instruction->arg3 != NULL ? instruction->arg3 : "echo";

            /* Reset input buffer for new prompt */
            state->input_length = 0;
            if (state->input_buffer != NULL && state->input_capacity > 0)
            {
                state->input_buffer[0] = '\0';
            }

            strncpy(state->input_target, var, sizeof(state->input_target) - 1);
            state->input_target[sizeof(state->input_target) - 1] = '\0';
            state->input_mode = (script_stringcasecmp(mode, "line") == 0) ? SCRIPT_INPUT_LINE : SCRIPT_INPUT_CHAR;
            state->input_echo = (script_stringcasecmp(echo, "noecho") != 0);
            state->status = (state->input_mode == SCRIPT_INPUT_LINE) ? SCRIPT_STATUS_WAIT_INPUT_LINE : SCRIPT_STATUS_WAIT_INPUT_CHAR;
            return;
        }

        case SCRIPT_CMD_IF:
        {
            /* Compound condition support: var op value [&& var op value]... [|| var op value]...
             * arg1 = full condition expression, arg2 = label
             */
            const char *condition_expr = instruction->arg1;
            const char *label = instruction->arg2;
            int final_result = 0;

            if (condition_expr != NULL)
            {
                char expr_copy[1024];
                char *p;
                char *clause_start;
                int current_result = 0;
                int have_result = 0;
                int pending_or = 0;
                int pending_and = 0;

                strncpy(expr_copy, condition_expr, sizeof(expr_copy) - 1);
                expr_copy[sizeof(expr_copy) - 1] = '\0';

                p = expr_copy;
                clause_start = p;

                while (1)
                {
                    char *and_pos = strstr(p, "&&");
                    char *or_pos = strstr(p, "||");
                    char *next_op = NULL;
                    int is_and = 0;
                    char *clause_end;
                    char clause[256];
                    char var[128], op[8], val[256];
                    char var_expanded[512], val_expanded[512];
                    const char *var_value;
                    int clause_result = 0;

                    /* Find the nearest operator */
                    if (and_pos != NULL && (or_pos == NULL || and_pos < or_pos))
                    {
                        next_op = and_pos;
                        is_and = 1;
                    }
                    else if (or_pos != NULL)
                    {
                        next_op = or_pos;
                        is_and = 0;
                    }

                    /* Extract current clause */
                    if (next_op != NULL)
                    {
                        clause_end = next_op;
                    }
                    else
                    {
                        clause_end = p + strlen(p);
                    }

                    /* Copy and trim the clause */
                    {
                        size_t len = (size_t)(clause_end - clause_start);
                        if (len >= sizeof(clause)) len = sizeof(clause) - 1;
                        strncpy(clause, clause_start, len);
                        clause[len] = '\0';
                    }

                    /* Parse clause: var op value */
                    {
                        char *cp = clause;
                        char *var_start;
                        char *op_start;
                        char *val_start;

                        /* Skip leading whitespace */
                        while (*cp && isspace((unsigned char)*cp)) cp++;
                        var_start = cp;

                        /* Find variable name end */
                        while (*cp && !isspace((unsigned char)*cp) && 
                               strncmp(cp, "==", 2) != 0 && strncmp(cp, "!=", 2) != 0 &&
                               strncmp(cp, ">=", 2) != 0 && strncmp(cp, "<=", 2) != 0 &&
                               *cp != '>' && *cp != '<') cp++;
                        
                        {
                            size_t vlen = (size_t)(cp - var_start);
                            if (vlen >= sizeof(var)) vlen = sizeof(var) - 1;
                            strncpy(var, var_start, vlen);
                            var[vlen] = '\0';
                            /* Trim trailing whitespace from var */
                            while (vlen > 0 && isspace((unsigned char)var[vlen-1])) var[--vlen] = '\0';
                        }

                        /* Skip whitespace before operator */
                        while (*cp && isspace((unsigned char)*cp)) cp++;
                        op_start = cp;

                        /* Find operator */
                        if (strncmp(cp, "==", 2) == 0 || strncmp(cp, "!=", 2) == 0 ||
                            strncmp(cp, ">=", 2) == 0 || strncmp(cp, "<=", 2) == 0)
                        {
                            op[0] = *cp++;
                            op[1] = *cp++;
                            op[2] = '\0';
                        }
                        else if (*cp == '>' || *cp == '<')
                        {
                            op[0] = *cp++;
                            op[1] = '\0';
                        }
                        else
                        {
                            op[0] = '\0';
                        }

                        /* Skip whitespace before value */
                        while (*cp && isspace((unsigned char)*cp)) cp++;
                        val_start = cp;

                        /* Check for backtick-quoted value */
                        if (*cp == '`')
                        {
                            char *end_tick = strchr(cp + 1, '`');
                            if (end_tick != NULL)
                            {
                                size_t vlen = (size_t)(end_tick - cp - 1);
                                if (vlen >= sizeof(val)) vlen = sizeof(val) - 1;
                                strncpy(val, cp + 1, vlen);
                                val[vlen] = '\0';
                            }
                            else
                            {
                                strncpy(val, cp + 1, sizeof(val) - 1);
                                val[sizeof(val) - 1] = '\0';
                            }
                        }
                        else
                        {
                            /* Copy rest as value, trim trailing whitespace */
                            strncpy(val, val_start, sizeof(val) - 1);
                            val[sizeof(val) - 1] = '\0';
                            {
                                size_t vlen = strlen(val);
                                while (vlen > 0 && isspace((unsigned char)val[vlen-1])) val[--vlen] = '\0';
                            }
                        }
                    }

                    /* Get variable value and expand macros */
                    /* First expand macros in var itself (for %{hour} etc) */
                    script_expand_macros(state, var, var_expanded, sizeof(var_expanded));
                    
                    /* If var_expanded is different from var, use it directly
                     * Otherwise look up as a variable name */
                    if (strcmp(var, var_expanded) == 0)
                    {
                        /* No macro expansion happened, try as variable name */
                        var_value = script_get_variable_value(state, var);
                        if (var_value != NULL)
                        {
                            script_expand_macros(state, var_value, var_expanded, sizeof(var_expanded));
                        }
                        /* else var_expanded already contains the original var string */
                    }
                    /* Expand macros in the value */
                    script_expand_macros(state, val, val_expanded, sizeof(val_expanded));

                    /* Evaluate the comparison */
                    if (strcmp(op, "==") == 0)
                    {
                        clause_result = (script_stringcasecmp(var_expanded, val_expanded) == 0);
                    }
                    else if (strcmp(op, "!=") == 0)
                    {
                        clause_result = (script_stringcasecmp(var_expanded, val_expanded) != 0);
                    }
                    else if (strcmp(op, ">") == 0)
                    {
                        clause_result = (atoi(var_expanded) > atoi(val_expanded));
                    }
                    else if (strcmp(op, "<") == 0)
                    {
                        clause_result = (atoi(var_expanded) < atoi(val_expanded));
                    }
                    else if (strcmp(op, ">=") == 0)
                    {
                        clause_result = (atoi(var_expanded) >= atoi(val_expanded));
                    }
                    else if (strcmp(op, "<=") == 0)
                    {
                        clause_result = (atoi(var_expanded) <= atoi(val_expanded));
                    }

                    /* Combine with previous results */
                    if (!have_result)
                    {
                        current_result = clause_result;
                        have_result = 1;
                    }
                    else if (pending_and)
                    {
                        current_result = current_result && clause_result;
                    }
                    else if (pending_or)
                    {
                        current_result = current_result || clause_result;
                    }

                    pending_and = 0;
                    pending_or = 0;

                    /* Move to next clause or exit */
                    if (next_op == NULL)
                    {
                        break;
                    }

                    if (is_and)
                    {
                        pending_and = 1;
                    }
                    else
                    {
                        pending_or = 1;
                    }

                    p = next_op + 2;
                    clause_start = p;
                }

                final_result = current_result;
            }

            if (final_result)
            {
                size_t pc;
                int found = 0;
                pc = script_find_label(state, label, &found);
                if (!found)
                {
                    script_set_error(state, "Unknown label '%s'", label != NULL ? label : "");
                    state->status = SCRIPT_STATUS_ERROR;
                }
                else
                {
                    state->program_counter = pc;
                }
            }
        }
        break;

        case SCRIPT_CMD_SET:
        {
            if (instruction->arg1 != NULL)
            {
                char buffer[512];
                const char *value_text = instruction->arg2 != NULL ? instruction->arg2 : "";
                script_expand_macros(state, value_text, buffer, sizeof(buffer));
                script_set_variable_value(state, instruction->arg1, buffer);
            }
        }
        break;

        case SCRIPT_CMD_ADD:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                snprintf(result, sizeof(result), "%d", val1 + val2);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_SUB:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                snprintf(result, sizeof(result), "%d", val1 - val2);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_MUL:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                snprintf(result, sizeof(result), "%d", val1 * val2);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_DIV:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                if (val2 != 0)
                {
                    snprintf(result, sizeof(result), "%d", val1 / val2);
                }
                else
                {
                    snprintf(result, sizeof(result), "0");
                }
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_MOD:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                if (val2 != 0)
                {
                    snprintf(result, sizeof(result), "%d", val1 % val2);
                }
                else
                {
                    snprintf(result, sizeof(result), "0");
                }
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_RANDOM:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int min_val, max_val, rand_val;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                min_val = atoi(buf1);
                max_val = atoi(buf2);
                if (max_val > min_val)
                {
                    rand_val = min_val + (rand() % (max_val - min_val + 1));
                }
                else
                {
                    rand_val = min_val;
                }
                snprintf(result, sizeof(result), "%d", rand_val);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_STRLEN:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL)
            {
                char expanded[512], result[64];
                const char *source = script_get_variable_value(state, instruction->arg2);
                if (source == NULL) source = "";
                script_expand_macros(state, source, expanded, sizeof(expanded));
                snprintf(result, sizeof(result), "%d", (int)strlen(expanded));
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_HASKEY:
        {
            /* Check if user has a specific key
             * Keys are stored as a space or comma-separated list
             * e.g., "A B C" or "A,B,C" or "A, B, C"
             */
            if (instruction->arg1 != NULL && instruction->arg2 != NULL)
            {
                const char *user_keys = state->host.get_user_keys != NULL ? 
                    state->host.get_user_keys(state->host.context) : "";
                const char *check_key = instruction->arg2;
                char keys_copy[256];
                char *key_tok;
                int found = 0;
                
                if (user_keys != NULL && *user_keys != '\0')
                {
                    strncpy(keys_copy, user_keys, sizeof(keys_copy) - 1);
                    keys_copy[sizeof(keys_copy) - 1] = '\0';
                    
                    /* Tokenize on space, comma, or both */
                    key_tok = strtok(keys_copy, " ,");
                    while (key_tok != NULL && !found)
                    {
                        if (script_stringcasecmp(key_tok, check_key) == 0)
                        {
                            found = 1;
                        }
                        key_tok = strtok(NULL, " ,");
                    }
                }
                
                script_set_variable_value(state, instruction->arg1, found ? "1" : "0");
            }
        }
        break;

        case SCRIPT_CMD_DETECTANSI:
        {
            /* ANSI terminal detection using Device Status Report (DSR)
             * Send ESC[6n (cursor position report request)
             * ANSI terminals respond with ESC[<row>;<col>R
             * Dumb terminals don't respond
             */
            const char *result_var = instruction->arg1;
            const char *timeout_str = instruction->arg2;
            unsigned int timeout_ms;
            
            if (result_var == NULL)
            {
                break;
            }
            
            /* Parse timeout (default 3000ms) */
            timeout_ms = (timeout_str != NULL) ? (unsigned int)strtoul(timeout_str, NULL, 10) : 3000;
            if (timeout_ms < 500) timeout_ms = 500;     /* Minimum 500ms */
            if (timeout_ms > 10000) timeout_ms = 10000; /* Maximum 10 seconds */
            
            /* Store result variable name */
            strncpy(state->ansi_result_var, result_var, sizeof(state->ansi_result_var) - 1);
            state->ansi_result_var[sizeof(state->ansi_result_var) - 1] = '\0';
            
            /* Reset ANSI detection state */
            state->ansi_parse_state = 0;
            state->ansi_response_len = 0;
            memset(state->ansi_response, 0, sizeof(state->ansi_response));
            
            /* Calculate deadline using CLOCKS_PER_SEC for proper timing */
            {
                clock_t ticks = (clock_t)(((double)timeout_ms / 1000.0) * CLOCKS_PER_SEC);
                if (ticks < 1) ticks = 1;
                state->ansi_deadline = clock() + ticks;
                debug_printf("ANSI detect: sending ESC[6n, timeout=%ums, CLOCKS_PER_SEC=%d, ticks=%ld\n",
                             timeout_ms, CLOCKS_PER_SEC, (long)ticks);
            }
            
            /* Send DSR query: ESC[6n */
            script_write_output(state, "\033[6n");
            
            /* Wait for response */
            state->status = SCRIPT_STATUS_WAIT_ANSI;
            return;
        }

        case SCRIPT_CMD_SYSOPCHAT:
        {
            /* Sysop chat - prompt for reason then page sysop */
            script_write_output(state, "\r\n\033[1;36mEnter reason to chat with sysop (or press Enter to cancel):\033[0m\r\n");
            script_write_output(state, "> ");
            
            /* Reset input buffer for reason collection */
            state->input_echo = 1;
            state->input_length = 0;
            if (state->input_buffer != NULL)
            {
                state->input_buffer[0] = '\0';
            }
            
            state->status = SCRIPT_STATUS_WAIT_CHAT_REASON;
            return;
        }

        case SCRIPT_CMD_CALL:
        {
            const char *action = instruction->arg1 != NULL ? instruction->arg1 : "";
            if (script_stringcasecmp(action, "time") == 0)
            {
                if (state->host.report_time != NULL)
                {
                    state->host.report_time(state->host.context);
                }
            }
            else if (script_stringcasecmp(action, "lineinfo") == 0)
            {
                if (state->host.report_line_info != NULL)
                {
                    state->host.report_line_info(state->host.context);
                }
            }
            else if (script_stringcasecmp(action, "door") == 0)
            {
                if (state->host.launch_door != NULL)
                {
                    char buffer[256];
                    const char *command = instruction->arg2 != NULL ? instruction->arg2 : "";
                    script_expand_macros(state, command, buffer, sizeof(buffer));
                    state->host.launch_door(state->host.context, buffer);
                    state->status = SCRIPT_STATUS_WAIT_DOOR;
                }
            }
            else if (script_stringcasecmp(action, "arcbbsdoor") == 0)
            {
                if (state->host.launch_arcbbs_door != NULL)
                {
                    char num_buffer[16];
                    char cmd_buffer[256];
                    const char *door_num_str = instruction->arg2 != NULL ? instruction->arg2 : "1";
                    const char *command = instruction->arg3 != NULL ? instruction->arg3 : "";
                    int door_number;
                    script_expand_macros(state, door_num_str, num_buffer, sizeof(num_buffer));
                    script_expand_macros(state, command, cmd_buffer, sizeof(cmd_buffer));
                    door_number = atoi(num_buffer);
                    if (door_number < 1) door_number = 1;
                    if (door_number > 254) door_number = 254;
                    state->host.launch_arcbbs_door(state->host.context, door_number, cmd_buffer);
                    state->status = SCRIPT_STATUS_WAIT_DOOR;
                }
            }
            else if (script_stringcasecmp(action, "disconnect") == 0)
            {
                if (state->host.request_disconnect != NULL)
                {
                    state->host.request_disconnect(state->host.context);
                }
            }
            else if (script_stringcasecmp(action, "message") == 0)
            {
                char buffer[512];
                const char *text = instruction->arg2 != NULL ? instruction->arg2 : "";
                script_expand_macros(state, text, buffer, sizeof(buffer));
                script_write_output(state, buffer);
            }
        }
        break;

        case SCRIPT_CMD_DOING:
        {
            if (state->host.report_activity != NULL)
            {
                char buffer[256];
                const char *text = instruction->arg1 != NULL ? instruction->arg1 : "";
                script_expand_macros(state, text, buffer, sizeof(buffer));
                script_translate_escapes(buffer);
                state->host.report_activity(state->host.context, buffer);
            }
        }
        break;

        case SCRIPT_CMD_RETURN:
            state->status = SCRIPT_STATUS_COMPLETED;
            break;

        case SCRIPT_CMD_PAUSE:
        {
            unsigned int duration = (unsigned int)strtoul(instruction->arg1 != NULL ? instruction->arg1 : "0", NULL, 10);
            state->sleep_deadline = script_calculate_sleep_deadline(duration);
            state->status = SCRIPT_STATUS_WAIT_SLEEP;
            return;
        }

        case SCRIPT_CMD_TYPE:
        {
            script_display_file(state, instruction->arg1);
        }
        break;

        case SCRIPT_CMD_ANYKEY:
        {
            const char *target = (instruction->arg1 != NULL && instruction->arg1[0] != '\0') ? instruction->arg1 : "_key";
            strncpy(state->input_target, target, sizeof(state->input_target) - 1);
            state->input_target[sizeof(state->input_target) - 1] = '\0';
            state->input_mode = SCRIPT_INPUT_CHAR;
            state->input_echo = 0;
            state->status = SCRIPT_STATUS_WAIT_INPUT_CHAR;
            return;
        }

        case SCRIPT_CMD_FG:
        {
            script_apply_colour_change(state, instruction->arg1, NULL, 1, 0);
        }
        break;

        case SCRIPT_CMD_BG:
        {
            script_apply_colour_change(state, NULL, instruction->arg1, 0, 1);
        }
        break;

        case SCRIPT_CMD_FGBG:
        {
            script_apply_colour_change(state, instruction->arg1, instruction->arg2, 1, 1);
        }
        break;

        case SCRIPT_CMD_CLS:
        {
            script_send_clear_screen(state);
        }
        break;

        case SCRIPT_CMD_POS:
        {
            script_move_cursor(state, instruction->arg2, instruction->arg1);
        }
        break;

        case SCRIPT_CMD_SCRIPT:
        {
            char path[256];
            const char *source = instruction->arg1 != NULL ? instruction->arg1 : "";

            script_expand_macros(state, source, path, sizeof(path));
            if (path[0] == '\0')
            {
                script_set_error(state, "Script command missing path");
                state->status = SCRIPT_STATUS_ERROR;
                break;
            }

            if (!script_start(state, path))
            {
                state->status = SCRIPT_STATUS_ERROR;
            }
            return;
        }

        case SCRIPT_CMD_LOGOFF:
        {
            if (state->host.force_disconnect != NULL)
            {
                state->host.force_disconnect(state->host.context);
            }
            state->status = SCRIPT_STATUS_COMPLETED;
        }
        break;

        case SCRIPT_CMD_ONLINE:
        {
            if (state->host.report_online_users != NULL)
            {
                state->host.report_online_users(state->host.context);
            }
        }
        break;

        case SCRIPT_CMD_FILEBASE:
        {
            const char *subcmd = instruction->arg1 != NULL ? instruction->arg1 : "list";
            const char *arg_raw = instruction->arg2;
            char arg_expanded[256];
            const char *arg;
            filebase_session *session = NULL;

            /* Expand macros in argument */
            if (arg_raw != NULL)
            {
                script_expand_macros(state, arg_raw, arg_expanded, sizeof(arg_expanded));
                arg = arg_expanded;
            }
            else
            {
                arg = NULL;
            }

            /* Get or create filebase session from host */
            if (state->host.get_filebase_session != NULL)
            {
                session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            }

            if (session == NULL)
            {
                script_write_output(state, "\r\n[Filebase not available]\r\n");
                break;
            }

            /* Update session access level from current user */
            if (state->host.get_user_accesslevel != NULL)
            {
                int level = state->host.get_user_accesslevel(state->host.context);
                const char *keys = NULL;
                if (state->host.get_user_keys != NULL)
                {
                    keys = state->host.get_user_keys(state->host.context);
                }
                filebase_session_set_access(session, level, keys);
            }

            if (script_stringcasecmp(subcmd, "list") == 0)
            {
                /* List available filebases */
                filebase_list_bases(session, (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "select") == 0)
            {
                /* Select a filebase: filebase select <id> */
                int base_id;
                LINETASK_FILEBASE_RECORD record;
                char msg[128];

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase select <id>]\r\n");
                    break;
                }

                base_id = atoi(arg);

                if (base_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid filebase ID]\r\n");
                    break;
                }

                if (!filebase_get_info(base_id, &record))
                {
                    script_write_output(state, "\r\n[Filebase not found]\r\n");
                    break;
                }

                /* Check access */
                if (!filebase_check_access(record.accesslevel, record.keys,
                                           session->user_accesslevel, session->user_keys))
                {
                    script_write_output(state, "\r\n[Access denied]\r\n");
                    break;
                }

                session->current_filebase = base_id;
                session->current_area = 0;
                snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected filebase: %s\033[0m\r\n", record.name);
                script_write_output(state, msg);
            }
            else if (script_stringcasecmp(subcmd, "areas") == 0)
            {
                /* List areas in current filebase */
                filebase_list_areas(session, (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "area") == 0)
            {
                /* Select an area: filebase area <id> */
                int area_id;
                char msg[128];

                if (session->current_filebase <= 0)
                {
                    script_write_output(state, "\r\n[No filebase selected]\r\n");
                    break;
                }

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase area <id>]\r\n");
                    break;
                }

                area_id = atoi(arg);
                if (area_id < 0)
                {
                    script_write_output(state, "\r\n[Invalid area ID]\r\n");
                    break;
                }

                if (area_id > 0)
                {
                    LINETASK_FILEBASE_AREA_RECORD area_record;
                    if (!filebase_get_area_info(session->current_filebase, area_id, &area_record))
                    {
                        script_write_output(state, "\r\n[Area not found]\r\n");
                        break;
                    }

                    if (!filebase_check_access(area_record.accesslevel, area_record.keys,
                                               session->user_accesslevel, session->user_keys))
                    {
                        script_write_output(state, "\r\n[Access denied]\r\n");
                        break;
                    }

                    snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected area: %s\033[0m\r\n", area_record.name);
                }
                else
                {
                    snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected: All Files\033[0m\r\n");
                }

                session->current_area = area_id;
                script_write_output(state, msg);
            }
            else if (script_stringcasecmp(subcmd, "files") == 0)
            {
                /* List files in current filebase/area */
                filebase_list_files(session, (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "info") == 0)
            {
                /* Show file info: filebase info <id> */
                int file_id;

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase info <file_id>]\r\n");
                    break;
                }

                file_id = atoi(arg);
                if (file_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid file ID]\r\n");
                    break;
                }

                filebase_show_file_info(session, file_id, (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "download") == 0)
            {
                /* Download a file: filebase download <id> */
                int file_id;

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase download <file_id>]\r\n");
                    break;
                }

                file_id = atoi(arg);
                if (file_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid file ID]\r\n");
                    break;
                }

                if (state->host.filebase_download != NULL)
                {
                    if (state->host.filebase_download(state->host.context, session->current_filebase, file_id))
                    {
                        /* Download initiated - wait for it to complete */
                        /* For now just show a message; transfer protocol will be added later */
                        script_write_output(state, "\r\n[Download initiated...]\r\n");
                    }
                    else
                    {
                        script_write_output(state, "\r\n[Download failed]\r\n");
                    }
                }
                else
                {
                    script_write_output(state, "\r\n[Download not implemented]\r\n");
                }
            }
            else if (script_stringcasecmp(subcmd, "reset") == 0)
            {
                /* Reset session */
                filebase_session_reset(session);
                script_write_output(state, "\r\n\033[1;32mFilebase selection cleared.\033[0m\r\n");
            }
            else
            {
                char msg[128];
                snprintf(msg, sizeof(msg), "\r\n[Unknown filebase command: %s]\r\n", subcmd);
                script_write_output(state, msg);
            }
        }
        break;

        case SCRIPT_CMD_LOGON:
        {
            /* Display logon prompt and wait for username */
            script_write_output(state, "\r\n");
            script_write_output(state, "Enter your username/password below to logon,\r\nor type NEW (and return) to register.\r\n");
            script_write_output(state, "\r\n");
            script_write_output(state, "Username: ");
            
            /* Initialize logon state */
            state->logon_username[0] = '\0';
            state->logon_attempts = 0;
            
            /* Wait for username input (line mode with echo) */
            state->input_echo = 1;
            state->input_length = 0;
            if (state->input_buffer != NULL)
            {
                state->input_buffer[0] = '\0';
            }
            state->status = SCRIPT_STATUS_WAIT_LOGON_USERNAME;
            return;
        }

        case SCRIPT_CMD_SENDFILE:
        {
            /* SENDFILE <file_id> [protocol]
             * Initiates a file transfer using the current filebase.
             * protocol: xmodem, xmodem-crc, xmodem-1k, ymodem, ymodem-g
             */
            const char *file_id_str = instruction->arg1;
            const char *protocol_str = instruction->arg2;
            char expanded_id[64];
            char expanded_proto[32];
            int file_id;
            int protocol = 1; /* Default to XMODEM-CRC */
            filebase_session *session = NULL;

            /* Expand macros in arguments */
            if (file_id_str != NULL)
            {
                script_expand_macros(state, file_id_str, expanded_id, sizeof(expanded_id));
                file_id = atoi(expanded_id);
            }
            else
            {
                file_id = 0;
            }

            if (protocol_str != NULL)
            {
                script_expand_macros(state, protocol_str, expanded_proto, sizeof(expanded_proto));
                
                if (script_stringcasecmp(expanded_proto, "xmodem") == 0)
                {
                    protocol = 0;
                }
                else if (script_stringcasecmp(expanded_proto, "xmodem-crc") == 0)
                {
                    protocol = 1;
                }
                else if (script_stringcasecmp(expanded_proto, "xmodem-1k") == 0)
                {
                    protocol = 2;
                }
                else if (script_stringcasecmp(expanded_proto, "ymodem") == 0)
                {
                    protocol = 3;
                }
                else if (script_stringcasecmp(expanded_proto, "ymodem-g") == 0)
                {
                    protocol = 4;
                }
                else if (script_stringcasecmp(expanded_proto, "zmodem") == 0)
                {
                    protocol = 5;
                }
            }

            if (file_id <= 0)
            {
                script_write_output(state, "\r\n[Invalid file ID]\r\n");
                break;
            }

            /* Get filebase session */
            if (state->host.get_filebase_session != NULL)
            {
                session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            }

            if (session == NULL || session->current_filebase <= 0)
            {
                script_write_output(state, "\r\n[No filebase selected]\r\n");
                break;
            }

            /* Check file access */
            {
                LINETASK_FILE_RECORD file_record;
                _kernel_swi_regs regs;

                regs.r[0] = 11; /* FILEBASE_CMD_FILE_INFO */
                regs.r[1] = session->current_filebase;
                regs.r[2] = file_id;

                if (_kernel_swi(0x5AA43, &regs, &regs) != NULL || regs.r[0] <= 0)
                {
                    script_write_output(state, "\r\n[File not found]\r\n");
                    break;
                }

                memcpy(&file_record, (void *)regs.r[0], sizeof(file_record));

                if (file_record.deleted)
                {
                    script_write_output(state, "\r\n[File not found]\r\n");
                    break;
                }

                if (!filebase_check_access(file_record.accesslevel, file_record.keys,
                                           session->user_accesslevel, session->user_keys))
                {
                    script_write_output(state, "\r\n[Access denied]\r\n");
                    break;
                }
            }

            /* Initiate transfer via host callback */
            if (state->host.start_transfer != NULL)
            {
                char msg[128];
                const char *proto_names[] = {"XMODEM", "XMODEM-CRC", "XMODEM-1K", "YMODEM", "YMODEM-G", "ZMODEM"};
                const char *proto_name = (protocol >= 0 && protocol <= 5) ? proto_names[protocol] : "XMODEM-CRC";

                snprintf(msg, sizeof(msg), 
                         "\r\n\033[1;33mStarting %s transfer. Start your receiver now...\033[0m\r\n",
                         proto_name);
                script_write_output(state, msg);

                if (state->host.start_transfer(state->host.context, 
                                               session->current_filebase, file_id, protocol))
                {
                    state->status = SCRIPT_STATUS_WAIT_TRANSFER;
                    return;
                }
                else
                {
                    script_write_output(state, "\r\n\033[1;31m[Transfer failed to start]\033[0m\r\n");
                }
            }
            else
            {
                script_write_output(state, "\r\n[File transfer not available]\r\n");
            }
        }
        break;

        case SCRIPT_CMD_RECEIVEFILE:
        {
            /* RECEIVEFILE <filename> [protocol]
             * Receives a file upload using the current filebase.
             * protocol: xmodem, xmodem-crc, xmodem-1k, ymodem, ymodem-g
             */
            const char *filename_str = instruction->arg1;
            const char *protocol_str = instruction->arg2;
            char expanded_filename[128];
            char expanded_proto[32];
            char temp_path[300];
            int protocol = 1; /* Default to XMODEM-CRC */
            filebase_session *session = NULL;
            int line_id = 0;

            /* Expand macros in arguments */
            if (filename_str != NULL)
            {
                script_expand_macros(state, filename_str, expanded_filename, sizeof(expanded_filename));
            }
            else
            {
                expanded_filename[0] = '\0';
            }

            if (protocol_str != NULL)
            {
                script_expand_macros(state, protocol_str, expanded_proto, sizeof(expanded_proto));
                
                if (script_stringcasecmp(expanded_proto, "xmodem") == 0)
                {
                    protocol = 0;
                }
                else if (script_stringcasecmp(expanded_proto, "xmodem-crc") == 0)
                {
                    protocol = 1;
                }
                else if (script_stringcasecmp(expanded_proto, "xmodem-1k") == 0)
                {
                    protocol = 2;
                }
                else if (script_stringcasecmp(expanded_proto, "ymodem") == 0)
                {
                    protocol = 3;
                }
                else if (script_stringcasecmp(expanded_proto, "ymodem-g") == 0)
                {
                    protocol = 4;
                }
                else if (script_stringcasecmp(expanded_proto, "zmodem") == 0)
                {
                    protocol = 5;
                }
            }

            if (expanded_filename[0] == '\0')
            {
                script_write_output(state, "\r\n[No filename specified]\r\n");
                break;
            }

            /* Get filebase session */
            if (state->host.get_filebase_session != NULL)
            {
                session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            }

            if (session == NULL || session->current_filebase <= 0)
            {
                script_write_output(state, "\r\n[No filebase selected]\r\n");
                break;
            }

            /* Check write access to current area */
            /* For now, any logged-in user with access can upload */

            /* Get line ID for temp file naming */
            if (state->host.get_line_id != NULL)
            {
                line_id = state->host.get_line_id(state->host.context);
            }

            /* Store upload metadata in script variables for post-transfer registration */
            script_set_variable_value(state, "_upload_filebase", "");
            script_set_variable_value(state, "_upload_area", "");
            script_set_variable_value(state, "_upload_filename", expanded_filename);
            {
                char num_buf[16];
                snprintf(num_buf, sizeof(num_buf), "%d", session->current_filebase);
                script_set_variable_value(state, "_upload_filebase", num_buf);
                snprintf(num_buf, sizeof(num_buf), "%d", session->current_area);
                script_set_variable_value(state, "_upload_area", num_buf);
            }

            /* Build temp path */
            filebase_get_temp_upload_path(session->current_filebase, line_id, temp_path, sizeof(temp_path));

            /* Initiate receive transfer via host callback */
            if (state->host.start_receive_transfer != NULL)
            {
                char msg[256];
                const char *proto_names[] = {"XMODEM", "XMODEM-CRC", "XMODEM-1K", "YMODEM", "YMODEM-G", "ZMODEM"};
                const char *proto_name = (protocol >= 0 && protocol <= 5) ? proto_names[protocol] : "XMODEM-CRC";

                snprintf(msg, sizeof(msg), 
                         "\r\n\033[1;33mReady to receive '%s' via %s.\r\n"
                         "Start your sender now...\033[0m\r\n",
                         expanded_filename, proto_name);
                script_write_output(state, msg);

                if (state->host.start_receive_transfer(state->host.context, temp_path, protocol))
                {
                    state->status = SCRIPT_STATUS_WAIT_TRANSFER;
                    return;
                }
                else
                {
                    script_write_output(state, "\r\n\033[1;31m[Receive failed to start]\033[0m\r\n");
                }
            }
            else
            {
                script_write_output(state, "\r\n[File receive not available]\r\n");
            }
        }
        break;

        default:
            break;
    }
}

static int script_emit_macro_replacement(script_state *state, const char *macro_name, script_buffer *buffer)
{
    const char *replacement = NULL;
    char temp[64];

    if (macro_name == NULL || buffer == NULL)
    {
        return 1;
    }

    if (state != NULL)
    {
        replacement = script_get_variable_value(state, macro_name);
    }

    if (replacement == NULL)
    {
        if (state != NULL && script_stringcasecmp(macro_name, "line") == 0)
        {
            int line_id = state->host.get_line_id != NULL ? state->host.get_line_id(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", line_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "t_handle") == 0)
        {
            int handle = state->host.get_task_handle != NULL ? state->host.get_task_handle(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", handle);
            replacement = temp;
        }
        else if (script_stringcasecmp(macro_name, "time") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                strftime(temp, sizeof(temp), "%H:%M:%S", local_tm);
                replacement = temp;
            }
            else
            {
                replacement = "";
            }
        }
        else if (script_stringcasecmp(macro_name, "date") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                strftime(temp, sizeof(temp), "%Y-%m-%d", local_tm);
                replacement = temp;
            }
            else
            {
                replacement = "";
            }
        }
        else if (script_stringcasecmp(macro_name, "hour") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_hour);
                replacement = temp;
            }
            else
            {
                replacement = "0";
            }
        }
        else if (script_stringcasecmp(macro_name, "minute") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_min);
                replacement = temp;
            }
            else
            {
                replacement = "0";
            }
        }
        else if (script_stringcasecmp(macro_name, "dayofweek") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_wday);
                replacement = temp;
            }
            else
            {
                replacement = "0";
            }
        }
        else if (script_stringcasecmp(macro_name, "day") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_mday);
                replacement = temp;
            }
            else
            {
                replacement = "1";
            }
        }
        else if (script_stringcasecmp(macro_name, "month") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_mon + 1);
                replacement = temp;
            }
            else
            {
                replacement = "1";
            }
        }
        else if (script_stringcasecmp(macro_name, "year") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", 1900 + local_tm->tm_year);
                replacement = temp;
            }
            else
            {
                replacement = "1970";
            }
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "accesslevel") == 0)
        {
            int level = state->host.get_user_accesslevel != NULL ? state->host.get_user_accesslevel(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", level);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userid") == 0)
        {
            int user_id = state->host.get_user_id != NULL ? state->host.get_user_id(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", user_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "registered") == 0)
        {
            int user_id = state->host.get_user_id != NULL ? state->host.get_user_id(state->host.context) : 0;
            replacement = user_id > 0 ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "sysop") == 0)
        {
            int is_sysop = state->host.get_user_sysop != NULL ? state->host.get_user_sysop(state->host.context) : 0;
            replacement = is_sysop ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "keys") == 0)
        {
            const char *keys = state->host.get_user_keys != NULL ? state->host.get_user_keys(state->host.context) : "";
            replacement = (keys != NULL) ? keys : "";
        }
        else
        {
            replacement = "";
        }
    }

    if (!script_buffer_append_string(buffer, replacement))
    {
        script_set_error(state, "Out of memory expanding text");
        return 0;
    }

    return 1;
}

static int script_expand_macros_to_buffer(script_state *state, const char *input, script_buffer *buffer, int translate_newlines)
{
    size_t i;
    unsigned char current;
    size_t start;
    size_t end;
    size_t macro_len;
    char macro_name[64];
    size_t previous_length;

    if (buffer == NULL)
    {
        return 0;
    }

    if (input == NULL)
    {
        return 1;
    }

    for (i = 0; input[i] != '\0'; ++i)
    {
        current = (unsigned char)input[i];

        if (current == 0xC2 && (unsigned char)input[i + 1] == 0xA7)
        {
            i++;
            current = 0xA7;
        }

        if (current == 0xA7)
        {
            start = i + 1;
            end = start;

            while (input[end] != '\0' && (unsigned char)input[end] != 0xA7)
            {
                end++;
            }

            if ((unsigned char)input[end] == 0xA7)
            {
                macro_len = end - start;

                if (macro_len >= sizeof(macro_name))
                {
                    macro_len = sizeof(macro_name) - 1;
                }
                memcpy(macro_name, &input[start], macro_len);
                macro_name[macro_len] = '\0';

                if (!script_emit_macro_replacement(state, macro_name, buffer))
                {
                    return 0;
                }

                i = end;
                continue;
            }
        }

        if (current == '%' && input[i + 1] == '{')
        {
            start = i + 2;
            end = start;

            while (input[end] != '\0' && input[end] != '}')
            {
                end++;
            }

            if (input[end] == '}')
            {
                macro_len = end - start;

                if (macro_len >= sizeof(macro_name))
                {
                    macro_len = sizeof(macro_name) - 1;
                }
                memcpy(macro_name, &input[start], macro_len);
                macro_name[macro_len] = '\0';

                if (!script_emit_macro_replacement(state, macro_name, buffer))
                {
                    return 0;
                }

                i = end;
                continue;
            }
        }

        if (translate_newlines && current == '\n')
        {
            previous_length = buffer->length;
            if (previous_length > 0 && buffer->data[previous_length - 1] == '\r')
            {
                if (!script_buffer_append_char(buffer, '\n'))
                {
                    script_set_error(state, "Out of memory expanding text");
                    return 0;
                }
            }
            else
            {
                if (!script_buffer_append_char(buffer, '\r') || !script_buffer_append_char(buffer, '\n'))
                {
                    script_set_error(state, "Out of memory expanding text");
                    return 0;
                }
            }
        }
        else
        {
            if (!script_buffer_append_char(buffer, (char)current))
            {
                script_set_error(state, "Out of memory expanding text");
                return 0;
            }
        }
    }

    return 1;
}

static void script_expand_macros(script_state *state, const char *input, char *buffer, size_t length)
{
    script_buffer expanded;
    size_t copy_len = 0;

    if (buffer == NULL || length == 0)
    {
        return;
    }

    script_buffer_init(&expanded);
    if (!script_expand_macros_to_buffer(state, input, &expanded, 0))
    {
        buffer[0] = '\0';
        script_buffer_free(&expanded);
        return;
    }

    if (expanded.length > 0 && expanded.data != NULL)
    {
        copy_len = expanded.length;
        if (copy_len >= length)
        {
            copy_len = length - 1;
        }
        memcpy(buffer, expanded.data, copy_len);
        buffer[copy_len] = '\0';
    }
    else
    {
        buffer[0] = '\0';
    }

    script_buffer_free(&expanded);
}

static void script_translate_escapes(char *text)
{
    size_t read_index = 0;
    size_t write_index = 0;
    char next;

    if (text == NULL)
    {
        return;
    }

    while (text[read_index] != '\0')
    {
        if (text[read_index] == '\\' && text[read_index + 1] != '\0')
        {
            next = text[read_index + 1];
            switch (next)
            {
                    case 'n':
                        text[write_index++] = '\r';
                        text[write_index++] = '\n';
                        break;
                    case 'r':
                        if (text[read_index + 2] == '\\' && text[read_index + 3] == 'n')
                        {
                            read_index += 2;
                            continue;
                        }
                        text[write_index++] = '\r';
                        break;
                case 't': text[write_index++] = '\t'; break;
                case '\\': text[write_index++] = '\\'; break;
                default:
                    text[write_index++] = next;
                    break;
            }
            read_index += 2;
        }
        else
        {
            text[write_index++] = text[read_index++];
        }
    }

    text[write_index] = '\0';
}

static void script_set_error(script_state *state, const char *fmt, ...)
{
    va_list args;
    if (state == NULL)
    {
        return;
    }

    va_start(args, fmt);
    vsnprintf(state->last_error, sizeof(state->last_error), fmt, args);
    va_end(args);
}

static void script_reset_input(script_state *state)
{
    state->input_mode = SCRIPT_INPUT_NONE;
    state->input_echo = 0;
    state->input_length = 0;
    if (state->input_buffer != NULL && state->input_capacity > 0)
    {
        state->input_buffer[0] = '\0';
    }
    state->input_target[0] = '\0';
}

static void script_write_output(script_state *state, const char *text)
{
    if (state != NULL && state->host.write_text != NULL && text != NULL)
    {
        state->host.write_text(state->host.context, text);
    }
}

static void script_set_variable_value(script_state *state, const char *name, const char *value)
{
    script_variable *var = script_find_variable(state, name, 1);
    if (var == NULL)
    {
        return;
    }

    free(var->value);
    var->value = script_duplicate_string(value != NULL ? value : "");
}

static const char *script_get_variable_value(const script_state *state, const char *name)
{
    size_t i;

    if (state == NULL || name == NULL)
    {
        return NULL;
    }

    for (i = 0; i < state->variable_count; ++i)
    {
        if (script_stringcasecmp(state->variables[i].name, name) == 0)
        {
            return state->variables[i].value;
        }
    }

    return NULL;
}

static int script_parse_backtick_string(const char *input, size_t *consumed, char **output)
{
    const char *start;
    const char *end;
    if (input == NULL || *input != '`')
    {
        return 0;
    }

    start = input + 1;
    end = strchr(start, '`');
    if (end == NULL)
    {
        return 0;
    }

    if (consumed != NULL)
    {
        *consumed = (size_t)(end - input) + 1;
    }

    *output = (char *)malloc((size_t)(end - start) + 1);
    if (*output == NULL)
    {
        return 0;
    }
    memcpy(*output, start, (size_t)(end - start));
    (*output)[end - start] = '\0';
    return 1;
}

static char *script_trim(char *text)
{
    char *start;
    char *end;

    if (text == NULL)
    {
        return NULL;
    }

    start = text;
    while (*start && isspace((unsigned char)*start))
    {
        start++;
    }

    end = start + strlen(start);
    while (end > start && isspace((unsigned char)*(end - 1)))
    {
        end--;
    }
    *end = '\0';
    return start;
}

static int script_is_empty_or_comment(const char *line)
{
    if (line == NULL)
    {
        return 1;
    }

    while (*line != '\0')
    {
        if (*line == '#')
        {
            return 1;
        }
        if (!isspace((unsigned char)*line))
        {
            return 0;
        }
        line++;
    }

    return 1;
}

static void script_free_instruction(script_instruction *instruction)
{
    if (instruction == NULL)
    {
        return;
    }

    free(instruction->arg1);
    free(instruction->arg2);
    free(instruction->arg3);
    free(instruction->arg4);
    instruction->arg1 = instruction->arg2 = instruction->arg3 = instruction->arg4 = NULL;
}

static void script_free_label(script_label *label)
{
    if (label == NULL)
    {
        return;
    }

    free(label->name);
    label->name = NULL;
}

static void script_free_variable(script_variable *variable)
{
    if (variable == NULL)
    {
        return;
    }
    free(variable->value);
    variable->value = NULL;
}

static clock_t script_calculate_sleep_deadline(unsigned int milliseconds)
{
    clock_t ticks = (clock_t)(((double)milliseconds / 1000.0) * CLOCKS_PER_SEC);
    if (ticks < 1)
    {
        ticks = 1;
    }
    return clock() + ticks;
}

static int script_stringcasecmp(const char *lhs, const char *rhs)
{
    unsigned char cl;
    unsigned char cr;

    if (lhs == NULL)
    {
        lhs = "";
    }
    if (rhs == NULL)
    {
        rhs = "";
    }

    while (*lhs != '\0' && *rhs != '\0')
    {
        cl = (unsigned char)tolower((unsigned char)*lhs);
        cr = (unsigned char)tolower((unsigned char)*rhs);
        if (cl != cr)
        {
            return (int)cl - (int)cr;
        }
        lhs++;
        rhs++;
    }

    cl = (unsigned char)tolower((unsigned char)*lhs);
    cr = (unsigned char)tolower((unsigned char)*rhs);
    return (int)cl - (int)cr;
}

static void script_apply_colour_change(script_state *state, const char *fg_text, const char *bg_text, int apply_fg, int apply_bg)
{
    char sequence[32];
    int length = 0;
    int fg_value;
    int bg_value;

    if (state == NULL)
    {
        return;
    }

    if (apply_fg && fg_text != NULL)
    {
        fg_value = atoi(fg_text);
        if (fg_value < 0)
        {
            fg_value = 0;
        }
        if (fg_value > 7)
        {
            fg_value = 7;
        }
        length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, "%s%d", (length == 0) ? "\x1B[" : ";", 30 + fg_value);
    }

    if (apply_bg && bg_text != NULL)
    {
        bg_value = atoi(bg_text);
        if (bg_value < 0)
        {
            bg_value = 0;
        }
        if (bg_value > 7)
        {
            bg_value = 7;
        }
        length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, "%s%d", (length == 0) ? "\x1B[" : ";", 40 + bg_value);
    }

    if (length > 0 && length < (int)sizeof(sequence))
    {
        sequence[length++] = 'm';
        sequence[length] = '\0';
        script_write_output(state, sequence);
    }
}

static void script_send_clear_screen(script_state *state)
{
    if (state == NULL)
    {
        return;
    }
    script_write_output(state, "\x1B[2J\x1B[H");
}

static void script_move_cursor(script_state *state, const char *col_text, const char *row_text)
{
    int column = (col_text != NULL) ? atoi(col_text) : 1;
    int row = (row_text != NULL) ? atoi(row_text) : 1;
    char sequence[32];

    if (state == NULL)
    {
        return;
    }

    if (column < 1)
    {
        column = 1;
    }
    if (row < 1)
    {
        row = 1;
    }

    snprintf(sequence, sizeof(sequence), "\x1B[%d;%dH", row, column);
    script_write_output(state, sequence);
}

static void script_display_file(script_state *state, const char *source)
{
    char path[256];
    FILE *fp;
    long file_size;
    size_t length;
    char *buffer = NULL;
    int parsed;

    if (state == NULL || source == NULL)
    {
        return;
    }

    script_expand_macros(state, source, path, sizeof(path));
    if (path[0] == '\0')
    {
        script_write_output(state, "\r\n[Type: missing filename]\r\n");
        return;
    }

    fp = fopen(path, "rb");
    if (fp == NULL)
    {
        char message[256];
        snprintf(message, sizeof(message), "\r\n[Type: cannot open %s]\r\n", path);
        script_write_output(state, message);
        return;
    }

    if (fseek(fp, 0, SEEK_END) != 0)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: unable to read file]\r\n");
        return;
    }

    file_size = ftell(fp);
    if (file_size < 0)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: unable to read file]\r\n");
        return;
    }

    if (fseek(fp, 0, SEEK_SET) != 0)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: unable to read file]\r\n");
        return;
    }

    length = (size_t)file_size;
    buffer = (char *)malloc(length + 1);
    if (buffer == NULL)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: out of memory]\r\n");
        return;
    }

    if (length > 0 && fread(buffer, 1, length, fp) != length)
    {
        free(buffer);
        fclose(fp);
        script_write_output(state, "\r\n[Type: read error]\r\n");
        return;
    }

    buffer[length] = '\0';
    fclose(fp);

    parsed = script_process_embedded_content(state, buffer, length, path, script_handle_embedded_text_as_output, script_handle_embedded_command_as_output, NULL);
    if (!parsed)
    {
        char message[256];
        if (state != NULL && state->last_error[0] != '\0')
        {
            snprintf(message, sizeof(message), "\r\n[Type: %s]\r\n", state->last_error);
        }
        else
        {
            snprintf(message, sizeof(message), "\r\n[Type: parse error]\r\n");
        }
        script_write_output(state, message);
    }

    free(buffer);
}

static char *script_duplicate_range(const char *source, size_t length)
{
    char *copy;

    if (source == NULL)
    {
        return NULL;
    }

    copy = (char *)malloc(length + 1);
    if (copy == NULL)
    {
        return NULL;
    }

    if (length > 0)
    {
        memcpy(copy, source, length);
    }
    copy[length] = '\0';
    return copy;
}

static void script_buffer_init(script_buffer *buffer)
{
    if (buffer == NULL)
    {
        return;
    }
    buffer->data = NULL;
    buffer->length = 0;
    buffer->capacity = 0;
}

static void script_buffer_free(script_buffer *buffer)
{
    if (buffer == NULL)
    {
        return;
    }
    free(buffer->data);
    buffer->data = NULL;
    buffer->length = 0;
    buffer->capacity = 0;
}

static void script_buffer_clear(script_buffer *buffer)
{
    if (buffer == NULL)
    {
        return;
    }
    buffer->length = 0;
    if (buffer->data != NULL)
    {
        buffer->data[0] = '\0';
    }
}

static int script_buffer_append_char(script_buffer *buffer, char ch)
{
    size_t required;
    size_t new_capacity;
    char *resized;

    if (buffer == NULL)
    {
        return 0;
    }

    required = buffer->length + 2;
    if (required > buffer->capacity)
    {
        new_capacity = buffer->capacity == 0 ? SCRIPT_LITERAL_BUFFER_CHUNK : buffer->capacity * 2;
        while (new_capacity < required)
        {
            new_capacity *= 2;
        }
        resized = (char *)realloc(buffer->data, new_capacity);
        if (resized == NULL)
        {
            return 0;
        }
        buffer->data = resized;
        buffer->capacity = new_capacity;
    }

    buffer->data[buffer->length++] = ch;
    buffer->data[buffer->length] = '\0';
    return 1;
}

static int script_buffer_append_string(script_buffer *buffer, const char *text)
{
    if (buffer == NULL || text == NULL)
    {
        return 1;
    }

    while (*text != '\0')
    {
        if (!script_buffer_append_char(buffer, *text++))
        {
            return 0;
        }
    }

    return 1;
}

static void script_buffer_trim_trailing_whitespace(script_buffer *buffer)
{
    if (buffer == NULL || buffer->data == NULL)
    {
        return;
    }

    while (buffer->length > 0)
    {
        unsigned char ch = (unsigned char)buffer->data[buffer->length - 1];
        if (!isspace(ch))
        {
            break;
        }
        buffer->length--;
        buffer->data[buffer->length] = '\0';
    }
}

static int script_buffer_has_embedded_blocks(const char *buffer, size_t length)
{
    size_t index = 0;
    char ch;

    if (buffer == NULL)
    {
        return 0;
    }

    while (index < length)
    {
        ch = buffer[index];

        if (ch == '/' && index + 1 < length && buffer[index + 1] == '*')
        {
            index += 2;
            while (index < length)
            {
                if (buffer[index] == '*' && index + 1 < length && buffer[index + 1] == '/')
                {
                    index += 2;
                    break;
                }
                index++;
            }
            continue;
        }

        if (ch == '{')
        {
            if (index + 1 >= length || buffer[index + 1] != '{')
            {
                return 1;
            }
            index += 2;
            continue;
        }

        index++;
    }

    return 0;
}

static char *script_strip_block_comments(const char *buffer, size_t length)
{
    char *result;
    size_t src = 0;
    size_t dst = 0;

    if (buffer == NULL || length == 0)
    {
        return NULL;
    }

    result = (char *)malloc(length + 1);
    if (result == NULL)
    {
        return NULL;
    }

    while (src < length)
    {
        if (buffer[src] == '/' && src + 1 < length && buffer[src + 1] == '*')
        {
            src += 2;
            while (src < length)
            {
                if (buffer[src] == '*' && src + 1 < length && buffer[src + 1] == '/')
                {
                    src += 2;
                    break;
                }
                if (buffer[src] == '\n')
                {
                    result[dst++] = '\n';
                }
                src++;
            }
        }
        else
        {
            result[dst++] = buffer[src++];
        }
    }

    result[dst] = '\0';
    return result;
}

static int script_parse_plain_lines(script_state *state, const char *buffer)
{
    int line_number = 0;
    const char *cursor = buffer;

    if (buffer == NULL)
    {
        return 1;
    }

    while (*cursor != '\0')
    {
        const char *line_start = cursor;
        size_t len;
        char *line_copy;

        while (*cursor != '\0' && *cursor != '\n')
        {
            cursor++;
        }

        len = (size_t)(cursor - line_start);
        line_copy = (char *)malloc(len + 1);
        if (line_copy == NULL)
        {
            script_set_error(state, "Out of memory parsing script");
            return 0;
        }

        if (len > 0)
        {
            memcpy(line_copy, line_start, len);
        }
        line_copy[len] = '\0';
        if (len > 0 && line_copy[len - 1] == '\r')
        {
            line_copy[len - 1] = '\0';
        }

        line_number++;
        if (!script_parse_line(state, line_copy, line_number))
        {
            free(line_copy);
            return 0;
        }

        free(line_copy);
        if (*cursor == '\n')
        {
            cursor++;
        }
    }

    return 1;
}

static int script_append_print_literal(script_state *state, const char *text, size_t length)
{
    script_instruction instruction;
    script_buffer normalised;
    size_t i;
    char ch;

    if (text == NULL || length == 0)
    {
        return 1;
    }

    script_buffer_init(&normalised);
    for (i = 0; i < length; ++i)
    {
        ch = text[i];

        if (ch == '\n')
        {
            size_t prev_len = normalised.length;
            if (prev_len > 0 && normalised.data[prev_len - 1] == '\r')
            {
                if (!script_buffer_append_char(&normalised, '\n'))
                {
                    script_buffer_free(&normalised);
                    script_set_error(state, "Out of memory storing literal text");
                    return 0;
                }
            }
            else
            {
                if (!script_buffer_append_char(&normalised, '\r') || !script_buffer_append_char(&normalised, '\n'))
                {
                    script_buffer_free(&normalised);
                    script_set_error(state, "Out of memory storing literal text");
                    return 0;
                }
            }
            continue;
        }

        if (!script_buffer_append_char(&normalised, ch))
        {
            script_buffer_free(&normalised);
            script_set_error(state, "Out of memory storing literal text");
            return 0;
        }
    }

    if (normalised.length == 0)
    {
        script_buffer_free(&normalised);
        return 1;
    }

    memset(&instruction, 0, sizeof(instruction));
    instruction.type = SCRIPT_CMD_PRINT;
    instruction.arg1 = script_duplicate_range(normalised.data, normalised.length);
    script_buffer_free(&normalised);
    if (instruction.arg1 == NULL)
    {
        script_set_error(state, "Out of memory storing literal text");
        return 0;
    }

    if (!script_append_instruction(state, &instruction))
    {
        script_free_instruction(&instruction);
        script_set_error(state, "Too many instructions while expanding text");
        return 0;
    }

    return 1;
}

static int script_execute_inline_command(script_state *state, const char *command_text, int line_number)
{
    script_instruction instruction;
    char *copy;
    char *trimmed;

    if (command_text == NULL)
    {
        return 1;
    }

    copy = script_duplicate_string(command_text);
    if (copy == NULL)
    {
        script_set_error(state, "Out of memory parsing inline command");
        return 0;
    }

    trimmed = script_trim(copy);
    if (*trimmed == '\0' || script_is_empty_or_comment(trimmed))
    {
        free(copy);
        return 1;
    }

    memset(&instruction, 0, sizeof(instruction));
    if (!script_build_instruction(state, trimmed, line_number, &instruction))
    {
        free(copy);
        return 0;
    }

    free(copy);

    if (instruction.type != SCRIPT_CMD_NONE)
    {
        script_execute_instruction(state, &instruction);
        script_free_instruction(&instruction);
    }

    return 1;
}

static int script_skip_comment(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name)
{
    size_t cursor;

    if (buffer == NULL || index == NULL)
    {
        return 0;
    }

    cursor = *index + 2;
    while (cursor < length)
    {
        if (buffer[cursor] == '\n' && line_number != NULL)
        {
            (*line_number)++;
        }

        if (buffer[cursor] == '*' && cursor + 1 < length && buffer[cursor + 1] == '/')
        {
            *index = cursor + 2;
            return 1;
        }
        cursor++;
    }

    script_set_error(state, "Unterminated comment in %s", source_name != NULL ? source_name : "script");
    *index = length;
    return 0;
}

static int script_process_embedded_block(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name, script_command_handler command_handler, void *context)
{
    script_buffer command;
    int result = 1;

    if (command_handler == NULL)
    {
        return 0;
    }

    script_buffer_init(&command);

    while (*index < length)
    {
        char ch;

        while (*index < length)
        {
            ch = buffer[*index];
            if (ch == '\r')
            {
                (*index)++;
                continue;
            }
            if (ch == '\n')
            {
                if (line_number != NULL)
                {
                    (*line_number)++;
                }
                (*index)++;
                continue;
            }
            if (ch == ' ' || ch == '\t' || ch == ',')
            {
                (*index)++;
                continue;
            }
            if (ch == '/' && *index + 1 < length && buffer[*index + 1] == '*')
            {
                if (!script_skip_comment(state, buffer, length, index, line_number, source_name))
                {
                    result = 0;
                    break;
                }
                continue;
            }
            break;
        }

        if (!result)
        {
            break;
        }

        if (*index >= length)
        {
            script_set_error(state, "Missing } in %s", source_name != NULL ? source_name : "script");
            result = 0;
            break;
        }

        if (buffer[*index] == '}')
        {
            (*index)++;
            break;
        }

        script_buffer_clear(&command);
        {
            int in_quote = 0;
            int in_macro = 0; /* Track %{...} macro depth */
            while (*index < length)
            {
                ch = buffer[*index];

                if (ch == '\r')
                {
                    (*index)++;
                    continue;
                }

                if (!in_quote && ch == '/' && *index + 1 < length && buffer[*index + 1] == '*')
                {
                    if (!script_skip_comment(state, buffer, length, index, line_number, source_name))
                    {
                        result = 0;
                        break;
                    }
                    continue;
                }

                if (ch == '`')
                {
                    in_quote = !in_quote;
                }
                else if (ch == '\n')
                {
                    if (!in_quote)
                    {
                        break;
                    }
                    script_set_error(state, "Missing ` in %s", source_name != NULL ? source_name : "script");
                    result = 0;
                    break;
                }
                else if (!in_quote && !in_macro && (ch == ',' || ch == '}'))
                {
                    break;
                }
                
                /* Track %{ macro start */
                if (!in_quote && ch == '%' && *index + 1 < length && buffer[*index + 1] == '{')
                {
                    in_macro++;
                }
                /* Track } that closes a macro */
                else if (!in_quote && in_macro > 0 && ch == '}')
                {
                    in_macro--;
                }

                if (!script_buffer_append_char(&command, ch))
                {
                    script_set_error(state, "Out of memory parsing %s", source_name != NULL ? source_name : "script");
                    result = 0;
                    break;
                }

                (*index)++;
            }
        }

        if (!result)
        {
            break;
        }

        script_buffer_trim_trailing_whitespace(&command);
        if (command.data != NULL && command.length > 0)
        {
            char *trimmed = script_trim(command.data);
            if (*trimmed != '\0' && !script_is_empty_or_comment(trimmed))
            {
                if (!command_handler(state, trimmed, line_number != NULL ? *line_number : 0, context))
                {
                    result = 0;
                    break;
                }
            }
        }

        if (*index < length)
        {
            ch = buffer[*index];
            if (ch == ',')
            {
                (*index)++;
            }
            else if (ch == '\n')
            {
                if (line_number != NULL)
                {
                    (*line_number)++;
                }
                (*index)++;
            }
        }
    }

    script_buffer_free(&command);
    return result;
}

static int script_process_embedded_content(script_state *state, const char *buffer, size_t length, const char *source_name, script_text_handler text_handler, script_command_handler command_handler, void *context)
{
    size_t index = 0;
    int line_number = 1;
    script_buffer literal;
    int result = 1;
    char ch;

    if (text_handler == NULL || command_handler == NULL)
    {
        return 0;
    }

    script_buffer_init(&literal);

    while (index < length && result)
    {
        ch = buffer[index];

        if (ch == '\r')
        {
            index++;
            continue;
        }

        if (ch == '/' && index + 1 < length && buffer[index + 1] == '*')
        {
            if (!script_skip_comment(state, buffer, length, &index, &line_number, source_name))
            {
                result = 0;
            }
            continue;
        }

        if (ch == '{')
        {
            if (index + 1 < length && buffer[index + 1] == '{')
            {
                index++;
                ch = '{';
            }
            else
            {
                if (literal.length > 0)
                {
                    if (!text_handler(state, literal.data, literal.length, line_number, context))
                    {
                        result = 0;
                        break;
                    }
                    script_buffer_clear(&literal);
                }
                index++;
                if (!script_process_embedded_block(state, buffer, length, &index, &line_number, source_name, command_handler, context))
                {
                    result = 0;
                }
                continue;
            }
        }

        if (ch == '\n')
        {
            line_number++;
        }

        if (!script_buffer_append_char(&literal, ch))
        {
            script_set_error(state, "Out of memory processing %s", source_name != NULL ? source_name : "script");
            result = 0;
            break;
        }

        index++;
    }

    if (result && literal.length > 0)
    {
        if (!text_handler(state, literal.data, literal.length, line_number, context))
        {
            result = 0;
        }
    }

    script_buffer_free(&literal);
    return result;
}

static int script_handle_embedded_text_as_instruction(script_state *state, const char *text, size_t length, int line_number, void *context)
{
    (void)line_number;
    (void)context;
    return script_append_print_literal(state, text, length);
}

static int script_handle_embedded_command_as_instruction(script_state *state, const char *command_text, int line_number, void *context)
{
    (void)context;
    return script_parse_line(state, command_text, line_number);
}

static int script_handle_embedded_text_as_output(script_state *state, const char *text, size_t length, int line_number, void *context)
{
    (void)line_number;
    (void)context;
    if (state == NULL || text == NULL || length == 0)
    {
        return 1;
    }

    {
        char *literal = script_duplicate_range(text, length);
        script_buffer expanded;

        if (literal == NULL)
        {
            script_set_error(state, "Out of memory expanding text");
            return 0;
        }

        script_buffer_init(&expanded);
        if (!script_expand_macros_to_buffer(state, literal, &expanded, 1))
        {
            free(literal);
            script_buffer_free(&expanded);
            return 0;
        }

        if (expanded.length > 0 && expanded.data != NULL)
        {
            script_write_output(state, expanded.data);
        }

        script_buffer_free(&expanded);
        free(literal);
    }

    return 1;
}

static int script_handle_embedded_command_as_output(script_state *state, const char *command_text, int line_number, void *context)
{
    (void)context;
    return script_execute_inline_command(state, command_text, line_number);
}
