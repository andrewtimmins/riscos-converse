#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdarg.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "debug.h"
#include "script.h"
#include "filebase.h"
#include "messagebase.h"
#include "main.h"

#define SCRIPT_DEFAULT_INSTRUCTION_CAPACITY 32
#define SCRIPT_DEFAULT_LABEL_CAPACITY 16
#define SCRIPT_DEFAULT_VARIABLE_CAPACITY 8
#define SCRIPT_INPUT_BUFFER_CHUNK 64
#define SCRIPT_LITERAL_BUFFER_CHUNK 256
#define SCRIPT_MAX_INSTRUCTIONS_PER_POLL 1000  /* Prevent infinite loops from locking up */
#define SCRIPT_ANSI_DETECT_TIMEOUT_CS 300  /* 3 second timeout in centiseconds */
#define SCRIPT_MAX_IF_DEPTH 16  /* Maximum nesting depth for IF/THEN blocks */
#define SCRIPT_MAX_LOOP_DEPTH 16  /* Maximum nesting depth for loops */

/* IF block tracking for compile-time transformation */
typedef struct script_if_block
{
    char else_label[32];
    char endif_label[32];
    int has_else;
} script_if_block;

static script_if_block script_if_stack[SCRIPT_MAX_IF_DEPTH];
static int script_if_depth = 0;
static int script_if_counter = 0;

/* Loop block tracking for compile-time transformation */
typedef enum {
    LOOP_TYPE_FOR,
    LOOP_TYPE_WHILE
} script_loop_type;

typedef struct script_loop_block
{
    script_loop_type type;
    char start_label[32];   /* Label at loop start (for CONTINUE in WHILE) */
    char test_label[32];    /* Label at loop test (for CONTINUE in FOR) */
    char end_label[32];     /* Label after loop (for BREAK) */
    char var_name[64];      /* FOR loop variable name */
} script_loop_block;

static script_loop_block script_loop_stack[SCRIPT_MAX_LOOP_DEPTH];
static int script_loop_depth = 0;
static int script_loop_counter = 0;

/* Preserve user "more" preference while composer runs */
static int composer_more_saved = -1;

/* Preserve user "more" preference during protocol selection */
static int protocol_more_saved = -1;

typedef struct script_buffer
{
    char *data;
    size_t length;
    size_t capacity;
} script_buffer;

typedef int (*script_text_handler)(script_state *state, const char *text, size_t length, int line_number, void *context);
typedef int (*script_command_handler)(script_state *state, const char *command_text, int line_number, void *context);

static void script_clear_program(script_state *state);
static void script_clear_variables(script_state *state);
static int script_load_file(script_state *state, const char *path);
static int script_parse_line(script_state *state, const char *line, int line_number);
static int script_build_instruction(script_state *state, char *line, int line_number, script_instruction *instruction);
static char *script_duplicate_string(const char *source);
static char *script_duplicate_range(const char *source, size_t length);
static int script_append_instruction(script_state *state, script_instruction *instr);
static int script_register_label(script_state *state, const char *name);
static void script_execute_instruction(script_state *state, script_instruction *instruction);
static void script_expand_macros(script_state *state, const char *input, char *buffer, size_t length);
static int script_expand_macros_to_buffer(script_state *state, const char *input, script_buffer *buffer, int translate_newlines);
static int script_emit_macro_replacement(script_state *state, const char *macro_name, script_buffer *buffer);
static void script_translate_escapes(char *text);
static void script_set_error(script_state *state, const char *fmt, ...);
static void script_reset_input(script_state *state);
static void script_write_output(script_state *state, const char *text);
/* Exported for ZMODEM auto-start in main.c */
void script_set_variable_value(script_state *state, const char *name, const char *value);
static const char *script_get_variable_value(const script_state *state, const char *name);
static int script_parse_backtick_string(const char *input, size_t *consumed, char **output);
static char *script_trim(char *text);
static int script_is_empty_or_comment(const char *line);
static void script_free_instruction(script_instruction *instruction);
static void script_free_label(script_label *label);
static void script_free_variable(script_variable *variable);
static clock_t script_calculate_sleep_deadline(unsigned int milliseconds);
static int script_stringcasecmp(const char *lhs, const char *rhs);
static char *script_strcasestr(const char *haystack, const char *needle);
static void script_apply_colour_change(script_state *state, const char *fg_text, const char *bg_text, int apply_fg, int apply_bg);
static void script_set_flash(script_state *state, const char *arg);
static void script_send_clear_screen(script_state *state);
static void script_send_clear_to_eol(script_state *state);
static void script_move_cursor(script_state *state, const char *row_text, const char *col_text);
static void script_display_file(script_state *state, const char *source, int trim_newlines);
static void script_start_receive_transfer(script_state *state, int protocol);
static int script_parse_protocol(const char *name);
static void script_buffer_init(script_buffer *buffer);
static void script_buffer_free(script_buffer *buffer);
static void script_buffer_clear(script_buffer *buffer);
static int script_buffer_append_char(script_buffer *buffer, char ch);
static int script_buffer_append_string(script_buffer *buffer, const char *text);
static void script_buffer_trim_trailing_whitespace(script_buffer *buffer);
static int script_buffer_has_embedded_blocks(const char *buffer, size_t length);
static char *script_strip_block_comments(const char *buffer, size_t length);
static int script_parse_plain_lines(script_state *state, const char *buffer);
static int script_append_print_literal(script_state *state, const char *text, size_t length);
static int script_execute_inline_command(script_state *state, const char *command_text, int line_number);
static int script_skip_comment(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name);
static int script_process_embedded_block(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name, script_command_handler command_handler, void *context);
static int script_process_embedded_content(script_state *state, const char *buffer, size_t length, const char *source_name, script_text_handler text_handler, script_command_handler command_handler, void *context);
static int script_handle_embedded_text_as_instruction(script_state *state, const char *text, size_t length, int line_number, void *context);
static int script_handle_embedded_command_as_instruction(script_state *state, const char *command_text, int line_number, void *context);
static void script_reset_if_state(void);
static int script_push_call_stack(script_state *state);
static int script_pop_call_stack(script_state *state);
static int script_handle_embedded_text_as_output(script_state *state, const char *text, size_t length, int line_number, void *context);
static int script_handle_embedded_command_as_output(script_state *state, const char *command_text, int line_number, void *context);
static void script_save_user_history(script_state *state);
static int script_evaluate_condition(script_state *state, const char *condition_expr);
static void script_reset_loop_state(void);
static int script_count_newlines(const char *text);

void script_initialise(script_state *state, const script_host *host)
{
    if (state == NULL)
    {
        return;
    }

    memset(state, 0, sizeof(*state));

    if (host != NULL)
    {
        state->host = *host;
    }

    state->instruction_capacity = SCRIPT_DEFAULT_INSTRUCTION_CAPACITY;
    state->instructions = (script_instruction *)calloc(state->instruction_capacity, sizeof(script_instruction));

    state->label_capacity = SCRIPT_DEFAULT_LABEL_CAPACITY;
    state->labels = (script_label *)calloc(state->label_capacity, sizeof(script_label));

    state->variable_capacity = SCRIPT_DEFAULT_VARIABLE_CAPACITY;
    state->variables = (script_variable *)calloc(state->variable_capacity, sizeof(script_variable));

    state->input_capacity = SCRIPT_INPUT_BUFFER_CHUNK;
    state->input_buffer = (char *)malloc(state->input_capacity);
    if (state->input_buffer != NULL)
    {
        state->input_buffer[0] = '\0';
    }

    state->status = SCRIPT_STATUS_IDLE;
    
    /* More prompt state: -1 = use user setting */
    state->more_override = -1;
    state->more_line_count = 0;
    state->more_screen_lines = 24;
    state->more_pending_text = NULL;
}

void script_dispose(script_state *state)
{
    size_t i;
    
    if (state == NULL)
    {
        return;
    }

    /* Free any call stack entries first */
    while (state->call_depth > 0)
    {
        script_call_frame *frame = &state->call_stack[state->call_depth - 1];
        
        if (frame->instructions != NULL)
        {
            for (i = 0; i < frame->instruction_count; ++i)
            {
                script_free_instruction(&frame->instructions[i]);
            }
            free(frame->instructions);
        }
        
        if (frame->labels != NULL)
        {
            for (i = 0; i < frame->label_count; ++i)
            {
                script_free_label(&frame->labels[i]);
            }
            free(frame->labels);
        }
        
        state->call_depth--;
    }

    script_clear_program(state);
    script_clear_variables(state);

    free(state->instructions);
    state->instructions = NULL;
    state->instruction_count = 0;
    state->instruction_capacity = 0;

    for (i = 0; i < state->label_count; ++i)
    {
        script_free_label(&state->labels[i]);
    }
    free(state->labels);
    state->labels = NULL;
    state->label_count = 0;
    state->label_capacity = 0;

    free(state->input_buffer);
    state->input_buffer = NULL;
    state->input_capacity = 0;
    state->input_length = 0;

    free(state->more_pending_text);
    state->more_pending_text = NULL;

    memset(state, 0, sizeof(*state));
}

int script_start(script_state *state, const char *path)
{
    if (state == NULL)
    {
        return 0;
    }

    script_stop(state);

    if (path == NULL)
    {
        script_set_error(state, "No script path specified");
        state->status = SCRIPT_STATUS_ERROR;
        return 0;
    }

    if (!script_load_file(state, path))
    {
        state->status = SCRIPT_STATUS_ERROR;
        return 0;
    }

    state->program_counter = 0;
    state->status = SCRIPT_STATUS_RUNNING;
    script_reset_input(state);
    return 1;
}

void script_stop(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    script_clear_program(state);
    /* NOTE: Do NOT clear variables here - they persist across script transitions
     * Variables are only cleared on session disconnect via script_reset_session
     * Also do NOT clear call_depth here - subscripts may be active
     */
    state->program_counter = 0;
    state->status = SCRIPT_STATUS_IDLE;
    script_reset_input(state);
}

void script_reset_session(script_state *state)
{
    size_t i;
    
    if (state == NULL)
    {
        return;
    }

    /* Free any call stack entries first (in case we stopped mid-subscript) */
    while (state->call_depth > 0)
    {
        script_call_frame *frame = &state->call_stack[state->call_depth - 1];
        
        if (frame->instructions != NULL)
        {
            for (i = 0; i < frame->instruction_count; ++i)
            {
                script_free_instruction(&frame->instructions[i]);
            }
            free(frame->instructions);
        }
        
        if (frame->labels != NULL)
        {
            for (i = 0; i < frame->label_count; ++i)
            {
                script_free_label(&frame->labels[i]);
            }
            free(frame->labels);
        }
        
        memset(frame, 0, sizeof(*frame));
        state->call_depth--;
    }

    script_stop(state);
    script_clear_variables(state);
    
    /* Reset loop state for new session */
    script_reset_loop_state();
    
    /* Reset more prompt state for new session */
    state->more_override = -1;
    state->more_line_count = 0;
    state->more_screen_lines = 24;
    free(state->more_pending_text);
    state->more_pending_text = NULL;
    state->pending_upload_filename[0] = '\0';
    state->pending_upload_description[0] = '\0';
    state->pending_upload_filebase = 0;
    state->pending_upload_area = 0;
    state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_NONE;
}

void script_process(script_state *state)
{
    int instructions_executed = 0;

    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_SLEEP)
    {
        if ((clock_t)clock() >= state->sleep_deadline)
        {
            state->status = SCRIPT_STATUS_RUNNING;
        }
    }

    /* Check for ANSI detection timeout */
    if (state->status == SCRIPT_STATUS_WAITING && 
        state->input_context == SCRIPT_INPUT_CTX_ANSI_DETECT)
    {
        if ((clock_t)clock() >= state->ansi_deadline)
        {
            /* Timeout - no ANSI response, assume dumb terminal */
            debug_printf("ANSI detect: TIMEOUT - no response received\n");
            script_set_variable_value(state, state->ansi_result_var, "0");
            state->ansi_parse_state = 0;
            state->ansi_response_len = 0;
            state->input_mode = SCRIPT_INPUT_MODE_NONE;
            state->input_context = SCRIPT_INPUT_CTX_NONE;
            state->status = SCRIPT_STATUS_RUNNING;
        }
    }

    while (state->status == SCRIPT_STATUS_RUNNING && state->program_counter < state->instruction_count)
    {
        script_instruction *instruction = &state->instructions[state->program_counter];
        state->program_counter++;
        script_execute_instruction(state, instruction);

        instructions_executed++;
        if (instructions_executed >= SCRIPT_MAX_INSTRUCTIONS_PER_POLL)
        {
            /* Yield to allow other tasks to run - prevents infinite loops from locking system */
            /* Script will continue on next poll */
            return;
        }
    }

    if (state->status == SCRIPT_STATUS_RUNNING && state->program_counter >= state->instruction_count)
    {
        /* Script finished - check if we need to return to a calling script */
        if (script_pop_call_stack(state))
        {
            /* Restored calling script - continue running */
            state->status = SCRIPT_STATUS_RUNNING;
        }
        else
        {
            /* No calling script - we're done */
            state->status = SCRIPT_STATUS_COMPLETED;
        }
    }
}

/* ===========================================================================
 * UNIFIED INPUT HANDLERS
 * These functions handle the common input collection logic, reducing
 * code duplication from the old switch-on-every-state approach.
 * ===========================================================================
 */

/* Forward declarations for context completion handlers */
static int input_complete_prompt(script_state *state);
static int input_complete_anykey(script_state *state);
static int input_complete_logon_user(script_state *state);
static int input_complete_logon_pass(script_state *state);
static int input_complete_newuser_user(script_state *state);
static int input_complete_newuser_pass(script_state *state);
static int input_complete_newuser_pass2(script_state *state);
static int input_complete_newuser_name(script_state *state);
static int input_complete_newuser_email(script_state *state);
static int input_complete_newuser_confirm(script_state *state);
static int input_complete_mb_select(script_state *state);
static int input_complete_mb_area(script_state *state);
static int input_complete_fb_select(script_state *state);
static int input_complete_fb_area(script_state *state);
static int input_complete_upload_file(script_state *state);
static int input_complete_upload_desc(script_state *state);
static int input_complete_protocol(script_state *state);
static int input_complete_chat_reason(script_state *state);
static int input_complete_more(script_state *state);
/* Viewer/browser char input handlers */
static int handle_mb_viewer_char(script_state *state, unsigned char byte);
static int handle_fb_browse_char(script_state *state, unsigned char byte);
static int handle_mb_compose_line(script_state *state);
static int handle_mb_search_line(script_state *state);
/* ANSI detection special handler */
static int handle_ansi_detection_byte(script_state *state, unsigned char byte);

/*
 * Handle line input accumulation (backspace, CR, character accumulation).
 * Returns 1 if input was consumed, 0 if not.
 */
static int handle_line_input_byte(script_state *state, unsigned char byte)
{
    int echo = state->input_echo;
    
    /* Ignore LF - we complete on CR */
    if (byte == '\n')
    {
        return 1;
    }

    /* CR triggers end of input */
    if (byte == '\r')
    {
        state->input_buffer[state->input_length] = '\0';
        if (echo && state->host.write_text != NULL)
        {
            state->host.write_text(state->host.context, "\r\n");
        }
        return -1;  /* Signal: input complete */
    }

    /* Handle backspace (ASCII 8 or 127) */
    if (byte == 8 || byte == 127)
    {
        if (state->input_length > 0)
        {
            state->input_length--;
            state->input_buffer[state->input_length] = '\0';
            if (echo && state->host.write_text != NULL)
            {
                state->host.write_text(state->host.context, "\b \b");
            }
        }
        return 1;
    }

    /* Grow buffer if needed */
    if (state->input_length + 1 >= state->input_capacity)
    {
        size_t new_capacity = state->input_capacity + SCRIPT_INPUT_BUFFER_CHUNK;
        char *resized = (char *)realloc(state->input_buffer, new_capacity);
        if (resized == NULL)
        {
            script_set_error(state, "Out of memory expanding input buffer");
            state->status = SCRIPT_STATUS_ERROR;
            return 0;
        }
        state->input_buffer = resized;
        state->input_capacity = new_capacity;
    }

    /* Accumulate character */
    state->input_buffer[state->input_length++] = (char)byte;
    if (echo && state->host.write_text != NULL)
    {
        char echobuf[2] = { (char)byte, '\0' };
        state->host.write_text(state->host.context, echobuf);
    }
    return 1;
}

/*
 * Dispatch to the appropriate completion handler based on input context.
 * Returns 1 if handled successfully.
 */
static int dispatch_input_complete(script_state *state)
{
    switch (state->input_context)
    {
        case SCRIPT_INPUT_CTX_PROMPT:
            return input_complete_prompt(state);
            
        case SCRIPT_INPUT_CTX_ANYKEY:
            return input_complete_anykey(state);
            
        case SCRIPT_INPUT_CTX_LOGON_USER:
            return input_complete_logon_user(state);
            
        case SCRIPT_INPUT_CTX_LOGON_PASS:
            return input_complete_logon_pass(state);
            
        case SCRIPT_INPUT_CTX_NEWUSER_USER:
            return input_complete_newuser_user(state);
            
        case SCRIPT_INPUT_CTX_NEWUSER_PASS:
            return input_complete_newuser_pass(state);
            
        case SCRIPT_INPUT_CTX_NEWUSER_PASS2:
            return input_complete_newuser_pass2(state);
            
        case SCRIPT_INPUT_CTX_NEWUSER_NAME:
            return input_complete_newuser_name(state);
            
        case SCRIPT_INPUT_CTX_NEWUSER_EMAIL:
            return input_complete_newuser_email(state);
            
        case SCRIPT_INPUT_CTX_NEWUSER_CONFIRM:
            return input_complete_newuser_confirm(state);
            
        case SCRIPT_INPUT_CTX_MB_SELECT:
            return input_complete_mb_select(state);
            
        case SCRIPT_INPUT_CTX_MB_AREA:
            return input_complete_mb_area(state);
            
        case SCRIPT_INPUT_CTX_FB_SELECT:
            return input_complete_fb_select(state);
            
        case SCRIPT_INPUT_CTX_FB_AREA:
            return input_complete_fb_area(state);
            
        case SCRIPT_INPUT_CTX_UPLOAD_FILE:
            return input_complete_upload_file(state);
            
        case SCRIPT_INPUT_CTX_UPLOAD_DESC:
            return input_complete_upload_desc(state);
            
        case SCRIPT_INPUT_CTX_PROTOCOL:
            return input_complete_protocol(state);
            
        case SCRIPT_INPUT_CTX_CHAT_REASON:
            return input_complete_chat_reason(state);
            
        case SCRIPT_INPUT_CTX_MORE:
            return input_complete_more(state);
            
        case SCRIPT_INPUT_CTX_MB_COMPOSE:
            return handle_mb_compose_line(state);
            
        case SCRIPT_INPUT_CTX_MB_SEARCH:
            return handle_mb_search_line(state);
            
        /* Note: MB_VIEWER and FB_BROWSE use char mode and are handled
         * directly in script_handle_user_byte, not via dispatch_input_complete */
            
        default:
            /* Unknown context - resume script */
            state->status = SCRIPT_STATUS_RUNNING;
            script_process(state);
            return 1;
    }
}

/* ===========================================================================
 * INPUT COMPLETION HANDLERS
 * Called when input is complete for a specific context.
 * These extract the logic from the old monolithic script_handle_user_byte.
 * ===========================================================================
 */

/* PROMPT/READLINE command completion */
static int input_complete_prompt(script_state *state)
{
    /* Store the input in the target variable */
    script_set_variable_value(state, state->input_target, state->input_buffer);
    state->more_line_count = 0;  /* Reset line count after input */
    script_clear_input(state);
    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

/* ANYKEY command completion - any key was pressed */
static int input_complete_anykey(script_state *state)
{
    script_clear_input(state);
    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

/* More prompt completion - user pressed a key */
static int input_complete_more(script_state *state)
{
    char key = (state->input_length > 0) ? state->input_buffer[0] : 0;
    
    /* Clear the "More?" prompt from the line */
    if (state->host.write_text != NULL)
    {
        state->host.write_text(state->host.context, "\r\033[K");
    }
    
    /* Check for quit/abort keys */
    if (key == 'q' || key == 'Q' || key == 'n' || key == 'N' || key == 3)  /* 3 = Ctrl+C */
    {
        /* User wants to stop - disable more for this session */
        state->more_override = 0;
        state->more_line_count = 0;
        /* Discard pending text */
        free(state->more_pending_text);
        state->more_pending_text = NULL;
    }
    else
    {
        /* Continue - reset line counter for next page */
        state->more_line_count = 0;
        
        /* Output the pending text that triggered the More? prompt */
        if (state->more_pending_text != NULL && state->host.write_text != NULL)
        {
            state->host.write_text(state->host.context, state->more_pending_text);
            state->more_line_count = script_count_newlines(state->more_pending_text);
            free(state->more_pending_text);
            state->more_pending_text = NULL;
        }
    }
    
    script_clear_input(state);
    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

/* Stub handlers - these will be filled in as we migrate each context */

static int input_complete_logon_user(script_state *state)
{
    /* Check if user typed NEW */
    if (script_stringcasecmp(state->input_buffer, "NEW") == 0)
    {
        /* User wants to register - start newuser script */
        if (state->host.start_newuser != NULL)
        {
            state->host.start_newuser(state->host.context);
        }
        return 1;
    }

    /* Store the username and prompt for password */
    strncpy(state->logon_username, state->input_buffer, sizeof(state->logon_username) - 1);
    state->logon_username[sizeof(state->logon_username) - 1] = '\0';

    script_write_output(state, "Password: ");
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE_NOECHO, SCRIPT_INPUT_CTX_LOGON_PASS);
    return 1;
}

static int input_complete_logon_pass(script_state *state)
{
    int auth_result = 0;
    int authenticated = 0;

    /* Attempt authentication */
    if (state->host.authenticate_user != NULL)
    {
        authenticated = state->host.authenticate_user(
            state->host.context,
            state->logon_username,
            state->input_buffer,
            &auth_result
        );
    }

    if (authenticated)
    {
        /* Success - run postlogon script */
        script_write_output(state, "\r\n\033[1;32mLogin successful!\033[0m\r\n\r\n");
        if (state->host.start_postlogon != NULL)
        {
            state->host.start_postlogon(state->host.context);
        }
        return 1;
    }

    /* Authentication failed */
    state->logon_attempts++;

    if (auth_result == 1)
    {
        script_write_output(state, "\r\n\033[1;31mUsername not found.\033[0m\r\n");
    }
    else if (auth_result == 2)
    {
        script_write_output(state, "\r\n\033[1;31mIncorrect password.\033[0m\r\n");
    }
    else if (auth_result == 3)
    {
        script_write_output(state, "\r\n\033[1;31mAccount is locked.\033[0m\r\n");
        if (state->host.force_disconnect != NULL)
        {
            state->host.force_disconnect(state->host.context);
        }
        state->status = SCRIPT_STATUS_COMPLETED;
        return 1;
    }
    else
    {
        script_write_output(state, "\r\n\033[1;31mLogin failed.\033[0m\r\n");
    }

    /* Check retry limit */
    if (state->logon_attempts >= 3)
    {
        script_write_output(state, "\r\n\033[1;31mToo many failed attempts.\033[0m\r\n");
        if (state->host.force_disconnect != NULL)
        {
            state->host.force_disconnect(state->host.context);
        }
        state->status = SCRIPT_STATUS_COMPLETED;
        return 1;
    }

    /* Allow retry - prompt for username again */
    script_write_output(state, "\r\nUsername: ");
    state->logon_username[0] = '\0';
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_LOGON_USER);
    return 1;
}

static int input_complete_newuser_user(script_state *state)
{
    /* Empty username - abort */
    if (state->input_length == 0)
    {
        script_write_output(state, "\r\n\033[1;33mRegistration cancelled.\033[0m\r\n");
        state->status = SCRIPT_STATUS_RUNNING;
        return 1;
    }

    /* Validate username length */
    if (state->input_length < 3)
    {
        script_write_output(state, "\r\n\033[1;31mUsername must be at least 3 characters.\033[0m\r\n");
        script_write_output(state, "\r\nUsername: ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    if (state->input_length > 31)
    {
        script_write_output(state, "\r\n\033[1;31mUsername must be 31 characters or less.\033[0m\r\n");
        script_write_output(state, "\r\nUsername: ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    /* Check if username is available */
    if (state->host.check_username_available != NULL)
    {
        if (!state->host.check_username_available(state->host.context, state->input_buffer))
        {
            script_write_output(state, "\r\n\033[1;31mSorry, that username is already taken.\033[0m\r\n");
            script_write_output(state, "\r\nUsername: ");
            state->input_length = 0;
            state->input_buffer[0] = '\0';
            return 1;
        }
    }

    /* Store username and prompt for password */
    strncpy(state->newuser_username, state->input_buffer, sizeof(state->newuser_username) - 1);
    state->newuser_username[sizeof(state->newuser_username) - 1] = '\0';

    script_write_output(state, "\r\nPassword: ");
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE_NOECHO, SCRIPT_INPUT_CTX_NEWUSER_PASS);
    return 1;
}

static int input_complete_newuser_pass(script_state *state)
{
    /* Validate password length */
    if (state->input_length < 4)
    {
        script_write_output(state, "\r\n\033[1;31mPassword must be at least 4 characters.\033[0m\r\n");
        script_write_output(state, "\r\nPassword: ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    if (state->input_length > 31)
    {
        script_write_output(state, "\r\n\033[1;31mPassword must be 31 characters or less.\033[0m\r\n");
        script_write_output(state, "\r\nPassword: ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    /* Store password and prompt for confirmation */
    strncpy(state->newuser_password, state->input_buffer, sizeof(state->newuser_password) - 1);
    state->newuser_password[sizeof(state->newuser_password) - 1] = '\0';

    script_write_output(state, "Confirm Password: ");
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE_NOECHO, SCRIPT_INPUT_CTX_NEWUSER_PASS2);
    return 1;
}

static int input_complete_newuser_pass2(script_state *state)
{
    /* Check passwords match */
    if (strcmp(state->newuser_password, state->input_buffer) != 0)
    {
        script_write_output(state, "\r\n\033[1;31mPasswords do not match. Please try again.\033[0m\r\n");
        script_write_output(state, "\r\nPassword: ");
        state->newuser_password[0] = '\0';
        script_begin_input(state, SCRIPT_INPUT_MODE_LINE_NOECHO, SCRIPT_INPUT_CTX_NEWUSER_PASS);
        return 1;
    }

    /* Passwords match - prompt for real name */
    script_write_output(state, "\r\nReal Name: ");
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_NEWUSER_NAME);
    return 1;
}

static int input_complete_newuser_name(script_state *state)
{
    /* Validate real name */
    if (state->input_length < 2)
    {
        script_write_output(state, "\r\n\033[1;31mPlease enter your real name.\033[0m\r\n");
        script_write_output(state, "\r\nReal Name: ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    if (state->input_length > 63)
    {
        script_write_output(state, "\r\n\033[1;31mName is too long (max 63 characters).\033[0m\r\n");
        script_write_output(state, "\r\nReal Name: ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    /* Store real name and prompt for email */
    strncpy(state->newuser_realname, state->input_buffer, sizeof(state->newuser_realname) - 1);
    state->newuser_realname[sizeof(state->newuser_realname) - 1] = '\0';

    script_write_output(state, "Email (optional): ");
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_NEWUSER_EMAIL);
    return 1;
}

static int input_complete_newuser_email(script_state *state)
{
    char summary[512];

    /* Email is optional - just validate length if provided */
    if (state->input_length > 63)
    {
        script_write_output(state, "\r\n\033[1;31mEmail is too long (max 63 characters).\033[0m\r\n");
        script_write_output(state, "\r\nEmail (optional): ");
        state->input_length = 0;
        state->input_buffer[0] = '\0';
        return 1;
    }

    /* Store email */
    strncpy(state->newuser_email, state->input_buffer, sizeof(state->newuser_email) - 1);
    state->newuser_email[sizeof(state->newuser_email) - 1] = '\0';

    /* Show summary and ask for confirmation */
    script_write_output(state, "\r\n\033[1;36m--- Account Summary ---\033[0m\r\n\r\n");
    snprintf(summary, sizeof(summary),
        "  Username:  \033[1;37m%s\033[0m\r\n"
        "  Real Name: \033[1;37m%s\033[0m\r\n"
        "  Email:     \033[1;37m%s\033[0m\r\n\r\n",
        state->newuser_username,
        state->newuser_realname,
        state->newuser_email[0] ? state->newuser_email : "(not provided)");
    script_write_output(state, summary);

    script_write_output(state, "Create this account? (\033[1;32mY\033[0m/\033[1;31mN\033[0m): ");
    script_begin_input(state, SCRIPT_INPUT_MODE_YESNO, SCRIPT_INPUT_CTX_NEWUSER_CONFIRM);
    return 1;
}

static int input_complete_newuser_confirm(script_state *state)
{
    /* This is called for Y key press - create the account */
    int user_id = 0;

    if (state->host.write_text != NULL)
    {
        state->host.write_text(state->host.context, "Y\r\n\r\n");
    }

    /* Create the user account */
    if (state->host.create_user != NULL)
    {
        user_id = state->host.create_user(
            state->host.context,
            state->newuser_username,
            state->newuser_password,
            state->newuser_realname,
            state->newuser_email
        );
    }

    if (user_id > 0)
    {
        script_write_output(state, "\033[1;32mAccount created successfully!\033[0m\r\n\r\n");
        script_write_output(state, "You can now log in with your new username and password.\r\n\r\n");
    }
    else
    {
        script_write_output(state, "\r\n\033[1;31mSorry, account creation failed. Please try again later.\033[0m\r\n\r\n");
    }

    /* Clear sensitive data */
    memset(state->newuser_password, 0, sizeof(state->newuser_password));
    state->status = SCRIPT_STATUS_RUNNING;
    return 1;
}

static int input_complete_mb_select(script_state *state)
{
    int base_id;
    messagebase_session *session = NULL;
    LINETASK_MESSAGEBASE_RECORD record;

    /* Empty input = cancel */
    if (state->input_length == 0)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    base_id = atoi(state->input_buffer);

    if (state->host.get_messagebase_session != NULL)
    {
        session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
    }

    if (session != NULL && base_id > 0)
    {
        if (messagebase_get_info(base_id, &record))
        {
            if (messagebase_check_access(record.accesslevel, record.keys,
                                          session->user_accesslevel, session->user_keys))
            {
                char msg[128];
                session->current_messagebase = base_id;
                session->current_area = 0;
                script_save_user_history(state);
                snprintf(msg, sizeof(msg), "\033[1;32mSelected: %s\033[0m\r\n", record.name);
                script_write_output(state, msg);
            }
            else
            {
                script_write_output(state, "\033[1;31m[Access denied]\033[0m\r\n");
            }
        }
        else
        {
            script_write_output(state, "\033[1;31m[Messagebase not found]\033[0m\r\n");
        }
    }
    else if (base_id <= 0 && state->input_length > 0)
    {
        script_write_output(state, "\033[1;31m[Invalid ID]\033[0m\r\n");
    }

    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

static int input_complete_mb_area(script_state *state)
{
    int area_id;
    messagebase_session *session = NULL;
    LINETASK_MESSAGEBASE_AREA_RECORD area_record;

    /* Empty input = cancel */
    if (state->input_length == 0)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    area_id = atoi(state->input_buffer);

    if (state->host.get_messagebase_session != NULL)
    {
        session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
    }

    if (session != NULL && area_id >= 0)
    {
        if (area_id == 0)
        {
            /* Select root/all messages */
            session->current_area = 0;
            script_save_user_history(state);
            script_write_output(state, "\033[1;32mSelected: [All Messages]\033[0m\r\n");
        }
        else if (messagebase_get_area_info(session->current_messagebase, area_id, &area_record))
        {
            char msg[128];
            session->current_area = area_id;
            script_save_user_history(state);
            snprintf(msg, sizeof(msg), "\033[1;32mSelected: %s\033[0m\r\n", area_record.name);
            script_write_output(state, msg);
        }
        else
        {
            script_write_output(state, "\033[1;31m[Area not found]\033[0m\r\n");
        }
    }
    else if (state->input_length > 0)
    {
        script_write_output(state, "\033[1;31m[Invalid ID]\033[0m\r\n");
    }

    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

static int input_complete_fb_select(script_state *state)
{
    int base_id;
    filebase_session *session = NULL;
    LINETASK_FILEBASE_RECORD record;

    /* Empty input = cancel */
    if (state->input_length == 0)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    base_id = atoi(state->input_buffer);

    if (state->host.get_filebase_session != NULL)
    {
        session = (filebase_session *)state->host.get_filebase_session(state->host.context);
    }

    if (session != NULL && base_id > 0)
    {
        if (filebase_get_info(base_id, &record))
        {
            if (filebase_check_access(record.accesslevel, record.keys,
                                       session->user_accesslevel, session->user_keys))
            {
                char msg[128];
                session->current_filebase = base_id;
                session->current_area = 0;
                script_save_user_history(state);
                snprintf(msg, sizeof(msg), "\033[1;32mSelected: %s\033[0m\r\n", record.name);
                script_write_output(state, msg);
            }
            else
            {
                script_write_output(state, "\033[1;31m[Access denied]\033[0m\r\n");
            }
        }
        else
        {
            script_write_output(state, "\033[1;31m[Filebase not found]\033[0m\r\n");
        }
    }
    else if (base_id <= 0 && state->input_length > 0)
    {
        script_write_output(state, "\033[1;31m[Invalid ID]\033[0m\r\n");
    }

    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

static int input_complete_fb_area(script_state *state)
{
    int area_id;
    filebase_session *session = NULL;
    LINETASK_FILEBASE_AREA_RECORD area_record;

    /* Empty input = cancel */
    if (state->input_length == 0)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    area_id = atoi(state->input_buffer);

    if (state->host.get_filebase_session != NULL)
    {
        session = (filebase_session *)state->host.get_filebase_session(state->host.context);
    }

    if (session != NULL && area_id >= 0)
    {
        if (area_id == 0)
        {
            /* Select root/all files */
            session->current_area = 0;
            script_save_user_history(state);
            script_write_output(state, "\033[1;32mSelected: [All Files]\033[0m\r\n");
        }
        else if (filebase_get_area_info(session->current_filebase, area_id, &area_record))
        {
            if (filebase_check_access(area_record.accesslevel, area_record.keys,
                                       session->user_accesslevel, session->user_keys))
            {
                char msg[128];
                session->current_area = area_id;
                script_save_user_history(state);
                snprintf(msg, sizeof(msg), "\033[1;32mSelected: %s\033[0m\r\n", area_record.name);
                script_write_output(state, msg);
            }
            else
            {
                script_write_output(state, "\033[1;31m[Access denied]\033[0m\r\n");
            }
        }
        else
        {
            script_write_output(state, "\033[1;31m[Area not found]\033[0m\r\n");
        }
    }
    else if (state->input_length > 0)
    {
        script_write_output(state, "\033[1;31m[Invalid ID]\033[0m\r\n");
    }

    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
    return 1;
}

static int input_complete_upload_file(script_state *state)
{
    /* Store the filename */
    strncpy(state->pending_upload_filename, state->input_buffer, sizeof(state->pending_upload_filename) - 1);
    state->pending_upload_filename[sizeof(state->pending_upload_filename) - 1] = '\0';

    /* Prompt for description */
    script_write_output(state, "Description: ");
    script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_UPLOAD_DESC);
    return 1;
}

static int input_complete_upload_desc(script_state *state)
{
    const char *protocol_file;

    /* Store the description */
    strncpy(state->pending_upload_description, state->input_buffer, sizeof(state->pending_upload_description) - 1);
    state->pending_upload_description[sizeof(state->pending_upload_description) - 1] = '\0';

    /* If protocol was already specified on command line, start transfer immediately */
    if (state->pending_upload_protocol >= 0)
    {
        script_start_receive_transfer(state, state->pending_upload_protocol);
        return 1;
    }

    /* Show protocol selection */
    protocol_file = NULL;
    if (state->host.get_protocol_file != NULL)
    {
        protocol_file = state->host.get_protocol_file(state->host.context);
    }

    if (protocol_file != NULL && protocol_file[0] != '\0')
    {
        script_display_file(state, protocol_file, 0);
    }
    else
    {
        script_write_output(state, "\r\nProtocol: \033[1;37m[\033[1;32mZ\033[1;37m]modem (recommended)\r\n");
    }

    /* Save current more setting */
    protocol_more_saved = state->more_override;
    state->more_override = 0;  /* Disable more during protocol selection */

    state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_WAIT_PROTOCOL;
    script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_PROTOCOL);
    return 1;
}

static int input_complete_protocol(script_state *state)
{
    int protocol = -1;
    char key;
    
    /* Get the key that was pressed */
    key = (state->input_length > 0) ? state->input_buffer[0] : 0;
    
    /* Map key to protocol */
    switch (key)
    {
        case 'z':
        case 'Z':
            protocol = 5;  /* ZMODEM */
            break;
        case 'y':
        case 'Y':
            protocol = 3;  /* YMODEM */
            break;
        case 'g':
        case 'G':
            protocol = 4;  /* YMODEM-G */
            break;
        case 'x':
        case 'X':
            protocol = 1;  /* XMODEM-CRC */
            break;
        case '1':
            protocol = 2;  /* XMODEM-1K */
            break;
        case 'a':
        case 'A':
        case 27:  /* ESC */
            /* Abort - restore More state first */
            if (protocol_more_saved != -1)
            {
                state->more_override = protocol_more_saved;
                protocol_more_saved = -1;
            }
            
            /* Check if aborting a browser download */
            if (state->is_browser_download)
            {
                state->is_browser_download = 0;
                state->pending_download_file_id = 0;
                state->pending_download_filebase = 0;
                script_write_output(state, "\r\n[Aborted]\r\n");
                /* Return to filebase browser */
                script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_FB_BROWSE);
                return 1;
            }
            
            state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_NONE;
            script_write_output(state, "\r\n[Aborted]\r\n");
            state->status = SCRIPT_STATUS_RUNNING;
            script_process(state);
            return 1;
        default:
            /* Invalid key - stay in protocol selection, re-prompt */
            return 1;
    }
    
    /* Restore More state before starting transfer */
    if (protocol_more_saved != -1)
    {
        state->more_override = protocol_more_saved;
        protocol_more_saved = -1;
    }
    
    /* Echo the selection */
    if (state->host.write_text != NULL)
    {
        char echo[2] = { key, '\0' };
        state->host.write_text(state->host.context, echo);
    }
    
    /* Check if this is a download from browser or an upload */
    if (state->is_browser_download)
    {
        /* Download: save values before clearing state */
        int download_file_id = state->pending_download_file_id;
        int download_filebase = state->pending_download_filebase;
        
        script_write_output(state, "\r\n");
        
        /* Clear download state */
        state->is_browser_download = 0;
        state->pending_download_file_id = 0;
        state->pending_download_filebase = 0;
        
        /* Execute file transfer */
        {
            filebase_session *fb_session = NULL;
            if (state->host.get_filebase_session != NULL)
            {
                fb_session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            }
            
            if (fb_session != NULL && state->host.start_transfer != NULL)
            {
                if (state->host.start_transfer(state->host.context, 
                                               download_filebase, 
                                               download_file_id,
                                               protocol))
                {
                    state->status = SCRIPT_STATUS_WAIT_TRANSFER;
                    return 1;
                }
                else
                {
                    script_write_output(state, "\r\n[Download failed to start]\r\n");
                }
            }
            else
            {
                script_write_output(state, "\r\n[Download not available]\r\n");
            }
        }
        
        /* Return to browser */
        script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_FB_BROWSE);
        return 1;
    }
    else
    {
        /* Upload: start receive transfer */
        script_start_receive_transfer(state, protocol);
        return 1;
    }
}

static int input_complete_chat_reason(script_state *state)
{
    /* Empty reason = cancel */
    if (state->input_length == 0)
    {
        script_write_output(state, "\r\n\033[1;33mChat request cancelled.\033[0m\r\n\r\n");
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    /* Have a reason - start pager via callback */
    if (state->host.start_chat_pager != NULL)
    {
        state->host.start_chat_pager(state->host.context, state->input_buffer);
    }
    /* Status will be set to WAIT_CHAT by the callback */
    return 1;
}

/* ===========================================================================
 * VIEWER/BROWSER CHAR INPUT HANDLERS
 * Handle single-character input for interactive viewers.
 * ===========================================================================
 */

/* Handle ANSI detection byte - state machine for ESC[<row>;<col>R */
static int handle_ansi_detection_byte(script_state *state, unsigned char byte)
{
    /* Debug: log each byte we receive during ANSI detection */
    debug_printf("ANSI detect: byte=0x%02X '%c' state=%d\n", 
                 byte, (byte >= 32 && byte < 127) ? byte : '.', state->ansi_parse_state);
    
    /* State machine to parse ANSI CPR response: ESC [ <digits> ; <digits> R */
    switch (state->ansi_parse_state)
    {
        case 0:  /* Waiting for ESC */
            if (byte == 0x1B)  /* ESC */
            {
                state->ansi_parse_state = 1;
                state->ansi_response_len = 0;
            }
            /* Ignore any other characters while waiting */
            break;

        case 1:  /* Got ESC, expecting [ */
            if (byte == '[')
            {
                state->ansi_parse_state = 2;
            }
            else
            {
                /* Not an ANSI sequence, reset */
                state->ansi_parse_state = 0;
            }
            break;

        case 2:  /* Got ESC[, reading row digits or waiting for ; or R */
            if (byte >= '0' && byte <= '9')
            {
                if (state->ansi_response_len < (int)sizeof(state->ansi_response) - 1)
                {
                    state->ansi_response[state->ansi_response_len++] = (char)byte;
                }
            }
            else if (byte == ';')
            {
                state->ansi_parse_state = 3;
            }
            else if (byte == 'R')
            {
                /* Complete! ESC[R or ESC[<row>R - still counts as ANSI */
                debug_printf("ANSI detect: SUCCESS (got 'R' in state 2)\n");
                script_set_variable_value(state, state->ansi_result_var, "1");
                state->ansi_parse_state = 0;
                state->ansi_response_len = 0;
                script_clear_input(state);
                state->status = SCRIPT_STATUS_RUNNING;
                script_process(state);
            }
            else
            {
                /* Unexpected character, reset */
                state->ansi_parse_state = 0;
                state->ansi_response_len = 0;
            }
            break;

        case 3:  /* Got semicolon, reading col digits */
            if (byte >= '0' && byte <= '9')
            {
                if (state->ansi_response_len < (int)sizeof(state->ansi_response) - 1)
                {
                    state->ansi_response[state->ansi_response_len++] = (char)byte;
                }
            }
            else if (byte == 'R')
            {
                /* Complete! ANSI terminal detected */
                debug_printf("ANSI detect: SUCCESS (got 'R' in state 3)\n");
                script_set_variable_value(state, state->ansi_result_var, "1");
                state->ansi_parse_state = 0;
                state->ansi_response_len = 0;
                script_clear_input(state);
                state->status = SCRIPT_STATUS_RUNNING;
                script_process(state);
            }
            else
            {
                /* Unexpected character, reset */
                state->ansi_parse_state = 0;
                state->ansi_response_len = 0;
            }
            break;
    }
    return 1;  /* Consumed the byte */
}

/* Handle messagebase viewer char input */
static int handle_mb_viewer_char(script_state *state, unsigned char byte)
{
    messagebase_session *session = NULL;
    int action;

    if (state->host.get_messagebase_session != NULL)
    {
        session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
    }

    if (session == NULL || !messagebase_viewer_is_active(session))
    {
        /* No active viewer - return to script */
        script_clear_input(state);
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    action = messagebase_viewer_handle_input(session, (char)byte,
                                              (void (*)(void*, const char*))script_write_output, state);

    switch (action)
    {
        case VIEWER_ACTION_CONTINUE:
            /* Stay in viewer, waiting for more input */
            return 1;

        case VIEWER_ACTION_NEXT:
            messagebase_viewer_goto_next(session,
                                          (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_PREV:
            messagebase_viewer_goto_prev(session,
                                          (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_START:
            messagebase_viewer_goto_start(session,
                                           (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_END:
            messagebase_viewer_goto_end(session,
                                         (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_NEXT_AREA:
            messagebase_viewer_next_area(session,
                                          (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_PREV_AREA:
            messagebase_viewer_prev_area(session,
                                          (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_CURRENT:
            messagebase_viewer_show_current(session,
                                             (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_REPLY:
            if (messagebase_viewer_start_reply(session,
                                                (void (*)(void*, const char*))script_write_output, state))
            {
                /* Composer is now active - switch to line input for compose */
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_COMPOSE);
            }
            else
            {
                /* Reply failed - stay in viewer */
                messagebase_viewer_show_prompt(session,
                                                (void (*)(void*, const char*))script_write_output, state);
            }
            return 1;

        case VIEWER_ACTION_PRIVATE_REPLY:
            if (messagebase_viewer_start_private_reply(session,
                                                        (void (*)(void*, const char*))script_write_output, state))
            {
                /* Composer is now active - switch to line input for compose */
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_COMPOSE);
            }
            else
            {
                /* Private reply failed - stay in viewer */
                messagebase_viewer_show_prompt(session,
                                                (void (*)(void*, const char*))script_write_output, state);
            }
            return 1;

        case VIEWER_ACTION_SEARCH:
            /* Start search - switch to line input for search term */
            messagebase_viewer_start_search(session,
                                             (void (*)(void*, const char*))script_write_output, state);
            script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_SEARCH);
            return 1;

        case VIEWER_ACTION_EXIT_SEARCH:
            /* Exit search mode - stay in viewer */
            messagebase_viewer_exit_search_mode(session,
                                                 (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case VIEWER_ACTION_QUIT:
        default:
            /* Quit viewer - return to script */
            messagebase_viewer_close(session);
            script_clear_input(state);
            state->status = SCRIPT_STATUS_RUNNING;
            script_process(state);
            return 1;
    }
}

/* Handle filebase browser char input */
static int handle_fb_browse_char(script_state *state, unsigned char byte)
{
    filebase_session *session = NULL;
    int action;

    if (state->host.get_filebase_session != NULL)
    {
        session = (filebase_session *)state->host.get_filebase_session(state->host.context);
    }

    if (session == NULL || !filebase_viewer_is_active(session))
    {
        /* No active browser - return to script */
        script_clear_input(state);
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    action = filebase_viewer_handle_input(session, (char)byte,
                                          (void (*)(void*, const char*))script_write_output, state);

    switch (action)
    {
        case FILEVIEWER_ACTION_CONTINUE:
            /* Stay in browser, waiting for more input */
            return 1;

        case FILEVIEWER_ACTION_NEXT:
            filebase_viewer_goto_next(session,
                                      (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case FILEVIEWER_ACTION_PREV:
            filebase_viewer_goto_prev(session,
                                      (void (*)(void*, const char*))script_write_output, state);
            return 1;

        case FILEVIEWER_ACTION_DOWNLOAD:
            /* Download action - save context and prompt for protocol */
            state->pending_download_file_id = session->viewer.file_id;
            state->pending_download_filebase = session->current_filebase;
            state->is_browser_download = 1;
            
            /* Show protocol selection prompt */
            script_write_output(state, "\r\n\r\n");
            script_write_output(state, "Protocol: \033[1;37m[\033[1;32mZ\033[1;37m]modem  "
                                       "[\033[1;33mY\033[1;37m]modem  "
                                       "[\033[1;33mG\033[1;37m]-Ymodem  "
                                       "[\033[1;32mX\033[1;37m]modem  "
                                       "[\033[1;32m1\033[1;37m]k-Xmodem  "
                                       "[\033[1;31mA\033[1;37m]bort : \033[1;31m");
            
            script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_PROTOCOL);
            return 1;

        case FILEVIEWER_ACTION_QUIT:
            /* Quit browser - return to script */
            filebase_viewer_close(session);
            script_clear_input(state);
            state->status = SCRIPT_STATUS_RUNNING;
            script_process(state);
            return 1;

        case FILEVIEWER_ACTION_INVALID:
        default:
            /* Invalid input - already handled by viewer */
            return 1;
    }
}

/* Handle messagebase composer line input completion */
static int handle_mb_compose_line(script_state *state)
{
    messagebase_session *session = NULL;
    int result;

    if (state->host.get_messagebase_session != NULL)
    {
        session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
    }

    if (session == NULL || !messagebase_composer_is_active(session))
    {
        /* No active composer - return to script */
        if (composer_more_saved != -1)
        {
            state->more_override = composer_more_saved;
            composer_more_saved = -1;
        }
        script_clear_input(state);
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    result = messagebase_composer_handle_line(session, state->input_buffer,
                                               (void (*)(void*, const char*))script_write_output, state);
    state->input_length = 0;
    if (state->input_buffer != NULL)
    {
        state->input_buffer[0] = '\0';
    }

    if (result > 0)
    {
        /* Composer needs more input - stay in compose mode */
        return 1;
    }
    else
    {
        /* Composer finished (sent, cancelled, or error) - return to viewer or script */
        if (composer_more_saved != -1)
        {
            state->more_override = composer_more_saved;
            composer_more_saved = -1;
        }
        
        /* Check if we should return to viewer */
        if (messagebase_viewer_is_active(session))
        {
            script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_MB_VIEWER);
        }
        else
        {
            script_clear_input(state);
            state->status = SCRIPT_STATUS_RUNNING;
            script_process(state);
        }
        return 1;
    }
}

/* Handle messagebase search line input completion */
static int handle_mb_search_line(script_state *state)
{
    messagebase_session *session = NULL;

    if (state->host.get_messagebase_session != NULL)
    {
        session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
    }

    if (session == NULL || !messagebase_viewer_is_active(session))
    {
        /* No active viewer - return to script */
        script_clear_input(state);
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }

    /* Perform the search with the entered term */
    messagebase_viewer_do_search(session, state->input_buffer,
                                  (void (*)(void*, const char*))script_write_output, state);
    state->input_length = 0;
    if (state->input_buffer != NULL)
    {
        state->input_buffer[0] = '\0';
    }

    /* Check result - if phase is IDLE, search was cancelled */
    if (session->viewer.phase == MESSAGE_VIEW_IDLE)
    {
        /* Came from script command, search cancelled/no results - resume script */
        script_clear_input(state);
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return 1;
    }
    else
    {
        /* Viewer is active (showing first result) - back to char input */
        script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_MB_VIEWER);
        return 1;
    }
}

int script_handle_user_byte(script_state *state, unsigned char byte)
{
    int result;
    
    if (state == NULL)
    {
        return 0;
    }

    /* NEW UNIFIED INPUT SYSTEM
     * If input_mode is set, route through the new handlers.
     * This eventually replaces all the status-based checks below.
     */
    if (state->input_mode != SCRIPT_INPUT_MODE_NONE)
    {
        switch (state->input_mode)
        {
            case SCRIPT_INPUT_MODE_LINE:
            case SCRIPT_INPUT_MODE_LINE_NOECHO:
                result = handle_line_input_byte(state, byte);
                if (result < 0)
                {
                    /* Input complete - dispatch to completion handler */
                    return dispatch_input_complete(state);
                }
                return result;
                
            case SCRIPT_INPUT_MODE_CHAR:
            case SCRIPT_INPUT_MODE_CHAR_ECHO:
                /* Check for viewer/browser contexts that handle chars specially */
                if (state->input_context == SCRIPT_INPUT_CTX_MB_VIEWER)
                {
                    return handle_mb_viewer_char(state, byte);
                }
                if (state->input_context == SCRIPT_INPUT_CTX_FB_BROWSE)
                {
                    return handle_fb_browse_char(state, byte);
                }
                /* Single character - complete immediately */
                state->input_buffer[0] = (char)byte;
                state->input_buffer[1] = '\0';
                state->input_length = 1;
                if (state->input_mode == SCRIPT_INPUT_MODE_CHAR_ECHO && 
                    state->host.write_text != NULL)
                {
                    char echo[4];
                    echo[0] = (char)byte;
                    echo[1] = '\r';
                    echo[2] = '\n';
                    echo[3] = '\0';
                    state->host.write_text(state->host.context, echo);
                }
                return dispatch_input_complete(state);
                
            case SCRIPT_INPUT_MODE_YESNO:
                /* Only accept Y/y/N/n */
                if (byte == 'Y' || byte == 'y')
                {
                    if (state->host.write_text != NULL)
                    {
                        state->host.write_text(state->host.context, "Y\r\n");
                    }
                    script_set_variable_value(state, state->input_target, "1");
                    state->input_buffer[0] = 'Y';
                    state->input_buffer[1] = '\0';
                    state->input_length = 1;
                    return dispatch_input_complete(state);
                }
                else if (byte == 'N' || byte == 'n')
                {
                    if (state->host.write_text != NULL)
                    {
                        state->host.write_text(state->host.context, "N\r\n");
                    }
                    script_set_variable_value(state, state->input_target, "0");
                    state->input_buffer[0] = 'N';
                    state->input_buffer[1] = '\0';
                    state->input_length = 1;
                    return dispatch_input_complete(state);
                }
                /* Ignore other keys for YESNO */
                return 1;
                
            case SCRIPT_INPUT_MODE_KEY:
                /* Check if byte is in valid_keys set */
                {
                    char *found = strchr(state->input_valid_keys, byte);
                    if (found != NULL)
                    {
                        state->input_buffer[0] = (char)byte;
                        state->input_buffer[1] = '\0';
                        state->input_length = 1;
                        return dispatch_input_complete(state);
                    }
                    /* Ignore invalid keys */
                    return 1;
                }
                
            case SCRIPT_INPUT_MODE_SPECIAL:
                /* Special handling for ANSI detection */
                if (state->input_context == SCRIPT_INPUT_CTX_ANSI_DETECT)
                {
                    return handle_ansi_detection_byte(state, byte);
                }
                break;
                
            default:
                break;
        }
    }

    /* All input is now handled via the unified input system above.
     * Chat mode uses SCRIPT_STATUS_WAIT_CHAT which is a non-input waiting state.
     */
    if (state->status == SCRIPT_STATUS_WAIT_CHAT)
    {
        /* Chat mode input is handled separately by the chat subsystem */
        return 0;
    }

    return 0;
}

void script_notify_door_closed(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_DOOR)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
    }
}

void script_notify_transfer_complete(script_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (state->status == SCRIPT_STATUS_WAIT_TRANSFER)
    {
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
    }
}

script_status script_get_status(const script_state *state)
{
    if (state == NULL)
    {
        return SCRIPT_STATUS_ERROR;
    }

    return state->status;
}

const char *script_get_last_error(const script_state *state)
{
    if (state == NULL)
    {
        return "Invalid script state";
    }

    if (state->last_error[0] == '\0')
    {
        return "Unknown error";
    }

    return state->last_error;
}

const char *script_get_variable(const script_state *state, const char *name)
{
    return script_get_variable_value(state, name);
}

static void script_clear_program(script_state *state)
{
    size_t i;

    if (state->instructions != NULL)
    {
        for (i = 0; i < state->instruction_count; ++i)
        {
            script_free_instruction(&state->instructions[i]);
        }
    }

    state->instruction_count = 0;

    if (state->labels != NULL)
    {
        for (i = 0; i < state->label_count; ++i)
        {
            script_free_label(&state->labels[i]);
        }
    }
    state->label_count = 0;
    
    /* Reset IF block parsing state */
    script_reset_if_state();
}

static void script_reset_if_state(void)
{
    script_if_depth = 0;
    script_if_counter = 0;
}

static void script_reset_loop_state(void)
{
    script_loop_depth = 0;
    script_loop_counter = 0;
}

/* Evaluate a condition expression (same logic as IF command)
 * Returns 1 if true, 0 if false */
static int script_evaluate_condition(script_state *state, const char *condition_expr)
{
    char expr_copy[1024];
    char *p;
    char *clause_start;
    int current_result = 0;
    int have_result = 0;
    int pending_or = 0;
    int pending_and = 0;

    if (condition_expr == NULL || condition_expr[0] == '\0')
    {
        return 0;
    }

    strncpy(expr_copy, condition_expr, sizeof(expr_copy) - 1);
    expr_copy[sizeof(expr_copy) - 1] = '\0';

    p = expr_copy;
    clause_start = p;

    while (1)
    {
        char *and_pos = strstr(p, "&&");
        char *or_pos = strstr(p, "||");
        char *next_op = NULL;
        int is_and = 0;
        char *clause_end;
        char clause[256];
        char var[128], op[16], val[256];
        char var_expanded[512], val_expanded[512];
        const char *var_value;
        int clause_result = 0;

        /* Find the nearest operator */
        if (and_pos != NULL && (or_pos == NULL || and_pos < or_pos))
        {
            next_op = and_pos;
            is_and = 1;
        }
        else if (or_pos != NULL)
        {
            next_op = or_pos;
            is_and = 0;
        }

        /* Extract current clause */
        if (next_op != NULL)
        {
            clause_end = next_op;
        }
        else
        {
            clause_end = p + strlen(p);
        }

        /* Copy and trim the clause */
        {
            size_t len = (size_t)(clause_end - clause_start);
            if (len >= sizeof(clause)) len = sizeof(clause) - 1;
            strncpy(clause, clause_start, len);
            clause[len] = '\0';
        }

        /* Parse clause: var op value */
        {
            char *cp = clause;
            char *var_start;
            char *contains_pos;

            /* Skip leading whitespace */
            while (*cp && isspace((unsigned char)*cp)) cp++;
            var_start = cp;

            /* Check for "contains" operator first (word-based) */
            contains_pos = strstr(cp, " contains ");
            if (contains_pos != NULL)
            {
                size_t vlen = (size_t)(contains_pos - var_start);
                if (vlen >= sizeof(var)) vlen = sizeof(var) - 1;
                strncpy(var, var_start, vlen);
                var[vlen] = '\0';
                while (vlen > 0 && isspace((unsigned char)var[vlen-1])) var[--vlen] = '\0';
                
                strcpy(op, "contains");
                cp = contains_pos + 10; /* skip " contains " */
                while (*cp && isspace((unsigned char)*cp)) cp++;
                
                /* Check for backtick-quoted value */
                if (*cp == '`')
                {
                    char *end_tick = strchr(cp + 1, '`');
                    if (end_tick != NULL)
                    {
                        size_t vlen2 = (size_t)(end_tick - cp - 1);
                        if (vlen2 >= sizeof(val)) vlen2 = sizeof(val) - 1;
                        strncpy(val, cp + 1, vlen2);
                        val[vlen2] = '\0';
                    }
                    else
                    {
                        strncpy(val, cp + 1, sizeof(val) - 1);
                        val[sizeof(val) - 1] = '\0';
                    }
                }
                else
                {
                    strncpy(val, cp, sizeof(val) - 1);
                    val[sizeof(val) - 1] = '\0';
                    {
                        size_t vlen2 = strlen(val);
                        while (vlen2 > 0 && isspace((unsigned char)val[vlen2-1])) val[--vlen2] = '\0';
                    }
                }
            }
            else
            {
                /* Find variable name end */
                while (*cp && !isspace((unsigned char)*cp) && 
                       strncmp(cp, "==", 2) != 0 && strncmp(cp, "!=", 2) != 0 &&
                       strncmp(cp, ">=", 2) != 0 && strncmp(cp, "<=", 2) != 0 &&
                       *cp != '>' && *cp != '<') cp++;
                
                {
                    size_t vlen = (size_t)(cp - var_start);
                    if (vlen >= sizeof(var)) vlen = sizeof(var) - 1;
                    strncpy(var, var_start, vlen);
                    var[vlen] = '\0';
                    while (vlen > 0 && isspace((unsigned char)var[vlen-1])) var[--vlen] = '\0';
                }

                /* Skip whitespace before operator */
                while (*cp && isspace((unsigned char)*cp)) cp++;

                /* Find operator */
                if (strncmp(cp, "==", 2) == 0 || strncmp(cp, "!=", 2) == 0 ||
                    strncmp(cp, ">=", 2) == 0 || strncmp(cp, "<=", 2) == 0)
                {
                    op[0] = *cp++;
                    op[1] = *cp++;
                    op[2] = '\0';
                }
                else if (*cp == '>' || *cp == '<')
                {
                    op[0] = *cp++;
                    op[1] = '\0';
                }
                else
                {
                    op[0] = '\0';
                }

                /* Skip whitespace before value */
                while (*cp && isspace((unsigned char)*cp)) cp++;

                /* Check for backtick-quoted value */
                if (*cp == '`')
                {
                    char *end_tick = strchr(cp + 1, '`');
                    if (end_tick != NULL)
                    {
                        size_t vlen = (size_t)(end_tick - cp - 1);
                        if (vlen >= sizeof(val)) vlen = sizeof(val) - 1;
                        strncpy(val, cp + 1, vlen);
                        val[vlen] = '\0';
                    }
                    else
                    {
                        strncpy(val, cp + 1, sizeof(val) - 1);
                        val[sizeof(val) - 1] = '\0';
                    }
                }
                else
                {
                    strncpy(val, cp, sizeof(val) - 1);
                    val[sizeof(val) - 1] = '\0';
                    {
                        size_t vlen = strlen(val);
                        while (vlen > 0 && isspace((unsigned char)val[vlen-1])) val[--vlen] = '\0';
                    }
                }
            }
        }

        /* Get variable value and expand macros */
        script_expand_macros(state, var, var_expanded, sizeof(var_expanded));
        
        if (strcmp(var, var_expanded) == 0)
        {
            var_value = script_get_variable_value(state, var);
            if (var_value != NULL)
            {
                script_expand_macros(state, var_value, var_expanded, sizeof(var_expanded));
            }
        }
        script_expand_macros(state, val, val_expanded, sizeof(val_expanded));

        /* Evaluate the comparison */
        if (strcmp(op, "==") == 0)
        {
            clause_result = (script_stringcasecmp(var_expanded, val_expanded) == 0);
        }
        else if (strcmp(op, "!=") == 0)
        {
            clause_result = (script_stringcasecmp(var_expanded, val_expanded) != 0);
        }
        else if (strcmp(op, ">") == 0)
        {
            clause_result = (atoi(var_expanded) > atoi(val_expanded));
        }
        else if (strcmp(op, "<") == 0)
        {
            clause_result = (atoi(var_expanded) < atoi(val_expanded));
        }
        else if (strcmp(op, ">=") == 0)
        {
            clause_result = (atoi(var_expanded) >= atoi(val_expanded));
        }
        else if (strcmp(op, "<=") == 0)
        {
            clause_result = (atoi(var_expanded) <= atoi(val_expanded));
        }
        else if (strcmp(op, "contains") == 0)
        {
            clause_result = (script_strcasestr(var_expanded, val_expanded) != NULL);
        }

        /* Combine with previous results */
        if (!have_result)
        {
            current_result = clause_result;
            have_result = 1;
        }
        else if (pending_and)
        {
            current_result = current_result && clause_result;
        }
        else if (pending_or)
        {
            current_result = current_result || clause_result;
        }

        pending_and = 0;
        pending_or = 0;

        /* Move to next clause or exit */
        if (next_op == NULL)
        {
            break;
        }

        if (is_and)
        {
            pending_and = 1;
        }
        else
        {
            pending_or = 1;
        }

        p = next_op + 2;
        clause_start = p;
    }

    return current_result;
}

/* Push current script state onto call stack before loading subscript */
static int script_push_call_stack(script_state *state)
{
    script_call_frame *frame;
    
    if (state->call_depth >= SCRIPT_MAX_CALL_DEPTH)
    {
        script_set_error(state, "Script call stack overflow (max depth %d)", SCRIPT_MAX_CALL_DEPTH);
        return 0;
    }
    
    frame = &state->call_stack[state->call_depth];
    
    /* Save current program state */
    frame->instructions = state->instructions;
    frame->instruction_count = state->instruction_count;
    frame->instruction_capacity = state->instruction_capacity;
    frame->labels = state->labels;
    frame->label_count = state->label_count;
    frame->label_capacity = state->label_capacity;
    frame->return_pc = state->program_counter + 1;  /* Return to instruction after 'script' command */
    
    state->call_depth++;
    
    /* Clear state for new script (don't free - we saved the pointers) */
    state->instructions = NULL;
    state->instruction_count = 0;
    state->instruction_capacity = 0;
    state->labels = NULL;
    state->label_count = 0;
    state->label_capacity = 0;
    
    return 1;
}

/* Pop call stack and restore previous script state */
static int script_pop_call_stack(script_state *state)
{
    script_call_frame *frame;
    size_t i;
    
    if (state->call_depth <= 0)
    {
        return 0;  /* Nothing to pop - script is finished */
    }
    
    /* Free current (subscript) program */
    if (state->instructions != NULL)
    {
        for (i = 0; i < state->instruction_count; ++i)
        {
            script_free_instruction(&state->instructions[i]);
        }
        free(state->instructions);
    }
    
    if (state->labels != NULL)
    {
        for (i = 0; i < state->label_count; ++i)
        {
            script_free_label(&state->labels[i]);
        }
        free(state->labels);
    }
    
    state->call_depth--;
    frame = &state->call_stack[state->call_depth];
    
    /* Restore previous script state */
    state->instructions = frame->instructions;
    state->instruction_count = frame->instruction_count;
    state->instruction_capacity = frame->instruction_capacity;
    state->labels = frame->labels;
    state->label_count = frame->label_count;
    state->label_capacity = frame->label_capacity;
    state->program_counter = frame->return_pc;
    
    /* Clear the frame */
    memset(frame, 0, sizeof(*frame));
    
    return 1;
}

static void script_clear_variables(script_state *state)
{
    size_t i;

    if (state->variables != NULL)
    {
        for (i = 0; i < state->variable_count; ++i)
        {
            script_free_variable(&state->variables[i]);
        }
    }
    state->variable_count = 0;
}

static int script_load_file(script_state *state, const char *path)
{
    FILE *fp;
    long file_size;
    size_t length;
    char *buffer = NULL;
    int result = 0;

    script_clear_program(state);

    fp = fopen(path, "rb");
    if (fp == NULL)
    {
        script_set_error(state, "Unable to open %s", path);
        return 0;
    }

    if (fseek(fp, 0, SEEK_END) != 0)
    {
        fclose(fp);
        script_set_error(state, "Unable to seek %s", path);
        return 0;
    }

    file_size = ftell(fp);
    if (file_size < 0)
    {
        fclose(fp);
        script_set_error(state, "Unable to determine size of %s", path);
        return 0;
    }

    if (fseek(fp, 0, SEEK_SET) != 0)
    {
        fclose(fp);
        script_set_error(state, "Unable to rewind %s", path);
        return 0;
    }

    length = (size_t)file_size;
    buffer = (char *)malloc(length + 1);
    if (buffer == NULL)
    {
        fclose(fp);
        script_set_error(state, "Out of memory loading %s", path);
        return 0;
    }

    if (length > 0 && fread(buffer, 1, length, fp) != length)
    {
        free(buffer);
        fclose(fp);
        script_set_error(state, "Failed to read %s", path);
        return 0;
    }

    buffer[length] = '\0';
    fclose(fp);

    if (script_buffer_has_embedded_blocks(buffer, length))
    {
        result = script_process_embedded_content(state, buffer, length, path, script_handle_embedded_text_as_instruction, script_handle_embedded_command_as_instruction, NULL);
    }
    else
    {
        char *stripped = script_strip_block_comments(buffer, length);
        if (stripped != NULL)
        {
            result = script_parse_plain_lines(state, stripped);
            free(stripped);
        }
        else
        {
            result = script_parse_plain_lines(state, buffer);
        }
    }

    free(buffer);

    if (!result)
    {
        script_clear_program(state);
    }

    return result;
}

static int script_parse_line(script_state *state, const char *line, int line_number)
{
    char *line_copy;
    char *trimmed;
    size_t len;
    script_instruction instruction;

    if (line == NULL)
    {
        return 1;
    }

    line_copy = script_duplicate_string(line);
    if (line_copy == NULL)
    {
        script_set_error(state, "Out of memory parsing line %d", line_number);
        return 0;
    }

    trimmed = script_trim(line_copy);
    if (*trimmed == '\0' || script_is_empty_or_comment(trimmed))
    {
        free(line_copy);
        return 1;
    }

    /* Handle "else" keyword */
    if (script_stringcasecmp(trimmed, "else") == 0)
    {
        script_instruction goto_instr;
        
        if (script_if_depth <= 0)
        {
            script_set_error(state, "else without matching if on line %d", line_number);
            free(line_copy);
            return 0;
        }
        
        if (script_if_stack[script_if_depth - 1].has_else)
        {
            script_set_error(state, "Duplicate else on line %d", line_number);
            free(line_copy);
            return 0;
        }
        
        /* Emit goto endif_label (to skip else block when condition was true) */
        memset(&goto_instr, 0, sizeof(goto_instr));
        goto_instr.type = SCRIPT_CMD_GOTO;
        goto_instr.arg1 = script_duplicate_string(script_if_stack[script_if_depth - 1].endif_label);
        if (!script_append_instruction(state, &goto_instr))
        {
            script_free_instruction(&goto_instr);
            script_set_error(state, "Too many instructions (line %d)", line_number);
            free(line_copy);
            return 0;
        }
        
        /* Register the else label */
        if (!script_register_label(state, script_if_stack[script_if_depth - 1].else_label))
        {
            script_set_error(state, "Unable to register else label on line %d", line_number);
            free(line_copy);
            return 0;
        }
        
        script_if_stack[script_if_depth - 1].has_else = 1;
        free(line_copy);
        return 1;
    }
    
    /* Handle "end if" or "endif" keyword */
    if (script_stringcasecmp(trimmed, "end if") == 0 || script_stringcasecmp(trimmed, "endif") == 0)
    {
        if (script_if_depth <= 0)
        {
            script_set_error(state, "end if without matching if on line %d", line_number);
            free(line_copy);
            return 0;
        }
        
        /* Register the endif label */
        if (!script_register_label(state, script_if_stack[script_if_depth - 1].endif_label))
        {
            script_set_error(state, "Unable to register endif label on line %d", line_number);
            free(line_copy);
            return 0;
        }
        
        script_if_depth--;
        free(line_copy);
        return 1;
    }

    len = strlen(trimmed);
    if (len > 0 && trimmed[len - 1] == ':')
    {
        trimmed[len - 1] = '\0';
        trimmed = script_trim(trimmed);
        if (!script_register_label(state, trimmed))
        {
            script_set_error(state, "Unable to register label on line %d", line_number);
            free(line_copy);
            return 0;
        }
        free(line_copy);
        return 1;
    }

    memset(&instruction, 0, sizeof(instruction));
    if (!script_build_instruction(state, trimmed, line_number, &instruction))
    {
        free(line_copy);
        return 0;
    }

    free(line_copy);

    if (instruction.type == SCRIPT_CMD_NONE)
    {
        return 1;
    }

    if (!script_append_instruction(state, &instruction))
    {
        script_free_instruction(&instruction);
        script_set_error(state, "Too many instructions (line %d)", line_number);
        return 0;
    }

    /* Register end labels AFTER the instruction is appended, so they point to the NEXT instruction */
    if (instruction.type == SCRIPT_CMD_FOR && instruction.arg5 != NULL)
    {
        /* arg5 = start_label - register it to point to instruction after FOR (loop body) */
        if (!script_register_label(state, instruction.arg5))
        {
            script_set_error(state, "Failed to register FOR loop start label on line %d", line_number);
            return 0;
        }
    }
    else if (instruction.type == SCRIPT_CMD_ENDFOR && instruction.arg3 != NULL)
    {
        /* arg3 = end_label - register it to point to instruction after ENDFOR */
        if (!script_register_label(state, instruction.arg3))
        {
            script_set_error(state, "Failed to register FOR loop end label on line %d", line_number);
            return 0;
        }
    }
    else if (instruction.type == SCRIPT_CMD_ENDWHILE && instruction.arg2 != NULL)
    {
        /* arg2 = end_label - register it to point to instruction after ENDWHILE */
        if (!script_register_label(state, instruction.arg2))
        {
            script_set_error(state, "Failed to register WHILE loop end label on line %d", line_number);
            return 0;
        }
    }

    return 1;
}

static int script_build_instruction(script_state *state, char *line, int line_number, script_instruction *instruction)
{
    char *token;
    char *line_after_cmd; /* Pointer to rest of line after command */
    size_t token_len;

    if (line == NULL || instruction == NULL)
    {
        return 0;
    }

    instruction->type = SCRIPT_CMD_NONE;

    /* Skip leading whitespace to find command start */
    while (*line && isspace((unsigned char)*line)) line++;
    
    /* Find end of first token (command) */
    token = line;
    while (*line && !isspace((unsigned char)*line)) line++;
    token_len = (size_t)(line - token);
    
    if (token_len == 0)
    {
        return 1;
    }
    
    /* Skip whitespace after command to find rest of line */
    while (*line && isspace((unsigned char)*line)) line++;
    line_after_cmd = line;
    
    /* Now use token_len to compare command names */
    /* We need to null-terminate for comparison, so use the original strtok approach
     * but save line_after_cmd first */
    
    /* Re-parse with strtok for other commands that need it */
    token = strtok(token, " \t");
    if (token == NULL)
    {
        return 1;
    }

    if (script_stringcasecmp(token, "label") == 0)
    {
        char *label_name = strtok(NULL, " \t");
        if (label_name == NULL)
        {
            script_set_error(state, "Missing label name on line %d", line_number);
            return 0;
        }
        if (!script_register_label(state, script_trim(label_name)))
        {
            script_set_error(state, "Unable to register label on line %d", line_number);
            return 0;
        }
        return 1;
    }

    if (script_stringcasecmp(token, "print") == 0)
    {
        char *rest = strtok(NULL, "");
        instruction->type = SCRIPT_CMD_PRINT;
        if (rest == NULL)
        {
            instruction->arg1 = script_duplicate_string("\r\n");
        }
        else
        {
            size_t consumed = 0;
            char *value = NULL;
            if (script_parse_backtick_string(rest, &consumed, &value))
            {
                instruction->arg1 = value;
            }
            else
            {
                instruction->arg1 = script_duplicate_string(script_trim(rest));
            }
        }
        return 1;
    }

    if (script_stringcasecmp(token, "goto") == 0)
    {
        char *label = strtok(NULL, " \t");
        if (label == NULL)
        {
            script_set_error(state, "Missing label for goto on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_GOTO;
        instruction->arg1 = script_duplicate_string(label);
        return 1;
    }

    if (script_stringcasecmp(token, "prompt") == 0)
    {
        char *var = strtok(NULL, " \t");
        char *mode = strtok(NULL, " \t");
        char *echo = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_PROMPT;
        instruction->arg1 = script_duplicate_string(var != NULL ? var : "selection");
        instruction->arg2 = script_duplicate_string(mode != NULL ? mode : "char");
        instruction->arg3 = script_duplicate_string(echo != NULL ? echo : "echo");
        return 1;
    }

    if (script_stringcasecmp(token, "if") == 0)
    {
        /* IF supports two syntaxes:
         * 1. if <condition> goto <label>     (original inline syntax)
         * 2. if <condition> then             (block syntax with else/end if)
         * 
         * Conditions support: ==, !=, >, <, >=, <=, contains
         * Compound conditions with && and || are supported
         */
        char *rest = line_after_cmd;
        char *goto_keyword = NULL;
        char *then_keyword = NULL;
        char *label_name;
        char *condition_text;
        char *search_pos;
        int is_block_if = 0;

        if (*rest == '\0')
        {
            script_set_error(state, "Malformed if statement on line %d", line_number);
            return 0;
        }

        /* Find the LAST occurrence of " goto " to handle compound conditions */
        search_pos = rest;
        while ((search_pos = strstr(search_pos, " goto ")) != NULL)
        {
            goto_keyword = search_pos;
            search_pos += 6;
        }
        
        /* Also check for " then" at end of line (block IF) */
        {
            size_t rest_len = strlen(rest);
            if (rest_len >= 5)
            {
                char *end_check = rest + rest_len - 4;
                if (script_stringcasecmp(end_check, "then") == 0 &&
                    (end_check == rest || isspace((unsigned char)*(end_check - 1))))
                {
                    then_keyword = end_check;
                    is_block_if = 1;
                }
            }
        }
        
        if (goto_keyword == NULL && then_keyword == NULL)
        {
            script_set_error(state, "If without goto or then on line %d", line_number);
            return 0;
        }
        
        if (is_block_if)
        {
            /* Block IF: if <condition> then */
            char inverted_condition[1024];
            char *cond_start;
            char *cond_end;
            
            if (script_if_depth >= SCRIPT_MAX_IF_DEPTH)
            {
                script_set_error(state, "Too many nested if blocks on line %d", line_number);
                return 0;
            }
            
            /* Extract condition (everything before "then") */
            *then_keyword = '\0';
            condition_text = script_trim(rest);
            
            /* Generate labels for this IF block */
            script_if_counter++;
            snprintf(script_if_stack[script_if_depth].else_label, 32, "_else_%d", script_if_counter);
            snprintf(script_if_stack[script_if_depth].endif_label, 32, "_endif_%d", script_if_counter);
            script_if_stack[script_if_depth].has_else = 0;
            
            /* For block IF, we need to invert the condition and jump to else/endif if false
             * For now, we'll pass the original condition and let execution handle it
             * with a special flag (arg3 = "block") to indicate inverted logic */
            instruction->type = SCRIPT_CMD_IF;
            instruction->arg1 = script_duplicate_string(condition_text);
            /* Jump to else label if exists, otherwise endif label */
            instruction->arg2 = script_duplicate_string(script_if_stack[script_if_depth].else_label);
            instruction->arg3 = script_duplicate_string("block"); /* Flag: invert condition */
            instruction->arg4 = script_duplicate_string(script_if_stack[script_if_depth].endif_label);
            
            script_if_depth++;
            return 1;
        }
        else
        {
            /* Original syntax: if <condition> goto <label> */
            if (goto_keyword == rest)
            {
                condition_text = "";
                label_name = script_trim(rest + 5);
            }
            else
            {
                *goto_keyword = '\0';
                condition_text = script_trim(rest);
                label_name = script_trim(goto_keyword + 6);
            }

            instruction->type = SCRIPT_CMD_IF;
            instruction->arg1 = script_duplicate_string(condition_text);
            instruction->arg2 = script_duplicate_string(label_name);
            instruction->arg3 = NULL;
            instruction->arg4 = NULL;
            return 1;
        }
    }

    if (script_stringcasecmp(token, "set") == 0)
    {
        char *var_name = strtok(NULL, " \t");
        char *value_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;
        if (var_name == NULL || value_text == NULL)
        {
            script_set_error(state, "Malformed set on line %d", line_number);
            return 0;
        }
        if (!script_parse_backtick_string(value_text, &consumed, &value_string))
        {
            value_string = script_duplicate_string(script_trim(value_text));
        }
        instruction->type = SCRIPT_CMD_SET;
        instruction->arg1 = script_duplicate_string(var_name);
        instruction->arg2 = value_string;
        return 1;
    }

    if (script_stringcasecmp(token, "call") == 0)
    {
        char *action = strtok(NULL, " \t");
        char *arg_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_CALL;
        instruction->arg1 = script_duplicate_string(action != NULL ? action : "");

        if (arg_text != NULL)
        {
            arg_text = script_trim(arg_text);

            /* For arcbbsdoor, parse door number first, then command */
            if (action != NULL && script_stringcasecmp(action, "arcbbsdoor") == 0)
            {
                char *door_num = strtok(arg_text, " \t");
                char *cmd_text = strtok(NULL, "");

                instruction->arg2 = script_duplicate_string(door_num != NULL ? door_num : "1");

                if (cmd_text != NULL)
                {
                    cmd_text = script_trim(cmd_text);
                    if (!script_parse_backtick_string(cmd_text, &consumed, &value_string))
                    {
                        value_string = script_duplicate_string(cmd_text);
                    }
                    instruction->arg3 = value_string;
                }
            }
            else
            {
                /* Standard call: arg2 is the command */
                if (!script_parse_backtick_string(arg_text, &consumed, &value_string))
                {
                    value_string = script_duplicate_string(arg_text);
                }
                instruction->arg2 = value_string;
            }
        }
        return 1;
    }

    if (script_stringcasecmp(token, "doing") == 0)
    {
        char *text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_DOING;

        if (text != NULL)
        {
            text = script_trim(text);
            if (!script_parse_backtick_string(text, &consumed, &value_string))
            {
                value_string = script_duplicate_string(text);
            }
            instruction->arg1 = value_string;
        }
        else
        {
            instruction->arg1 = script_duplicate_string("");
        }
        return 1;
    }

    if (script_stringcasecmp(token, "return") == 0 || script_stringcasecmp(token, "stop") == 0)
    {
        instruction->type = SCRIPT_CMD_RETURN;
        return 1;
    }

    if (script_stringcasecmp(token, "pause") == 0 || script_stringcasecmp(token, "sleep") == 0)
    {
        char *duration = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_PAUSE;
        instruction->arg1 = script_duplicate_string(duration != NULL ? duration : "0");
        return 1;
    }

    if (script_stringcasecmp(token, "type") == 0)
    {
        char *path_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        if (path_text == NULL)
        {
            script_set_error(state, "Missing filename for type on line %d", line_number);
            return 0;
        }

        path_text = script_trim(path_text);
        if (!script_parse_backtick_string(path_text, &consumed, &value_string))
        {
            value_string = script_duplicate_string(path_text);
        }

        instruction->type = SCRIPT_CMD_TYPE;
        instruction->arg1 = value_string;
        return 1;
    }

    if (script_stringcasecmp(token, "anykey") == 0)
    {
        char *var = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_ANYKEY;
        instruction->arg1 = script_duplicate_string(var != NULL ? var : "_key");
        return 1;
    }

    if (script_stringcasecmp(token, "fgbg") == 0)
    {
        char *fg = strtok(NULL, " \t");
        char *bg = strtok(NULL, " \t");
        if (fg == NULL || bg == NULL)
        {
            script_set_error(state, "Malformed fgbg on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_FGBG;
        instruction->arg1 = script_duplicate_string(fg);
        instruction->arg2 = script_duplicate_string(bg);
        return 1;
    }

    if (script_stringcasecmp(token, "fg") == 0)
    {
        char *fg = strtok(NULL, " \t");
        if (fg == NULL)
        {
            script_set_error(state, "Missing colour for fg on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_FG;
        instruction->arg1 = script_duplicate_string(fg);
        return 1;
    }

    if (script_stringcasecmp(token, "bg") == 0)
    {
        char *bg = strtok(NULL, " \t");
        if (bg == NULL)
        {
            script_set_error(state, "Missing colour for bg on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_BG;
        instruction->arg1 = script_duplicate_string(bg);
        return 1;
    }

    if (script_stringcasecmp(token, "flash") == 0)
    {
        char *val = strtok(NULL, " \t");
        if (val == NULL)
        {
            script_set_error(state, "Missing value for flash on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_FLASH;
        instruction->arg1 = script_duplicate_string(val);
        return 1;
    }

    if (script_stringcasecmp(token, "bold") == 0)
    {
        /* BOLD [0|1] - enable/disable bold attribute. Defaults to 1 if no argument. */
        char *val = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_BOLD;
        instruction->arg1 = script_duplicate_string(val != NULL ? val : "1");
        return 1;
    }

    if (script_stringcasecmp(token, "std") == 0)
    {
        /* STD - reset to standard attributes (white on black, no bold, no flash) */
        instruction->type = SCRIPT_CMD_STD;
        return 1;
    }

    if (script_stringcasecmp(token, "readline") == 0)
    {
        /* READLINE <variable> [noecho] - read a line of input into variable */
        char *var = strtok(NULL, " \t");
        char *echo = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_READLINE;
        instruction->arg1 = script_duplicate_string(var != NULL ? var : "input");
        instruction->arg2 = script_duplicate_string(echo != NULL ? echo : "echo");
        return 1;
    }

    if (script_stringcasecmp(token, "yesno") == 0)
    {
        /* YESNO <variable> [prompt_text] - prompt for Y/N, store "1" or "0" */
        char *var = strtok(NULL, " \t");
        char *prompt_text = strtok(NULL, "");  /* Get rest of line as prompt */
        instruction->type = SCRIPT_CMD_YESNO;
        instruction->arg1 = script_duplicate_string(var != NULL ? var : "answer");
        if (prompt_text != NULL)
        {
            size_t consumed = 0;
            char *value = NULL;
            if (script_parse_backtick_string(prompt_text, &consumed, &value))
            {
                instruction->arg2 = value;
            }
            else
            {
                instruction->arg2 = script_duplicate_string(script_trim(prompt_text));
            }
        }
        return 1;
    }

    /* FOR <var> = <start> TO <end> [STEP <n>] */
    if (script_stringcasecmp(token, "for") == 0)
    {
        char *var = strtok(NULL, " \t");
        char *eq = strtok(NULL, " \t");
        char *start_val = strtok(NULL, " \t");
        char *to_kw = strtok(NULL, " \t");
        char *end_val = strtok(NULL, " \t");
        char *step_kw = strtok(NULL, " \t");
        char *step_val = NULL;

        if (var == NULL || eq == NULL || start_val == NULL || to_kw == NULL || end_val == NULL)
        {
            script_set_error(state, "Invalid FOR syntax on line %d (use: FOR var = start TO end [STEP n])", line_number);
            return 0;
        }

        if (script_stringcasecmp(eq, "=") != 0)
        {
            script_set_error(state, "FOR requires '=' after variable on line %d", line_number);
            return 0;
        }

        if (script_stringcasecmp(to_kw, "to") != 0)
        {
            script_set_error(state, "FOR requires 'TO' keyword on line %d", line_number);
            return 0;
        }

        if (step_kw != NULL && script_stringcasecmp(step_kw, "step") == 0)
        {
            step_val = strtok(NULL, " \t");
        }

        if (script_loop_depth >= SCRIPT_MAX_LOOP_DEPTH)
        {
            script_set_error(state, "Loop nesting too deep on line %d", line_number);
            return 0;
        }

        /* Generate labels for this loop */
        script_loop_counter++;
        snprintf(script_loop_stack[script_loop_depth].start_label, 32, "_for_start_%d", script_loop_counter);
        snprintf(script_loop_stack[script_loop_depth].test_label, 32, "_for_test_%d", script_loop_counter);
        snprintf(script_loop_stack[script_loop_depth].end_label, 32, "_for_end_%d", script_loop_counter);
        strncpy(script_loop_stack[script_loop_depth].var_name, var, 63);
        script_loop_stack[script_loop_depth].var_name[63] = '\0';
        script_loop_stack[script_loop_depth].type = LOOP_TYPE_FOR;
        script_loop_depth++;

        instruction->type = SCRIPT_CMD_FOR;
        instruction->arg1 = script_duplicate_string(var);
        instruction->arg2 = script_duplicate_string(start_val);
        instruction->arg3 = script_duplicate_string(end_val);
        instruction->arg4 = script_duplicate_string(step_val != NULL ? step_val : "1");
        /* arg5 stores start_label for post-append registration in script_parse_line */
        instruction->arg5 = script_duplicate_string(script_loop_stack[script_loop_depth - 1].start_label);
        return 1;
    }

    /* ENDFOR or NEXT */
    if (script_stringcasecmp(token, "endfor") == 0 || script_stringcasecmp(token, "next") == 0)
    {
        if (script_loop_depth <= 0 || script_loop_stack[script_loop_depth - 1].type != LOOP_TYPE_FOR)
        {
            script_set_error(state, "ENDFOR/NEXT without matching FOR on line %d", line_number);
            return 0;
        }

        /* Note: start_label is registered after FOR is appended (via FOR's arg5) */
        
        /* Register the test label (points to ENDFOR for CONTINUE) */
        if (!script_register_label(state, script_loop_stack[script_loop_depth - 1].test_label))
        {
            script_set_error(state, "Failed to register FOR loop test label on line %d", line_number);
            return 0;
        }

        script_loop_depth--;
        instruction->type = SCRIPT_CMD_ENDFOR;
        instruction->arg1 = script_duplicate_string(script_loop_stack[script_loop_depth].var_name);
        instruction->arg2 = script_duplicate_string(script_loop_stack[script_loop_depth].start_label);
        instruction->arg3 = script_duplicate_string(script_loop_stack[script_loop_depth].end_label);
        
        /* Note: end_label will be registered AFTER instruction append in script_parse_line,
         * so it points to the instruction AFTER ENDFOR (for BREAK to work correctly) */
        return 1;
    }

    /* WHILE <condition> */
    if (script_stringcasecmp(token, "while") == 0)
    {
        char *condition = strtok(NULL, "");
        if (condition == NULL || condition[0] == '\0')
        {
            script_set_error(state, "WHILE requires a condition on line %d", line_number);
            return 0;
        }

        if (script_loop_depth >= SCRIPT_MAX_LOOP_DEPTH)
        {
            script_set_error(state, "Loop nesting too deep on line %d", line_number);
            return 0;
        }

        /* Generate labels for this loop */
        script_loop_counter++;
        snprintf(script_loop_stack[script_loop_depth].start_label, 32, "_while_start_%d", script_loop_counter);
        snprintf(script_loop_stack[script_loop_depth].test_label, 32, "_while_start_%d", script_loop_counter);  /* Same as start for WHILE */
        snprintf(script_loop_stack[script_loop_depth].end_label, 32, "_while_end_%d", script_loop_counter);
        script_loop_stack[script_loop_depth].var_name[0] = '\0';
        script_loop_stack[script_loop_depth].type = LOOP_TYPE_WHILE;
        
        /* Register the start label (points to this WHILE instruction for condition re-test) */
        if (!script_register_label(state, script_loop_stack[script_loop_depth].start_label))
        {
            script_set_error(state, "Failed to register WHILE loop start label on line %d", line_number);
            return 0;
        }
        
        script_loop_depth++;

        instruction->type = SCRIPT_CMD_WHILE;
        instruction->arg1 = script_duplicate_string(script_trim(condition));
        instruction->arg2 = script_duplicate_string(script_loop_stack[script_loop_depth - 1].start_label);
        instruction->arg3 = script_duplicate_string(script_loop_stack[script_loop_depth - 1].end_label);
        return 1;
    }

    /* ENDWHILE */
    if (script_stringcasecmp(token, "endwhile") == 0)
    {
        if (script_loop_depth <= 0 || script_loop_stack[script_loop_depth - 1].type != LOOP_TYPE_WHILE)
        {
            script_set_error(state, "ENDWHILE without matching WHILE on line %d", line_number);
            return 0;
        }

        script_loop_depth--;
        
        /* Note: end_label will be registered AFTER instruction append in script_parse_line,
         * so it points to the instruction AFTER ENDWHILE (for BREAK to work correctly) */
        
        instruction->type = SCRIPT_CMD_ENDWHILE;
        instruction->arg1 = script_duplicate_string(script_loop_stack[script_loop_depth].start_label);
        instruction->arg2 = script_duplicate_string(script_loop_stack[script_loop_depth].end_label);
        return 1;
    }

    /* BREAK - exit innermost loop */
    if (script_stringcasecmp(token, "break") == 0)
    {
        if (script_loop_depth <= 0)
        {
            script_set_error(state, "BREAK outside of loop on line %d", line_number);
            return 0;
        }

        instruction->type = SCRIPT_CMD_BREAK;
        instruction->arg1 = script_duplicate_string(script_loop_stack[script_loop_depth - 1].end_label);
        return 1;
    }

    /* CONTINUE - jump to loop test */
    if (script_stringcasecmp(token, "continue") == 0)
    {
        if (script_loop_depth <= 0)
        {
            script_set_error(state, "CONTINUE outside of loop on line %d", line_number);
            return 0;
        }

        instruction->type = SCRIPT_CMD_CONTINUE;
        instruction->arg1 = script_duplicate_string(script_loop_stack[script_loop_depth - 1].test_label);
        return 1;
    }

    if (script_stringcasecmp(token, "oscli") == 0)
    {
        char *rest = strtok(NULL, "");
        instruction->type = SCRIPT_CMD_OSCLI;
        if (rest != NULL)
        {
            size_t consumed = 0;
            char *value = NULL;
            if (script_parse_backtick_string(rest, &consumed, &value))
            {
                instruction->arg1 = value;
            }
            else
            {
                instruction->arg1 = script_duplicate_string(script_trim(rest));
            }
        }
        return 1;
    }

    if (script_stringcasecmp(token, "cls") == 0)
    {
        instruction->type = SCRIPT_CMD_CLS;
        return 1;
    }

    if (script_stringcasecmp(token, "cll") == 0)
    {
        instruction->type = SCRIPT_CMD_CLL;
        return 1;
    }

    if (script_stringcasecmp(token, "pos") == 0)
    {
        char *col = strtok(NULL, " \t");
        char *row = strtok(NULL, " \t");
        if (col == NULL || row == NULL)
        {
            script_set_error(state, "Malformed pos on line %d", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_POS;
        instruction->arg1 = script_duplicate_string(row);
        instruction->arg2 = script_duplicate_string(col);
        return 1;
    }

    if (script_stringcasecmp(token, "script") == 0)
    {
        char *path_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        if (path_text == NULL)
        {
            script_set_error(state, "Missing filename for script on line %d", line_number);
            return 0;
        }

        path_text = script_trim(path_text);
        if (!script_parse_backtick_string(path_text, &consumed, &value_string))
        {
            value_string = script_duplicate_string(path_text);
        }

        instruction->type = SCRIPT_CMD_SCRIPT;
        instruction->arg1 = value_string;
        return 1;
    }

    if (script_stringcasecmp(token, "logoff") == 0)
    {
        instruction->type = SCRIPT_CMD_LOGOFF;
        return 1;
    }

    if (script_stringcasecmp(token, "online") == 0)
    {
        instruction->type = SCRIPT_CMD_ONLINE;
        return 1;
    }

    if (script_stringcasecmp(token, "loginscan") == 0)
    {
        instruction->type = SCRIPT_CMD_LOGINSCAN;
        return 1;
    }

    if (script_stringcasecmp(token, "more") == 0)
    {
        char *arg = strtok(NULL, " \t");
        instruction->type = SCRIPT_CMD_MORE;
        instruction->arg1 = script_duplicate_string(arg != NULL ? arg : "1");
        return 1;
    }

    if (script_stringcasecmp(token, "filebase") == 0)
    {
        char *subcmd = strtok(NULL, " \t");
        char *arg_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_FILEBASE;
        instruction->arg1 = script_duplicate_string(subcmd != NULL ? subcmd : "list");

        if (arg_text != NULL)
        {
            arg_text = script_trim(arg_text);
            if (!script_parse_backtick_string(arg_text, &consumed, &value_string))
            {
                value_string = script_duplicate_string(arg_text);
            }
            instruction->arg2 = value_string;
        }
        return 1;
    }

    if (script_stringcasecmp(token, "logon") == 0)
    {
        instruction->type = SCRIPT_CMD_LOGON;
        return 1;
    }

    if (script_stringcasecmp(token, "newuser") == 0)
    {
        instruction->type = SCRIPT_CMD_NEWUSER;
        return 1;
    }

    if (script_stringcasecmp(token, "sendfile") == 0)
    {
        /* SENDFILE <file_id> [protocol]
         * protocol: xmodem, xmodem-crc, xmodem-1k, ymodem, ymodem-g (default: xmodem-crc)
         */
        char *file_id_str = strtok(NULL, " \t");
        char *protocol_str = strtok(NULL, " \t");

        instruction->type = SCRIPT_CMD_SENDFILE;
        instruction->arg1 = script_duplicate_string(file_id_str != NULL ? file_id_str : "0");
        instruction->arg2 = script_duplicate_string(protocol_str != NULL ? protocol_str : "xmodem-crc");
        return 1;
    }

    if (script_stringcasecmp(token, "receivefile") == 0)
    {
        /* RECEIVEFILE <filename> [protocol]
         * protocol: xmodem, xmodem-crc, xmodem-1k, ymodem, ymodem-g, zmodem
         * If protocol omitted, user is prompted to select
         */
        char *filename_str = strtok(NULL, " \t");
        char *protocol_str = strtok(NULL, " \t");

        instruction->type = SCRIPT_CMD_RECEIVEFILE;
        instruction->arg1 = script_duplicate_string(filename_str != NULL ? filename_str : "");
        instruction->arg2 = script_duplicate_string(protocol_str != NULL ? protocol_str : "");
        return 1;
    }

    /* Math commands: add, sub, mul, div, mod
     * Syntax: add <result_var> <operand1> <operand2>
     */
    if (script_stringcasecmp(token, "add") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed add on line %d (usage: add result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_ADD;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "sub") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed sub on line %d (usage: sub result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_SUB;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "mul") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed mul on line %d (usage: mul result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_MUL;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "div") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed div on line %d (usage: div result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_DIV;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    if (script_stringcasecmp(token, "mod") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *op1 = strtok(NULL, " \t");
        char *op2 = strtok(NULL, " \t");
        if (result == NULL || op1 == NULL || op2 == NULL)
        {
            script_set_error(state, "Malformed mod on line %d (usage: mod result op1 op2)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_MOD;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(op1);
        instruction->arg3 = script_duplicate_string(op2);
        return 1;
    }

    /* Random: random <result_var> <min> <max> */
    if (script_stringcasecmp(token, "random") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *min_str = strtok(NULL, " \t");
        char *max_str = strtok(NULL, " \t");
        if (result == NULL || min_str == NULL || max_str == NULL)
        {
            script_set_error(state, "Malformed random on line %d (usage: random result min max)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_RANDOM;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(min_str);
        instruction->arg3 = script_duplicate_string(max_str);
        return 1;
    }

    /* String length: strlen <result_var> <string_var> */
    if (script_stringcasecmp(token, "strlen") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *source = strtok(NULL, " \t");
        if (result == NULL || source == NULL)
        {
            script_set_error(state, "Malformed strlen on line %d (usage: strlen result source)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_STRLEN;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(source);
        return 1;
    }

    /* Check if user has a key: haskey <result_var> <key> */
    if (script_stringcasecmp(token, "haskey") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *key = strtok(NULL, " \t");
        if (result == NULL || key == NULL)
        {
            script_set_error(state, "Malformed haskey on line %d (usage: haskey result key)", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_HASKEY;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(key);
        return 1;
    }

    /* ANSI terminal detection: detectansi <result_var> [timeout_ms] */
    if (script_stringcasecmp(token, "detectansi") == 0)
    {
        char *result = strtok(NULL, " \t");
        char *timeout = strtok(NULL, " \t");
        if (result == NULL)
        {
            script_set_error(state, "Malformed detectansi on line %d (usage: detectansi result [timeout_ms])", line_number);
            return 0;
        }
        instruction->type = SCRIPT_CMD_DETECTANSI;
        instruction->arg1 = script_duplicate_string(result);
        instruction->arg2 = script_duplicate_string(timeout != NULL ? timeout : "3000");
        return 1;
    }

    /* Sysop chat: sysopchat - prompts for reason then pages sysop */
    if (script_stringcasecmp(token, "sysopchat") == 0)
    {
        instruction->type = SCRIPT_CMD_SYSOPCHAT;
        return 1;
    }

    /* Messagebase: messagebase <subcommand> [args] */
    if (script_stringcasecmp(token, "messagebase") == 0)
    {
        char *subcmd = strtok(NULL, " \t");
        char *arg_text = strtok(NULL, "");
        char *value_string = NULL;
        size_t consumed = 0;

        instruction->type = SCRIPT_CMD_MESSAGEBASE;
        instruction->arg1 = script_duplicate_string(subcmd != NULL ? subcmd : "list");

        if (arg_text != NULL)
        {
            arg_text = script_trim(arg_text);
            if (!script_parse_backtick_string(arg_text, &consumed, &value_string))
            {
                value_string = script_duplicate_string(arg_text);
            }
            instruction->arg2 = value_string;
        }
        return 1;
    }

    script_set_error(state, "Unknown command '%s' on line %d", token, line_number);
    return 0;
}

static char *script_duplicate_string(const char *source)
{
    char *copy;
    if (source == NULL)
    {
        return NULL;
    }
    copy = (char *)malloc(strlen(source) + 1);
    if (copy != NULL)
    {
        strcpy(copy, source);
    }
    return copy;
}

static int script_append_instruction(script_state *state, script_instruction *instr)
{
    if (state->instruction_count >= state->instruction_capacity)
    {
        size_t new_capacity = state->instruction_capacity + SCRIPT_DEFAULT_INSTRUCTION_CAPACITY;
        script_instruction *resized = (script_instruction *)realloc(state->instructions, new_capacity * sizeof(script_instruction));
        if (resized == NULL)
        {
            return 0;
        }
        state->instructions = resized;
        state->instruction_capacity = new_capacity;
    }

    state->instructions[state->instruction_count] = *instr;
    state->instruction_count++;
    return 1;
}

static int script_register_label(script_state *state, const char *name)
{
    if (name == NULL || *name == '\0')
    {
        return 0;
    }

    if (state->label_count >= state->label_capacity)
    {
        size_t new_capacity = state->label_capacity + SCRIPT_DEFAULT_LABEL_CAPACITY;
        script_label *resized = (script_label *)realloc(state->labels, new_capacity * sizeof(script_label));
        if (resized == NULL)
        {
            return 0;
        }
        state->labels = resized;
        state->label_capacity = new_capacity;
    }

    state->labels[state->label_count].name = script_duplicate_string(name);
    state->labels[state->label_count].instruction_index = state->instruction_count;
    state->label_count++;
    return 1;
}

static size_t script_find_label(const script_state *state, const char *name, int *found)
{
    if (found != NULL)
    {
        *found = 0;
    }

    size_t i;

    if (state == NULL || name == NULL)
    {
        return 0;
    }

    for (i = 0; i < state->label_count; ++i)
    {
        if (state->labels[i].name != NULL && script_stringcasecmp(state->labels[i].name, name) == 0)
        {
            if (found != NULL)
            {
                *found = 1;
            }
            return state->labels[i].instruction_index;
        }
    }

    return 0;
}

static script_variable *script_find_variable(script_state *state, const char *name, int create_if_missing)
{
    size_t i;

    if (state == NULL || name == NULL)
    {
        return NULL;
    }

    for (i = 0; i < state->variable_count; ++i)
    {
        if (script_stringcasecmp(state->variables[i].name, name) == 0)
        {
            return &state->variables[i];
        }
    }

    if (!create_if_missing)
    {
        return NULL;
    }

    if (state->variable_count >= state->variable_capacity)
    {
        size_t new_capacity = state->variable_capacity + SCRIPT_DEFAULT_VARIABLE_CAPACITY;
        script_variable *resized = (script_variable *)realloc(state->variables, new_capacity * sizeof(script_variable));
        if (resized == NULL)
        {
            return NULL;
        }
        state->variables = resized;
        state->variable_capacity = new_capacity;
    }

    memset(&state->variables[state->variable_count], 0, sizeof(script_variable));
    strncpy(state->variables[state->variable_count].name, name, sizeof(state->variables[state->variable_count].name) - 1);
    state->variables[state->variable_count].value = script_duplicate_string("");
    state->variable_count++;
    return &state->variables[state->variable_count - 1];
}

static void script_execute_instruction(script_state *state, script_instruction *instruction)
{
    if (state == NULL || instruction == NULL)
    {
        return;
    }

    switch (instruction->type)
    {
        case SCRIPT_CMD_PRINT:
        {
            char buffer[512];
            const char *text = instruction->arg1 != NULL ? instruction->arg1 : "";
            script_expand_macros(state, text, buffer, sizeof(buffer));
            script_translate_escapes(buffer);
            script_write_output(state, buffer);
        }
        break;

        case SCRIPT_CMD_GOTO:
        {
            size_t pc;
            int found = 0;
            pc = script_find_label(state, instruction->arg1, &found);
            if (!found)
            {
                script_set_error(state, "Unknown label '%s'", instruction->arg1 != NULL ? instruction->arg1 : "");
                state->status = SCRIPT_STATUS_ERROR;
            }
            else
            {
                state->program_counter = pc;
            }
        }
        break;

        case SCRIPT_CMD_PROMPT:
        {
            const char *var = instruction->arg1 != NULL ? instruction->arg1 : "selection";
            const char *mode_str = instruction->arg2 != NULL ? instruction->arg2 : "char";
            const char *echo_str = instruction->arg3 != NULL ? instruction->arg3 : "echo";
            int want_line = (script_stringcasecmp(mode_str, "line") == 0);
            int want_echo = (script_stringcasecmp(echo_str, "noecho") != 0);
            script_input_mode_t mode;

            /* Determine the input mode based on line/char and echo settings */
            if (want_line)
            {
                mode = want_echo ? SCRIPT_INPUT_MODE_LINE : SCRIPT_INPUT_MODE_LINE_NOECHO;
            }
            else
            {
                mode = want_echo ? SCRIPT_INPUT_MODE_CHAR_ECHO : SCRIPT_INPUT_MODE_CHAR;
            }

            strncpy(state->input_target, var, sizeof(state->input_target) - 1);
            state->input_target[sizeof(state->input_target) - 1] = '\0';
            script_begin_input(state, mode, SCRIPT_INPUT_CTX_PROMPT);
            return;
        }

        case SCRIPT_CMD_IF:
        {
            /* Compound condition support: var op value [&& var op value]... [|| var op value]...
             * arg1 = full condition expression, arg2 = label (or else_label for block IF)
             * arg3 = "block" if this is a block IF (invert result)
             * arg4 = endif_label for block IF (fallback if no else)
             */
            const char *condition_expr = instruction->arg1;
            const char *label = instruction->arg2;
            const char *endif_label = instruction->arg4;
            int is_block_if = (instruction->arg3 != NULL && strcmp(instruction->arg3, "block") == 0);
            int final_result = 0;

            if (condition_expr != NULL)
            {
                char expr_copy[1024];
                char *p;
                char *clause_start;
                int current_result = 0;
                int have_result = 0;
                int pending_or = 0;
                int pending_and = 0;

                strncpy(expr_copy, condition_expr, sizeof(expr_copy) - 1);
                expr_copy[sizeof(expr_copy) - 1] = '\0';

                p = expr_copy;
                clause_start = p;

                while (1)
                {
                    char *and_pos = strstr(p, "&&");
                    char *or_pos = strstr(p, "||");
                    char *next_op = NULL;
                    int is_and = 0;
                    char *clause_end;
                    char clause[256];
                    char var[128], op[16], val[256];
                    char var_expanded[512], val_expanded[512];
                    const char *var_value;
                    int clause_result = 0;

                    /* Find the nearest operator */
                    if (and_pos != NULL && (or_pos == NULL || and_pos < or_pos))
                    {
                        next_op = and_pos;
                        is_and = 1;
                    }
                    else if (or_pos != NULL)
                    {
                        next_op = or_pos;
                        is_and = 0;
                    }

                    /* Extract current clause */
                    if (next_op != NULL)
                    {
                        clause_end = next_op;
                    }
                    else
                    {
                        clause_end = p + strlen(p);
                    }

                    /* Copy and trim the clause */
                    {
                        size_t len = (size_t)(clause_end - clause_start);
                        if (len >= sizeof(clause)) len = sizeof(clause) - 1;
                        strncpy(clause, clause_start, len);
                        clause[len] = '\0';
                    }

                    /* Parse clause: var op value */
                    {
                        char *cp = clause;
                        char *var_start;
                        char *contains_pos;

                        /* Skip leading whitespace */
                        while (*cp && isspace((unsigned char)*cp)) cp++;
                        var_start = cp;

                        /* Check for "contains" operator first (word-based) */
                        contains_pos = strstr(cp, " contains ");
                        if (contains_pos != NULL)
                        {
                            size_t vlen = (size_t)(contains_pos - var_start);
                            if (vlen >= sizeof(var)) vlen = sizeof(var) - 1;
                            strncpy(var, var_start, vlen);
                            var[vlen] = '\0';
                            while (vlen > 0 && isspace((unsigned char)var[vlen-1])) var[--vlen] = '\0';
                            
                            strcpy(op, "contains");
                            cp = contains_pos + 10; /* skip " contains " */
                            while (*cp && isspace((unsigned char)*cp)) cp++;
                            
                            /* Check for backtick-quoted value */
                            if (*cp == '`')
                            {
                                char *end_tick = strchr(cp + 1, '`');
                                if (end_tick != NULL)
                                {
                                    size_t vlen2 = (size_t)(end_tick - cp - 1);
                                    if (vlen2 >= sizeof(val)) vlen2 = sizeof(val) - 1;
                                    strncpy(val, cp + 1, vlen2);
                                    val[vlen2] = '\0';
                                }
                                else
                                {
                                    strncpy(val, cp + 1, sizeof(val) - 1);
                                    val[sizeof(val) - 1] = '\0';
                                }
                            }
                            else
                            {
                                strncpy(val, cp, sizeof(val) - 1);
                                val[sizeof(val) - 1] = '\0';
                                {
                                    size_t vlen2 = strlen(val);
                                    while (vlen2 > 0 && isspace((unsigned char)val[vlen2-1])) val[--vlen2] = '\0';
                                }
                            }
                        }
                        else
                        {
                            /* Find variable name end (original logic) */
                            while (*cp && !isspace((unsigned char)*cp) && 
                                   strncmp(cp, "==", 2) != 0 && strncmp(cp, "!=", 2) != 0 &&
                                   strncmp(cp, ">=", 2) != 0 && strncmp(cp, "<=", 2) != 0 &&
                                   *cp != '>' && *cp != '<') cp++;
                            
                            {
                                size_t vlen = (size_t)(cp - var_start);
                                if (vlen >= sizeof(var)) vlen = sizeof(var) - 1;
                                strncpy(var, var_start, vlen);
                                var[vlen] = '\0';
                                while (vlen > 0 && isspace((unsigned char)var[vlen-1])) var[--vlen] = '\0';
                            }

                            /* Skip whitespace before operator */
                            while (*cp && isspace((unsigned char)*cp)) cp++;

                            /* Find operator */
                            if (strncmp(cp, "==", 2) == 0 || strncmp(cp, "!=", 2) == 0 ||
                                strncmp(cp, ">=", 2) == 0 || strncmp(cp, "<=", 2) == 0)
                            {
                                op[0] = *cp++;
                                op[1] = *cp++;
                                op[2] = '\0';
                            }
                            else if (*cp == '>' || *cp == '<')
                            {
                                op[0] = *cp++;
                                op[1] = '\0';
                            }
                            else
                            {
                                op[0] = '\0';
                            }

                            /* Skip whitespace before value */
                            while (*cp && isspace((unsigned char)*cp)) cp++;

                            /* Check for backtick-quoted value */
                            if (*cp == '`')
                            {
                                char *end_tick = strchr(cp + 1, '`');
                                if (end_tick != NULL)
                                {
                                    size_t vlen = (size_t)(end_tick - cp - 1);
                                    if (vlen >= sizeof(val)) vlen = sizeof(val) - 1;
                                    strncpy(val, cp + 1, vlen);
                                    val[vlen] = '\0';
                                }
                                else
                                {
                                    strncpy(val, cp + 1, sizeof(val) - 1);
                                    val[sizeof(val) - 1] = '\0';
                                }
                            }
                            else
                            {
                                strncpy(val, cp, sizeof(val) - 1);
                                val[sizeof(val) - 1] = '\0';
                                {
                                    size_t vlen = strlen(val);
                                    while (vlen > 0 && isspace((unsigned char)val[vlen-1])) val[--vlen] = '\0';
                                }
                            }
                        }
                    }

                    /* Get variable value and expand macros */
                    script_expand_macros(state, var, var_expanded, sizeof(var_expanded));
                    
                    if (strcmp(var, var_expanded) == 0)
                    {
                        var_value = script_get_variable_value(state, var);
                        if (var_value != NULL)
                        {
                            script_expand_macros(state, var_value, var_expanded, sizeof(var_expanded));
                        }
                    }
                    script_expand_macros(state, val, val_expanded, sizeof(val_expanded));

                    /* Evaluate the comparison */
                    if (strcmp(op, "==") == 0)
                    {
                        clause_result = (script_stringcasecmp(var_expanded, val_expanded) == 0);
                    }
                    else if (strcmp(op, "!=") == 0)
                    {
                        clause_result = (script_stringcasecmp(var_expanded, val_expanded) != 0);
                    }
                    else if (strcmp(op, ">") == 0)
                    {
                        clause_result = (atoi(var_expanded) > atoi(val_expanded));
                    }
                    else if (strcmp(op, "<") == 0)
                    {
                        clause_result = (atoi(var_expanded) < atoi(val_expanded));
                    }
                    else if (strcmp(op, ">=") == 0)
                    {
                        clause_result = (atoi(var_expanded) >= atoi(val_expanded));
                    }
                    else if (strcmp(op, "<=") == 0)
                    {
                        clause_result = (atoi(var_expanded) <= atoi(val_expanded));
                    }
                    else if (strcmp(op, "contains") == 0)
                    {
                        /* Case-insensitive substring search */
                        clause_result = (script_strcasestr(var_expanded, val_expanded) != NULL);
                    }

                    /* Combine with previous results */
                    if (!have_result)
                    {
                        current_result = clause_result;
                        have_result = 1;
                    }
                    else if (pending_and)
                    {
                        current_result = current_result && clause_result;
                    }
                    else if (pending_or)
                    {
                        current_result = current_result || clause_result;
                    }

                    pending_and = 0;
                    pending_or = 0;

                    /* Move to next clause or exit */
                    if (next_op == NULL)
                    {
                        break;
                    }

                    if (is_and)
                    {
                        pending_and = 1;
                    }
                    else
                    {
                        pending_or = 1;
                    }

                    p = next_op + 2;
                    clause_start = p;
                }

                final_result = current_result;
            }

            /* For block IF, we want to jump if condition is FALSE (skip the block)
             * For goto IF, we want to jump if condition is TRUE */
            if (is_block_if)
            {
                if (!final_result)
                {
                    /* Condition is false, jump to else or endif */
                    size_t pc;
                    int found = 0;
                    
                    /* Try else label first */
                    pc = script_find_label(state, label, &found);
                    if (!found && endif_label != NULL)
                    {
                        /* No else, try endif label */
                        pc = script_find_label(state, endif_label, &found);
                    }
                    
                    if (found)
                    {
                        state->program_counter = pc;
                    }
                    /* If neither found, just continue (will hit error at else/endif) */
                }
                /* If condition is true, just continue into the block */
            }
            else
            {
                /* Original goto behavior: jump if true */
                if (final_result)
                {
                    size_t pc;
                    int found = 0;
                    pc = script_find_label(state, label, &found);
                    if (!found)
                    {
                        script_set_error(state, "Unknown label '%s'", label != NULL ? label : "");
                        state->status = SCRIPT_STATUS_ERROR;
                    }
                    else
                    {
                        state->program_counter = pc;
                    }
                }
            }
        }
        break;

        case SCRIPT_CMD_SET:
        {
            if (instruction->arg1 != NULL)
            {
                char buffer[512];
                const char *value_text = instruction->arg2 != NULL ? instruction->arg2 : "";
                script_expand_macros(state, value_text, buffer, sizeof(buffer));
                script_set_variable_value(state, instruction->arg1, buffer);
            }
        }
        break;

        case SCRIPT_CMD_ADD:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                snprintf(result, sizeof(result), "%d", val1 + val2);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_SUB:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                snprintf(result, sizeof(result), "%d", val1 - val2);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_MUL:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                snprintf(result, sizeof(result), "%d", val1 * val2);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_DIV:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                if (val2 != 0)
                {
                    snprintf(result, sizeof(result), "%d", val1 / val2);
                }
                else
                {
                    snprintf(result, sizeof(result), "0");
                }
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_MOD:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int val1, val2;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                val1 = atoi(buf1);
                val2 = atoi(buf2);
                if (val2 != 0)
                {
                    snprintf(result, sizeof(result), "%d", val1 % val2);
                }
                else
                {
                    snprintf(result, sizeof(result), "0");
                }
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_RANDOM:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL && instruction->arg3 != NULL)
            {
                char buf1[64], buf2[64], result[64];
                int min_val, max_val, rand_val;
                script_expand_macros(state, instruction->arg2, buf1, sizeof(buf1));
                script_expand_macros(state, instruction->arg3, buf2, sizeof(buf2));
                min_val = atoi(buf1);
                max_val = atoi(buf2);
                if (max_val > min_val)
                {
                    rand_val = min_val + (rand() % (max_val - min_val + 1));
                }
                else
                {
                    rand_val = min_val;
                }
                snprintf(result, sizeof(result), "%d", rand_val);
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_STRLEN:
        {
            if (instruction->arg1 != NULL && instruction->arg2 != NULL)
            {
                char expanded[512], result[64];
                const char *source = script_get_variable_value(state, instruction->arg2);
                if (source == NULL) source = "";
                script_expand_macros(state, source, expanded, sizeof(expanded));
                snprintf(result, sizeof(result), "%d", (int)strlen(expanded));
                script_set_variable_value(state, instruction->arg1, result);
            }
        }
        break;

        case SCRIPT_CMD_HASKEY:
        {
            /* Check if user has a specific key
             * Keys are stored as a space or comma-separated list
             * e.g., "A B C" or "A,B,C" or "A, B, C"
             */
            if (instruction->arg1 != NULL && instruction->arg2 != NULL)
            {
                const char *user_keys = state->host.get_user_keys != NULL ? 
                    state->host.get_user_keys(state->host.context) : "";
                const char *check_key = instruction->arg2;
                char keys_copy[256];
                char *key_tok;
                int found = 0;
                
                if (user_keys != NULL && *user_keys != '\0')
                {
                    strncpy(keys_copy, user_keys, sizeof(keys_copy) - 1);
                    keys_copy[sizeof(keys_copy) - 1] = '\0';
                    
                    /* Tokenize on space, comma, or both */
                    key_tok = strtok(keys_copy, " ,");
                    while (key_tok != NULL && !found)
                    {
                        if (script_stringcasecmp(key_tok, check_key) == 0)
                        {
                            found = 1;
                        }
                        key_tok = strtok(NULL, " ,");
                    }
                }
                
                script_set_variable_value(state, instruction->arg1, found ? "1" : "0");
            }
        }
        break;

        case SCRIPT_CMD_DETECTANSI:
        {
            /* ANSI terminal detection using Device Status Report (DSR)
             * Send ESC[6n (cursor position report request)
             * ANSI terminals respond with ESC[<row>;<col>R
             * Dumb terminals don't respond
             */
            const char *result_var = instruction->arg1;
            const char *timeout_str = instruction->arg2;
            unsigned int timeout_ms;
            
            if (result_var == NULL)
            {
                break;
            }
            
            /* Parse timeout (default 3000ms) */
            timeout_ms = (timeout_str != NULL) ? (unsigned int)strtoul(timeout_str, NULL, 10) : 3000;
            if (timeout_ms < 500) timeout_ms = 500;     /* Minimum 500ms */
            if (timeout_ms > 10000) timeout_ms = 10000; /* Maximum 10 seconds */
            
            /* Store result variable name */
            strncpy(state->ansi_result_var, result_var, sizeof(state->ansi_result_var) - 1);
            state->ansi_result_var[sizeof(state->ansi_result_var) - 1] = '\0';
            
            /* Reset ANSI detection state */
            state->ansi_parse_state = 0;
            state->ansi_response_len = 0;
            memset(state->ansi_response, 0, sizeof(state->ansi_response));
            
            /* Calculate deadline using CLOCKS_PER_SEC for proper timing */
            {
                clock_t ticks = (clock_t)(((double)timeout_ms / 1000.0) * CLOCKS_PER_SEC);
                if (ticks < 1) ticks = 1;
                state->ansi_deadline = clock() + ticks;
                debug_printf("ANSI detect: sending ESC[6n, timeout=%ums, CLOCKS_PER_SEC=%d, ticks=%ld\n",
                             timeout_ms, CLOCKS_PER_SEC, (long)ticks);
            }
            
            /* Send DSR query: ESC[6n */
            script_write_output(state, "\033[6n");
            
            /* Wait for response using unified input with SPECIAL mode for ANSI detection */
            script_begin_input(state, SCRIPT_INPUT_MODE_SPECIAL, SCRIPT_INPUT_CTX_ANSI_DETECT);
            return;
        }

        case SCRIPT_CMD_SYSOPCHAT:
        {
            /* Sysop chat - prompt for reason then page sysop */
            script_write_output(state, "\r\n\033[1;36mEnter reason to chat with sysop (or press Enter to cancel):\033[0m\r\n");
            script_write_output(state, "> ");
            
            script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_CHAT_REASON);
            return;
        }

        case SCRIPT_CMD_MESSAGEBASE:
        {
            const char *subcmd = instruction->arg1 != NULL ? instruction->arg1 : "list";
            const char *arg_raw = instruction->arg2;
            char arg_expanded[256];
            const char *arg;
            messagebase_session *session = NULL;

            /* Expand macros in argument */
            if (arg_raw != NULL)
            {
                script_expand_macros(state, arg_raw, arg_expanded, sizeof(arg_expanded));
                arg = arg_expanded;
            }
            else
            {
                arg = NULL;
            }

            /* Get messagebase session from host */
            if (state->host.get_messagebase_session != NULL)
            {
                session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
            }

            if (session == NULL)
            {
                script_write_output(state, "\r\n[Messagebase not available]\r\n");
                break;
            }

            /* Update session access level from current user */
            if (state->host.get_user_accesslevel != NULL)
            {
                int level = state->host.get_user_accesslevel(state->host.context);
                const char *keys = NULL;
                const char *realname = NULL;
                int user_id = 0;
                if (state->host.get_user_keys != NULL)
                {
                    keys = state->host.get_user_keys(state->host.context);
                }
                if (state->host.get_user_id != NULL)
                {
                    user_id = state->host.get_user_id(state->host.context);
                }
                if (state->host.get_user_realname != NULL)
                {
                    realname = state->host.get_user_realname(state->host.context);
                }
                messagebase_session_set_access(session, user_id, level, keys, realname);
            }

            if (script_stringcasecmp(subcmd, "list") == 0)
            {
                int saved_more = state->more_override;
                state->more_override = 0;  /* Disable More during list */
                state->more_line_count = 0;  /* Reset line count */
                state->host.write_text(state->host.context, "\033[2J\033[H");  /* Clear screen directly */
                messagebase_list_bases(session, (void (*)(void*, const char*))state->host.write_text, state->host.context);
                state->more_override = saved_more;
                /* Prompt for selection */
                state->host.write_text(state->host.context, "\r\nEnter messagebase number to access: ");
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_SELECT);
                return;
            }
            else if (script_stringcasecmp(subcmd, "select") == 0)
            {
                int base_id;
                LINETASK_MESSAGEBASE_RECORD record;
                char msg[128];

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: messagebase select <id>]\r\n");
                    break;
                }

                base_id = atoi(arg);
                if (base_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid messagebase ID]\r\n");
                    break;
                }

                if (!messagebase_get_info(base_id, &record))
                {
                    script_write_output(state, "\r\n[Messagebase not found]\r\n");
                    break;
                }

                if (!messagebase_check_access(record.accesslevel, record.keys,
                                               session->user_accesslevel, session->user_keys))
                {
                    script_write_output(state, "\r\n[Access denied]\r\n");
                    break;
                }

                session->current_messagebase = base_id;
                session->current_area = 0;
                script_save_user_history(state);
                snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected messagebase: %s\033[0m\r\n", record.name);
                script_write_output(state, msg);
            }
            else if (script_stringcasecmp(subcmd, "areas") == 0)
            {
                if (session->current_messagebase <= 0)
                {
                    script_write_output(state, "[Select a messagebase first]\r\n");
                    break;
                }
                state->more_line_count = 0;  /* Reset line count */
                state->host.write_text(state->host.context, "\033[2J\033[H");  /* Clear screen directly */
                messagebase_list_areas(session, (void (*)(void*, const char*))state->host.write_text, state->host.context);
                /* Prompt for selection */
                state->host.write_text(state->host.context, "\r\nEnter area number to access: ");
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_AREA);
                return;
            }
            else if (script_stringcasecmp(subcmd, "area") == 0)
            {
                int area_id;
                LINETASK_MESSAGEBASE_AREA_RECORD area_record;
                char msg[128];

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: messagebase area <id>]\r\n");
                    break;
                }

                area_id = atoi(arg);
                if (area_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid area ID]\r\n");
                    break;
                }

                if (!messagebase_get_area_info(session->current_messagebase, area_id, &area_record))
                {
                    script_write_output(state, "\r\n[Area not found]\r\n");
                    break;
                }

                /* Note: Messagebase areas don't have their own access control - 
                 * access is controlled at the messagebase level, which was already
                 * checked when the messagebase was selected */

                session->current_area = area_id;
                script_save_user_history(state);
                snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected area: %s\033[0m\r\n", area_record.name);
                script_write_output(state, msg);
            }
            else if (script_stringcasecmp(subcmd, "inbox") == 0)
            {
                /* Read private inbox - automatically selects private area */
                int private_base = 0, private_area = 0;
                
                if (!messagebase_find_private_area_global(&private_base, &private_area))
                {
                    script_write_output(state, "\r\n[No Private Mail area configured]\r\n");
                    break;
                }
                
                /* Save current selection to restore when viewer closes */
                session->viewer.saved_messagebase = session->current_messagebase;
                session->viewer.saved_area = session->current_area;
                
                /* Temporarily select the private area */
                session->current_messagebase = private_base;
                session->current_area = private_area;
                
                if (messagebase_enter_reader(session, (void (*)(void*, const char*))script_write_output, state))
                {
                    /* Reader is now active - wait for char input via unified system */
                    script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_MB_VIEWER);
                    return;
                }
                /* enter_reader already displayed error message */
                /* Restore selection since we didn't enter the reader */
                session->current_messagebase = session->viewer.saved_messagebase;
                session->current_area = session->viewer.saved_area;
                session->viewer.saved_messagebase = 0;
                session->viewer.saved_area = 0;
            }
            else if (script_stringcasecmp(subcmd, "messages") == 0)
            {
                /* Enter continuous message reader */
                if (session->current_messagebase <= 0)
                {
                    script_write_output(state, "\r\n[Select a messagebase first]\r\n");
                    break;
                }
                if (session->current_area <= 0)
                {
                    script_write_output(state, "\r\n[Select an area first]\r\n");
                    break;
                }

                if (messagebase_enter_reader(session, (void (*)(void*, const char*))script_write_output, state))
                {
                    /* Reader is now active - wait for char input via unified system */
                    script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_MB_VIEWER);
                    return;
                }
                /* enter_reader already displayed error message */
            }
            else if (script_stringcasecmp(subcmd, "read") == 0)
            {
                int msg_id;
                LINETASK_MESSAGE_RECORD msg_record;

                if (session->current_messagebase <= 0)
                {
                    script_write_output(state, "\r\n[Select a messagebase first]\r\n");
                    break;
                }
                if (session->current_area <= 0)
                {
                    script_write_output(state, "\r\n[Select an area first]\r\n");
                    break;
                }

                if (arg == NULL || *arg == '\0')
                {
                    msg_id = messagebase_get_first_message_id(session);
                }
                else
                {
                    msg_id = atoi(arg);
                }

                if (msg_id <= 0)
                {
                    script_write_output(state, "\r\n[No messages available]\r\n");
                    break;
                }

                if (!messagebase_get_message_info(session->current_messagebase, msg_id, &msg_record))
                {
                    script_write_output(state, "\r\n[Message not found]\r\n");
                    break;
                }

                if (!messagebase_can_read_message(session, &msg_record))
                {
                    script_write_output(state, "\r\n[Access denied]\r\n");
                    break;
                }

                /* Initialize reader state */
                session->viewer.total_messages = messagebase_count_messages(session);
                session->viewer.message_position = messagebase_get_message_position(session, msg_id);
                session->viewer.reading_direction = READER_DIR_FORWARD;

                messagebase_viewer_init(session, msg_id);
                messagebase_mark_as_read(session, msg_id);
                messagebase_viewer_show_header(session, (void (*)(void*, const char*))script_write_output, state);
                messagebase_viewer_show_body(session, (void (*)(void*, const char*))script_write_output, state);
                messagebase_viewer_show_prompt(session, (void (*)(void*, const char*))script_write_output, state);

                /* Wait for char input via unified system */
                script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_MB_VIEWER);
                return;
            }
            else if (script_stringcasecmp(subcmd, "compose") == 0)
            {
                /* messagebase compose [type] [args]
                 * type can be: private [username], netmail [address] [name], or empty for current area
                 */
                char type[32];
                char arg1_buf[64];
                char arg2_buf[64];
                int parsed = 0;
                int result = 0;

                type[0] = '\0';
                arg1_buf[0] = '\0';
                arg2_buf[0] = '\0';

                /* Parse compose type and optional args */
                if (arg != NULL && *arg != '\0')
                {
                    char temp_arg[256];
                    char *tok;
                    strncpy(temp_arg, arg, sizeof(temp_arg) - 1);
                    temp_arg[sizeof(temp_arg) - 1] = '\0';

                    tok = strtok(temp_arg, " \t");
                    if (tok != NULL)
                    {
                        strncpy(type, tok, sizeof(type) - 1);
                        type[sizeof(type) - 1] = '\0';

                        tok = strtok(NULL, " \t");
                        if (tok != NULL)
                        {
                            strncpy(arg1_buf, tok, sizeof(arg1_buf) - 1);
                            arg1_buf[sizeof(arg1_buf) - 1] = '\0';

                            tok = strtok(NULL, "");
                            if (tok != NULL)
                            {
                                while (*tok == ' ' || *tok == '\t') tok++;
                                strncpy(arg2_buf, tok, sizeof(arg2_buf) - 1);
                                arg2_buf[sizeof(arg2_buf) - 1] = '\0';
                            }
                        }
                    }
                }

                if (script_stringcasecmp(type, "private") == 0)
                {
                    /* Disable More? prompts during composer BEFORE starting */
                    composer_more_saved = state->more_override;
                    state->more_override = 0;
                    
                    /* messagebase compose private [username] */
                    result = messagebase_composer_start_private(session,
                        arg1_buf[0] != '\0' ? arg1_buf : NULL,
                        (void (*)(void*, const char*))script_write_output, state);
                    parsed = 1;
                }
                else if (script_stringcasecmp(type, "netmail") == 0)
                {
                    /* Disable More? prompts during composer BEFORE starting */
                    composer_more_saved = state->more_override;
                    state->more_override = 0;
                    
                    /* messagebase compose netmail [address] [name] */
                    result = messagebase_composer_start_netmail(session,
                        arg2_buf[0] != '\0' ? arg2_buf : NULL,
                        arg1_buf[0] != '\0' ? arg1_buf : NULL,
                        (void (*)(void*, const char*))script_write_output, state);
                    parsed = 1;
                }
                else if (type[0] == '\0')
                {
                    /* No type specified - use current area */
                    if (session->current_messagebase <= 0 || session->current_area <= 0)
                    {
                        script_write_output(state, "\r\n[Select a messagebase/area first, or use: compose private / compose netmail]\r\n");
                        break;
                    }
                    
                    /* Disable More? prompts during composer BEFORE starting */
                    composer_more_saved = state->more_override;
                    state->more_override = 0;
                    
                    result = messagebase_composer_start_post(session, 
                        (void (*)(void*, const char*))script_write_output, state);
                    parsed = 1;
                }
                else
                {
                    script_write_output(state, "\r\n[Usage: messagebase compose [private [user] | netmail [addr] [name]]]\r\n");
                    break;
                }

                if (parsed && result)
                {
                    /* Wait for compose input via unified system */
                    script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_COMPOSE);
                    return;
                }
            }
            else if (script_stringcasecmp(subcmd, "reset") == 0)
            {
                messagebase_session_reset(session);
                script_write_output(state, "\r\n[Messagebase selection reset]\r\n");
            }
            else if (script_stringcasecmp(subcmd, "info") == 0)
            {
                int msg_id;

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: messagebase info <id>]\r\n");
                    break;
                }

                msg_id = atoi(arg);
                messagebase_show_message_info(session, msg_id,
                                              (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "search") == 0)
            {
                /* messagebase search [base] [area]
                 * If base/area provided, select them first
                 * Then prompt for search term
                 */
                int base_id = 0;
                int area_id = 0;

                if (arg != NULL && *arg != '\0')
                {
                    char temp_arg[128];
                    char *tok;
                    strncpy(temp_arg, arg, sizeof(temp_arg) - 1);
                    temp_arg[sizeof(temp_arg) - 1] = '\0';

                    tok = strtok(temp_arg, " \t");
                    if (tok != NULL)
                    {
                        base_id = atoi(tok);
                        tok = strtok(NULL, " \t");
                        if (tok != NULL)
                        {
                            area_id = atoi(tok);
                        }
                    }
                }

                /* Select base/area if provided */
                if (base_id > 0)
                {
                    session->current_messagebase = base_id;
                    if (area_id > 0)
                    {
                        session->current_area = area_id;
                    }
                }

                /* Check we have a base and area selected */
                if (session->current_messagebase <= 0)
                {
                    script_write_output(state, "\r\n[Select a messagebase first, or use: messagebase search <base> <area>]\r\n");
                    break;
                }
                if (session->current_area <= 0)
                {
                    script_write_output(state, "\r\n[Select an area first, or use: messagebase search <base> <area>]\r\n");
                    break;
                }

                /* Initialize viewer state for search (not viewing a message yet) */
                session->viewer.phase = MESSAGE_VIEW_IDLE;
                session->viewer.message_id = 0;

                /* Start the search prompt */
                messagebase_viewer_start_search(session,
                                                 (void (*)(void*, const char*))script_write_output, state);

                /* Switch to line input for search term via unified system */
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_MB_SEARCH);
                return;
            }
            else
            {
                char msg[128];
                snprintf(msg, sizeof(msg), "\r\n[Unknown messagebase command: %s]\r\n", subcmd);
                script_write_output(state, msg);
            }
        }
        break;

        case SCRIPT_CMD_CALL:
        {
            const char *action = instruction->arg1 != NULL ? instruction->arg1 : "";
            if (script_stringcasecmp(action, "time") == 0)
            {
                if (state->host.report_time != NULL)
                {
                    state->host.report_time(state->host.context);
                }
            }
            else if (script_stringcasecmp(action, "lineinfo") == 0)
            {
                if (state->host.report_line_info != NULL)
                {
                    state->host.report_line_info(state->host.context);
                }
            }
            else if (script_stringcasecmp(action, "riscbbsdoor") == 0)
            {
                if (state->host.launch_riscbbs_door != NULL)
                {
                    char buffer[256];
                    const char *command = instruction->arg2 != NULL ? instruction->arg2 : "";
                    int use_26bit = (instruction->arg3 != NULL && 
                                     script_stringcasecmp(instruction->arg3, "26bit") == 0) ? 1 : 0;
                    script_expand_macros(state, command, buffer, sizeof(buffer));
                    state->host.launch_riscbbs_door(state->host.context, buffer, use_26bit);
                    state->status = SCRIPT_STATUS_WAIT_DOOR;
                }
            }
            else if (script_stringcasecmp(action, "arcbbsdoor") == 0)
            {
                if (state->host.launch_arcbbs_door != NULL)
                {
                    char num_buffer[16];
                    char cmd_buffer[256];
                    const char *door_num_str = instruction->arg2 != NULL ? instruction->arg2 : "1";
                    const char *command = instruction->arg3 != NULL ? instruction->arg3 : "";
                    int use_26bit = (instruction->arg4 != NULL && 
                                     script_stringcasecmp(instruction->arg4, "26bit") == 0) ? 1 : 0;
                    int door_number;
                    script_expand_macros(state, door_num_str, num_buffer, sizeof(num_buffer));
                    script_expand_macros(state, command, cmd_buffer, sizeof(cmd_buffer));
                    door_number = atoi(num_buffer);
                    if (door_number < 1) door_number = 1;
                    if (door_number > 254) door_number = 254;
                    state->host.launch_arcbbs_door(state->host.context, door_number, cmd_buffer, use_26bit);
                    state->status = SCRIPT_STATUS_WAIT_DOOR;
                }
            }
            else if (script_stringcasecmp(action, "door") == 0)
            {
                if (state->host.launch_door != NULL)
                {
                    char buffer[256];
                    const char *command = instruction->arg2 != NULL ? instruction->arg2 : "";
                    int use_26bit = (instruction->arg3 != NULL && 
                                     script_stringcasecmp(instruction->arg3, "26bit") == 0) ? 1 : 0;
                    script_expand_macros(state, command, buffer, sizeof(buffer));
                    state->host.launch_door(state->host.context, buffer, use_26bit);
                    state->status = SCRIPT_STATUS_WAIT_DOOR;
                }
            }
            else if (script_stringcasecmp(action, "disconnect") == 0)
            {
                if (state->host.request_disconnect != NULL)
                {
                    state->host.request_disconnect(state->host.context);
                }
            }
            else if (script_stringcasecmp(action, "message") == 0)
            {
                char buffer[512];
                const char *text = instruction->arg2 != NULL ? instruction->arg2 : "";
                script_expand_macros(state, text, buffer, sizeof(buffer));
                script_write_output(state, buffer);
            }
        }
        break;

        case SCRIPT_CMD_DOING:
        {
            if (state->host.report_activity != NULL)
            {
                char buffer[256];
                const char *text = instruction->arg1 != NULL ? instruction->arg1 : "";
                script_expand_macros(state, text, buffer, sizeof(buffer));
                script_translate_escapes(buffer);
                state->host.report_activity(state->host.context, buffer);
            }
        }
        break;

        case SCRIPT_CMD_RETURN:
        {
            /* Return from subscript to calling script, or complete if top-level */
            if (script_pop_call_stack(state))
            {
                /* Restored calling script - continue running */
                state->status = SCRIPT_STATUS_RUNNING;
            }
            else
            {
                /* No calling script - we're done */
                state->status = SCRIPT_STATUS_COMPLETED;
            }
        }
        break;

        case SCRIPT_CMD_PAUSE:
        {
            unsigned int duration = (unsigned int)strtoul(instruction->arg1 != NULL ? instruction->arg1 : "0", NULL, 10);
            state->sleep_deadline = script_calculate_sleep_deadline(duration);
            state->status = SCRIPT_STATUS_WAIT_SLEEP;
            return;
        }

        case SCRIPT_CMD_TYPE:
        {
            script_display_file(state, instruction->arg1, 1);
        }
        break;

        case SCRIPT_CMD_ANYKEY:
        {
            const char *target = (instruction->arg1 != NULL && instruction->arg1[0] != '\0') ? instruction->arg1 : "_key";
            
            /* Display configured anykey file if available */
            if (state->host.get_anykey_file != NULL)
            {
                const char *anykey_file = state->host.get_anykey_file(state->host.context);
                if (anykey_file != NULL && anykey_file[0] != '\0')
                {
                    script_display_file(state, anykey_file, 1);
                }
            }

            strncpy(state->input_target, target, sizeof(state->input_target) - 1);
            state->input_target[sizeof(state->input_target) - 1] = '\0';
            script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_ANYKEY);
            return;
        }

        case SCRIPT_CMD_FG:
        {
            script_apply_colour_change(state, instruction->arg1, NULL, 1, 0);
        }
        break;

        case SCRIPT_CMD_BG:
        {
            script_apply_colour_change(state, NULL, instruction->arg1, 0, 1);
        }
        break;

        case SCRIPT_CMD_FGBG:
        {
            script_apply_colour_change(state, instruction->arg1, instruction->arg2, 1, 1);
        }
        break;

        case SCRIPT_CMD_FLASH:
        {
            script_set_flash(state, instruction->arg1);
        }
        break;

        case SCRIPT_CMD_BOLD:
        {
            /* BOLD [0|1] - enable/disable bold/bright attribute */
            char expanded[32];
            int enable = 1;
            
            if (instruction->arg1 != NULL)
            {
                script_expand_macros(state, instruction->arg1, expanded, sizeof(expanded));
                enable = (atoi(expanded) != 0);
            }
            
            if (state->host.write_text != NULL)
            {
                if (enable)
                {
                    state->host.write_text(state->host.context, "\033[1m");  /* Bold on */
                }
                else
                {
                    state->host.write_text(state->host.context, "\033[22m"); /* Bold off */
                }
            }
        }
        break;

        case SCRIPT_CMD_STD:
        {
            /* STD - reset to standard attributes (white on black, no effects) */
            if (state->host.write_text != NULL)
            {
                state->host.write_text(state->host.context, "\033[0;37;40m");
            }
        }
        break;

        case SCRIPT_CMD_READLINE:
        {
            /* READLINE <variable> [noecho] - read a line of input */
            const char *var = instruction->arg1 != NULL ? instruction->arg1 : "input";
            const char *echo = instruction->arg2 != NULL ? instruction->arg2 : "echo";
            int want_echo = (script_stringcasecmp(echo, "noecho") != 0);
            script_input_mode_t mode = want_echo ? SCRIPT_INPUT_MODE_LINE : SCRIPT_INPUT_MODE_LINE_NOECHO;

            strncpy(state->input_target, var, sizeof(state->input_target) - 1);
            state->input_target[sizeof(state->input_target) - 1] = '\0';
            script_begin_input(state, mode, SCRIPT_INPUT_CTX_PROMPT);
            return;
        }

        case SCRIPT_CMD_YESNO:
        {
            /* YESNO <variable> [prompt_text] - Y/N prompt, stores "1" or "0" */
            const char *var = instruction->arg1 != NULL ? instruction->arg1 : "answer";
            
            /* If there's a prompt, display it */
            if (instruction->arg2 != NULL && instruction->arg2[0] != '\0')
            {
                char expanded[512];
                script_expand_macros(state, instruction->arg2, expanded, sizeof(expanded));
                if (state->host.write_text != NULL)
                {
                    state->host.write_text(state->host.context, expanded);
                }
            }

            strncpy(state->input_target, var, sizeof(state->input_target) - 1);
            state->input_target[sizeof(state->input_target) - 1] = '\0';
            script_begin_input(state, SCRIPT_INPUT_MODE_YESNO, SCRIPT_INPUT_CTX_PROMPT);
            return;
        }

        /* ========== LOOP COMMANDS ========== */

        case SCRIPT_CMD_FOR:
        {
            /* FOR <var> = <start> TO <end> [STEP <n>]
             * arg1 = variable name
             * arg2 = start value
             * arg3 = end value  
             * arg4 = step value (default 1)
             */
            const char *var = instruction->arg1;
            char start_expanded[64], end_expanded[64], step_expanded[64];
            int start_val, end_val, step_val;
            char value_str[32];
            int found = 0;
            size_t start_label_pc;
            
            /* Expand macro values */
            script_expand_macros(state, instruction->arg2, start_expanded, sizeof(start_expanded));
            script_expand_macros(state, instruction->arg3, end_expanded, sizeof(end_expanded));
            script_expand_macros(state, instruction->arg4, step_expanded, sizeof(step_expanded));
            
            start_val = atoi(start_expanded);
            end_val = atoi(end_expanded);
            step_val = atoi(step_expanded);
            if (step_val == 0) step_val = 1;  /* Prevent infinite loop */
            
            /* Set the loop variable to start value */
            snprintf(value_str, sizeof(value_str), "%d", start_val);
            script_set_variable_value(state, var, value_str);
            
            /* Store end and step in special variables for ENDFOR to use */
            snprintf(value_str, sizeof(value_str), "%d", end_val);
            {
                char end_var[80];
                snprintf(end_var, sizeof(end_var), "_for_end_%s", var);
                script_set_variable_value(state, end_var, value_str);
            }
            snprintf(value_str, sizeof(value_str), "%d", step_val);
            {
                char step_var[80];
                snprintf(step_var, sizeof(step_var), "_for_step_%s", var);
                script_set_variable_value(state, step_var, value_str);
            }
            
            /* Check if we should skip the loop entirely */
            if ((step_val > 0 && start_val > end_val) || (step_val < 0 && start_val < end_val))
            {
                /* Skip to end label - find the _for_end_N label */
                char end_label[64];
                /* Extract the loop counter from our internal label naming */
                /* The parsing stored labels in the loop_stack, but we need to find them */
                /* We'll scan forward for ENDFOR and use its end_label */
                size_t i;
                for (i = state->program_counter + 1; i < state->instruction_count; i++)
                {
                    if (state->instructions[i].type == SCRIPT_CMD_ENDFOR &&
                        state->instructions[i].arg1 != NULL &&
                        strcmp(state->instructions[i].arg1, var) == 0)
                    {
                        /* Found matching ENDFOR, jump past it */
                        if (state->instructions[i].arg3 != NULL)
                        {
                            start_label_pc = script_find_label(state, state->instructions[i].arg3, &found);
                            if (found)
                            {
                                state->program_counter = start_label_pc;
                                return;
                            }
                        }
                        break;
                    }
                }
            }
            /* Otherwise continue into the loop body */
        }
        break;

        case SCRIPT_CMD_ENDFOR:
        {
            /* ENDFOR / NEXT
             * arg1 = variable name
             * arg2 = start_label (jump back point)
             * arg3 = end_label (for BREAK)
             */
            const char *var = instruction->arg1;
            const char *start_label = instruction->arg2;
            const char *end_label = instruction->arg3;
            char end_var[80], step_var[80];
            const char *current_str, *end_str, *step_str;
            int current_val, end_val, step_val;
            char value_str[32];
            int found = 0;
            size_t pc;
            
            /* Get current value and limits */
            current_str = script_get_variable_value(state, var);
            current_val = current_str ? atoi(current_str) : 0;
            
            snprintf(end_var, sizeof(end_var), "_for_end_%s", var);
            snprintf(step_var, sizeof(step_var), "_for_step_%s", var);
            
            end_str = script_get_variable_value(state, end_var);
            step_str = script_get_variable_value(state, step_var);
            
            end_val = end_str ? atoi(end_str) : 0;
            step_val = step_str ? atoi(step_str) : 1;
            
            /* Increment the loop variable */
            current_val += step_val;
            snprintf(value_str, sizeof(value_str), "%d", current_val);
            script_set_variable_value(state, var, value_str);
            
            /* Check if we should continue looping */
            if ((step_val > 0 && current_val <= end_val) || (step_val < 0 && current_val >= end_val))
            {
                /* Jump back to start of loop body (instruction after FOR) */
                pc = script_find_label(state, start_label, &found);
                if (found)
                {
                    state->program_counter = pc;
                }
            }
            /* Else fall through to next instruction (loop complete) */
            
            /* Register end label for BREAK to find */
            if (end_label != NULL)
            {
                /* The label should already be registered during parsing */
            }
        }
        break;

        case SCRIPT_CMD_WHILE:
        {
            /* WHILE <condition>
             * arg1 = condition expression
             * arg2 = start_label (for CONTINUE and ENDWHILE)
             * arg3 = end_label (for BREAK)
             */
            const char *condition = instruction->arg1;
            const char *end_label = instruction->arg3;
            int result;
            
            /* Evaluate the condition */
            result = script_evaluate_condition(state, condition);
            
            if (!result)
            {
                /* Condition is false - skip to end of loop */
                int found = 0;
                size_t pc = script_find_label(state, end_label, &found);
                if (found)
                {
                    state->program_counter = pc;
                }
            }
            /* Otherwise continue into the loop body */
        }
        break;

        case SCRIPT_CMD_ENDWHILE:
        {
            /* ENDWHILE
             * arg1 = start_label (jump back to re-test condition)
             * arg2 = end_label (register for BREAK)
             */
            const char *start_label = instruction->arg1;
            int found = 0;
            size_t pc;
            
            /* Jump back to WHILE to re-evaluate condition */
            pc = script_find_label(state, start_label, &found);
            if (found)
            {
                state->program_counter = pc;
            }
        }
        break;

        case SCRIPT_CMD_BREAK:
        {
            /* BREAK - exit innermost loop
             * arg1 = end_label (where to jump)
             */
            const char *end_label = instruction->arg1;
            int found = 0;
            size_t pc;
            
            pc = script_find_label(state, end_label, &found);
            if (found)
            {
                state->program_counter = pc;
            }
        }
        break;

        case SCRIPT_CMD_CONTINUE:
        {
            /* CONTINUE - jump to loop test
             * arg1 = test_label (where to jump)
             * For WHILE: jumps to start (re-test condition)
             * For FOR: jumps to ENDFOR (increment and test)
             */
            const char *test_label = instruction->arg1;
            int found = 0;
            size_t pc;
            
            pc = script_find_label(state, test_label, &found);
            if (found)
            {
                state->program_counter = pc;
            }
        }
        break;

        /* ========== END LOOP COMMANDS ========== */

        case SCRIPT_CMD_OSCLI:
        {
            char expanded[512];
            if (instruction->arg1 != NULL)
            {
                script_expand_macros(state, instruction->arg1, expanded, sizeof(expanded));
                if (expanded[0] != '\0')
                {
                    system(expanded);
                }
            }
        }
        break;

        case SCRIPT_CMD_CLS:
        {
            script_send_clear_screen(state);
            /* Reset line counter when screen is cleared */
            state->more_line_count = 0;
        }
        break;

        case SCRIPT_CMD_CLL:
        {
            script_send_clear_to_eol(state);
        }
        break;

        case SCRIPT_CMD_POS:
        {
            script_move_cursor(state, instruction->arg2, instruction->arg1);
        }
        break;

        case SCRIPT_CMD_SCRIPT:
        {
            char path[256];
            const char *source = instruction->arg1 != NULL ? instruction->arg1 : "";

            script_expand_macros(state, source, path, sizeof(path));
            if (path[0] == '\0')
            {
                script_set_error(state, "Script command missing path");
                state->status = SCRIPT_STATUS_ERROR;
                break;
            }

            /* Push current script onto call stack before loading subscript */
            if (!script_push_call_stack(state))
            {
                state->status = SCRIPT_STATUS_ERROR;
                break;
            }
            
            /* Allocate new instruction/label arrays for subscript */
            state->instruction_capacity = SCRIPT_DEFAULT_INSTRUCTION_CAPACITY;
            state->instructions = (script_instruction *)calloc(state->instruction_capacity, sizeof(script_instruction));
            state->label_capacity = SCRIPT_DEFAULT_LABEL_CAPACITY;
            state->labels = (script_label *)calloc(state->label_capacity, sizeof(script_label));
            
            if (state->instructions == NULL || state->labels == NULL)
            {
                script_set_error(state, "Out of memory loading subscript");
                script_pop_call_stack(state);  /* Restore previous state */
                state->status = SCRIPT_STATUS_ERROR;
                break;
            }

            if (!script_start(state, path))
            {
                /* script_start failed - pop call stack to restore previous script */
                script_pop_call_stack(state);
                state->status = SCRIPT_STATUS_ERROR;
            }
            return;
        }

        case SCRIPT_CMD_LOGOFF:
        {
            if (state->host.force_disconnect != NULL)
            {
                state->host.force_disconnect(state->host.context);
            }
            state->status = SCRIPT_STATUS_COMPLETED;
        }
        break;

        case SCRIPT_CMD_ONLINE:
        {
            if (state->host.report_online_users != NULL)
            {
                state->host.report_online_users(state->host.context);
            }
        }
        break;

        case SCRIPT_CMD_LOGINSCAN:
        {
            /* Login scan - find new messages and files for the user since last scan */
            messagebase_session *msg_session = NULL;
            filebase_session *file_session = NULL;
            const script_user_stats *user_stats = NULL;
            time_t last_scan_time = 0;
            int user_id = 0;
            int user_accesslevel = 0;
            const char *user_keys = NULL;
            int new_messages = 0;
            int new_files = 0;
            _kernel_swi_regs regs;
            char line[256];
            int base_index;

            /* Get user info */
            if (state->host.get_user_id != NULL)
            {
                user_id = state->host.get_user_id(state->host.context);
            }
            if (state->host.get_user_accesslevel != NULL)
            {
                user_accesslevel = state->host.get_user_accesslevel(state->host.context);
            }
            if (state->host.get_user_keys != NULL)
            {
                user_keys = state->host.get_user_keys(state->host.context);
            }
            if (state->host.get_user_stats != NULL)
            {
                user_stats = state->host.get_user_stats(state->host.context);
            }

            if (user_stats != NULL)
            {
                last_scan_time = user_stats->lastscan;
            }

            script_write_output(state, "\r\n\033[1;33mScanning for new messages and files...\033[0m\r\n");

            /* Get sessions */
            if (state->host.get_messagebase_session != NULL)
            {
                msg_session = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
            }
            if (state->host.get_filebase_session != NULL)
            {
                file_session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            }

            /* Scan messagebases for new messages addressed to user */
            if (msg_session != NULL && user_id > 0)
            {
                int saved_base = msg_session->current_messagebase;
                int saved_area = msg_session->current_area;

                /* Enumerate all messagebases */
                base_index = 0;
                while (1)
                {
                    LINETASK_MESSAGEBASE_RECORD *base_rec;
                    int area_index;

                    regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_BASES;
                    regs.r[1] = base_index;

                    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
                    {
                        break;
                    }

                    base_rec = (LINETASK_MESSAGEBASE_RECORD *)regs.r[0];
                    if (base_rec == NULL)
                    {
                        break;
                    }

                    /* Check access to this messagebase */
                    if (!messagebase_check_access(base_rec->accesslevel, base_rec->keys,
                                                  user_accesslevel, user_keys != NULL ? user_keys : ""))
                    {
                        base_index++;
                        continue;
                    }

                    /* Enumerate all areas in this messagebase */
                    area_index = 0;
                    while (1)
                    {
                        LINETASK_MESSAGEBASE_AREA_RECORD *area_rec;
                        int msg_index;
                        int area_new_count = 0;

                        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_AREAS;
                        regs.r[1] = base_rec->id;
                        regs.r[2] = area_index;

                        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
                        {
                            break;
                        }

                        area_rec = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

                        /* Enumerate messages in this area */
                        msg_index = 0;
                        while (1)
                        {
                            LINETASK_MESSAGE_RECORD *msg_rec;

                            regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
                            regs.r[1] = base_rec->id;
                            regs.r[2] = area_rec->id;
                            regs.r[3] = msg_index;

                            if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
                            {
                                break;
                            }

                            msg_rec = (LINETASK_MESSAGE_RECORD *)regs.r[0];

                            /* Check if this message is for the user and is new */
                            if (msg_rec->deleted == 0 &&
                                msg_rec->receivedby == user_id &&
                                (last_scan_time == 0 || msg_rec->imported > last_scan_time) &&
                                msg_rec->read_time == 0)
                            {
                                area_new_count++;
                                new_messages++;
                            }

                            msg_index++;
                        }

                        /* Report if new messages found in this area */
                        if (area_new_count > 0)
                        {
                            snprintf(line, sizeof(line),
                                     "\033[1;33m%d new message(s)\033[0m in \033[1;37m%s\033[0m > \033[1;37m%s\033[0m\r\n",
                                     area_new_count, base_rec->name, area_rec->name);
                            script_write_output(state, line);
                        }

                        area_index++;
                    }

                    base_index++;
                }

                /* Restore session state */
                msg_session->current_messagebase = saved_base;
                msg_session->current_area = saved_area;
            }

            /* Scan filebases for new files */
            if (file_session != NULL)
            {
                int saved_base = file_session->current_filebase;
                int saved_area = file_session->current_area;

                /* Enumerate all filebases */
                base_index = 0;
                while (1)
                {
                    LINETASK_FILEBASE_RECORD *base_rec;
                    int area_index;

                    regs.r[0] = FILEBASE_CMD_ENUMERATE_BASES;
                    regs.r[1] = base_index;

                    if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
                    {
                        break;
                    }

                    base_rec = (LINETASK_FILEBASE_RECORD *)regs.r[0];
                    if (base_rec == NULL)
                    {
                        break;
                    }

                    /* Check access to this filebase */
                    if (!filebase_check_access(base_rec->accesslevel, base_rec->keys,
                                               user_accesslevel, user_keys != NULL ? user_keys : ""))
                    {
                        base_index++;
                        continue;
                    }

                    /* Enumerate all areas in this filebase */
                    area_index = 0;
                    while (1)
                    {
                        LINETASK_FILEBASE_AREA_RECORD *area_rec;
                        int file_index;
                        int area_new_count = 0;

                        regs.r[0] = FILEBASE_CMD_ENUMERATE_AREAS;
                        regs.r[1] = base_rec->id;
                        regs.r[2] = area_index;

                        if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
                        {
                            break;
                        }

                        area_rec = (LINETASK_FILEBASE_AREA_RECORD *)regs.r[0];

                        /* Check access to this area */
                        if (!filebase_check_access(area_rec->accesslevel, area_rec->keys,
                                                   user_accesslevel, user_keys != NULL ? user_keys : ""))
                        {
                            area_index++;
                            continue;
                        }

                        /* Enumerate files in this area */
                        file_index = 0;
                        while (1)
                        {
                            LINETASK_FILE_RECORD *file_rec;

                            regs.r[0] = FILEBASE_CMD_ENUMERATE_FILES;
                            regs.r[1] = base_rec->id;
                            regs.r[2] = area_rec->id;
                            regs.r[3] = file_index;

                            if (_kernel_swi(SWI_FILER_FILEBASE, &regs, &regs) != NULL || regs.r[0] == -1)
                            {
                                break;
                            }

                            file_rec = (LINETASK_FILE_RECORD *)regs.r[0];

                            /* Check if this file is new since last scan */
                            if (file_rec->deleted == 0 &&
                                (last_scan_time == 0 || file_rec->uploaddate > last_scan_time))
                            {
                                /* Check access to this file */
                                if (filebase_check_access(file_rec->accesslevel, file_rec->keys,
                                                          user_accesslevel, user_keys != NULL ? user_keys : ""))
                                {
                                    area_new_count++;
                                    new_files++;
                                }
                            }

                            file_index++;
                        }

                        /* Report if new files found in this area */
                        if (area_new_count > 0)
                        {
                            snprintf(line, sizeof(line),
                                     "\033[1;32m%d new file(s)\033[0m in \033[1;37m%s\033[0m > \033[1;37m%s\033[0m\r\n",
                                     area_new_count, base_rec->name, area_rec->name);
                            script_write_output(state, line);
                        }

                        area_index++;
                    }

                    base_index++;
                }

                /* Restore session state */
                file_session->current_filebase = saved_base;
                file_session->current_area = saved_area;
            }

            /* Summary */
            if (new_messages == 0 && new_files == 0)
            {
                script_write_output(state, "\r\n\033[1;32mNo new messages or files since your last scan.\033[0m\r\n");
            }
            else
            {
                snprintf(line, sizeof(line),
                         "\033[1;36mScan complete: \033[1;33m%d\033[1;36m new message(s), \033[1;32m%d\033[1;36m new file(s).\033[0m\r\n",
                         new_messages, new_files);
                script_write_output(state, line);
            }

            /* Update lastscan timestamp in user record */
            if (user_id > 0 && user_stats != NULL)
            {
                typedef struct {
                    time_t lastlogon;
                    time_t lastscan;
                    int calls;
                    int todaytime;
                    int uploadskb;
                    int downloadskb;
                    int uploads;
                    int downloads;
                } LOGINSCAN_USER_STATS;

                LOGINSCAN_USER_STATS updated_stats;
                time_t now = time(NULL);
                
                updated_stats.lastlogon = user_stats->lastlogon;
                updated_stats.lastscan = now;  /* Update to current time */
                updated_stats.calls = user_stats->calls;
                updated_stats.todaytime = user_stats->todaytime;
                updated_stats.uploadskb = user_stats->uploadskb;
                updated_stats.downloadskb = user_stats->downloadskb;
                updated_stats.uploads = user_stats->uploads;
                updated_stats.downloads = user_stats->downloads;

                regs.r[0] = 6;  /* FILER_USERDB_CMD_UPDATE_STATS */
                regs.r[1] = user_id;
                regs.r[2] = (int)&updated_stats;
                _kernel_swi(0x5AA41, &regs, &regs);  /* SWI_FILER_USERDB */
                
                /* Also update the host's local copy so subsequent saves include the new value */
                if (state->host.update_lastscan != NULL)
                {
                    state->host.update_lastscan(state->host.context, now);
                }
            }
        }
        break;

        case SCRIPT_CMD_MORE:
        {
            /* more <n> - temporarily enable/disable more prompts (0=off, 1=on) */
            char buffer[16];
            int enable;
            const char *arg = instruction->arg1 != NULL ? instruction->arg1 : "1";
            
            script_expand_macros(state, arg, buffer, sizeof(buffer));
            enable = atoi(buffer);
            
            /* Set override: 0 = disabled, 1 = enabled */
            state->more_override = enable ? 1 : 0;
            
            /* Reset line counter when enabling/disabling */
            state->more_line_count = 0;
        }
        break;

        case SCRIPT_CMD_FILEBASE:
        {
            const char *subcmd = instruction->arg1 != NULL ? instruction->arg1 : "list";
            const char *arg_raw = instruction->arg2;
            char arg_expanded[256];
            const char *arg;
            filebase_session *session = NULL;

            /* Expand macros in argument */
            if (arg_raw != NULL)
            {
                script_expand_macros(state, arg_raw, arg_expanded, sizeof(arg_expanded));
                arg = arg_expanded;
            }
            else
            {
                arg = NULL;
            }

            /* Get or create filebase session from host */
            if (state->host.get_filebase_session != NULL)
            {
                session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            }

            if (session == NULL)
            {
                script_write_output(state, "\r\n[Filebase not available]\r\n");
                break;
            }

            /* Update session access level from current user */
            if (state->host.get_user_accesslevel != NULL)
            {
                int level = state->host.get_user_accesslevel(state->host.context);
                const char *keys = NULL;
                if (state->host.get_user_keys != NULL)
                {
                    keys = state->host.get_user_keys(state->host.context);
                }
                filebase_session_set_access(session, level, keys);
            }

            if (script_stringcasecmp(subcmd, "list") == 0)
            {
                /* List available filebases - clear screen and prompt for selection */
                int saved_more = state->more_override;
                state->more_override = 0;  /* Disable More during list */
                state->more_line_count = 0;  /* Reset line count */
                state->host.write_text(state->host.context, "\033[2J\033[H");  /* Clear screen */
                filebase_list_bases(session, (void (*)(void*, const char*))state->host.write_text, state->host.context);
                state->more_override = saved_more;
                /* Prompt for selection */
                state->host.write_text(state->host.context, "\r\nEnter filebase number to access: ");
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_FB_SELECT);
                return;
            }
            else if (script_stringcasecmp(subcmd, "select") == 0)
            {
                /* Select a filebase: filebase select <id> */
                int base_id;
                LINETASK_FILEBASE_RECORD record;
                char msg[128];

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase select <id>]\r\n");
                    break;
                }

                base_id = atoi(arg);

                if (base_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid filebase ID]\r\n");
                    break;
                }

                if (!filebase_get_info(base_id, &record))
                {
                    script_write_output(state, "\r\n[Filebase not found]\r\n");
                    break;
                }

                /* Check access */
                if (!filebase_check_access(record.accesslevel, record.keys,
                                           session->user_accesslevel, session->user_keys))
                {
                    script_write_output(state, "\r\n[Access denied]\r\n");
                    break;
                }

                session->current_filebase = base_id;
                session->current_area = 0;
                script_save_user_history(state);
                snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected filebase: %s\033[0m\r\n", record.name);
                script_write_output(state, msg);
            }
            else if (script_stringcasecmp(subcmd, "areas") == 0)
            {
                /* List areas in current filebase - clear screen and prompt for selection */
                if (session->current_filebase <= 0)
                {
                    script_write_output(state, "[Select a filebase first]\r\n");
                    break;
                }
                state->more_line_count = 0;  /* Reset line count */
                state->host.write_text(state->host.context, "\033[2J\033[H");  /* Clear screen */
                filebase_list_areas(session, (void (*)(void*, const char*))state->host.write_text, state->host.context);
                /* Prompt for selection */
                state->host.write_text(state->host.context, "\r\nEnter area number to access: ");
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_FB_AREA);
                return;
            }
            else if (script_stringcasecmp(subcmd, "area") == 0)
            {
                /* Select an area: filebase area <id> */
                int area_id;
                char msg[128];

                if (session->current_filebase <= 0)
                {
                    script_write_output(state, "\r\n[No filebase selected]\r\n");
                    break;
                }

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase area <id>]\r\n");
                    break;
                }

                area_id = atoi(arg);
                if (area_id < 0)
                {
                    script_write_output(state, "\r\n[Invalid area ID]\r\n");
                    break;
                }

                if (area_id > 0)
                {
                    LINETASK_FILEBASE_AREA_RECORD area_record;
                    if (!filebase_get_area_info(session->current_filebase, area_id, &area_record))
                    {
                        script_write_output(state, "\r\n[Area not found]\r\n");
                        break;
                    }

                    if (!filebase_check_access(area_record.accesslevel, area_record.keys,
                                               session->user_accesslevel, session->user_keys))
                    {
                        script_write_output(state, "\r\n[Access denied]\r\n");
                        break;
                    }

                    snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected area: %s\033[0m\r\n", area_record.name);
                }
                else
                {
                    snprintf(msg, sizeof(msg), "\r\n\033[1;32mSelected: All Files\033[0m\r\n");
                }

                session->current_area = area_id;
                script_save_user_history(state);
                script_write_output(state, msg);
            }
            else if (script_stringcasecmp(subcmd, "files") == 0)
            {
                /* List files in current filebase/area */
                filebase_list_files(session, (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "browse") == 0)
            {
                /* Enter continuous file browser */
                /* Disable More? prompts during browser */
                state->more_override = 0;
                
                if (filebase_enter_browser(session, (void (*)(void*, const char*))script_write_output, state))
                {
                    /* Wait for char input via unified system */
                    script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_FB_BROWSE);
                }
            }
            else if (script_stringcasecmp(subcmd, "info") == 0)
            {
                /* Show file info: filebase info <id> */
                int file_id;

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase info <file_id>]\r\n");
                    break;
                }

                file_id = atoi(arg);
                if (file_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid file ID]\r\n");
                    break;
                }

                filebase_show_file_info(session, file_id, (void (*)(void*, const char*))script_write_output, state);
            }
            else if (script_stringcasecmp(subcmd, "download") == 0)
            {
                /* Download a file: filebase download <id> */
                int file_id;

                if (arg == NULL || *arg == '\0')
                {
                    script_write_output(state, "\r\n[Usage: filebase download <file_id>]\r\n");
                    break;
                }

                file_id = atoi(arg);
                if (file_id <= 0)
                {
                    script_write_output(state, "\r\n[Invalid file ID]\r\n");
                    break;
                }

                if (state->host.filebase_download != NULL)
                {
                    if (state->host.filebase_download(state->host.context, session->current_filebase, file_id))
                    {
                        /* Download initiated - wait for it to complete */
                        /* For now just show a message; transfer protocol will be added later */
                        script_write_output(state, "\r\n[Download initiated...]\r\n");
                    }
                    else
                    {
                        script_write_output(state, "\r\n[Download failed]\r\n");
                    }
                }
                else
                {
                    script_write_output(state, "\r\n[Download not implemented]\r\n");
                }
            }
            else if (script_stringcasecmp(subcmd, "reset") == 0)
            {
                /* Reset session */
                filebase_session_reset(session);
                script_write_output(state, "\r\n\033[1;32mFilebase selection cleared.\033[0m\r\n");
            }
            else
            {
                char msg[128];
                snprintf(msg, sizeof(msg), "\r\n[Unknown filebase command: %s]\r\n", subcmd);
                script_write_output(state, msg);
            }
        }
        break;

        case SCRIPT_CMD_LOGON:
        {
            /* Display logon prompt and wait for username */
            script_write_output(state, "\r\n");
            script_write_output(state, "Enter your username/password below to logon,\r\nor type NEW (and return) to register.\r\n");
            script_write_output(state, "\r\n");
            script_write_output(state, "Username: ");
            
            /* Initialize logon state */
            state->logon_username[0] = '\0';
            state->logon_attempts = 0;
            
            /* Wait for username input (line mode with echo) */
            script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_LOGON_USER);
            return;
        }

        case SCRIPT_CMD_NEWUSER:
        {
            /* Start new user registration - prompt for username */
            script_write_output(state, "Username: ");

            /* Initialize newuser state */
            state->newuser_username[0] = '\0';
            state->newuser_password[0] = '\0';
            state->newuser_realname[0] = '\0';
            state->newuser_email[0] = '\0';

            /* Wait for username input */
            script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_NEWUSER_USER);
            return;
        }

        case SCRIPT_CMD_SENDFILE:
        {
            /* SENDFILE <file_id> [protocol]
             * Initiates a file download (BBS sends to user).
             */
            const char *file_id_str = instruction->arg1;
            const char *protocol_str = instruction->arg2;
            int file_id = 0;
            int protocol = 1;  /* Default: XMODEM-CRC */
            int base_id = 0;
            filebase_session *fb_session = NULL;
            char expanded[256];
            
            /* Get file ID */
            if (file_id_str != NULL && file_id_str[0] != '\0')
            {
                script_expand_macros(state, file_id_str, expanded, sizeof(expanded));
                file_id = atoi(expanded);
            }
            
            if (file_id <= 0)
            {
                script_write_output(state, "\r\n\033[1;31m[Invalid file ID]\033[0m\r\n");
                break;
            }
            
            /* Get filebase session for base_id */
            if (state->host.get_filebase_session != NULL)
            {
                fb_session = (filebase_session *)state->host.get_filebase_session(state->host.context);
                if (fb_session != NULL)
                {
                    base_id = fb_session->current_filebase;
                }
            }
            
            if (base_id <= 0)
            {
                script_write_output(state, "\r\n\033[1;31m[No filebase selected]\033[0m\r\n");
                break;
            }
            
            /* Parse protocol */
            if (protocol_str != NULL && protocol_str[0] != '\0')
            {
                script_expand_macros(state, protocol_str, expanded, sizeof(expanded));
                if (script_stringcasecmp(expanded, "xmodem") == 0)
                    protocol = 0;
                else if (script_stringcasecmp(expanded, "xmodem-crc") == 0)
                    protocol = 1;
                else if (script_stringcasecmp(expanded, "xmodem-1k") == 0)
                    protocol = 2;
                else if (script_stringcasecmp(expanded, "ymodem") == 0)
                    protocol = 3;
                else if (script_stringcasecmp(expanded, "ymodem-g") == 0)
                    protocol = 4;
                else if (script_stringcasecmp(expanded, "zmodem") == 0)
                    protocol = 5;
            }
            
            /* Start the transfer */
            if (state->host.start_transfer != NULL)
            {
                if (state->host.start_transfer(state->host.context, base_id, file_id, protocol))
                {
                    state->status = SCRIPT_STATUS_WAIT_TRANSFER;
                    return;  /* Transfer started - script waits */
                }
                else
                {
                    script_write_output(state, "\r\n\033[1;31m[Transfer failed to start]\033[0m\r\n");
                }
            }
            else
            {
                script_write_output(state, "\r\n\033[1;31m[File transfer not available]\033[0m\r\n");
            }
        }
        break;

        case SCRIPT_CMD_RECEIVEFILE:
        {
            /* RECEIVEFILE [filename] [protocol]
             * Initiates a file upload (user sends to BBS).
             * 
             * Modes:
             *   receivefile              - prompt for filename, description, protocol
             *   receivefile protocol     - prompt for filename and description
             *   receivefile file proto   - prompt for description only
             *
             * If arg1 looks like a protocol name, treat it as protocol-only mode.
             */
            const char *arg1_str = instruction->arg1;
            const char *arg2_str = instruction->arg2;
            char expanded1[256];
            char expanded2[256];
            int protocol = -1;  /* -1 = need to prompt */
            int have_filename = 0;
            
            /* Expand arguments */
            expanded1[0] = '\0';
            expanded2[0] = '\0';
            if (arg1_str != NULL && arg1_str[0] != '\0')
            {
                script_expand_macros(state, arg1_str, expanded1, sizeof(expanded1));
            }
            if (arg2_str != NULL && arg2_str[0] != '\0')
            {
                script_expand_macros(state, arg2_str, expanded2, sizeof(expanded2));
            }
            
            /* Reset upload state */
            state->pending_upload_filename[0] = '\0';
            state->pending_upload_description[0] = '\0';
            state->pending_upload_protocol = -1;
            state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_NONE;
            
            /* Check if arg1 is a protocol name */
            if (expanded1[0] != '\0')
            {
                if (script_stringcasecmp(expanded1, "xmodem") == 0 ||
                    script_stringcasecmp(expanded1, "xmodem-crc") == 0 ||
                    script_stringcasecmp(expanded1, "xmodem-1k") == 0 ||
                    script_stringcasecmp(expanded1, "ymodem") == 0 ||
                    script_stringcasecmp(expanded1, "ymodem-g") == 0 ||
                    script_stringcasecmp(expanded1, "zmodem") == 0)
                {
                    /* arg1 is protocol - Mode 2: prompt for filename and description */
                    protocol = script_parse_protocol(expanded1);
                    state->pending_upload_protocol = protocol;
                }
                else
                {
                    /* arg1 is filename */
                    have_filename = 1;
                    strncpy(state->pending_upload_filename, expanded1, 
                            sizeof(state->pending_upload_filename) - 1);
                    state->pending_upload_filename[sizeof(state->pending_upload_filename) - 1] = '\0';
                    
                    /* Check if arg2 is protocol */
                    if (expanded2[0] != '\0')
                    {
                        protocol = script_parse_protocol(expanded2);
                        state->pending_upload_protocol = protocol;
                    }
                }
            }
            
            /* Determine what to prompt for */
            if (!have_filename)
            {
                /* Need filename - start prompting flow */
                script_write_output(state, "Filename: ");
                state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_WAIT_FILENAME;
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_UPLOAD_FILE);
                return;
            }
            else
            {
                /* Have filename - prompt for description */
                script_write_output(state, "Description: ");
                state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_WAIT_DESCRIPTION;
                script_begin_input(state, SCRIPT_INPUT_MODE_LINE, SCRIPT_INPUT_CTX_UPLOAD_DESC);
                return;
            }
        }
        break;

        default:
            break;
    }
}

/* Helper to save user history when messagebase/filebase selections change */
#define SWI_CONVERSE_FILER_USERDB 0x5AA41
#define FILER_USERDB_CMD_UPDATE_HISTORY 5

typedef struct {
    int messagebase;
    int messagebasearea;
    int filebase;
    int filebasearea;
} script_user_history;

static void script_save_user_history(script_state *state)
{
    _kernel_swi_regs regs;
    script_user_history history;
    filebase_session *fb = NULL;
    messagebase_session *mb = NULL;
    int user_id = 0;

    if (state == NULL)
    {
        return;
    }

    /* Get user ID - only save for authenticated users */
    if (state->host.get_user_id != NULL)
    {
        user_id = state->host.get_user_id(state->host.context);
    }
    if (user_id <= 0)
    {
        return;
    }

    /* Get current session states */
    if (state->host.get_filebase_session != NULL)
    {
        fb = (filebase_session *)state->host.get_filebase_session(state->host.context);
    }
    if (state->host.get_messagebase_session != NULL)
    {
        mb = (messagebase_session *)state->host.get_messagebase_session(state->host.context);
    }

    /* Build history structure */
    history.messagebase = (mb != NULL) ? mb->current_messagebase : 0;
    history.messagebasearea = (mb != NULL) ? mb->current_area : 0;
    history.filebase = (fb != NULL) ? fb->current_filebase : 0;
    history.filebasearea = (fb != NULL) ? fb->current_area : 0;

    /* Call Filer SWI to update history */
    regs.r[0] = FILER_USERDB_CMD_UPDATE_HISTORY;
    regs.r[1] = user_id;
    regs.r[2] = (int)&history;

    _kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs);
}

static int script_emit_macro_replacement(script_state *state, const char *macro_name, script_buffer *buffer)
{
    const char *replacement = NULL;
    char temp[64];

    if (macro_name == NULL || buffer == NULL)
    {
        return 1;
    }

    if (state != NULL)
    {
        replacement = script_get_variable_value(state, macro_name);
    }

    if (replacement == NULL)
    {
        if (state != NULL && script_stringcasecmp(macro_name, "line") == 0)
        {
            int line_id = state->host.get_line_id != NULL ? state->host.get_line_id(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", line_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "t_handle") == 0)
        {
            int handle = state->host.get_task_handle != NULL ? state->host.get_task_handle(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", handle);
            replacement = temp;
        }
        else if (script_stringcasecmp(macro_name, "time") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%02d:%02d:%02d", 
                    local_tm->tm_hour, local_tm->tm_min, local_tm->tm_sec);
                replacement = temp;
            }
            else
            {
                replacement = "00:00:00";
            }
        }
        else if (script_stringcasecmp(macro_name, "date") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%02d/%02d/%04d", 
                    local_tm->tm_mday, local_tm->tm_mon + 1, 1900 + local_tm->tm_year);
                replacement = temp;
            }
            else
            {
                replacement = "01/01/1970";
            }
        }
        else if (script_stringcasecmp(macro_name, "version") == 0)
        {
            replacement = APP_VERSION;
        }
        else if (script_stringcasecmp(macro_name, "hour") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_hour);
                replacement = temp;
            }
            else
            {
                replacement = "0";
            }
        }
        else if (script_stringcasecmp(macro_name, "minute") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_min);
                replacement = temp;
            }
            else
            {
                replacement = "0";
            }
        }
        else if (script_stringcasecmp(macro_name, "dayofweek") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_wday);
                replacement = temp;
            }
            else
            {
                replacement = "0";
            }
        }
        else if (script_stringcasecmp(macro_name, "day") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_mday);
                replacement = temp;
            }
            else
            {
                replacement = "1";
            }
        }
        else if (script_stringcasecmp(macro_name, "month") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", local_tm->tm_mon + 1);
                replacement = temp;
            }
            else
            {
                replacement = "1";
            }
        }
        else if (script_stringcasecmp(macro_name, "year") == 0)
        {
            time_t now = time(NULL);
            struct tm *local_tm = localtime(&now);
            if (local_tm != NULL)
            {
                snprintf(temp, sizeof(temp), "%d", 1900 + local_tm->tm_year);
                replacement = temp;
            }
            else
            {
                replacement = "1970";
            }
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "accesslevel") == 0)
        {
            int level = state->host.get_user_accesslevel != NULL ? state->host.get_user_accesslevel(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", level);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userid") == 0)
        {
            int user_id = state->host.get_user_id != NULL ? state->host.get_user_id(state->host.context) : 0;
            snprintf(temp, sizeof(temp), "%d", user_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "registered") == 0)
        {
            int user_id = state->host.get_user_id != NULL ? state->host.get_user_id(state->host.context) : 0;
            replacement = user_id > 0 ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "sysop") == 0)
        {
            int is_sysop = state->host.get_user_sysop != NULL ? state->host.get_user_sysop(state->host.context) : 0;
            replacement = is_sysop ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "keys") == 0)
        {
            const char *keys = state->host.get_user_keys != NULL ? state->host.get_user_keys(state->host.context) : "";
            replacement = (keys != NULL) ? keys : "";
        }
        /* User stats macros */
        else if (state != NULL && script_stringcasecmp(macro_name, "lastlogon") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            if (stats != NULL && stats->lastlogon > 0)
            {
                struct tm *tm_info = localtime(&stats->lastlogon);
                if (tm_info != NULL)
                {
                    strftime(temp, sizeof(temp), "%d/%m/%Y %H:%M", tm_info);
                    replacement = temp;
                }
                else
                {
                    replacement = "Never";
                }
            }
            else
            {
                replacement = "Never";
            }
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "lastscan") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            if (stats != NULL && stats->lastscan > 0)
            {
                struct tm *tm_info = localtime(&stats->lastscan);
                if (tm_info != NULL)
                {
                    strftime(temp, sizeof(temp), "%d/%m/%Y %H:%M", tm_info);
                    replacement = temp;
                }
                else
                {
                    replacement = "Never";
                }
            }
            else
            {
                replacement = "Never";
            }
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "usercalls") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", stats != NULL ? stats->calls : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "todaytime") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", stats != NULL ? stats->todaytime : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "uploadskb") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", stats != NULL ? stats->uploadskb : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "downloadskb") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", stats != NULL ? stats->downloadskb : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "useruploads") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", stats != NULL ? stats->uploads : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userdownloads") == 0)
        {
            const script_user_stats *stats = state->host.get_user_stats != NULL ? 
                state->host.get_user_stats(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", stats != NULL ? stats->downloads : 0);
            replacement = temp;
        }
        /* User flags macros */
        else if (state != NULL && script_stringcasecmp(macro_name, "useransi") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            replacement = (flags != NULL && flags->ansi) ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "usermore") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            replacement = (flags != NULL && flags->more) ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userlines") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", flags != NULL ? flags->lines : 24);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "usercls") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            replacement = (flags != NULL && flags->cls) ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userexpert") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            replacement = (flags != NULL && flags->expert) ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "usernolimit") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            replacement = (flags != NULL && flags->nolimit) ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userinvisible") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            replacement = (flags != NULL && flags->invisible) ? "1" : "0";
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userchataccess") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", flags != NULL ? flags->chataccess : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userratios") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", flags != NULL ? flags->ratios : 0);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "usermaxtime") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", flags != NULL ? flags->maxtime : 60);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "userprotocol") == 0)
        {
            const script_user_flags *flags = state->host.get_user_flags != NULL ? 
                state->host.get_user_flags(state->host.context) : NULL;
            snprintf(temp, sizeof(temp), "%d", flags != NULL ? flags->defaultprotocol : 5);
            replacement = temp;
        }
        /* Filebase selection macros */
        else if (state != NULL && script_stringcasecmp(macro_name, "filebaseid") == 0)
        {
            filebase_session *fb = state->host.get_filebase_session != NULL ? 
                (filebase_session *)state->host.get_filebase_session(state->host.context) : NULL;
            int fb_id = (fb != NULL) ? fb->current_filebase : 0;
            snprintf(temp, sizeof(temp), "%d", fb_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "filebasename") == 0)
        {
            filebase_session *fb = state->host.get_filebase_session != NULL ?
                (filebase_session *)state->host.get_filebase_session(state->host.context) : NULL;
            if (fb != NULL && fb->current_filebase > 0)
            {
                LINETASK_FILEBASE_RECORD rec;
                if (filebase_get_info(fb->current_filebase, &rec))
                {
                    strncpy(temp, rec.name, sizeof(temp) - 1);
                    temp[sizeof(temp) - 1] = '\0';
                    replacement = temp;
                }
                else
                {
                    replacement = "";
                }
            }
            else
            {
                replacement = "";
            }
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "filebaseareaid") == 0)
        {
            filebase_session *fb = state->host.get_filebase_session != NULL ?
                (filebase_session *)state->host.get_filebase_session(state->host.context) : NULL;
            int area_id = (fb != NULL) ? fb->current_area : 0;
            snprintf(temp, sizeof(temp), "%d", area_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "filebaseareaname") == 0)
        {
            filebase_session *fb = state->host.get_filebase_session != NULL ?
                (filebase_session *)state->host.get_filebase_session(state->host.context) : NULL;
            if (fb != NULL && fb->current_filebase > 0 && fb->current_area > 0)
            {
                LINETASK_FILEBASE_AREA_RECORD rec;
                if (filebase_get_area_info(fb->current_filebase, fb->current_area, &rec))
                {
                    strncpy(temp, rec.name, sizeof(temp) - 1);
                    temp[sizeof(temp) - 1] = '\0';
                    replacement = temp;
                }
                else
                {
                    replacement = "";
                }
            }
            else
            {
                replacement = "";
            }
        }
        /* Messagebase selection macros */
        else if (state != NULL && script_stringcasecmp(macro_name, "messagebaseid") == 0)
        {
            messagebase_session *mb = state->host.get_messagebase_session != NULL ?
                (messagebase_session *)state->host.get_messagebase_session(state->host.context) : NULL;
            int mb_id = (mb != NULL) ? mb->current_messagebase : 0;
            snprintf(temp, sizeof(temp), "%d", mb_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "messagebasename") == 0)
        {
            messagebase_session *mb = state->host.get_messagebase_session != NULL ?
                (messagebase_session *)state->host.get_messagebase_session(state->host.context) : NULL;
            if (mb != NULL && mb->current_messagebase > 0)
            {
                LINETASK_MESSAGEBASE_RECORD rec;
                if (messagebase_get_info(mb->current_messagebase, &rec))
                {
                    strncpy(temp, rec.name, sizeof(temp) - 1);
                    temp[sizeof(temp) - 1] = '\0';
                    replacement = temp;
                }
                else
                {
                    replacement = "";
                }
            }
            else
            {
                replacement = "";
            }
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "messagebaseareaid") == 0)
        {
            messagebase_session *mb = state->host.get_messagebase_session != NULL ?
                (messagebase_session *)state->host.get_messagebase_session(state->host.context) : NULL;
            int area_id = (mb != NULL) ? mb->current_area : 0;
            snprintf(temp, sizeof(temp), "%d", area_id);
            replacement = temp;
        }
        else if (state != NULL && script_stringcasecmp(macro_name, "messagebaseareaname") == 0)
        {
            messagebase_session *mb = state->host.get_messagebase_session != NULL ?
                (messagebase_session *)state->host.get_messagebase_session(state->host.context) : NULL;
            if (mb != NULL && mb->current_messagebase > 0 && mb->current_area > 0)
            {
                LINETASK_MESSAGEBASE_AREA_RECORD rec;
                if (messagebase_get_area_info(mb->current_messagebase, mb->current_area, &rec))
                {
                    strncpy(temp, rec.name, sizeof(temp) - 1);
                    temp[sizeof(temp) - 1] = '\0';
                    replacement = temp;
                }
                else
                {
                    replacement = "";
                }
            }
            else
            {
                replacement = "";
            }
        }
        else
        {
            replacement = "";
        }
    }

    if (!script_buffer_append_string(buffer, replacement))
    {
        script_set_error(state, "Out of memory expanding text");
        return 0;
    }

    return 1;
}

static int script_expand_macros_to_buffer(script_state *state, const char *input, script_buffer *buffer, int translate_newlines)
{
    size_t i;
    unsigned char current;
    size_t start;
    size_t end;
    size_t macro_len;
    char macro_name[64];
    size_t previous_length;

    if (buffer == NULL)
    {
        return 0;
    }

    if (input == NULL)
    {
        return 1;
    }

    for (i = 0; input[i] != '\0'; ++i)
    {
        current = (unsigned char)input[i];

        if (current == 0xC2 && (unsigned char)input[i + 1] == 0xA7)
        {
            i++;
            current = 0xA7;
        }

        if (current == 0xA7)
        {
            start = i + 1;
            end = start;

            while (input[end] != '\0' && (unsigned char)input[end] != 0xA7)
            {
                end++;
            }

            if ((unsigned char)input[end] == 0xA7)
            {
                macro_len = end - start;

                if (macro_len >= sizeof(macro_name))
                {
                    macro_len = sizeof(macro_name) - 1;
                }
                memcpy(macro_name, &input[start], macro_len);
                macro_name[macro_len] = '\0';

                if (!script_emit_macro_replacement(state, macro_name, buffer))
                {
                    return 0;
                }

                i = end;
                continue;
            }
        }

        if (current == '%' && input[i + 1] == '{')
        {
            start = i + 2;
            end = start;

            while (input[end] != '\0' && input[end] != '}')
            {
                end++;
            }

            if (input[end] == '}')
            {
                macro_len = end - start;

                if (macro_len >= sizeof(macro_name))
                {
                    macro_len = sizeof(macro_name) - 1;
                }
                memcpy(macro_name, &input[start], macro_len);
                macro_name[macro_len] = '\0';

                if (!script_emit_macro_replacement(state, macro_name, buffer))
                {
                    return 0;
                }

                i = end;
                continue;
            }
        }

        if (translate_newlines && current == '\n')
        {
            previous_length = buffer->length;
            if (previous_length > 0 && buffer->data[previous_length - 1] == '\r')
            {
                if (!script_buffer_append_char(buffer, '\n'))
                {
                    script_set_error(state, "Out of memory expanding text");
                    return 0;
                }
            }
            else
            {
                if (!script_buffer_append_char(buffer, '\r') || !script_buffer_append_char(buffer, '\n'))
                {
                    script_set_error(state, "Out of memory expanding text");
                    return 0;
                }
            }
        }
        else
        {
            if (!script_buffer_append_char(buffer, (char)current))
            {
                script_set_error(state, "Out of memory expanding text");
                return 0;
            }
        }
    }

    return 1;
}

static void script_expand_macros(script_state *state, const char *input, char *buffer, size_t length)
{
    script_buffer expanded;
    size_t copy_len = 0;

    if (buffer == NULL || length == 0)
    {
        return;
    }

    script_buffer_init(&expanded);
    if (!script_expand_macros_to_buffer(state, input, &expanded, 0))
    {
        buffer[0] = '\0';
        script_buffer_free(&expanded);
        return;
    }

    if (expanded.length > 0 && expanded.data != NULL)
    {
        copy_len = expanded.length;
        if (copy_len >= length)
        {
            copy_len = length - 1;
        }
        memcpy(buffer, expanded.data, copy_len);
        buffer[copy_len] = '\0';
    }
    else
    {
        buffer[0] = '\0';
    }

    script_buffer_free(&expanded);
}

static void script_translate_escapes(char *text)
{
    size_t read_index = 0;
    size_t write_index = 0;
    char next;

    if (text == NULL)
    {
        return;
    }

    while (text[read_index] != '\0')
    {
        if (text[read_index] == '\\' && text[read_index + 1] != '\0')
        {
            next = text[read_index + 1];
            switch (next)
            {
                    case 'n':
                        text[write_index++] = '\r';
                        text[write_index++] = '\n';
                        break;
                    case 'r':
                        if (text[read_index + 2] == '\\' && text[read_index + 3] == 'n')
                        {
                            read_index += 2;
                            continue;
                        }
                        text[write_index++] = '\r';
                        break;
                case 't': text[write_index++] = '\t'; break;
                case '\\': text[write_index++] = '\\'; break;
                case '`': text[write_index++] = '`'; break;
                default:
                    /* Unknown escape - preserve the backslash */
                    text[write_index++] = '\\';
                    text[write_index++] = next;
                    break;
            }
            read_index += 2;
        }
        else
        {
            text[write_index++] = text[read_index++];
        }
    }

    text[write_index] = '\0';
}

static void script_set_error(script_state *state, const char *fmt, ...)
{
    va_list args;
    if (state == NULL)
    {
        return;
    }

    va_start(args, fmt);
    vsnprintf(state->last_error, sizeof(state->last_error), fmt, args);
    va_end(args);
}

static void script_reset_input(script_state *state)
{
    state->input_mode = SCRIPT_INPUT_MODE_NONE;
    state->input_context = SCRIPT_INPUT_CTX_NONE;
    state->input_echo = 0;
    state->input_length = 0;
    if (state->input_buffer != NULL && state->input_capacity > 0)
    {
        state->input_buffer[0] = '\0';
    }
    state->input_target[0] = '\0';
    state->input_valid_keys[0] = '\0';
}

/*
 * Begin waiting for input with a specific mode and context.
 * Echo behavior is derived from the mode (LINE/CHAR_ECHO vs LINE_NOECHO/CHAR).
 */
void script_begin_input(script_state *state, script_input_mode_t mode, 
                        script_input_context context)
{
    int echo;
    
    if (state == NULL)
    {
        return;
    }
    
    /* Derive echo from mode - this is the key simplification */
    switch (mode)
    {
        case SCRIPT_INPUT_MODE_LINE:
        case SCRIPT_INPUT_MODE_CHAR_ECHO:
            echo = 1;
            break;
        default:
            echo = 0;
            break;
    }
    
    state->input_mode = mode;
    state->input_context = context;
    state->input_echo = echo;
    state->input_length = 0;
    if (state->input_buffer != NULL && state->input_capacity > 0)
    {
        state->input_buffer[0] = '\0';
    }
    state->input_valid_keys[0] = '\0';
    /* Note: input_target is NOT cleared here - callers may set it before calling this function */
    
    state->status = SCRIPT_STATUS_WAITING;
}

/*
 * Begin waiting for a single keypress from a set of valid keys.
 */
void script_begin_input_keys(script_state *state, script_input_context context,
                             const char *valid_keys, const char *target)
{
    if (state == NULL)
    {
        return;
    }
    
    state->input_mode = SCRIPT_INPUT_MODE_KEY;
    state->input_context = context;
    state->input_echo = 0;  /* Key input usually doesn't echo */
    state->input_length = 0;
    if (state->input_buffer != NULL && state->input_capacity > 0)
    {
        state->input_buffer[0] = '\0';
    }
    
    if (valid_keys != NULL)
    {
        strncpy(state->input_valid_keys, valid_keys, sizeof(state->input_valid_keys) - 1);
        state->input_valid_keys[sizeof(state->input_valid_keys) - 1] = '\0';
    }
    else
    {
        state->input_valid_keys[0] = '\0';
    }
    
    if (target != NULL)
    {
        strncpy(state->input_target, target, sizeof(state->input_target) - 1);
        state->input_target[sizeof(state->input_target) - 1] = '\0';
    }
    else
    {
        state->input_target[0] = '\0';
    }
    
    state->status = SCRIPT_STATUS_WAITING;
}

/*
 * Clear input state without changing status.
 */
void script_clear_input(script_state *state)
{
    if (state == NULL)
    {
        return;
    }
    
    state->input_mode = SCRIPT_INPUT_MODE_NONE;
    state->input_context = SCRIPT_INPUT_CTX_NONE;
    state->input_echo = 0;
    state->input_length = 0;
    if (state->input_buffer != NULL && state->input_capacity > 0)
    {
        state->input_buffer[0] = '\0';
    }
    state->input_target[0] = '\0';
    state->input_valid_keys[0] = '\0';
}

/*
 * Check if "more" prompts should be active for this session.
 * Returns the screen lines setting if active, 0 if not.
 */
static int script_more_active(script_state *state)
{
    const script_user_flags *flags;
    int more_enabled;
    int screen_lines;
    
    if (state == NULL)
    {
        return 0;
    }
    
    /* Check override first */
    if (state->more_override == 0)
    {
        return 0;  /* Explicitly disabled */
    }
    else if (state->more_override == 1)
    {
        /* Explicitly enabled - use stored screen lines or default */
        return state->more_screen_lines > 0 ? state->more_screen_lines : 24;
    }
    
    /* No override (-1) - use user flags */
    if (state->host.get_user_flags == NULL)
    {
        return 0;
    }
    
    flags = state->host.get_user_flags(state->host.context);
    if (flags == NULL)
    {
        return 0;
    }
    
    more_enabled = flags->more;
    screen_lines = flags->lines > 0 ? flags->lines : 24;
    
    /* Cache the screen lines setting */
    state->more_screen_lines = screen_lines;
    
    return more_enabled ? screen_lines : 0;
}

/*
 * Count newlines in text WITHOUT updating line counter.
 * Returns the count of newlines in the text.
 */
static int script_count_newlines(const char *text)
{
    const char *p;
    int count = 0;
    
    if (text == NULL)
    {
        return 0;
    }
    
    for (p = text; *p != '\0'; p++)
    {
        if (*p == '\n')
        {
            count++;
        }
    }
    
    return count;
}

/*
 * Write output text, handling More? prompt if needed.
 * Checks BEFORE outputting to avoid scrolling past the pause point.
 */
static void script_write_output(script_state *state, const char *text)
{
    int screen_lines;
    int pending_lines;
    
    if (state == NULL || state->host.write_text == NULL || text == NULL)
    {
        return;
    }
    
    /* Check if more prompts are active */
    screen_lines = script_more_active(state);
    
    if (screen_lines == 0)
    {
        /* More prompts disabled - just output directly */
        state->host.write_text(state->host.context, text);
        return;
    }
    
    /* Count how many lines this text would add */
    pending_lines = script_count_newlines(text);
    
    /* Check if outputting this would exceed the limit BEFORE we output */
    if (state->more_line_count + pending_lines >= screen_lines - 1)
    {
        /* We would exceed - save text for later and show More? prompt */
        free(state->more_pending_text);
        state->more_pending_text = script_duplicate_string(text);
        
        /* Display configured more file if available, otherwise use default text */
        if (state->host.get_more_file != NULL)
        {
            const char *more_file = state->host.get_more_file(state->host.context);
            if (more_file != NULL && more_file[0] != '\0')
            {
                script_display_file(state, more_file, 1);
            }
            else
            {
                /* No file configured - use default */
                state->host.write_text(state->host.context, "\033[7mMore?\033[0m ");
            }
        }
        else
        {
            /* No callback - use default */
            state->host.write_text(state->host.context, "\033[7mMore?\033[0m ");
        }
        
        script_begin_input(state, SCRIPT_INPUT_MODE_CHAR, SCRIPT_INPUT_CTX_MORE);
        return;
    }
    
    /* Safe to output - update line count and write */
    state->more_line_count += pending_lines;
    state->host.write_text(state->host.context, text);
}

/* Exported for ZMODEM auto-start in main.c */
void script_set_variable_value(script_state *state, const char *name, const char *value)
{
    script_variable *var = script_find_variable(state, name, 1);
    if (var == NULL)
    {
        return;
    }

    free(var->value);
    var->value = script_duplicate_string(value != NULL ? value : "");
}

static const char *script_get_variable_value(const script_state *state, const char *name)
{
    size_t i;

    if (state == NULL || name == NULL)
    {
        return NULL;
    }

    for (i = 0; i < state->variable_count; ++i)
    {
        if (script_stringcasecmp(state->variables[i].name, name) == 0)
        {
            return state->variables[i].value;
        }
    }

    return NULL;
}

static int script_parse_backtick_string(const char *input, size_t *consumed, char **output)
{
    const char *start;
    const char *end;
    if (input == NULL || *input != '`')
    {
        return 0;
    }

    start = input + 1;
    end = strchr(start, '`');
    if (end == NULL)
    {
        return 0;
    }

    if (consumed != NULL)
    {
        *consumed = (size_t)(end - input) + 1;
    }

    *output = (char *)malloc((size_t)(end - start) + 1);
    if (*output == NULL)
    {
        return 0;
    }
    memcpy(*output, start, (size_t)(end - start));
    (*output)[end - start] = '\0';
    return 1;
}

static char *script_trim(char *text)
{
    char *start;
    char *end;

    if (text == NULL)
    {
        return NULL;
    }

    start = text;
    while (*start && isspace((unsigned char)*start))
    {
        start++;
    }

    end = start + strlen(start);
    while (end > start && isspace((unsigned char)*(end - 1)))
    {
        end--;
    }
    *end = '\0';
    return start;
}

static int script_is_empty_or_comment(const char *line)
{
    if (line == NULL)
    {
        return 1;
    }

    while (*line != '\0')
    {
        if (*line == '#')
        {
            return 1;
        }
        if (!isspace((unsigned char)*line))
        {
            return 0;
        }
        line++;
    }

    return 1;
}

static void script_free_instruction(script_instruction *instruction)
{
    if (instruction == NULL)
    {
        return;
    }

    free(instruction->arg1);
    free(instruction->arg2);
    free(instruction->arg3);
    free(instruction->arg4);
    free(instruction->arg5);
    instruction->arg1 = instruction->arg2 = instruction->arg3 = instruction->arg4 = instruction->arg5 = NULL;
}

static void script_free_label(script_label *label)
{
    if (label == NULL)
    {
        return;
    }

    free(label->name);
    label->name = NULL;
}

static void script_free_variable(script_variable *variable)
{
    if (variable == NULL)
    {
        return;
    }
    free(variable->value);
    variable->value = NULL;
}

static clock_t script_calculate_sleep_deadline(unsigned int milliseconds)
{
    clock_t ticks = (clock_t)(((double)milliseconds / 1000.0) * CLOCKS_PER_SEC);
    if (ticks < 1)
    {
        ticks = 1;
    }
    return clock() + ticks;
}

static int script_stringcasecmp(const char *lhs, const char *rhs)
{
    unsigned char cl;
    unsigned char cr;

    if (lhs == NULL)
    {
        lhs = "";
    }
    if (rhs == NULL)
    {
        rhs = "";
    }

    while (*lhs != '\0' && *rhs != '\0')
    {
        cl = (unsigned char)tolower((unsigned char)*lhs);
        cr = (unsigned char)tolower((unsigned char)*rhs);
        if (cl != cr)
        {
            return (int)cl - (int)cr;
        }
        lhs++;
        rhs++;
    }

    cl = (unsigned char)tolower((unsigned char)*lhs);
    cr = (unsigned char)tolower((unsigned char)*rhs);
    return (int)cl - (int)cr;
}

static char *script_strcasestr(const char *haystack, const char *needle)
{
    size_t needle_len;
    
    if (haystack == NULL || needle == NULL)
    {
        return NULL;
    }
    
    needle_len = strlen(needle);
    if (needle_len == 0)
    {
        return (char *)haystack;
    }
    
    while (*haystack != '\0')
    {
        if (tolower((unsigned char)*haystack) == tolower((unsigned char)*needle))
        {
            /* Potential match - check full needle */
            size_t i;
            int match = 1;
            for (i = 0; i < needle_len; i++)
            {
                if (haystack[i] == '\0')
                {
                    match = 0;
                    break;
                }
                if (tolower((unsigned char)haystack[i]) != tolower((unsigned char)needle[i]))
                {
                    match = 0;
                    break;
                }
            }
            if (match)
            {
                return (char *)haystack;
            }
        }
        haystack++;
    }
    
    return NULL;
}

static void script_apply_colour_change(script_state *state, const char *fg_text, const char *bg_text, int apply_fg, int apply_bg)
{
    char sequence[48];
    int length = 0;
    int fg_value = 0;
    int bg_value = 0;
    int fg_bright = 0;
    int bg_bright = 0;

    if (state == NULL)
    {
        return;
    }

    if (apply_fg && fg_text != NULL)
    {
        fg_value = atoi(fg_text);
        if (fg_value < 0)
        {
            fg_value = 0;
        }
        if (fg_value > 15)
        {
            fg_value = 15;
        }
        /* Colors 8-15 are bright versions of 0-7 */
        if (fg_value >= 8)
        {
            fg_bright = 1;
            fg_value -= 8;
        }
    }

    if (apply_bg && bg_text != NULL)
    {
        bg_value = atoi(bg_text);
        if (bg_value < 0)
        {
            bg_value = 0;
        }
        if (bg_value > 15)
        {
            bg_value = 15;
        }
        /* Colors 8-15 are bright versions of 0-7 */
        if (bg_value >= 8)
        {
            bg_bright = 1;
            bg_value -= 8;
        }
    }

    /* Build ANSI sequence */
    /* For bright foreground colors, we need bold (1) attribute */
    /* For non-bright, we turn off bold (22) to be safe */
    length = snprintf(sequence, sizeof(sequence), "\x1B[");
    
    if (apply_fg && fg_text != NULL)
    {
        if (fg_bright)
        {
            length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, "1;%d", 30 + fg_value);
        }
        else
        {
            length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, "22;%d", 30 + fg_value);
        }
    }

    if (apply_bg && bg_text != NULL)
    {
        if (length > 2)
        {
            length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, ";");
        }
        if (bg_bright)
        {
            /* Bright backgrounds use 100-107 */
            length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, "%d", 100 + bg_value);
        }
        else
        {
            length += snprintf(sequence + length, sizeof(sequence) - (size_t)length, "%d", 40 + bg_value);
        }
    }

    if (length > 2 && length < (int)sizeof(sequence))
    {
        sequence[length++] = 'm';
        sequence[length] = '\0';
        script_write_output(state, sequence);
    }
}

static void script_set_flash(script_state *state, const char *arg)
{
    int enable = (arg != NULL) ? atoi(arg) : 0;
    if (state == NULL)
    {
        return;
    }

    if (enable)
    {
        script_write_output(state, "\x1B[5m");
    }
    else
    {
        script_write_output(state, "\x1B[25m");
    }
}

static void script_send_clear_screen(script_state *state)
{
    if (state == NULL)
    {
        return;
    }
    script_write_output(state, "\x1B[2J\x1B[H");
}

static void script_send_clear_to_eol(script_state *state)
{
    if (state == NULL)
    {
        return;
    }
    /* ANSI escape sequence: ESC[K = Erase from cursor to end of line */
    script_write_output(state, "\x1B[K");
}

static void script_move_cursor(script_state *state, const char *col_text, const char *row_text)
{
    int column = (col_text != NULL) ? atoi(col_text) : 1;
    int row = (row_text != NULL) ? atoi(row_text) : 1;
    char sequence[32];

    if (state == NULL)
    {
        return;
    }

    if (column < 1)
    {
        column = 1;
    }
    if (row < 1)
    {
        row = 1;
    }

    snprintf(sequence, sizeof(sequence), "\x1B[%d;%dH", row, column);
    script_write_output(state, sequence);
}

static void script_display_file(script_state *state, const char *source, int trim_newlines)
{
    char path[256];
    FILE *fp;
    long file_size;
    size_t length;
    char *buffer = NULL;
    int parsed;

    if (state == NULL || source == NULL)
    {
        return;
    }

    script_expand_macros(state, source, path, sizeof(path));
    if (path[0] == '\0')
    {
        script_write_output(state, "\r\n[Type: missing filename]\r\n");
        return;
    }

    fp = fopen(path, "rb");
    if (fp == NULL)
    {
        char message[256];
        snprintf(message, sizeof(message), "\r\n[Type: cannot open %s]\r\n", path);
        script_write_output(state, message);
        return;
    }

    if (fseek(fp, 0, SEEK_END) != 0)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: unable to read file]\r\n");
        return;
    }

    file_size = ftell(fp);
    if (file_size < 0)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: unable to read file]\r\n");
        return;
    }

    if (fseek(fp, 0, SEEK_SET) != 0)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: unable to read file]\r\n");
        return;
    }

    length = (size_t)file_size;
    buffer = (char *)malloc(length + 1);
    if (buffer == NULL)
    {
        fclose(fp);
        script_write_output(state, "\r\n[Type: out of memory]\r\n");
        return;
    }

    if (length > 0 && fread(buffer, 1, length, fp) != length)
    {
        free(buffer);
        fclose(fp);
        script_write_output(state, "\r\n[Type: read error]\r\n");
        return;
    }

    if (trim_newlines)
    {
        while (length > 0 && (buffer[length - 1] == '\r' || buffer[length - 1] == '\n'))
        {
            length--;
        }
    }

    buffer[length] = '\0';
    fclose(fp);

    parsed = script_process_embedded_content(state, buffer, length, path, script_handle_embedded_text_as_output, script_handle_embedded_command_as_output, NULL);
    if (!parsed)
    {
        char message[256];
        if (state != NULL && state->last_error[0] != '\0')
        {
            snprintf(message, sizeof(message), "\r\n[Type: %s]\r\n", state->last_error);
        }
        else
        {
            snprintf(message, sizeof(message), "\r\n[Type: parse error]\r\n");
        }
        script_write_output(state, message);
    }

    free(buffer);
}

/*
 * Start a receive transfer using the pending upload info stored in state.
 * Called when protocol is selected (either from command or from prompt).
 */
static void script_start_receive_transfer(script_state *state, int protocol)
{
    char temp_path[260];
    
    if (state == NULL)
    {
        return;
    }

    state->pending_upload_stage = SCRIPT_UPLOAD_STAGE_NONE;
    
    /* Check we have a filename */
    if (state->pending_upload_filename[0] == '\0')
    {
        script_write_output(state, "\r\n\033[1;31m[No filename specified]\033[0m\r\n");
        state->status = SCRIPT_STATUS_RUNNING;
        script_process(state);
        return;
    }
    
    /* Build temp path */
    snprintf(temp_path, sizeof(temp_path),
             "<Converse$Dir>.Temp.Upload_%s", state->pending_upload_filename);
    
    /* Store metadata in script variables for post-transfer processing */
    script_set_variable_value(state, "_upload_filename", state->pending_upload_filename);
    script_set_variable_value(state, "_upload_description", state->pending_upload_description);
    
    /* Also store filebase/area for registration */
    {
        filebase_session *fb_session = NULL;
        if (state->host.get_filebase_session != NULL)
        {
            fb_session = (filebase_session *)state->host.get_filebase_session(state->host.context);
            if (fb_session != NULL)
            {
                char id_str[16];
                snprintf(id_str, sizeof(id_str), "%d", fb_session->current_filebase);
                script_set_variable_value(state, "_upload_filebase", id_str);
                snprintf(id_str, sizeof(id_str), "%d", fb_session->current_area);
                script_set_variable_value(state, "_upload_area", id_str);
            }
        }
    }
    
    /* Start the receive transfer */
    if (state->host.start_receive_transfer != NULL)
    {
        script_write_output(state, "\r\n");
        if (state->host.start_receive_transfer(state->host.context, temp_path, protocol))
        {
            state->status = SCRIPT_STATUS_WAIT_TRANSFER;
            return;  /* Transfer started - script waits */
        }
        else
        {
            script_write_output(state, "\033[1;31m[Transfer failed to start]\033[0m\r\n");
        }
    }
    else
    {
        script_write_output(state, "\r\n\033[1;31m[File transfer not available]\033[0m\r\n");
    }
    
    state->status = SCRIPT_STATUS_RUNNING;
    script_process(state);
}

/*
 * Parse a protocol name string and return the protocol number.
 * Returns -1 if not a valid protocol name.
 */
static int script_parse_protocol(const char *name)
{
    if (name == NULL || name[0] == '\0')
    {
        return -1;
    }
    
    if (script_stringcasecmp(name, "xmodem") == 0)
        return 0;
    if (script_stringcasecmp(name, "xmodem-crc") == 0)
        return 1;
    if (script_stringcasecmp(name, "xmodem-1k") == 0)
        return 2;
    if (script_stringcasecmp(name, "ymodem") == 0)
        return 3;
    if (script_stringcasecmp(name, "ymodem-g") == 0)
        return 4;
    if (script_stringcasecmp(name, "zmodem") == 0)
        return 5;
    
    return -1;
}

static char *script_duplicate_range(const char *source, size_t length)
{
    char *copy;

    if (source == NULL)
    {
        return NULL;
    }

    copy = (char *)malloc(length + 1);
    if (copy == NULL)
    {
        return NULL;
    }

    if (length > 0)
    {
        memcpy(copy, source, length);
    }
    copy[length] = '\0';
    return copy;
}

static void script_buffer_init(script_buffer *buffer)
{
    if (buffer == NULL)
    {
        return;
    }
    buffer->data = NULL;
    buffer->length = 0;
    buffer->capacity = 0;
}

static void script_buffer_free(script_buffer *buffer)
{
    if (buffer == NULL)
    {
        return;
    }
    free(buffer->data);
    buffer->data = NULL;
    buffer->length = 0;
    buffer->capacity = 0;
}

static void script_buffer_clear(script_buffer *buffer)
{
    if (buffer == NULL)
    {
        return;
    }
    buffer->length = 0;
    if (buffer->data != NULL)
    {
        buffer->data[0] = '\0';
    }
}

static int script_buffer_append_char(script_buffer *buffer, char ch)
{
    size_t required;
    size_t new_capacity;
    char *resized;

    if (buffer == NULL)
    {
        return 0;
    }

    required = buffer->length + 2;
    if (required > buffer->capacity)
    {
        new_capacity = buffer->capacity == 0 ? SCRIPT_LITERAL_BUFFER_CHUNK : buffer->capacity * 2;
        while (new_capacity < required)
        {
            new_capacity *= 2;
        }
        resized = (char *)realloc(buffer->data, new_capacity);
        if (resized == NULL)
        {
            return 0;
        }
        buffer->data = resized;
        buffer->capacity = new_capacity;
    }

    buffer->data[buffer->length++] = ch;
    buffer->data[buffer->length] = '\0';
    return 1;
}

static int script_buffer_append_string(script_buffer *buffer, const char *text)
{
    if (buffer == NULL || text == NULL)
    {
        return 1;
    }

    while (*text != '\0')
    {
        if (!script_buffer_append_char(buffer, *text++))
        {
            return 0;
        }
    }

    return 1;
}

static void script_buffer_trim_trailing_whitespace(script_buffer *buffer)
{
    if (buffer == NULL || buffer->data == NULL)
    {
        return;
    }

    while (buffer->length > 0)
    {
        unsigned char ch = (unsigned char)buffer->data[buffer->length - 1];
        if (!isspace(ch))
        {
            break;
        }
        buffer->length--;
        buffer->data[buffer->length] = '\0';
    }
}

static int script_buffer_has_embedded_blocks(const char *buffer, size_t length)
{
    size_t index = 0;
    char ch;

    if (buffer == NULL)
    {
        return 0;
    }

    while (index < length)
    {
        ch = buffer[index];

        if (ch == '/' && index + 1 < length && buffer[index + 1] == '*')
        {
            index += 2;
            while (index < length)
            {
                if (buffer[index] == '*' && index + 1 < length && buffer[index + 1] == '/')
                {
                    index += 2;
                    break;
                }
                index++;
            }
            continue;
        }

        if (ch == '{')
        {
            if (index + 1 >= length || buffer[index + 1] != '{')
            {
                return 1;
            }
            index += 2;
            continue;
        }

        index++;
    }

    return 0;
}

static char *script_strip_block_comments(const char *buffer, size_t length)
{
    char *result;
    size_t src = 0;
    size_t dst = 0;

    if (buffer == NULL || length == 0)
    {
        return NULL;
    }

    result = (char *)malloc(length + 1);
    if (result == NULL)
    {
        return NULL;
    }

    while (src < length)
    {
        if (buffer[src] == '/' && src + 1 < length && buffer[src + 1] == '*')
        {
            src += 2;
            while (src < length)
            {
                if (buffer[src] == '*' && src + 1 < length && buffer[src + 1] == '/')
                {
                    src += 2;
                    break;
                }
                if (buffer[src] == '\n')
                {
                    result[dst++] = '\n';
                }
                src++;
            }
        }
        else
        {
            result[dst++] = buffer[src++];
        }
    }

    result[dst] = '\0';
    return result;
}

static int script_parse_plain_lines(script_state *state, const char *buffer)
{
    int line_number = 0;
    const char *cursor = buffer;

    if (buffer == NULL)
    {
        return 1;
    }

    while (*cursor != '\0')
    {
        const char *line_start = cursor;
        size_t len;
        char *line_copy;

        while (*cursor != '\0' && *cursor != '\n')
        {
            cursor++;
        }

        len = (size_t)(cursor - line_start);
        line_copy = (char *)malloc(len + 1);
        if (line_copy == NULL)
        {
            script_set_error(state, "Out of memory parsing script");
            return 0;
        }

        if (len > 0)
        {
            memcpy(line_copy, line_start, len);
        }
        line_copy[len] = '\0';
        if (len > 0 && line_copy[len - 1] == '\r')
        {
            line_copy[len - 1] = '\0';
        }

        line_number++;
        if (!script_parse_line(state, line_copy, line_number))
        {
            free(line_copy);
            return 0;
        }

        free(line_copy);
        if (*cursor == '\n')
        {
            cursor++;
        }
    }

    return 1;
}

static int script_append_print_literal(script_state *state, const char *text, size_t length)
{
    script_instruction instruction;
    script_buffer normalised;
    size_t i;
    char ch;

    if (text == NULL || length == 0)
    {
        return 1;
    }

    script_buffer_init(&normalised);
    for (i = 0; i < length; ++i)
    {
        ch = text[i];

        if (ch == '\n')
        {
            size_t prev_len = normalised.length;
            if (prev_len > 0 && normalised.data[prev_len - 1] == '\r')
            {
                if (!script_buffer_append_char(&normalised, '\n'))
                {
                    script_buffer_free(&normalised);
                    script_set_error(state, "Out of memory storing literal text");
                    return 0;
                }
            }
            else
            {
                if (!script_buffer_append_char(&normalised, '\r') || !script_buffer_append_char(&normalised, '\n'))
                {
                    script_buffer_free(&normalised);
                    script_set_error(state, "Out of memory storing literal text");
                    return 0;
                }
            }
            continue;
        }

        if (!script_buffer_append_char(&normalised, ch))
        {
            script_buffer_free(&normalised);
            script_set_error(state, "Out of memory storing literal text");
            return 0;
        }
    }

    if (normalised.length == 0)
    {
        script_buffer_free(&normalised);
        return 1;
    }

    memset(&instruction, 0, sizeof(instruction));
    instruction.type = SCRIPT_CMD_PRINT;
    instruction.arg1 = script_duplicate_range(normalised.data, normalised.length);
    script_buffer_free(&normalised);
    if (instruction.arg1 == NULL)
    {
        script_set_error(state, "Out of memory storing literal text");
        return 0;
    }

    if (!script_append_instruction(state, &instruction))
    {
        script_free_instruction(&instruction);
        script_set_error(state, "Too many instructions while expanding text");
        return 0;
    }

    return 1;
}

static int script_execute_inline_command(script_state *state, const char *command_text, int line_number)
{
    script_instruction instruction;
    char *copy;
    char *trimmed;

    if (command_text == NULL)
    {
        return 1;
    }

    copy = script_duplicate_string(command_text);
    if (copy == NULL)
    {
        script_set_error(state, "Out of memory parsing inline command");
        return 0;
    }

    trimmed = script_trim(copy);
    if (*trimmed == '\0' || script_is_empty_or_comment(trimmed))
    {
        free(copy);
        return 1;
    }

    memset(&instruction, 0, sizeof(instruction));
    if (!script_build_instruction(state, trimmed, line_number, &instruction))
    {
        free(copy);
        return 0;
    }

    free(copy);

    if (instruction.type != SCRIPT_CMD_NONE)
    {
        script_execute_instruction(state, &instruction);
        script_free_instruction(&instruction);
    }

    return 1;
}

static int script_skip_comment(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name)
{
    size_t cursor;

    if (buffer == NULL || index == NULL)
    {
        return 0;
    }

    cursor = *index + 2;
    while (cursor < length)
    {
        if (buffer[cursor] == '\n' && line_number != NULL)
        {
            (*line_number)++;
        }

        if (buffer[cursor] == '*' && cursor + 1 < length && buffer[cursor + 1] == '/')
        {
            *index = cursor + 2;
            return 1;
        }
        cursor++;
    }

    script_set_error(state, "Unterminated comment in %s", source_name != NULL ? source_name : "script");
    *index = length;
    return 0;
}

static int script_process_embedded_block(script_state *state, const char *buffer, size_t length, size_t *index, int *line_number, const char *source_name, script_command_handler command_handler, void *context)
{
    script_buffer command;
    int result = 1;

    if (command_handler == NULL)
    {
        return 0;
    }

    script_buffer_init(&command);

    while (*index < length)
    {
        char ch;

        while (*index < length)
        {
            ch = buffer[*index];
            if (ch == '\r')
            {
                (*index)++;
                continue;
            }
            if (ch == '\n')
            {
                if (line_number != NULL)
                {
                    (*line_number)++;
                }
                (*index)++;
                continue;
            }
            if (ch == ' ' || ch == '\t' || ch == ',')
            {
                (*index)++;
                continue;
            }
            if (ch == '/' && *index + 1 < length && buffer[*index + 1] == '*')
            {
                if (!script_skip_comment(state, buffer, length, index, line_number, source_name))
                {
                    result = 0;
                    break;
                }
                continue;
            }
            break;
        }

        if (!result)
        {
            break;
        }

        if (*index >= length)
        {
            script_set_error(state, "Missing } in %s", source_name != NULL ? source_name : "script");
            result = 0;
            break;
        }

        if (buffer[*index] == '}')
        {
            (*index)++;
            break;
        }

        script_buffer_clear(&command);
        {
            int in_quote = 0;
            int in_macro = 0; /* Track %{...} macro depth */
            while (*index < length)
            {
                ch = buffer[*index];

                if (ch == '\r')
                {
                    (*index)++;
                    continue;
                }

                if (!in_quote && ch == '/' && *index + 1 < length && buffer[*index + 1] == '*')
                {
                    if (!script_skip_comment(state, buffer, length, index, line_number, source_name))
                    {
                        result = 0;
                        break;
                    }
                    continue;
                }

                if (ch == '`')
                {
                    in_quote = !in_quote;
                }
                else if (ch == '\n')
                {
                    if (!in_quote)
                    {
                        break;
                    }
                    script_set_error(state, "Missing ` in %s", source_name != NULL ? source_name : "script");
                    result = 0;
                    break;
                }
                else if (!in_quote && !in_macro && (ch == ',' || ch == '}'))
                {
                    break;
                }
                
                /* Track %{ macro start */
                if (!in_quote && ch == '%' && *index + 1 < length && buffer[*index + 1] == '{')
                {
                    in_macro++;
                }
                /* Track } that closes a macro */
                else if (!in_quote && in_macro > 0 && ch == '}')
                {
                    in_macro--;
                }

                if (!script_buffer_append_char(&command, ch))
                {
                    script_set_error(state, "Out of memory parsing %s", source_name != NULL ? source_name : "script");
                    result = 0;
                    break;
                }

                (*index)++;
            }
        }

        if (!result)
        {
            break;
        }

        script_buffer_trim_trailing_whitespace(&command);
        if (command.data != NULL && command.length > 0)
        {
            char *trimmed = script_trim(command.data);
            if (*trimmed != '\0' && !script_is_empty_or_comment(trimmed))
            {
                if (!command_handler(state, trimmed, line_number != NULL ? *line_number : 0, context))
                {
                    result = 0;
                    break;
                }
            }
        }

        if (*index < length)
        {
            ch = buffer[*index];
            if (ch == ',')
            {
                (*index)++;
            }
            else if (ch == '\n')
            {
                if (line_number != NULL)
                {
                    (*line_number)++;
                }
                (*index)++;
            }
        }
    }

    script_buffer_free(&command);
    return result;
}

static int script_process_embedded_content(script_state *state, const char *buffer, size_t length, const char *source_name, script_text_handler text_handler, script_command_handler command_handler, void *context)
{
    size_t index = 0;
    int line_number = 1;
    script_buffer literal;
    int result = 1;
    char ch;
    int has_content_on_line = 0;

    if (text_handler == NULL || command_handler == NULL)
    {
        return 0;
    }

    script_buffer_init(&literal);

    while (index < length && result)
    {
        ch = buffer[index];

        /* Skip \r only if followed by \n (normalize CRLF to LF) */
        /* Keep standalone \r for cursor positioning in ANSI files */
        if (ch == '\r')
        {
            if (index + 1 < length && buffer[index + 1] == '\n')
            {
                index++;
                continue;
            }
        }

        if (ch == '/' && index + 1 < length && buffer[index + 1] == '*')
        {
            if (!script_skip_comment(state, buffer, length, &index, &line_number, source_name))
            {
                result = 0;
            }
            continue;
        }

        if (ch == '{')
        {
            /* Check if this is %{...} macro syntax - if so, treat as literal */
            int is_macro = (literal.length > 0 && literal.data[literal.length - 1] == '%');
            
            if (index + 1 < length && buffer[index + 1] == '{')
            {
                /* Escaped {{ becomes literal { */
                index++;
                ch = '{';
            }
            else if (is_macro)
            {
                /* This is %{ - treat the { as literal, will be expanded later */
                /* Fall through to append_char below */
            }
            else
            {
                if (literal.length > 0)
                {
                    if (!text_handler(state, literal.data, literal.length, line_number, context))
                    {
                        result = 0;
                        break;
                    }
                    script_buffer_clear(&literal);
                }
                index++;
                if (!script_process_embedded_block(state, buffer, length, &index, &line_number, source_name, command_handler, context))
                {
                    result = 0;
                }
                else if (has_content_on_line == 0)
                {
                    /* If line had no content before this block, consume following newline */
                    size_t peek = index;
                    if (peek < length && buffer[peek] == '\r') peek++;
                    if (peek < length && buffer[peek] == '\n')
                    {
                        index = peek + 1;
                        line_number++;
                    }
                }
                continue;
            }
        }

        if (ch == '\n')
        {
            line_number++;
            has_content_on_line = 0;
        }
        else
        {
            has_content_on_line = 1;
        }

        if (!script_buffer_append_char(&literal, ch))
        {
            script_set_error(state, "Out of memory processing %s", source_name != NULL ? source_name : "script");
            result = 0;
            break;
        }

        index++;
    }

    if (result && literal.length > 0)
    {
        if (!text_handler(state, literal.data, literal.length, line_number, context))
        {
            result = 0;
        }
    }

    script_buffer_free(&literal);
    return result;
}

static int script_handle_embedded_text_as_instruction(script_state *state, const char *text, size_t length, int line_number, void *context)
{
    (void)line_number;
    (void)context;
    return script_append_print_literal(state, text, length);
}

static int script_handle_embedded_command_as_instruction(script_state *state, const char *command_text, int line_number, void *context)
{
    (void)context;
    return script_parse_line(state, command_text, line_number);
}

static int script_handle_embedded_text_as_output(script_state *state, const char *text, size_t length, int line_number, void *context)
{
    (void)line_number;
    (void)context;
    if (state == NULL || text == NULL || length == 0)
    {
        return 1;
    }

    {
        char *literal = script_duplicate_range(text, length);
        script_buffer expanded;

        if (literal == NULL)
        {
            script_set_error(state, "Out of memory expanding text");
            return 0;
        }

        script_buffer_init(&expanded);
        if (!script_expand_macros_to_buffer(state, literal, &expanded, 1))
        {
            free(literal);
            script_buffer_free(&expanded);
            return 0;
        }

        if (expanded.length > 0 && expanded.data != NULL)
        {
            script_write_output(state, expanded.data);
        }

        script_buffer_free(&expanded);
        free(literal);
    }

    return 1;
}

static int script_handle_embedded_command_as_output(script_state *state, const char *command_text, int line_number, void *context)
{
    (void)context;
    return script_execute_inline_command(state, command_text, line_number);
}
