/* LineTask Wimp helper that proxies Pipes traffic on a specific line. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <kernel.h>
#include <swis.h>

#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Handler.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Screen.h"
#include "C:Desk.Template.h"
#include "C:Desk.Window.h"
#include "C:Desk.WimpSWIs.h"
#include "script.h"
#include "filebase.h"
#include "debug.h"
#include "iconnames.h"
#include "main.h"

#define PIPES_SWI_BASE 0x5AA00

#define SWI_CONVERSE_PIPES_INPUT_READ   (PIPES_SWI_BASE + 3)
#define SWI_CONVERSE_PIPES_OUTPUT_WRITE (PIPES_SWI_BASE + 5)
#define SWI_OS_BYTE                     0x00000006

#define PIPE_TRANSFER_CHUNK 256
#define PIPE_CONTROL_TOKEN      ((unsigned char)0x00)
#define PIPE_CONTROL_CONNECT    'C'
#define PIPE_CONTROL_DISCONNECT 'D'

#define RISC_BBS_MESSAGE_START   0x00C0900
#define RISC_BBS_MESSAGE_END     0x00C0901
#define RISC_BBS_MESSAGE_OUTPUT  0x00C0902
#define RISC_BBS_MESSAGE_ACK     0x00C0903
#define RISC_BBS_MESSAGE_INPUT   0x00C0904
#define LINE_MESSAGE_BASE        0x5AA00
#define LINE_SHUTDOWN_MESSAGE    (LINE_MESSAGE_BASE + 0)
#define LINE_ACTIVITY_MESSAGE    (LINE_MESSAGE_BASE + 1)
#define LINE_CONTROL_MESSAGE     (LINE_MESSAGE_BASE + 2)
#define LINE_TASK_OPEN_WINDOW_MESSAGE (LINE_MESSAGE_BASE + 3)
#define LINE_TASK_REGISTER_MESSAGE (LINE_MESSAGE_BASE + 4)
#define LINE_USER_MESSAGE        (LINE_MESSAGE_BASE + 5)
#define LINE_CONTROL_REASON_LOGOFF 1

#define LINE_ACTIVITY_MAX_TEXT   96

#define CONVERSE_FILER_BASE          0x5AA40
#define FILER_SWI_LOGGING            0
#define FILER_SWI_USERDB             1
#define FILER_LOG_REASON_LINE        1
#define FILER_USERDB_CMD_SEARCH      3
#define FILER_USERDB_CMD_AUTHENTICATE 4
#define SWI_CONVERSE_FILER_LOGGING   (CONVERSE_FILER_BASE + FILER_SWI_LOGGING)
#define SWI_CONVERSE_FILER_USERDB    (CONVERSE_FILER_BASE + FILER_SWI_USERDB)

/* ConverseBBS Support module SWIs */
#define SWI_CONVERSEBBS_CONFIG       0x5AA80
#define SWI_CONVERSEBBS_LINE         0x5AA81
#define SWI_CONVERSEBBS_ACTIVITY     0x5AA82

/* ARCbbsDoors emulator SWIs - matches original API */
#define ARCBBS_SWI_BASE              0x41040
#define SWI_ARCBBSDOORS_READSTATUS   (ARCBBS_SWI_BASE + 0)   /* ReadStatus */
#define SWI_ARCBBSDOORS_WRITESTATUS  (ARCBBS_SWI_BASE + 1)   /* WriteStatus */
/* SWIs 2-5 are SendRequest, GetReply, Reserved, Reserved */
/* SWIs 6-11 are InputStatus, InputRead, OutputStatus, OutputWrite, ClearInput, ClearOutput */
#define SWI_ARCBBSDOORS_HOSTWRITE    (ARCBBS_SWI_BASE + 12)  /* Extended: Host writes to door input */
#define SWI_ARCBBSDOORS_HOSTREAD     (ARCBBS_SWI_BASE + 13)  /* Extended: Host reads from door output */
#define SWI_ARCBBSDOORS_ACTIVATE     (ARCBBS_SWI_BASE + 14)  /* Extended: Activate line */
#define SWI_ARCBBSDOORS_DEACTIVATE   (ARCBBS_SWI_BASE + 15)  /* Extended: Deactivate line */

/* ARCbbsDoors status byte values */
#define ARCBBS_STATUS_IDLE           0
#define ARCBBS_STATUS_ACTIVE         255

/* Door request code - any value 1-254 can be used to indicate a door launch request */
#define ARCBBS_STATUS_REQUEST        1

/* Line state reason codes and field indices */
#define LINE_REASON_SET              0
#define LINE_REASON_GET              1
#define LINE_FIELD_CONFIGURED        0
#define LINE_FIELD_CONNECTED         1
#define LINE_FIELD_USER_ID           2
#define LINE_FIELD_CONNECT_TIME      3
#define LINE_FIELD_HOSTNAME          4

/* Activity reason codes */
#define ACTIVITY_REASON_GET          1

/* Max lines to query */
#define SUPPORT_MAX_LINES            32

#if CLOCKS_PER_SEC < 4
#define DOOR_ACK_INTERVAL_TICKS 1
#else
#define DOOR_ACK_INTERVAL_TICKS (CLOCKS_PER_SEC / 4)
#endif

#define DOOR_LAUNCH_TIMEOUT_TICKS (5 * CLOCKS_PER_SEC)
#define BOTSTOPPER_TIMEOUT_SECS    30
#define BOTSTOPPER_CHAR            '*'
#define SCRIPT_ENTRY_PATH "<Converse$Dir>.BBS.Start"

#define SWI_OS_READMONOTONICTIME 0x00000042
#define POLL_IDLE_DELAY 1  /* centiseconds between null polls (10ms) */

/* ConverseBBS Support module - LineConfig SWI */
#define SWI_CONVERSEBBS_LINECONFIG   0x5AA83

/* LineConfig reason codes and fields */
#define LINECONFIG_REASON_GET        1
#define LINECONFIG_FIELD_ENABLED     0
#define LINECONFIG_FIELD_BOTSTOPPER  1
#define LINECONFIG_FIELD_HELLO       2

/* Botstopper states */
typedef enum
{
    BOTSTOPPER_STATE_INACTIVE = 0,  /* Not in botstopper mode */
    BOTSTOPPER_STATE_WAITING,       /* Waiting for user to type ** */
    BOTSTOPPER_STATE_PASSED,        /* User passed the challenge */
    BOTSTOPPER_STATE_FAILED         /* User timed out or failed */
} BOTSTOPPER_STATE;

typedef struct
{
    int line_id;
    char line_label[8];
    int session_active;
    int control_stage;
    unsigned char control_code;
    Desk_bool quit_requested;
    Desk_bool door_launch_pending;
    Desk_bool door_active;
    int door_task_handle;
    char *door_output_buffer;
    clock_t door_next_ack_tick;
    clock_t door_launch_deadline;
    /* ARCbbs door state */
    Desk_bool arcbbs_door_active;
    Desk_bool arcbbs_door_launch_pending;
    clock_t arcbbs_door_launch_deadline;
    clock_t arcbbs_poll_tick;
    int arcbbs_requested_door_number;
    /* Botstopper state */
    BOTSTOPPER_STATE botstopper_state;
    time_t botstopper_deadline;
    int botstopper_star_count;
    /* Script engine */
    script_state script;
    /* Filebase session */
    filebase_session fb_session;
    /* User session state */
    int user_id;
    int user_accesslevel;
    char user_keys[128];
} line_task_state;

static line_task_state task_state;
static Desk_window_handle main_window_handle;

static char app_compiled[]=__DATE__" at "__TIME__;

static int pipes_input_read_byte(int line_id);
static int pipes_input_read_block(int line_id, char *buffer, int length);
static int pipes_output_write_block(int line_id, const char *buffer, int length);
static void pipes_output_write_string(int line_id, const char *string);
static void pipes_send_welcome(line_task_state *state);
static void handle_server_stream(line_task_state *state, const char *buffer, int length);
static Desk_bool handle_null_poll(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_message_event(Desk_event_pollblock *event, void *ref);
static void process_server_stream(line_task_state *state);
static void initialise_task_state(line_task_state *state, int argc, char **argv);
static void initialise_resources(void);
static void shutdown_resources(void);
static void show_main_window(void);
static void notify_server_ready(const line_task_state *state);
static void update_main_window_title(line_task_state *state);
static void wait_for_pipe_space(void);
static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref);
static void menu_handle_user_byte(line_task_state *state, unsigned char byte);
static void botstopper_start(line_task_state *state);
static void botstopper_process(line_task_state *state);
static int botstopper_handle_byte(line_task_state *state, unsigned char byte);
static int config_get_botstopper_enabled(void);
static const char *config_get_prelogon_script(void);
static const char *config_get_postlogon_script(void);
static const char *config_get_newuser_script(void);
static const char *lineconfig_get_hello(int line_id);
static const char *lineconfig_get_botstopper(int line_id);
static void script_start_session(line_task_state *state);
static void script_start_prelogon(line_task_state *state);
static void script_start_postlogon(line_task_state *state);
static void script_start_newuser(line_task_state *state);
static void script_stop_session(line_task_state *state);
static void script_print_time(line_task_state *state);
static void script_print_line_info(line_task_state *state);
static void door_reset_state(line_task_state *state);
static void door_process(line_task_state *state);
static void door_send_acknowledgement(line_task_state *state);
static void door_queue_output(line_task_state *state, const char *text, size_t length);
static void door_flush_output(line_task_state *state);
static void door_close_session(line_task_state *state, const char *message);
static void arcbbs_door_reset_state(line_task_state *state);
static void arcbbs_door_process(line_task_state *state);
static void arcbbs_door_close_session(line_task_state *state, const char *message);
static int arcbbs_activate_line(int line_id);
static int arcbbs_deactivate_line(int line_id);
static int arcbbs_set_status(int line_id, unsigned char status);
static int arcbbs_get_status(int line_id);
static int arcbbs_write_input(int line_id, unsigned char byte);
static int arcbbs_read_output(int line_id);
static void script_host_write(void *context, const char *text);
static void script_host_launch_door(void *context, const char *command_line);
static void script_host_launch_arcbbs_door(void *context, int door_number, const char *command_line);
static void script_host_report_time(void *context);
static void script_host_report_line_info(void *context);
static void script_host_request_disconnect(void *context);
static void script_host_force_disconnect(void *context);
static void script_host_report_activity(void *context, const char *text);
static void script_host_report_online_users(void *context);
static int script_host_get_line_id(void *context);
static int script_host_get_task_handle(void *context);
static void *script_host_get_filebase_session(void *context);
static int script_host_get_user_accesslevel(void *context);
static const char *script_host_get_user_keys(void *context);
static int script_host_filebase_download(void *context, int base_id, int file_id);
static int script_host_authenticate_user(void *context, const char *username, const char *password, int *auth_result);
static void script_host_start_postlogon(void *context);
static void script_host_start_newuser(void *context);
static void log_line_event(int line_id, const char *message);
static void send_user_message(int line_id, const char *real_name);
static void poll_idle(void);

static void poll_idle(void)
{
    _kernel_swi_regs regs;
    Desk_event_pollblock event;
    int earliest;

    /* Get current monotonic time and add delay */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    earliest = regs.r[0] + POLL_IDLE_DELAY;

    /* Poll with idle time - won't return null events until 'earliest' */
    Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
    Desk_Event_Process(&event);
}

/* Send user name message to Server to update the status window user column.
 * Pass NULL or empty string to reset to waiting state.
 */
static void send_user_message(int line_id, const char *real_name)
{
    Desk_message_block message;
    
    memset(&message, 0, sizeof(message));
    message.header.size = sizeof(Desk_message_header) + 4 + 100;  /* word for line_id + name buffer */
    message.header.action = (Desk_message_action)LINE_USER_MESSAGE;
    message.data.words[0] = line_id;
    
    if (real_name != NULL && real_name[0] != '\0')
    {
        strncpy((char *)&message.data.bytes[4], real_name, 96);
        message.data.bytes[99] = '\0';
    }
    else
    {
        message.data.bytes[4] = '\0';  /* Empty string to reset */
    }
    
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

int main(int argc, char **argv)
{
    initialise_task_state(&task_state, argc, argv);

    {
        char task_name[32];
        snprintf(task_name, sizeof(task_name), "Converse Line [%d]", task_state.line_id);
        Desk_Event_Initialise(task_name);
    }
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();
    Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY, Desk_Handler_NullRedraw, NULL);
    Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY, Desk_Handler_OpenWindow, NULL);
    Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY, handle_window_close, NULL);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, handle_null_poll, &task_state);
    Desk_Event_Claim(Desk_event_USERMESSAGE, Desk_event_ANY, Desk_event_ANY, handle_message_event, &task_state);
    Desk_Event_Claim(Desk_event_USERMESSAGERECORDED, Desk_event_ANY, Desk_event_ANY, handle_message_event, &task_state);

    initialise_resources();
    notify_server_ready(&task_state);

    while (task_state.quit_requested == Desk_bool_FALSE)
    {
        poll_idle();
    }

    log_line_event(task_state.line_id, "LineTask shutting down");

    script_dispose(&task_state.script);
    shutdown_resources();
    Desk_Event_CloseDown();
    return 0;
}

static void initialise_task_state(line_task_state *state, int argc, char **argv)
{
    int line_id = 0;
    const char *line_arg = "0";

    if (argc > 1 && argv[1] != NULL)
    {
        line_arg = argv[1];
        line_id = atoi(argv[1]);
    }

    if (line_id < 0)
    {
        line_id = 0;
    }
    if (line_id > 31)
    {
        line_id = 31;
    }

    state->line_id = line_id;
    strncpy(state->line_label, line_arg, sizeof(state->line_label) - 1);
    state->line_label[sizeof(state->line_label) - 1] = '\0';
    state->session_active = 0;
    state->control_stage = 0;
    state->control_code = 0;
    state->quit_requested = Desk_bool_FALSE;
    state->botstopper_state = BOTSTOPPER_STATE_INACTIVE;
    state->botstopper_deadline = 0;
    state->botstopper_star_count = 0;
    door_reset_state(state);
    arcbbs_door_reset_state(state);

    {
        script_host host;
        memset(&host, 0, sizeof(host));
        host.context = state;
        host.write_text = script_host_write;
        host.launch_door = script_host_launch_door;
        host.launch_arcbbs_door = script_host_launch_arcbbs_door;
        host.report_time = script_host_report_time;
        host.report_line_info = script_host_report_line_info;
        host.request_disconnect = script_host_request_disconnect;
        host.force_disconnect = script_host_force_disconnect;
        host.report_activity = script_host_report_activity;
        host.report_online_users = script_host_report_online_users;
        host.get_line_id = script_host_get_line_id;
        host.get_task_handle = script_host_get_task_handle;
        host.get_filebase_session = script_host_get_filebase_session;
        host.get_user_accesslevel = script_host_get_user_accesslevel;
        host.get_user_keys = script_host_get_user_keys;
        host.filebase_download = script_host_filebase_download;
        host.authenticate_user = script_host_authenticate_user;
        host.start_postlogon = script_host_start_postlogon;
        host.start_newuser = script_host_start_newuser;
        script_initialise(&state->script, &host);
    }

    /* Initialise filebase session */
    filebase_session_init(&state->fb_session);
    state->user_id = 0;
    state->user_accesslevel = 0;
    state->user_keys[0] = '\0';
}

static void initialise_resources(void)
{
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");
    Desk_Template_Initialise();
    Desk_Template_UseOutlineFonts();
    Desk_Template_LoadFile("Templates");
    main_window_handle = Desk_Window_Create("main", NULL);
    update_main_window_title(&task_state);
}

static void shutdown_resources(void)
{
    Desk_Template_ClearAll();
    main_window_handle = 0;
}

static void show_main_window(void)
{
    if (main_window_handle != 0)
    {
        Desk_Window_Show(main_window_handle, Desk_open_CENTERED);
    }
}

static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);

    if (event != NULL)
    {
        Desk_Window_Hide(event->data.openblock.window);
    }

    return Desk_bool_TRUE;
}

static void notify_server_ready(const line_task_state *state)
{
    Desk_message_block message;

    if (state == NULL)
    {
        return;
    }

    memset(&message, 0, sizeof(message));
    message.header.size = 24;
    message.header.action = (Desk_message_action)LINE_TASK_REGISTER_MESSAGE;
    message.data.words[0] = state->line_id;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

static void update_main_window_title(line_task_state *state)
{
    char title[32];
    const char *label = "000";

    if (state == NULL || main_window_handle == 0)
    {
        return;
    }

    if (state->line_label[0] != '\0')
    {
        label = state->line_label;
    }
    else
    {
        snprintf(state->line_label, sizeof(state->line_label), "%d", state->line_id);
        label = state->line_label;
    }

    snprintf(title, sizeof(title), "Converse Line #%s", label);
    Desk_Window_SetTitle(main_window_handle, title);
}

static void door_reset_state(line_task_state *state)
{
    if (state->door_output_buffer != NULL)
    {
        free(state->door_output_buffer);
        state->door_output_buffer = NULL;
    }

    state->door_launch_pending = Desk_bool_FALSE;
    state->door_active = Desk_bool_FALSE;
    state->door_task_handle = 0;
    state->door_next_ack_tick = 0;
    state->door_launch_deadline = 0;

    log_line_event(state->line_id, "LineTask started");
}

static Desk_bool handle_null_poll(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    Desk_UNUSED(event);

    process_server_stream(state);
    botstopper_process(state);
    door_process(state);
    arcbbs_door_process(state);
    script_process(&state->script);
    return Desk_bool_TRUE;
}

static Desk_bool handle_message_event(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    unsigned int action = event->data.message.header.action;

    if (action == Desk_message_QUIT)
    {
        state->quit_requested = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    if (action == LINE_SHUTDOWN_MESSAGE)
    {
        int reason = event->data.message.data.words[0];
        if (reason == 0)
        {
            state->quit_requested = Desk_bool_TRUE;
            return Desk_bool_TRUE;
        }
        return Desk_bool_FALSE;
    }

    if (action == LINE_TASK_OPEN_WINDOW_MESSAGE)
    {
        int target_line = event->data.message.data.words[0];
        if (target_line == state->line_id)
        {
            show_main_window();
            return Desk_bool_TRUE;
        }
        return Desk_bool_FALSE;
    }

    if (action == RISC_BBS_MESSAGE_START)
    {
        if (state->door_launch_pending == Desk_bool_FALSE || state->door_active != Desk_bool_FALSE)
        {
            return Desk_bool_FALSE;
        }

        state->door_task_handle = event->data.message.header.sender;
        state->door_active = Desk_bool_TRUE;
        state->door_launch_pending = Desk_bool_FALSE;
        state->door_launch_deadline = 0;
        state->door_next_ack_tick = 0;
        pipes_output_write_string(state->line_id, "");
        door_send_acknowledgement(state);
        state->door_next_ack_tick = clock() + DOOR_ACK_INTERVAL_TICKS;
        return Desk_bool_TRUE;
    }

    if (action == RISC_BBS_MESSAGE_END)
    {
        if (state->door_active == Desk_bool_FALSE || event->data.message.header.sender != state->door_task_handle)
        {
            return Desk_bool_FALSE;
        }

        door_close_session(state, "");
        return Desk_bool_TRUE;
    }

    if (action == RISC_BBS_MESSAGE_OUTPUT)
    {
        int payload_length;

        if (state->door_active == Desk_bool_FALSE || event->data.message.header.sender != state->door_task_handle)
        {
            return Desk_bool_FALSE;
        }

        payload_length = event->data.message.header.size - 20;
        if (payload_length < 0)
        {
            payload_length = 0;
        }
        door_queue_output(state, (const char *)event->data.message.data.bytes, (size_t)payload_length);
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

static void process_server_stream(line_task_state *state)
{
    int iteration = 0;

    while (iteration < 4)
    {
        char buffer[PIPE_TRANSFER_CHUNK];
        int copied = pipes_input_read_block(state->line_id, buffer, sizeof(buffer));

        if (copied <= 0)
        {
            break;
        }

        handle_server_stream(state, buffer, copied);
        iteration++;
    }
}

static void handle_plain_server_byte(line_task_state *state, unsigned char byte)
{
    if (state->session_active != 0)
    {
        menu_handle_user_byte(state, byte);
    }
}

static void handle_server_stream(line_task_state *state, const char *buffer, int length)
{
    int index = 0;

    while (index < length)
    {
        unsigned char byte = (unsigned char)buffer[index++];

        if (state->control_stage == 0)
        {
            if (byte == PIPE_CONTROL_TOKEN)
            {
                state->control_stage = 1;
                continue;
            }

            handle_plain_server_byte(state, byte);
            continue;
        }

        if (state->control_stage == 1)
        {
            state->control_code = byte;
            state->control_stage = 2;
            continue;
        }

        /* control_stage == 2: expecting trailing token */
        if (byte != PIPE_CONTROL_TOKEN)
        {
            handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
            handle_plain_server_byte(state, state->control_code);
            handle_plain_server_byte(state, byte);
            state->control_stage = 0;
            continue;
        }

        state->control_stage = 0;

        if (state->control_code == PIPE_CONTROL_CONNECT)
        {
            state->session_active = 1;
            log_line_event(state->line_id, "Session connected");
            pipes_send_welcome(state);
            
            /* Check if botstopper is enabled globally */
            if (config_get_botstopper_enabled())
            {
                botstopper_start(state);
            }
            else
            {
                /* No botstopper - go straight to prelogon script */
                script_start_prelogon(state);
            }
            continue;
        }

        if (state->control_code == PIPE_CONTROL_DISCONNECT)
        {
            if (state->session_active != 0)
            {
                pipes_output_write_string(state->line_id, "\r\n[LINETASK CLOSED]\r\n");
            }
            state->session_active = 0;
            state->botstopper_state = BOTSTOPPER_STATE_INACTIVE;
            if (state->door_active != Desk_bool_FALSE || state->door_launch_pending != Desk_bool_FALSE)
            {
                door_close_session(state, "\r\n[Door session ended]\r\n");
            }
            if (state->arcbbs_door_active != Desk_bool_FALSE || state->arcbbs_door_launch_pending != Desk_bool_FALSE)
            {
                arcbbs_door_close_session(state, "\r\n[ARCbbs door session ended]\r\n");
            }
            /* Reset filebase session and user state on disconnect */
            filebase_session_reset(&state->fb_session);
            state->user_id = 0;
            state->user_accesslevel = 0;
            state->user_keys[0] = '\0';
            /* Reset user display in Server status window */
            send_user_message(state->line_id, NULL);
            log_line_event(state->line_id, "Session disconnected");
            script_stop_session(state);
            continue;
        }

        handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
        handle_plain_server_byte(state, state->control_code);
        handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
    }
}

static int pipes_input_read_byte(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_READ, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

static int pipes_input_read_block(int line_id, char *buffer, int length)
{
    int copied = 0;

    while (copied < length)
    {
        _kernel_swi_regs regs;

        regs.r[0] = line_id;
        if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_READ, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] < 0)
        {
            break;
        }

        buffer[copied++] = (char)regs.r[0];
    }

    return copied;
}

static int pipes_output_write_block(int line_id, const char *buffer, int length)
{
    int copied = 0;

    while (copied < length)
    {
        _kernel_swi_regs regs;

        regs.r[0] = line_id;
        regs.r[1] = (unsigned int)(unsigned char)buffer[copied];
        if (_kernel_swi(SWI_CONVERSE_PIPES_OUTPUT_WRITE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] != 0)
        {
            break;
        }

        copied++;
    }

    return copied;
}

static void pipes_output_write_string(int line_id, const char *string)
{
    while (*string != '\0')
    {
        int chunk = (int)strlen(string);
        int written;

        if (chunk > PIPE_TRANSFER_CHUNK)
        {
            chunk = PIPE_TRANSFER_CHUNK;
        }

        written = pipes_output_write_block(line_id, string, chunk);
        if (written <= 0)
        {
            wait_for_pipe_space();
            continue;
        }

        string += written;
    }
}

static void pipes_send_welcome(line_task_state *state)
{
    char banner[128];
    char connected[128];

    snprintf(banner, sizeof(banner), "Converse/RISC OS (v0.01) - Compiled on %s\r\n", app_compiled);
    pipes_output_write_string(state->line_id, banner);
    snprintf(connected, sizeof(connected), "Connection established on Line #%d\r\n", state->line_id);
    pipes_output_write_string(state->line_id, connected);
}

static void wait_for_pipe_space(void)
{
    Desk_event_pollblock event;

    /* Do a Wimp poll to allow the Server to drain the pipe */
    Desk_Wimp_Poll(Desk_Event_mask, &event);
    Desk_Event_Process(&event);
}

/*
 * RiscBBS door glue
 * ------------------
 * The line task now owns the RiscBBS door handshake so we can prototype door launches without involving the server.
 * Once a door starts it posts 0xC0900, we latch the task handle, stream user keystrokes via 0xC0904, and drip-feed
 * acknowledgements (0xC0903) so the door keeps pumping output (0xC0902).  
 */
static void door_process(line_task_state *state)
{
    clock_t now;

    door_flush_output(state);

    now = clock();

    if (state->door_launch_pending != Desk_bool_FALSE && state->door_launch_deadline != 0)
    {
        if (now >= state->door_launch_deadline)
        {
            pipes_output_write_string(state->line_id, "\r\n[Door did not respond]\r\n");
            door_reset_state(state);
            script_notify_door_closed(&state->script);
            return;
        }
    }

    if (state->door_active == Desk_bool_FALSE)
    {
        return;
    }

    if (state->door_next_ack_tick == 0 || now >= state->door_next_ack_tick)
    {
        door_send_acknowledgement(state);
        state->door_next_ack_tick = now + DOOR_ACK_INTERVAL_TICKS;
    }
}

static void door_send_acknowledgement(line_task_state *state)
{
    Desk_message_block message;

    if (state->door_task_handle == 0)
    {
        return;
    }

    memset(&message, 0, sizeof(message));
    message.header.size = 20;
    message.header.action = (Desk_message_action)RISC_BBS_MESSAGE_ACK;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, state->door_task_handle, NULL);
}

static void door_queue_output(line_task_state *state, const char *text, size_t length)
{
    if (state->door_active == Desk_bool_FALSE)
    {
        return;
    }

    if (text == NULL || length == 0)
    {
        return;
    }

    if (state->door_output_buffer == NULL)
    {
        state->door_output_buffer = (char *)malloc(length + 1);
        if (state->door_output_buffer == NULL)
        {
            return;
        }

        memcpy(state->door_output_buffer, text, length);
        state->door_output_buffer[length] = '\0';
        return;
    }

    {
        size_t existing = strlen(state->door_output_buffer);
        char *extended = (char *)realloc(state->door_output_buffer, existing + length + 1);
        if (extended == NULL)
        {
            return;
        }

        memcpy(extended + existing, text, length);
        extended[existing + length] = '\0';
        state->door_output_buffer = extended;
    }
}

static void door_flush_output(line_task_state *state)
{
    if (state->door_output_buffer == NULL)
    {
        return;
    }

    pipes_output_write_string(state->line_id, state->door_output_buffer);
    free(state->door_output_buffer);
    state->door_output_buffer = NULL;
}

static void door_send_user_byte(line_task_state *state, unsigned char byte)
{
    Desk_message_block message;

    if (state->door_active == Desk_bool_FALSE || state->door_task_handle == 0)
    {
        return;
    }

    memset(&message, 0, sizeof(message));
    message.header.size = 24;
    message.header.action = (Desk_message_action)RISC_BBS_MESSAGE_INPUT;
    message.data.bytes[0] = (char)byte;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, state->door_task_handle, NULL);
}

static void door_close_session(line_task_state *state, const char *message)
{
    if (message != NULL)
    {
        pipes_output_write_string(state->line_id, message);
    }

    door_flush_output(state);
    door_reset_state(state);
    script_notify_door_closed(&state->script);
}

/*
 * ARCbbsDoors emulator integration
 * ---------------------------------
 * Unlike RiscBBS doors which use Wimp messages, ARCbbs doors use a shared buffer
 * with status byte polling. The protocol is:
 *   1. LineTask sets status to a request code (1-254) and launches the door
 *   2. Door polls GetStatus until it sees 255 (active)
 *   3. Door uses GetByte/PutByte for I/O
 *   4. When door exits, it sets status to 0 (idle)
 *   5. LineTask detects status=0 and knows door has finished
 */

static void arcbbs_door_reset_state(line_task_state *state)
{
    state->arcbbs_door_active = Desk_bool_FALSE;
    state->arcbbs_door_launch_pending = Desk_bool_FALSE;
    state->arcbbs_door_launch_deadline = 0;
    state->arcbbs_poll_tick = 0;
    state->arcbbs_requested_door_number = 0;

    /* Deactivate line in ARCbbsDoors module */
    arcbbs_deactivate_line(state->line_id);
}

static void arcbbs_door_process(line_task_state *state)
{
    int status;

    /* If door is active, bridge I/O */
    if (state->arcbbs_door_active != Desk_bool_FALSE)
    {
        int byte;
        int output_count = 0;
        int input_count = 0;
        static int debug_poll_count = 0;

        /* Check if door has finished (status back to 0) */
        status = arcbbs_get_status(state->line_id);
        if (status == ARCBBS_STATUS_IDLE)
        {
            debug_printf("LineTask ARCbbs: door finished (status=0)\n");
            arcbbs_door_close_session(state, "");
            return;
        }

        /* Debug: log polling status periodically */
        if (debug_poll_count < 5)
        {
            debug_printf("LineTask ARCbbs: polling line=%d status=%d\n", state->line_id, status);
            debug_poll_count++;
        }

        /* Read output from door and send to pipe (door->user) */
        while (output_count < PIPE_TRANSFER_CHUNK && (byte = arcbbs_read_output(state->line_id)) >= 0)
        {
            char ch = (char)byte;
            pipes_output_write_block(state->line_id, &ch, 1);
            output_count++;
        }

        /* Debug: log if we got output */
        if (output_count > 0)
        {
            debug_printf("LineTask ARCbbs: read %d bytes from door output\n", output_count);
        }

        /* Read input from pipe and send to door (user->door) */
        while (input_count < PIPE_TRANSFER_CHUNK)
        {
            byte = pipes_input_read_byte(state->line_id);
            if (byte < 0)
            {
                break;
            }
            if (arcbbs_write_input(state->line_id, (unsigned char)byte) != 0)
            {
                /* ARCbbs input buffer full - stop for now */
                break;
            }
            input_count++;
        }

        /* Debug: log if we sent input */
        if (input_count > 0)
        {
            debug_printf("LineTask ARCbbs: wrote %d bytes to door input\n", input_count);
        }
    }
}

static void arcbbs_door_close_session(line_task_state *state, const char *message)
{
    if (message != NULL)
    {
        pipes_output_write_string(state->line_id, message);
    }

    arcbbs_door_reset_state(state);
    script_notify_door_closed(&state->script);
}

/* ARCbbsDoors SWI wrappers */

static int arcbbs_activate_line(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_ACTIVATE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return (regs.r[0] == 0) ? 0 : -1;
}

static int arcbbs_deactivate_line(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_DEACTIVATE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return (regs.r[0] == 0) ? 0 : -1;
}

static int arcbbs_set_status(int line_id, unsigned char status)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = status;
    if (_kernel_swi(SWI_ARCBBSDOORS_WRITESTATUS, &regs, &regs) != NULL)
    {
        return -1;
    }

    return 0;
}

static int arcbbs_get_status(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_READSTATUS, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

static int arcbbs_write_input(int line_id, unsigned char byte)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = byte;
    if (_kernel_swi(SWI_ARCBBSDOORS_HOSTWRITE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return (regs.r[0] == 0) ? 0 : -1;
}

static int arcbbs_read_output(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_HOSTREAD, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns byte or -1 if empty */
}

static void menu_handle_user_byte(line_task_state *state, unsigned char byte)
{
    /* Check if botstopper is active first */
    if (state->botstopper_state == BOTSTOPPER_STATE_WAITING)
    {
        if (botstopper_handle_byte(state, byte))
        {
            /* Botstopper consumed the byte */
            return;
        }
    }

    if (state->door_active != Desk_bool_FALSE)
    {
        door_send_user_byte(state, byte);
        return;
    }

    if (state->arcbbs_door_active != Desk_bool_FALSE)
    {
        /* Write user input to ARCbbsDoors input buffer */
        arcbbs_write_input(state->line_id, byte);
        return;
    }

    if (state->door_launch_pending != Desk_bool_FALSE)
    {
        return;
    }

    if (state->arcbbs_door_launch_pending != Desk_bool_FALSE)
    {
        return;
    }

    (void)script_handle_user_byte(&state->script, byte);
}

/* ******************************************************************************************************************************************************** */
/* Configuration Helpers                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

/*
 * Check if botstopper is enabled globally (from System config).
 * Returns 1 if enabled, 0 if disabled.
 */
static int config_get_botstopper_enabled(void)
{
    _kernel_swi_regs regs;
    const char *value;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"botstopper";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }

    value = (const char *)regs.r[0];
    if (value == NULL)
    {
        return 0;
    }

    /* Check for "yes", "1", "on", "true" */
    if (value[0] == 'y' || value[0] == 'Y' ||
        value[0] == '1' ||
        value[0] == 'o' || value[0] == 'O' ||
        value[0] == 't' || value[0] == 'T')
    {
        return 1;
    }

    return 0;
}

/*
 * Get the prelogon script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_prelogon_script(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"prelogon";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the postlogon script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_postlogon_script(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"postlogon";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the newuser script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_newuser_script(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"newuser";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the hello message for a specific line.
 * Returns pointer to string or NULL.
 */
static const char *lineconfig_get_hello(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINECONFIG_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINECONFIG_FIELD_HELLO;
    if (_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the botstopper text for a specific line.
 * Returns pointer to string or NULL.
 */
static const char *lineconfig_get_botstopper(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINECONFIG_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINECONFIG_FIELD_BOTSTOPPER;
    if (_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/* ******************************************************************************************************************************************************** */
/* Botstopper Challenge                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/*
 * Start the botstopper challenge.
 * Displays hello message and botstopper text, then waits for user to type ** within timeout.
 */
static void botstopper_start(line_task_state *state)
{
    const char *hello;
    const char *botstopper_text;

    if (state == NULL)
    {
        return;
    }

    /* Get hello message for this line */
    hello = lineconfig_get_hello(state->line_id);
    if (hello != NULL && hello[0] != '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n");
        pipes_output_write_string(state->line_id, hello);
        pipes_output_write_string(state->line_id, "\r\n");
    }

    /* Get botstopper challenge text for this line */
    botstopper_text = lineconfig_get_botstopper(state->line_id);
    if (botstopper_text != NULL && botstopper_text[0] != '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n");
        pipes_output_write_string(state->line_id, botstopper_text);
        pipes_output_write_string(state->line_id, "\r\n\r\n");
    }

    /* Set up challenge state */
    state->botstopper_state = BOTSTOPPER_STATE_WAITING;
    state->botstopper_deadline = time(NULL) + BOTSTOPPER_TIMEOUT_SECS;
    state->botstopper_star_count = 0;

    log_line_event(state->line_id, "Botstopper challenge started");
}

/*
 * Process botstopper timeout.
 * Called from null poll to check if user has timed out.
 */
static void botstopper_process(line_task_state *state)
{
    if (state == NULL || state->botstopper_state != BOTSTOPPER_STATE_WAITING)
    {
        return;
    }

    /* Check for timeout */
    if (time(NULL) >= state->botstopper_deadline)
    {
        pipes_output_write_string(state->line_id, "\r\n[Botstopper timeout - disconnecting]\r\n");
        log_line_event(state->line_id, "Botstopper timeout");
        state->botstopper_state = BOTSTOPPER_STATE_FAILED;
        
        /* Force disconnect */
        script_host_force_disconnect(state);
    }
}

/*
 * Handle user byte during botstopper challenge.
 * Returns 1 if the byte was consumed, 0 otherwise.
 */
static int botstopper_handle_byte(line_task_state *state, unsigned char byte)
{
    if (state == NULL || state->botstopper_state != BOTSTOPPER_STATE_WAITING)
    {
        return 0;
    }

    /* Check if user typed the botstopper character */
    if (byte == BOTSTOPPER_CHAR)
    {
        state->botstopper_star_count++;
        
        /* Echo the character */
        pipes_output_write_block(state->line_id, (const char *)&byte, 1);

        /* Check if we have enough stars */
        if (state->botstopper_star_count >= 2)
        {
            pipes_output_write_string(state->line_id, "\r\n\r\n[Access granted]\r\n\r\n");
            log_line_event(state->line_id, "Botstopper passed");
            state->botstopper_state = BOTSTOPPER_STATE_PASSED;
            
            /* Start the prelogon script */
            script_start_prelogon(state);
        }
    }
    else
    {
        /* Wrong character - reset star count */
        state->botstopper_star_count = 0;
    }

    return 1;  /* Always consume bytes during botstopper */
}

/* ******************************************************************************************************************************************************** */
/* Script Control                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/*
 * Start the prelogon script (after botstopper or if botstopper is disabled).
 */
static void script_start_prelogon(line_task_state *state)
{
    const char *prelogon_path;

    if (state == NULL)
    {
        return;
    }

    /* Get prelogon script path from config */
    prelogon_path = config_get_prelogon_script();
    
    debug_printf("script_start_prelogon: prelogon_path=%s", 
                 prelogon_path ? prelogon_path : "(null)");
    
    if (prelogon_path != NULL && prelogon_path[0] != '\0')
    {
        log_line_event(state->line_id, "Starting prelogon script");
        if (!script_start(&state->script, prelogon_path))
        {
            const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
            char message[192];
            snprintf(message, sizeof(message), "\r\n[Unable to start prelogon script: %s]\r\n", error);
            pipes_output_write_string(state->line_id, message);
            /* Fall back to Start script */
            script_start_session(state);
            return;
        }
        script_process(&state->script);
    }
    else
    {
        /* No prelogon script - fall back to default Start script */
        log_line_event(state->line_id, "No prelogon script, starting default");
        script_start_session(state);
    }
}

/*
 * Start the postlogon script (after successful authentication).
 */
static void script_start_postlogon(line_task_state *state)
{
    const char *postlogon_path;

    if (state == NULL)
    {
        return;
    }

    /* Get postlogon script path from config */
    postlogon_path = config_get_postlogon_script();
    
    debug_printf("script_start_postlogon: postlogon_path=%s", 
                 postlogon_path ? postlogon_path : "(null)");
    
    if (postlogon_path != NULL && postlogon_path[0] != '\0')
    {
        log_line_event(state->line_id, "Starting postlogon script");
        if (!script_start(&state->script, postlogon_path))
        {
            const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
            char message[192];
            snprintf(message, sizeof(message), "\r\n[Unable to start postlogon script: %s]\r\n", error);
            pipes_output_write_string(state->line_id, message);
            /* Fall back to Start script */
            script_start_session(state);
            return;
        }
        script_process(&state->script);
    }
    else
    {
        /* No postlogon script - fall back to default Start script */
        log_line_event(state->line_id, "No postlogon script, starting default");
        script_start_session(state);
    }
}

/*
 * Start the newuser script (for new user registration).
 */
static void script_start_newuser(line_task_state *state)
{
    const char *newuser_path;

    if (state == NULL)
    {
        return;
    }

    /* Get newuser script path from config */
    newuser_path = config_get_newuser_script();
    
    debug_printf("script_start_newuser: newuser_path=%s", 
                 newuser_path ? newuser_path : "(null)");
    
    if (newuser_path != NULL && newuser_path[0] != '\0')
    {
        log_line_event(state->line_id, "Starting newuser script");
        if (!script_start(&state->script, newuser_path))
        {
            const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
            char message[192];
            snprintf(message, sizeof(message), "\r\n[Unable to start newuser script: %s]\r\n", error);
            pipes_output_write_string(state->line_id, message);
            return;
        }
        script_process(&state->script);
    }
    else
    {
        /* No newuser script configured */
        pipes_output_write_string(state->line_id, "\r\n[New user registration is not available]\r\n");
        log_line_event(state->line_id, "No newuser script configured");
    }
}

static void script_start_session(line_task_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (!script_start(&state->script, SCRIPT_ENTRY_PATH))
    {
        const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
        char message[192];
        snprintf(message, sizeof(message), "\r\n[Unable to start script: %s]\r\n", error);
        pipes_output_write_string(state->line_id, message);
        return;
    }

    script_process(&state->script);
}

static void script_stop_session(line_task_state *state)
{
    if (state == NULL)
    {
        return;
    }

    script_stop(&state->script);
}

static void script_print_time(line_task_state *state)
{
    time_t now;
    struct tm *local_tm;
    char formatted[64];
    char message[160];

    if (state == NULL)
    {
        return;
    }

    now = time(NULL);
    local_tm = localtime(&now);
    if (local_tm == NULL || strftime(formatted, sizeof(formatted), "%Y-%m-%d %H:%M:%S", local_tm) == 0)
    {
        pipes_output_write_string(state->line_id, "Unable to read system time.\r\n");
        return;
    }

    snprintf(message, sizeof(message), "Current time: %s\r\n", formatted);
    pipes_output_write_string(state->line_id, message);
}

static void script_print_line_info(line_task_state *state)
{
    char message[192];
    const char *session = (state != NULL && state->session_active != 0) ? "connected" : "idle";
    const char *door_state;

    if (state == NULL)
    {
        return;
    }

    if (state->door_active != Desk_bool_FALSE)
    {
        door_state = "door running";
    }
    else if (state->door_launch_pending != Desk_bool_FALSE)
    {
        door_state = "door starting";
    }
    else
    {
        door_state = "no door";
    }

    snprintf(message,
             sizeof(message),
             "Line %d: %s, %s\r\n",
             state->line_id,
             session,
             door_state);
    pipes_output_write_string(state->line_id, message);
}

static void script_host_write(void *context, const char *text)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL || text == NULL)
    {
        return;
    }

    pipes_output_write_string(state->line_id, text);
}

static void script_host_launch_door(void *context, const char *command_line)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return;
    }

    if (state->session_active == 0)
    {
        pipes_output_write_string(state->line_id, "\r\n[Door unavailable until connected]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_active != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door is already running]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_launch_pending != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door launch is already pending]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (command_line == NULL || *command_line == '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n[Door command missing]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    Desk_Wimp_StartTask(command_line);
    state->door_launch_pending = Desk_bool_TRUE;
    state->door_launch_deadline = clock() + DOOR_LAUNCH_TIMEOUT_TICKS;
    pipes_output_write_string(state->line_id, "\r\n[Launching door]\r\n");
}

static void script_host_launch_arcbbs_door(void *context, int door_number, const char *command_line)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return;
    }

    if (state->session_active == 0)
    {
        pipes_output_write_string(state->line_id, "\r\n[ARCbbs door unavailable until connected]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_active != Desk_bool_FALSE || state->arcbbs_door_active != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door is already running]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_launch_pending != Desk_bool_FALSE || state->arcbbs_door_launch_pending != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door launch is already pending]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (command_line == NULL || *command_line == '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n[ARCbbs door command missing]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    /* Validate door number (1-254) */
    if (door_number < 1 || door_number > 254)
    {
        pipes_output_write_string(state->line_id, "\r\n[Invalid door number]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    /* Activate the line in ARCbbsDoors module */
    if (arcbbs_activate_line(state->line_id) != 0)
    {
        debug_printf("LineTask ARCbbs: activate failed for line %d\n", state->line_id);
        pipes_output_write_string(state->line_id, "\r\n[ARCbbsDoors module not available]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    debug_printf("LineTask ARCbbs: activated line %d\n", state->line_id);

    /* Store the door number we're requesting */
    state->arcbbs_requested_door_number = door_number;

    /* Set status to door number (1-254) - door polls for its number, then writes 255 to accept */
    arcbbs_set_status(state->line_id, (unsigned char)door_number);
    debug_printf("LineTask ARCbbs: set status to %d (door number) BEFORE launch\n", door_number);

    debug_printf("LineTask ARCbbs: launching '%s'\n", command_line);

    /* Launch the door */
    Desk_Wimp_StartTask(command_line);

    /* Mark as active immediately */
    state->arcbbs_door_active = Desk_bool_TRUE;
    state->arcbbs_door_launch_pending = Desk_bool_FALSE;
    state->arcbbs_door_launch_deadline = 0;

    debug_printf("LineTask ARCbbs: door launched, active=TRUE\n");
    pipes_output_write_string(state->line_id, "\r\n[Launching ARCbbs door]\r\n");
}

static void script_host_report_time(void *context)
{
    script_print_time((line_task_state *)context);
}

static void script_host_report_line_info(void *context)
{
    script_print_line_info((line_task_state *)context);
}

static void script_host_request_disconnect(void *context)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return;
    }

    pipes_output_write_string(state->line_id, "\r\n[Please hang up to disconnect]\r\n");
}

static void script_host_force_disconnect(void *context)
{
    line_task_state *state = (line_task_state *)context;
    Desk_message_block message;

    if (state == NULL)
    {
        return;
    }

    if (state->session_active == 0)
    {
        return;
    }

    /* Reset user display in Server status window */
    send_user_message(state->line_id, NULL);

    memset(&message, 0, sizeof(message));
    message.header.size = 32;
    message.header.action = (Desk_message_action)LINE_CONTROL_MESSAGE;
    message.data.words[0] = state->line_id;
    message.data.words[1] = LINE_CONTROL_REASON_LOGOFF;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);

    pipes_output_write_string(state->line_id, "\r\n[Disconnecting...]\r\n");
}

static void script_host_report_activity(void *context, const char *text)
{
    line_task_state *state = (line_task_state *)context;
    Desk_message_block message;
    size_t payload_len;
    size_t padded_len;
    char payload[LINE_ACTIVITY_MAX_TEXT];

    if (state == NULL)
    {
        return;
    }

    if (text == NULL)
    {
        text = "";
    }

    strncpy(payload, text, sizeof(payload) - 1);
    payload[sizeof(payload) - 1] = '\0';
    payload_len = strlen(payload);

    memset(&message, 0, sizeof(message));
    message.header.action = (Desk_message_action)LINE_ACTIVITY_MESSAGE;
    message.data.words[0] = state->line_id;
    memcpy(&message.data.bytes[4], payload, payload_len + 1);

    padded_len = (payload_len + 1 + 3) & ~3U;
    message.header.size = 24 + (int)padded_len;

    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);

    if (payload_len > 0)
    {
        log_line_event(state->line_id, payload);
    }
}

static void script_host_report_online_users(void *context)
{
    line_task_state *state = (line_task_state *)context;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int line;
    char output[256];
    int found_any = 0;

    if (state == NULL)
    {
        return;
    }

    /* Print header */
    pipes_output_write_string(state->line_id, "\r\n");
    pipes_output_write_string(state->line_id, "Line  User                           Online  Activity\r\n");
    pipes_output_write_string(state->line_id, "----  ------------------------------  ------  --------\r\n");

    /* Query each line */
    for (line = 0; line < SUPPORT_MAX_LINES; line++)
    {
        int connected = 0;
        int user_id = 0;
        time_t connect_time = 0;
        const char *activity = "Online";
        int online_mins = 0;
        int online_secs = 0;
        char username[64];

        /* Check if line is connected */
        regs.r[0] = LINE_REASON_GET;
        regs.r[1] = line;
        regs.r[2] = LINE_FIELD_CONNECTED;
        err = _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
        if (err != NULL)
        {
            /* Module not loaded - bail out */
            pipes_output_write_string(state->line_id, "[ConverseBBS module not available]\r\n");
            return;
        }
        connected = regs.r[0];

        if (connected == 0)
        {
            continue;
        }

        found_any = 1;

        /* Get user ID */
        regs.r[0] = LINE_REASON_GET;
        regs.r[1] = line;
        regs.r[2] = LINE_FIELD_USER_ID;
        if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL)
        {
            user_id = regs.r[0];
        }

        /* Look up user from Filer userdb */
        if (user_id > 0)
        {
            _kernel_swi_regs filer_regs;
            filer_regs.r[0] = FILER_USERDB_CMD_SEARCH;
            filer_regs.r[1] = user_id;
            if (_kernel_swi(SWI_CONVERSE_FILER_USERDB, &filer_regs, &filer_regs) == NULL && filer_regs.r[0] != 0)
            {
                /* USER_RECORD returned:
                 * - realname at offset 36 (64 bytes)
                 * - user_flags.sysop at offset 600 (int)
                 */
                char *record_bytes = (char *)filer_regs.r[0];
                char realname[64];
                int is_sysop;

                strncpy(realname, record_bytes + 36, sizeof(realname) - 1);
                realname[sizeof(realname) - 1] = '\0';

                is_sysop = *((int *)(record_bytes + 600));

                if (realname[0] != '\0')
                {
                    if (is_sysop)
                    {
                        snprintf(username, sizeof(username), "%s [SYSOP]", realname);
                    }
                    else
                    {
                        strncpy(username, realname, sizeof(username) - 1);
                        username[sizeof(username) - 1] = '\0';
                    }
                }
                else
                {
                    /* No real name, fall back to username at offset 4 */
                    strncpy(username, record_bytes + 4, sizeof(username) - 1);
                    username[sizeof(username) - 1] = '\0';
                    if (is_sysop)
                    {
                        char temp[64];
                        strncpy(temp, username, sizeof(temp) - 1);
                        temp[sizeof(temp) - 1] = '\0';
                        snprintf(username, sizeof(username), "%s [SYSOP]", temp);
                    }
                }
            }
            else
            {
                snprintf(username, sizeof(username), "User #%d", user_id);
            }
        }
        else
        {
            strcpy(username, "Guest");
        }

        /* Get connect time */
        regs.r[0] = LINE_REASON_GET;
        regs.r[1] = line;
        regs.r[2] = LINE_FIELD_CONNECT_TIME;
        if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL)
        {
            connect_time = (time_t)regs.r[0];
        }

        /* Calculate online duration */
        if (connect_time != 0)
        {
            time_t now = time(NULL);
            int elapsed = (int)(now - connect_time);
            if (elapsed < 0) elapsed = 0;
            online_mins = elapsed / 60;
            online_secs = elapsed % 60;
        }

        /* Get activity */
        regs.r[0] = ACTIVITY_REASON_GET;
        regs.r[1] = line;
        if (_kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs) == NULL && regs.r[0] != 0)
        {
            const char *act_ptr = (const char *)regs.r[0];
            if (act_ptr != NULL && act_ptr[0] != '\0')
            {
                activity = act_ptr;
            }
        }

        /* Format and output the line */
        snprintf(output, sizeof(output), "%-4d  %-30s  %02d:%02d   %s\r\n",
                 line, username, online_mins, online_secs, activity);
        pipes_output_write_string(state->line_id, output);
    }

    if (found_any == 0)
    {
        pipes_output_write_string(state->line_id, "No users currently online.\r\n");
    }

    pipes_output_write_string(state->line_id, "\r\n");
}

static int script_host_get_line_id(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->line_id : -1;
}

static int script_host_get_task_handle(void *context)
{
    Desk_UNUSED(context);
    return Desk_Event_taskhandle;
}

static void *script_host_get_filebase_session(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? &state->fb_session : NULL;
}

static int script_host_get_user_accesslevel(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->user_accesslevel : 0;
}

static const char *script_host_get_user_keys(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->user_keys : "";
}

static int script_host_filebase_download(void *context, int base_id, int file_id)
{
    line_task_state *state = (line_task_state *)context;
    long file_size = 0;
    char msg[128];

    if (state == NULL || base_id <= 0 || file_id <= 0)
    {
        return 0;
    }

    /* Get file size from Filer */
    if (!filebase_get_file_size(base_id, file_id, &file_size))
    {
        return 0;
    }

    /* For now, just report the file is ready for download */
    /* Future: integrate with Xmodem/Ymodem/Zmodem transfer protocols */
    snprintf(msg, sizeof(msg), "\r\n[File ready for download: %ld bytes]\r\n", file_size);
    pipes_output_write_string(state->line_id, msg);

    return 1;
}

/*
 * Authenticate user via Filer module.
 * Returns 1 on success, 0 on failure.
 * auth_result is set to:
 *   0 = success
 *   1 = user not found
 *   2 = bad password
 *   3 = account locked
 */
static int script_host_authenticate_user(void *context, const char *username, const char *password, int *auth_result)
{
    line_task_state *state = (line_task_state *)context;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int result;
    int user_id;
    int access_level;
    const char *keys;
    char log_msg[128];

    if (state == NULL || username == NULL || password == NULL || auth_result == NULL)
    {
        if (auth_result != NULL)
        {
            *auth_result = 1;  /* User not found */
        }
        return 0;
    }

    /* Call Filer SWI 0x5AA41 with reason 4 (authenticate) */
    regs.r[0] = FILER_USERDB_CMD_AUTHENTICATE;
    regs.r[1] = (int)username;
    regs.r[2] = (int)password;
    
    err = _kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs);
    if (err != NULL)
    {
        debug_printf("script_host_authenticate_user: SWI error %s", err->errmess);
        *auth_result = 1;  /* User not found (or module error) */
        return 0;
    }

    /* R0 = auth result, R1 = USER_RECORD pointer (if success) */
    result = regs.r[0];
    *auth_result = result;

    if (result != 0)
    {
        /* Authentication failed */
        snprintf(log_msg, sizeof(log_msg), "Login failed for '%s' (reason %d)", username, result);
        log_line_event(state->line_id, log_msg);
        return 0;
    }

    /* Authentication successful - extract user data from USER_RECORD */
    if (regs.r[1] != 0)
    {
        /* USER_RECORD layout (from structs.h):
         * int id                   offset 0
         * char username[32]        offset 4
         * char realname[64]        offset 36
         * char email[64]           offset 100
         * char password[32]        offset 164
         * char keys[128]           offset 196
         * char userdir[256]        offset 324
         * USER_FLAGS               offset 580
         *   - accesslevel is 15 ints (60 bytes) into USER_FLAGS = offset 640
         */
        #define USER_RECORD_OFFSET_ID          0
        #define USER_RECORD_OFFSET_REALNAME    36
        #define USER_RECORD_OFFSET_KEYS        196
        #define USER_RECORD_OFFSET_ACCESSLEVEL 640
        
        char *record_bytes = (char *)regs.r[1];
        const char *realname;
        
        user_id = *((int *)(record_bytes + USER_RECORD_OFFSET_ID));
        realname = record_bytes + USER_RECORD_OFFSET_REALNAME;
        keys = record_bytes + USER_RECORD_OFFSET_KEYS;
        access_level = *((int *)(record_bytes + USER_RECORD_OFFSET_ACCESSLEVEL));
        
        /* Update line state with user ID */
        {
            _kernel_swi_regs line_regs;
            line_regs.r[0] = LINE_REASON_SET;
            line_regs.r[1] = state->line_id;
            line_regs.r[2] = LINE_FIELD_USER_ID;
            line_regs.r[3] = user_id;
            _kernel_swi(SWI_CONVERSEBBS_LINE, &line_regs, &line_regs);
        }
        
        /* Store user info in task state */
        state->user_id = user_id;
        state->user_accesslevel = access_level;
        strncpy(state->user_keys, keys, sizeof(state->user_keys) - 1);
        state->user_keys[sizeof(state->user_keys) - 1] = '\0';
        
        /* Send user name to Server to update status window */
        send_user_message(state->line_id, realname);
        
        snprintf(log_msg, sizeof(log_msg), "User '%s' logged in (id=%d, level=%d)", username, user_id, access_level);
        log_line_event(state->line_id, log_msg);
        
        debug_printf("script_host_authenticate_user: success user_id=%d access=%d", user_id, access_level);
    }

    return 1;
}

static void script_host_start_postlogon(void *context)
{
    line_task_state *state = (line_task_state *)context;
    
    if (state == NULL)
    {
        return;
    }
    
    script_start_postlogon(state);
}

static void script_host_start_newuser(void *context)
{
    line_task_state *state = (line_task_state *)context;
    
    if (state == NULL)
    {
        return;
    }
    
    script_start_newuser(state);
}

static void log_line_event(int line_id, const char *message)
{
    _kernel_swi_regs regs;

    if (line_id < 0 || message == NULL || *message == '\0')
    {
        return;
    }

    memset(&regs, 0, sizeof(regs));
    regs.r[0] = FILER_LOG_REASON_LINE;
    regs.r[1] = line_id;
    regs.r[2] = (int)message;
    _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
}
