/* LineTask Wimp helper that proxies Pipes traffic on a specific line. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>
#include <kernel.h>
#include <swis.h>

#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.Handler.h"
#include "C:Desk.Icon.h"
#include "C:Desk.GFX.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Screen.h"
#include "C:Desk.Template.h"
#include "C:Desk.Window.h"
#include "C:Desk.Wimp.h"
#include "C:Desk.WimpSWIs.h"
#include "script.h"
#include "filebase.h"
#include "messagebase.h"
#include "transfer.h"
#include "debug.h"
#include "iconnames.h"
#include "main.h"
#include "ansi.h"
#include "ansiterm.h"

#define PIPES_SWI_BASE 0x5AA00

#define SWI_CONVERSE_PIPES_INPUT_READ   (PIPES_SWI_BASE + 3)
#define SWI_CONVERSE_PIPES_OUTPUT_WRITE (PIPES_SWI_BASE + 5)
#define SWI_CONVERSE_PIPES_INPUT_WRITE  (PIPES_SWI_BASE + 8)
#define SWI_OS_BYTE                     0x00000006
#define SWI_Wimp_SetCaretPosition       0x400D2

#define PIPE_TRANSFER_CHUNK 256
#define PIPE_CONTROL_TOKEN      ((unsigned char)0x00)
#define PIPE_CONTROL_CONNECT    'C'
#define PIPE_CONTROL_DISCONNECT 'D'

#define RISC_BBS_MESSAGE_START   0x00C0900
#define RISC_BBS_MESSAGE_END     0x00C0901
#define RISC_BBS_MESSAGE_OUTPUT  0x00C0902
#define RISC_BBS_MESSAGE_ACK     0x00C0903
#define RISC_BBS_MESSAGE_INPUT   0x00C0904
#define LINE_MESSAGE_BASE        0x5AA00
#define LINE_SHUTDOWN_MESSAGE    (LINE_MESSAGE_BASE + 0)
#define LINE_ACTIVITY_MESSAGE    (LINE_MESSAGE_BASE + 1)
#define LINE_CONTROL_MESSAGE     (LINE_MESSAGE_BASE + 2)
#define LINE_TASK_OPEN_WINDOW_MESSAGE (LINE_MESSAGE_BASE + 3)
#define LINE_TASK_REGISTER_MESSAGE (LINE_MESSAGE_BASE + 4)
#define LINE_USER_MESSAGE        (LINE_MESSAGE_BASE + 5)
#define LINE_CONTROL_REASON_LOGOFF 1

#define LINE_ACTIVITY_MAX_TEXT   96

#define CONVERSE_FILER_BASE          0x5AA40
#define FILER_SWI_LOGGING            0
#define FILER_SWI_USERDB             1
#define FILER_LOG_REASON_LINE        1
#define FILER_LOG_REASON_CALL        2
#define FILER_USERDB_CMD_SEARCH      3
#define FILER_USERDB_CMD_AUTHENTICATE 4
#define SWI_CONVERSE_FILER_LOGGING   (CONVERSE_FILER_BASE + FILER_SWI_LOGGING)
#define SWI_CONVERSE_FILER_USERDB    (CONVERSE_FILER_BASE + FILER_SWI_USERDB)

/* Call status values for FILER_LOG_REASON_CALL */
#define CALL_STATUS_ANSWERED         0
#define CALL_STATUS_HUNGUP           1
#define CALL_STATUS_ABORTED          2
#define CALL_STATUS_REJECTED         3

/* ConverseBBS Support module SWIs */
#define SWI_CONVERSEBBS_CONFIG       0x5AA80
#define SWI_CONVERSEBBS_LINE         0x5AA81
#define SWI_CONVERSEBBS_ACTIVITY     0x5AA82

/* ARCbbsDoors emulator SWIs - matches original API */
#define ARCBBS_SWI_BASE              0x41040
#define SWI_ARCBBSDOORS_READSTATUS   (ARCBBS_SWI_BASE + 0)   /* ReadStatus */
#define SWI_ARCBBSDOORS_WRITESTATUS  (ARCBBS_SWI_BASE + 1)   /* WriteStatus */
/* SWIs 2-5 are SendRequest, GetReply, Reserved, Reserved */
/* SWIs 6-11 are InputStatus, InputRead, OutputStatus, OutputWrite, ClearInput, ClearOutput */
#define SWI_ARCBBSDOORS_HOSTWRITE    (ARCBBS_SWI_BASE + 12)  /* Extended: Host writes to door input */
#define SWI_ARCBBSDOORS_HOSTREAD     (ARCBBS_SWI_BASE + 13)  /* Extended: Host reads from door output */
#define SWI_ARCBBSDOORS_ACTIVATE     (ARCBBS_SWI_BASE + 14)  /* Extended: Activate line */
#define SWI_ARCBBSDOORS_DEACTIVATE   (ARCBBS_SWI_BASE + 15)  /* Extended: Deactivate line */

/* ARCbbsDoors status byte values */
#define ARCBBS_STATUS_IDLE           0
#define ARCBBS_STATUS_ACTIVE         255

/* Door request code - any value 1-254 can be used to indicate a door launch request */
#define ARCBBS_STATUS_REQUEST        1

/* Line state reason codes and field indices */
#define LINE_REASON_SET              0
#define LINE_REASON_GET              1
#define LINE_FIELD_CONFIGURED        0
#define LINE_FIELD_CONNECTED         1
#define LINE_FIELD_USER_ID           2
#define LINE_FIELD_CONNECT_TIME      3
#define LINE_FIELD_HOSTNAME          4

/* Activity reason codes */
#define ACTIVITY_REASON_GET          1

/* Max lines to query */
#define SUPPORT_MAX_LINES            32

#if CLOCKS_PER_SEC < 4
#define DOOR_ACK_INTERVAL_TICKS 1
#else
#define DOOR_ACK_INTERVAL_TICKS (CLOCKS_PER_SEC / 4)
#endif

#define DOOR_LAUNCH_TIMEOUT_TICKS (5 * CLOCKS_PER_SEC)
#define BOTSTOPPER_TIMEOUT_SECS    30
#define BOTSTOPPER_CHAR            '*'
#define SCRIPT_ENTRY_PATH "<Converse$Dir>.BBS.Start"

#define SWI_OS_READMONOTONICTIME 0x00000042
#define POLL_IDLE_DELAY 1  /* centiseconds between null polls (10ms) */

/* ConverseBBS Support module - LineConfig SWI */
#define SWI_CONVERSEBBS_LINECONFIG   0x5AA83

/* LineConfig reason codes and fields */
#define LINECONFIG_REASON_GET        1
#define LINECONFIG_FIELD_ENABLED     0
#define LINECONFIG_FIELD_BOTSTOPPER  1
#define LINECONFIG_FIELD_HELLO       2

/* Botstopper states */
typedef enum
{
    BOTSTOPPER_STATE_INACTIVE = 0,  /* Not in botstopper mode */
    BOTSTOPPER_STATE_WAITING,       /* Waiting for user to type ** */
    BOTSTOPPER_STATE_PASSED,        /* User passed the challenge */
    BOTSTOPPER_STATE_FAILED         /* User timed out or failed */
} BOTSTOPPER_STATE;

#define CHAT_PAGER_TIMEOUT_SECS  30
#define CHAT_BEEP_INTERVAL_CS    50    /* Centiseconds between beeps */
#define CHAT_SPLIT_ROW           12    /* Row where screen splits (1-based) */
#define CHAT_SYSOP_START_ROW     2     /* Sysop text starts at row 2 */
#define CHAT_USER_START_ROW      14    /* User text starts at row 14 */
#define CHAT_MAX_COLS            80
#define CHAT_TEXT_COLUMN         8     /* Column where chat text begins */
#define CHAT_HEADER_ROW          1
#define CHAT_HEADER_MARGIN_COL   1
#define CHAT_HEADER_TIMER_INIT   "00:00:00"
#define CHAT_PANE_X_OFFSET        6    /* Pixel tweak so panes stay inside parent border */
#define CHAT_PANE_Y_OFFSET       -2

#define CHAT_PANE_MAX_LINES          512
#define CHAT_PANE_LINE_CHARS         256
#define CHAT_PANE_MIN_COLUMNS        40
#define CHAT_PANE_CHAR_WIDTH_SHIFT   4
#define CHAT_PANE_CHAR_HEIGHT_SHIFT  5
#define CHAT_PANE_CHAR_WIDTH         (1 << CHAT_PANE_CHAR_WIDTH_SHIFT)
#define CHAT_PANE_CHAR_HEIGHT        (1 << CHAT_PANE_CHAR_HEIGHT_SHIFT)

typedef struct chat_pane_view
{
    Desk_window_handle window;
    char lines[CHAT_PANE_MAX_LINES][CHAT_PANE_LINE_CHARS];
    uint16_t line_lengths[CHAT_PANE_MAX_LINES];
    int start_index;
    int line_count;
    int longest_length;
    Desk_bool longest_valid;
    Desk_bool follow_tail;
    int extent_min_x;
    int extent_min_y;
    int extent_max_x;
    int extent_max_y;
} chat_pane_view;

typedef struct
{
    int line_id;
    char line_label[8];
    int session_active;
    int local_mode;
    char local_input_buffer[256];
    int local_input_head;
    int local_input_tail;
    int control_stage;
    unsigned char control_code;
    Desk_bool quit_requested;
    Desk_bool door_launch_pending;
    Desk_bool door_active;
    int door_task_handle;
    char *door_output_buffer;
    clock_t door_next_ack_tick;
    clock_t door_launch_deadline;
    /* ARCbbs door state */
    Desk_bool arcbbs_door_active;
    Desk_bool arcbbs_door_launch_pending;
    clock_t arcbbs_door_launch_deadline;
    clock_t arcbbs_poll_tick;
    int arcbbs_requested_door_number;
    /* Botstopper state */
    BOTSTOPPER_STATE botstopper_state;
    time_t botstopper_deadline;
    int botstopper_star_count;
    /* Script engine */
    script_state script;
    /* Filebase session */
    filebase_session fb_session;
    /* Messagebase session */
    messagebase_session mb_session;
    /* File transfer session */
    transfer_session xfer_session;
    /* User session state */
    int user_id;
    int user_accesslevel;
    int user_sysop;
    char user_keys[128];
    char user_realname[64];
    /* User stats (from USER_STATS in USER_RECORD) */
    script_user_stats user_stats;
    /* User flags (from USER_FLAGS in USER_RECORD) */
    script_user_flags user_flags;
    /* Sysop chat state */
    Desk_bool chat_paging;              /* Pager window is open */
    Desk_bool chat_active;              /* Chat session is active */
    clock_t chat_pager_deadline;        /* 30 second timeout */
    clock_t chat_next_beep;             /* Next beep time */
    char chat_reason[256];              /* User's reason for paging */
    char chat_user_buffer[1024];        /* What user is typing */
    char chat_sysop_buffer[1024];       /* What sysop is typing */
    int chat_user_len;
    int chat_sysop_len;
    int chat_user_row;                  /* Current row in user's ANSI area */
    int chat_sysop_row;                 /* Current row in sysop's ANSI area */
    clock_t chat_timer_start;           /* Monotonic timestamp when chat began */
    int chat_timer_last_seconds;        /* Last HH:MM:SS value pushed to icon */
    chat_pane_view chat_user_pane;
    chat_pane_view chat_sysop_pane;
    /* ANSI terminal emulator for snoop/login (dynamically allocated) */
    ansiterm_state *terminal;
} line_task_state;

static line_task_state task_state;
static Desk_window_handle main_window_handle;
static Desk_window_handle chatpager_window_handle;
static Desk_window_handle chat_window_handle;
static Desk_window_handle userchat_window_handle;
static Desk_window_handle sysopchat_window_handle;

static char app_compiled[]=__DATE__" at "__TIME__;

static int pipes_input_read_byte(int line_id);
static int pipes_input_read_block(int line_id, char *buffer, int length);
static int pipes_input_write_block(int line_id, const char *buffer, int length);
static int pipes_output_write_block(int line_id, const char *buffer, int length);
static void pipes_output_write_string(int line_id, const char *string);
static void pipes_send_welcome(line_task_state *state);
static void handle_server_stream(line_task_state *state, const char *buffer, int length);
static Desk_bool handle_null_poll(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_message_event(Desk_event_pollblock *event, void *ref);
static void process_server_stream(line_task_state *state);
static void initialise_task_state(line_task_state *state, int argc, char **argv);
static void initialise_resources(void);
static void shutdown_resources(void);
static void show_main_window(void);
static void notify_server_ready(const line_task_state *state);
static void update_main_window_title(line_task_state *state);
static void wait_for_pipe_space(void);
static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_open_event(Desk_event_pollblock *event, void *ref);
static void menu_handle_user_byte(line_task_state *state, unsigned char byte);
static void botstopper_start(line_task_state *state);
static void botstopper_process(line_task_state *state);
static int botstopper_handle_byte(line_task_state *state, unsigned char byte);
static int config_get_botstopper_enabled(void);
static const char *config_get_prelogon_script(void);
static const char *config_get_postlogon_script(void);
static const char *config_get_anykey_file(void);
static const char *config_get_newuser_script(void);
static const char *config_get_sysop_name(void);
static const char *lineconfig_get_hello(int line_id);
static const char *lineconfig_get_botstopper(int line_id);
static void script_start_session(line_task_state *state);
static void script_start_prelogon(line_task_state *state);
static void script_start_postlogon(line_task_state *state);
static void script_start_newuser(line_task_state *state);
static void script_stop_session(line_task_state *state);
static void script_print_time(line_task_state *state);
static void script_print_line_info(line_task_state *state);
static void door_reset_state(line_task_state *state);
static void door_process(line_task_state *state);
static void door_send_acknowledgement(line_task_state *state);
static void door_queue_output(line_task_state *state, const char *text, size_t length);
static void door_flush_output(line_task_state *state);
static void door_close_session(line_task_state *state, const char *message);
static void arcbbs_door_reset_state(line_task_state *state);
static void arcbbs_door_process(line_task_state *state);
static void arcbbs_door_close_session(line_task_state *state, const char *message);
static int arcbbs_activate_line(int line_id);
static int arcbbs_deactivate_line(int line_id);
static int arcbbs_set_status(int line_id, unsigned char status);
static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_terminal_click(Desk_event_pollblock *event, void *ref);
static int arcbbs_get_status(int line_id);
static int arcbbs_write_input(int line_id, unsigned char byte);
static int arcbbs_read_output(int line_id);
static void script_host_write(void *context, const char *text);
static void script_host_launch_door(void *context, const char *command_line);
static void script_host_launch_arcbbs_door(void *context, int door_number, const char *command_line);
static void script_host_report_time(void *context);
static void script_host_report_line_info(void *context);
static void script_host_request_disconnect(void *context);
static void script_host_force_disconnect(void *context);
static void script_host_report_activity(void *context, const char *text);
static void script_host_report_online_users(void *context);
static int script_host_get_line_id(void *context);
static int script_host_get_task_handle(void *context);
static void *script_host_get_filebase_session(void *context);
static void *script_host_get_messagebase_session(void *context);
static int script_host_get_user_accesslevel(void *context);
static int script_host_get_user_sysop(void *context);
static const char *script_host_get_user_keys(void *context);
static int script_host_filebase_download(void *context, int base_id, int file_id);
static int script_host_authenticate_user(void *context, const char *username, const char *password, int *auth_result);
static void script_host_start_postlogon(void *context);
static void script_host_start_newuser(void *context);
static const char *script_host_get_anykey_file(void *context);
static int script_host_start_transfer(void *context, int base_id, int file_id, int protocol);
static int script_host_start_receive_transfer(void *context, const char *temp_path, int protocol);
static int script_host_get_user_id(void *context);
static const script_user_stats *script_host_get_user_stats(void *context);
static const script_user_flags *script_host_get_user_flags(void *context);
static void script_host_start_chat_pager(void *context, const char *reason);
static void log_line_event(int line_id, const char *message);
static void send_user_message(int line_id, const char *real_name);
static void perform_session_disconnect(line_task_state *state);
static void send_user_message(int line_id, const char *real_name);
static void poll_idle(void);
/* Sysop chat functions */
static void chat_reset_state(line_task_state *state);
static void chat_start_pager(line_task_state *state, const char *reason);
static void chat_close_pager(line_task_state *state, int accepted);
static void chat_start_session(line_task_state *state);
static void chat_end_session(line_task_state *state);
static void chat_process(line_task_state *state);
static void chat_handle_user_byte(line_task_state *state, unsigned char byte);
static void chat_send_sysop_char(line_task_state *state, char ch);
static void chat_send_sysop_line(line_task_state *state, const char *text);
static void chat_show_panes(line_task_state *state);
static void chat_hide_panes(void);
static void chat_update_panes(line_task_state *state);
static void chat_setup_split_screen(line_task_state *state);
static void chat_beep(void);
static void chat_draw_header(line_task_state *state, const char *timer_text);
static void chat_update_user_timer(line_task_state *state, const char *time_text);
static Desk_bool handle_chatpager_click(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_chat_click(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_chat_key(Desk_event_pollblock *event, void *ref);
static void chatpane_init(chat_pane_view *pane);
static void chatpane_set_window(chat_pane_view *pane, Desk_window_handle window);
static void chatpane_clear(chat_pane_view *pane);
static void chatpane_append_char(chat_pane_view *pane, char ch);
static void chatpane_backspace(chat_pane_view *pane);
static void chatpane_newline(chat_pane_view *pane);
static void chatpane_force_redraw(chat_pane_view *pane);
static void chatpane_update_extent(chat_pane_view *pane);
static void chatpane_scroll_to_bottom(chat_pane_view *pane);
static Desk_bool chatpane_handle_redraw(Desk_event_pollblock *event, void *ref);
static Desk_bool chatpane_handle_scroll(Desk_event_pollblock *event, void *ref);
/* ANSI terminal functions */
static void terminal_init(line_task_state *state);
static void terminal_finalise(line_task_state *state);
static void terminal_feed_output(line_task_state *state, const char *data, int len);
static void terminal_send_input(int line_id, const char *data, int len);
static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref);

static void poll_idle(void)
{
    _kernel_swi_regs regs;
    Desk_event_pollblock event;
    int earliest;

    /* Get current monotonic time and add delay */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    earliest = regs.r[0] + POLL_IDLE_DELAY;

    /* Poll with idle time - won't return null events until 'earliest' */
    Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
    Desk_Event_Process(&event);
}

/* Send user name message to Server to update the status window user column.
 * Pass NULL or empty string to reset to waiting state.
 */
static void send_user_message(int line_id, const char *real_name)
{
    Desk_message_block message;
    
    memset(&message, 0, sizeof(message));
    message.header.size = sizeof(Desk_message_header) + 4 + 100;  /* word for line_id + name buffer */
    message.header.action = (Desk_message_action)LINE_USER_MESSAGE;
    message.data.words[0] = line_id;
    
    if (real_name != NULL && real_name[0] != '\0')
    {
        strncpy((char *)&message.data.bytes[4], real_name, 96);
        message.data.bytes[99] = '\0';
    }
    else
    {
        message.data.bytes[4] = '\0';  /* Empty string to reset */
    }
    
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

int main(int argc, char **argv)
{
    initialise_task_state(&task_state, argc, argv);

    {
        char task_name[32];
        snprintf(task_name, sizeof(task_name), "Converse Line [%d]", task_state.line_id);
        Desk_Event_Initialise(task_name);
    }
    Desk_EventMsg_Initialise();
    Desk_Screen_CacheModeInfo();
    Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY, Desk_Handler_NullRedraw, NULL);
    Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY, handle_open_event, NULL);
    Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY, handle_window_close, NULL);
    Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY, handle_null_poll, &task_state);
    Desk_Event_Claim(Desk_event_USERMESSAGE, Desk_event_ANY, Desk_event_ANY, handle_message_event, &task_state);
    Desk_Event_Claim(Desk_event_USERMESSAGERECORDED, Desk_event_ANY, Desk_event_ANY, handle_message_event, &task_state);

    initialise_resources();
    
    /* Register terminal handlers */
    if (main_window_handle != 0)
    {
        Desk_Event_Claim(Desk_event_REDRAW, main_window_handle, Desk_event_ANY, handle_terminal_redraw, &task_state);
        Desk_Event_Claim(Desk_event_KEY, main_window_handle, Desk_event_ANY, handle_terminal_key, &task_state);
        Desk_Event_Claim(Desk_event_CLICK, main_window_handle, Desk_event_ANY, handle_terminal_click, &task_state);
    }
    
    /* Register click handlers for chat windows */
    Desk_Event_Claim(Desk_event_CLICK, chatpager_window_handle, Desk_event_ANY, handle_chatpager_click, &task_state);
    Desk_Event_Claim(Desk_event_CLICK, chat_window_handle, Desk_event_ANY, handle_chat_click, &task_state);
    Desk_Event_Claim(Desk_event_KEY, chat_window_handle, Desk_event_ANY, handle_chat_key, &task_state);
    
    notify_server_ready(&task_state);

    while (task_state.quit_requested == Desk_bool_FALSE)
    {
        poll_idle();
    }

    log_line_event(task_state.line_id, "LineTask shutting down");

    script_dispose(&task_state.script);
    shutdown_resources();
    Desk_Event_CloseDown();
    return 0;
}

static void initialise_task_state(line_task_state *state, int argc, char **argv)
{
    int line_id = 0;
    const char *line_arg = "0";

    if (argc > 1 && argv[1] != NULL)
    {
        line_arg = argv[1];
        line_id = atoi(argv[1]);
    }

    if (line_id < 0)
    {
        line_id = 0;
    }
    if (line_id > 31)
    {
        line_id = 31;
    }

    state->line_id = line_id;
    strncpy(state->line_label, line_arg, sizeof(state->line_label) - 1);
    state->line_label[sizeof(state->line_label) - 1] = '\0';
    state->session_active = 0;
    state->local_mode = 0;
    state->local_input_head = 0;
    state->local_input_tail = 0;
    state->control_stage = 0;
    state->control_code = 0;
    state->quit_requested = Desk_bool_FALSE;
    state->botstopper_state = BOTSTOPPER_STATE_INACTIVE;
    state->botstopper_deadline = 0;
    state->botstopper_star_count = 0;
    door_reset_state(state);
    arcbbs_door_reset_state(state);
    chatpane_init(&state->chat_user_pane);
    chatpane_init(&state->chat_sysop_pane);

    {
        script_host host;
        memset(&host, 0, sizeof(host));
        host.context = state;
        host.write_text = script_host_write;
        host.launch_door = script_host_launch_door;
        host.launch_arcbbs_door = script_host_launch_arcbbs_door;
        host.report_time = script_host_report_time;
        host.report_line_info = script_host_report_line_info;
        host.request_disconnect = script_host_request_disconnect;
        host.force_disconnect = script_host_force_disconnect;
        host.report_activity = script_host_report_activity;
        host.report_online_users = script_host_report_online_users;
        host.get_line_id = script_host_get_line_id;
        host.get_task_handle = script_host_get_task_handle;
        host.get_filebase_session = script_host_get_filebase_session;
        host.get_messagebase_session = script_host_get_messagebase_session;
        host.get_user_accesslevel = script_host_get_user_accesslevel;
        host.get_user_sysop = script_host_get_user_sysop;
        host.get_user_keys = script_host_get_user_keys;
        host.filebase_download = script_host_filebase_download;
        host.authenticate_user = script_host_authenticate_user;
        host.start_postlogon = script_host_start_postlogon;
        host.start_newuser = script_host_start_newuser;
        host.get_anykey_file = script_host_get_anykey_file;
        host.start_transfer = script_host_start_transfer;
        host.start_receive_transfer = script_host_start_receive_transfer;
        host.get_user_id = script_host_get_user_id;
        host.get_user_stats = script_host_get_user_stats;
        host.get_user_flags = script_host_get_user_flags;
        host.start_chat_pager = script_host_start_chat_pager;
        script_initialise(&state->script, &host);
    }

    /* Initialise filebase session */
    filebase_session_init(&state->fb_session);
    
    /* Initialise messagebase session */
    messagebase_session_init(&state->mb_session);
    
    /* Initialise transfer session */
    memset(&state->xfer_session, 0, sizeof(state->xfer_session));
    
    /* Initialise chat state */
    chat_reset_state(state);
    
    /* Initialise ANSI terminal (pointer starts as NULL) */
    state->terminal = NULL;
    terminal_init(state);
    
    state->user_id = 0;
    state->user_accesslevel = 0;
    state->user_sysop = 0;
    state->user_keys[0] = '\0';
    state->user_realname[0] = '\0';
    memset(&state->user_stats, 0, sizeof(state->user_stats));
    memset(&state->user_flags, 0, sizeof(state->user_flags));
}

static void initialise_resources(void)
{
    Desk_Resource_Initialise("ConverseRes");
    Desk_Msgs_LoadFile("Messages");
    Desk_Template_Initialise();
    Desk_Template_UseOutlineFonts();
    Desk_Template_LoadFile("Templates");
    main_window_handle = Desk_Window_Create("main", NULL);
    chatpager_window_handle = Desk_Window_Create("chatpager", NULL);
    chat_window_handle = Desk_Window_Create("chat", NULL);
    userchat_window_handle = Desk_Window_Create("userchat", NULL);
    sysopchat_window_handle = Desk_Window_Create("sysopchat", NULL);

    if (main_window_handle != 0)
    {
        Desk_Window_SetExtent(main_window_handle,
                              0,
                              -ANSITERM_HEIGHT,
                              ANSITERM_WIDTH,
                              0);
    }

    chatpane_set_window(&task_state.chat_user_pane, userchat_window_handle);
    chatpane_set_window(&task_state.chat_sysop_pane, sysopchat_window_handle);

    if (userchat_window_handle != 0)
    {
        Desk_Event_Claim(Desk_event_REDRAW, userchat_window_handle, Desk_event_ANY,
                         chatpane_handle_redraw, &task_state.chat_user_pane);
        Desk_Event_Claim(Desk_event_SCROLL, userchat_window_handle, Desk_event_ANY,
                         chatpane_handle_scroll, &task_state.chat_user_pane);
    }

    if (sysopchat_window_handle != 0)
    {
        Desk_Event_Claim(Desk_event_REDRAW, sysopchat_window_handle, Desk_event_ANY,
                         chatpane_handle_redraw, &task_state.chat_sysop_pane);
        Desk_Event_Claim(Desk_event_SCROLL, sysopchat_window_handle, Desk_event_ANY,
                         chatpane_handle_scroll, &task_state.chat_sysop_pane);
    }

    /* Main window IS the terminal - register terminal handlers for it */
    if (main_window_handle != 0 && task_state.terminal != NULL)
    {
        task_state.terminal->window = main_window_handle;
    }

    update_main_window_title(&task_state);
}

static void shutdown_resources(void)
{
    terminal_finalise(&task_state);
    Desk_Template_ClearAll();
    main_window_handle = 0;
    chatpager_window_handle = 0;
    chat_window_handle = 0;
    userchat_window_handle = 0;
    sysopchat_window_handle = 0;
}

static void show_main_window(void)
{
    if (main_window_handle != 0)
    {
        Desk_Window_Show(main_window_handle, Desk_open_CENTERED);

        /* Set input focus to the window */
        {
            _kernel_swi_regs regs;
            regs.r[0] = main_window_handle;
            regs.r[1] = -1; /* Icon handle (-1 for window) */
            regs.r[2] = 0;  /* X offset */
            regs.r[3] = 0;  /* Y offset */
            regs.r[4] = -1; /* Height (-1 for default) */
            regs.r[5] = 0;  /* Index */
            _kernel_swi(SWI_Wimp_SetCaretPosition, &regs, &regs);
        }

        /* Enable terminal snoop and input modes when window is shown */
        if (task_state.terminal != NULL)
        {
            ansiterm_set_snoop(task_state.terminal, 1);
            ansiterm_set_input(task_state.terminal, 1);
            
            /* Display status message in terminal */
            if (task_state.session_active)
            {
                ansiterm_process_block(task_state.terminal, 
                    (const unsigned char *)"\033[1;32m[Snoop Mode Active]\033[0m\r\n", 32);
            }
            else
            {
                ansiterm_process_block(task_state.terminal,
                    (const unsigned char *)"\033[1;33m[Sysop Login Mode - Starting Session]\033[0m\r\n", 52);
                
                /* Start local session if not already running */
                if (script_get_status(&task_state.script) == SCRIPT_STATUS_IDLE)
                {
                    _kernel_swi_regs regs;
                    
                    task_state.local_mode = 1;
                    task_state.session_active = 1;
                    
                    /* Update Support module state */
                    regs.r[0] = LINE_REASON_SET;
                    regs.r[1] = task_state.line_id;
                    regs.r[2] = LINE_FIELD_CONNECTED;
                    regs.r[3] = 1;
                    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
                    
                    regs.r[0] = LINE_REASON_SET;
                    regs.r[1] = task_state.line_id;
                    regs.r[2] = LINE_FIELD_HOSTNAME;
                    regs.r[3] = (int)"Local";
                    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
                    
                    regs.r[0] = LINE_REASON_SET;
                    regs.r[1] = task_state.line_id;
                    regs.r[2] = LINE_FIELD_CONNECT_TIME;
                    regs.r[3] = (int)time(NULL);
                    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
                    
                    pipes_send_welcome(&task_state);
                    script_start_prelogon(&task_state);
                }
            }
            ansiterm_invalidate(task_state.terminal);
        }
    }
}

static void perform_session_disconnect(line_task_state *state)
{
    if (state->session_active != 0)
    {
        if (state->local_mode)
        {
             pipes_output_write_string(state->line_id, "\r\n[Local session ended]\r\n");
        }
        else
        {
             pipes_output_write_string(state->line_id, "\r\n[LINETASK CLOSED]\r\n");
        }
    }
    
    state->session_active = 0;
    state->botstopper_state = BOTSTOPPER_STATE_INACTIVE;
    
    if (state->door_active != Desk_bool_FALSE || state->door_launch_pending != Desk_bool_FALSE)
    {
        door_close_session(state, "\r\n[Door session ended]\r\n");
    }
    if (state->arcbbs_door_active != Desk_bool_FALSE || state->arcbbs_door_launch_pending != Desk_bool_FALSE)
    {
        arcbbs_door_close_session(state, "\r\n[ARCbbs door session ended]\r\n");
    }
    
    /* Reset filebase and messagebase session and user state on disconnect */
    filebase_session_reset(&state->fb_session);
    messagebase_session_reset(&state->mb_session);
    
    state->user_id = 0;
    state->user_accesslevel = 0;
    state->user_sysop = 0;
    state->user_keys[0] = '\0';
    state->user_realname[0] = '\0';
    memset(&state->user_stats, 0, sizeof(state->user_stats));
    memset(&state->user_flags, 0, sizeof(state->user_flags));
    
    /* Reset user display in Server status window */
    send_user_message(state->line_id, NULL);
    
    log_line_event(state->line_id, "Session disconnected");
    script_stop_session(state);
}

static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref)
{
    Desk_UNUSED(ref);

    if (event != NULL)
    {
        if (event->data.openblock.window == main_window_handle)
        {
            /* Disable terminal modes when main window is closed */
            if (task_state.terminal != NULL)
            {
                ansiterm_set_snoop(task_state.terminal, 0);
                ansiterm_set_input(task_state.terminal, 0);
            }

            /* If running a local sysop session, stop it */
            if (task_state.local_mode)
            {
                _kernel_swi_regs regs;
                
                perform_session_disconnect(&task_state);
                task_state.local_mode = 0;
                
                /* Reset Support module state */
                regs.r[0] = LINE_REASON_SET;
                regs.r[1] = task_state.line_id;
                regs.r[2] = LINE_FIELD_CONNECTED;
                regs.r[3] = 0;
                _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
                
                regs.r[0] = LINE_REASON_SET;
                regs.r[1] = task_state.line_id;
                regs.r[2] = LINE_FIELD_USER_ID;
                regs.r[3] = 0;
                _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

                /* Reset Hostname */
                regs.r[0] = LINE_REASON_SET;
                regs.r[1] = task_state.line_id;
                regs.r[2] = LINE_FIELD_HOSTNAME;
                regs.r[3] = (int)"";
                _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

                /* Reset Activity text */
                regs.r[0] = 0; /* ACTIVITY_REASON_SET */
                regs.r[1] = task_state.line_id;
                regs.r[2] = (int)"";
                _kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs);

                /* Also send Wimp message to Server to update UI immediately */
                script_host_report_activity(&task_state, "");
            }
        }
        Desk_Window_Hide(event->data.openblock.window);
    }

    return Desk_bool_TRUE;
}

static Desk_bool handle_open_event(Desk_event_pollblock *event, void *ref)
{
    Desk_Handler_OpenWindow(event, ref);

    if (event != NULL && event->data.openblock.window == chat_window_handle)
    {
        chat_update_panes(&task_state);
    }

    return Desk_bool_TRUE;
}

static void notify_server_ready(const line_task_state *state)
{
    Desk_message_block message;

    if (state == NULL)
    {
        return;
    }

    memset(&message, 0, sizeof(message));
    message.header.size = 24;
    message.header.action = (Desk_message_action)LINE_TASK_REGISTER_MESSAGE;
    message.data.words[0] = state->line_id;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

static void update_main_window_title(line_task_state *state)
{
    char title[32];
    const char *label = "000";

    if (state == NULL || main_window_handle == 0)
    {
        return;
    }

    if (state->line_label[0] != '\0')
    {
        label = state->line_label;
    }
    else
    {
        snprintf(state->line_label, sizeof(state->line_label), "%d", state->line_id);
        label = state->line_label;
    }

    snprintf(title, sizeof(title), "Converse Line #%s", label);
    Desk_Window_SetTitle(main_window_handle, title);
}

static void door_reset_state(line_task_state *state)
{
    if (state->door_output_buffer != NULL)
    {
        free(state->door_output_buffer);
        state->door_output_buffer = NULL;
    }

    state->door_launch_pending = Desk_bool_FALSE;
    state->door_active = Desk_bool_FALSE;
    state->door_task_handle = 0;
    state->door_next_ack_tick = 0;
    state->door_launch_deadline = 0;

    log_line_event(state->line_id, "LineTask started");
}

static Desk_bool handle_null_poll(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    static clock_t last_blink_time = 0;
    clock_t now;
    Desk_UNUSED(event);

    /* Handle terminal blink */
    now = clock();
    if (now - last_blink_time >= 50) /* 50cs = 0.5s */
    {
        if (state->terminal)
            ansiterm_blink(state->terminal);
        last_blink_time = now;
    }

    /* Poll file transfer if active - do this FIRST to consume raw bytes */
    if (transfer_is_active(&state->xfer_session))
    {
        if (!transfer_poll(&state->xfer_session))
        {
            /* Transfer completed - notify script engine */
            if (state->xfer_session.result == XFER_RESULT_OK)
            {
                /* Check if this was a receive (upload) transfer */
                if (state->xfer_session.direction == TRANSFER_DIR_RECEIVE)
                {
                    /* Register the uploaded file in the filebase */
                    const char *fb_str = script_get_variable(&state->script, "_upload_filebase");
                    const char *area_str = script_get_variable(&state->script, "_upload_area");
                    const char *filename = script_get_variable(&state->script, "_upload_filename");
                    int base_id = fb_str ? atoi(fb_str) : 0;
                    int area_id = area_str ? atoi(area_str) : 0;
                    
                    if (base_id > 0 && filename && filename[0] != '\0')
                    {
                        int file_id = filebase_register_upload(
                            base_id, area_id,
                            state->xfer_session.upload_path,
                            filename,
                            NULL,  /* No description for now */
                            state->user_id,
                            0,     /* Default access level */
                            NULL   /* No keys required */
                        );
                        
                        if (file_id > 0)
                        {
                            char msg[256];
                            snprintf(msg, sizeof(msg),
                                "\r\n\033[1;32mUpload complete! File ID: %d\033[0m\r\n", file_id);
                            pipes_output_write_string(state->line_id, msg);
                            
                            snprintf(msg, sizeof(msg), "Upload registered: %s (file_id=%d)", filename, file_id);
                            log_line_event(state->line_id, msg);
                        }
                        else
                        {
                            pipes_output_write_string(state->line_id,
                                "\r\n\033[1;33mFile received but registration failed.\033[0m\r\n");
                        }
                    }
                    else
                    {
                        pipes_output_write_string(state->line_id,
                            "\r\n\033[1;32mFile received.\033[0m\r\n");
                    }
                }
                else
                {
                    pipes_output_write_string(state->line_id, 
                        "\r\n\033[1;32mTransfer complete!\033[0m\r\n");
                }
            }
            else
            {
                char msg[128];
                snprintf(msg, sizeof(msg), 
                    "\r\n\033[1;31mTransfer failed: %s\033[0m\r\n",
                    state->xfer_session.error_msg[0] ? state->xfer_session.error_msg : "Unknown error");
                pipes_output_write_string(state->line_id, msg);
            }
            script_notify_transfer_complete(&state->script);
        }
        /* Don't process normal input during active transfer */
    }
    else
    {
        /* Normal input processing when no transfer is active */
        process_server_stream(state);
        botstopper_process(state);
        door_process(state);
        arcbbs_door_process(state);
        chat_process(state);
    }
    
    script_process(&state->script);
    
    /* Check for script errors and report them to user */
    if (script_get_status(&state->script) == SCRIPT_STATUS_ERROR)
    {
        char error_msg[256];
        snprintf(error_msg, sizeof(error_msg), 
            "\r\n\033[1;31m[Script Error: %s]\033[0m\r\n",
            script_get_last_error(&state->script));
        pipes_output_write_string(state->line_id, error_msg);
        snprintf(error_msg, sizeof(error_msg), "Script error: %s", script_get_last_error(&state->script));
        log_line_event(state->line_id, error_msg);
        script_stop(&state->script);
    }
    
    return Desk_bool_TRUE;
}

static Desk_bool handle_message_event(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    unsigned int action = event->data.message.header.action;

    if (action == Desk_message_QUIT)
    {
        state->quit_requested = Desk_bool_TRUE;
        return Desk_bool_TRUE;
    }

    if (action == LINE_SHUTDOWN_MESSAGE)
    {
        int reason = event->data.message.data.words[0];
        if (reason == 0)
        {
            state->quit_requested = Desk_bool_TRUE;
            return Desk_bool_TRUE;
        }
        return Desk_bool_FALSE;
    }

    if (action == LINE_TASK_OPEN_WINDOW_MESSAGE)
    {
        int target_line = event->data.message.data.words[0];
        if (target_line == state->line_id)
        {
            show_main_window();
            return Desk_bool_TRUE;
        }
        return Desk_bool_FALSE;
    }

    if (action == RISC_BBS_MESSAGE_START)
    {
        if (state->door_launch_pending == Desk_bool_FALSE || state->door_active != Desk_bool_FALSE)
        {
            return Desk_bool_FALSE;
        }

        state->door_task_handle = event->data.message.header.sender;
        state->door_active = Desk_bool_TRUE;
        state->door_launch_pending = Desk_bool_FALSE;
        state->door_launch_deadline = 0;
        state->door_next_ack_tick = 0;
        pipes_output_write_string(state->line_id, "");
        door_send_acknowledgement(state);
        state->door_next_ack_tick = clock() + DOOR_ACK_INTERVAL_TICKS;
        return Desk_bool_TRUE;
    }

    if (action == RISC_BBS_MESSAGE_END)
    {
        if (state->door_active == Desk_bool_FALSE || event->data.message.header.sender != state->door_task_handle)
        {
            return Desk_bool_FALSE;
        }

        door_close_session(state, "");
        return Desk_bool_TRUE;
    }

    if (action == RISC_BBS_MESSAGE_OUTPUT)
    {
        int payload_length;

        if (state->door_active == Desk_bool_FALSE || event->data.message.header.sender != state->door_task_handle)
        {
            return Desk_bool_FALSE;
        }

        payload_length = event->data.message.header.size - 20;
        if (payload_length < 0)
        {
            payload_length = 0;
        }
        door_queue_output(state, (const char *)event->data.message.data.bytes, (size_t)payload_length);
        return Desk_bool_TRUE;
    }

    return Desk_bool_FALSE;
}

static void process_server_stream(line_task_state *state)
{
    int iteration = 0;

    while (iteration < 4)
    {
        char buffer[PIPE_TRANSFER_CHUNK];
        int copied = pipes_input_read_block(state->line_id, buffer, sizeof(buffer));

        if (copied <= 0)
        {
            break;
        }

        handle_server_stream(state, buffer, copied);
        iteration++;
    }
}

static void handle_plain_server_byte(line_task_state *state, unsigned char byte)
{
    /* Note: We do NOT echo input to the terminal here (snoop).
       The script engine or door will echo the input to the output stream if appropriate.
       The output stream is snooped in pipes_output_write_string, so we will see the echo there.
       Echoing here would cause double characters (one from input snoop, one from output snoop).
    */

    if (state->session_active != 0 || 
        (state->terminal && state->terminal->input_mode && script_get_status(&state->script) != SCRIPT_STATUS_IDLE))
    {
        menu_handle_user_byte(state, byte);
    }
}

static void handle_server_stream(line_task_state *state, const char *buffer, int length)
{
    int index = 0;

    while (index < length)
    {
        unsigned char byte = (unsigned char)buffer[index++];

        if (state->control_stage == 0)
        {
            if (byte == PIPE_CONTROL_TOKEN)
            {
                state->control_stage = 1;
                continue;
            }

            handle_plain_server_byte(state, byte);
            continue;
        }

        if (state->control_stage == 1)
        {
            state->control_code = byte;
            state->control_stage = 2;
            continue;
        }

        /* control_stage == 2: expecting trailing token */
        if (byte != PIPE_CONTROL_TOKEN)
        {
            handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
            handle_plain_server_byte(state, state->control_code);
            handle_plain_server_byte(state, byte);
            state->control_stage = 0;
            continue;
        }

        state->control_stage = 0;

        if (state->control_code == PIPE_CONTROL_CONNECT)
        {
            state->session_active = 1;
            log_line_event(state->line_id, "Session connected");
            pipes_send_welcome(state);
            
            /* Check if botstopper is enabled globally */
            if (config_get_botstopper_enabled())
            {
                botstopper_start(state);
            }
            else
            {
                /* No botstopper - go straight to prelogon script */
                script_start_prelogon(state);
            }
            continue;
        }

        if (state->control_code == PIPE_CONTROL_DISCONNECT)
        {
            perform_session_disconnect(state);
            continue;
        }

        handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
        handle_plain_server_byte(state, state->control_code);
        handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
    }
}

static int pipes_input_read_byte(int line_id)
{
    _kernel_swi_regs regs;

    if (task_state.local_mode)
    {
        if (task_state.local_input_head != task_state.local_input_tail)
        {
            int byte = (unsigned char)task_state.local_input_buffer[task_state.local_input_tail];
            task_state.local_input_tail = (task_state.local_input_tail + 1) % 256;
            return byte;
        }
        return -1;
    }

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_READ, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

static int pipes_input_read_block(int line_id, char *buffer, int length)
{
    int copied = 0;

    if (task_state.local_mode)
    {
        while (copied < length)
        {
            if (task_state.local_input_head != task_state.local_input_tail)
            {
                buffer[copied++] = task_state.local_input_buffer[task_state.local_input_tail];
                task_state.local_input_tail = (task_state.local_input_tail + 1) % 256;
            }
            else
            {
                break;
            }
        }
        return copied;
    }

    while (copied < length)
    {
        _kernel_swi_regs regs;

        regs.r[0] = line_id;
        if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_READ, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] < 0)
        {
            break;
        }

        buffer[copied++] = (char)regs.r[0];
    }

    return copied;
}

static int pipes_output_write_block(int line_id, const char *buffer, int length)
{
    int copied = 0;

    while (copied < length)
    {
        _kernel_swi_regs regs;

        regs.r[0] = line_id;
        regs.r[1] = (unsigned int)(unsigned char)buffer[copied];
        if (_kernel_swi(SWI_CONVERSE_PIPES_OUTPUT_WRITE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] != 0)
        {
            break;
        }

        copied++;
    }

    return copied;
}

/* Write to the input pipe (host->slave direction) - used for sysop terminal input */
static int pipes_input_write_block(int line_id, const char *buffer, int length)
{
    int copied = 0;

    if (task_state.local_mode)
    {
        while (copied < length)
        {
            int next_head = (task_state.local_input_head + 1) % 256;
            if (next_head == task_state.local_input_tail)
            {
                break; /* Buffer full */
            }
            task_state.local_input_buffer[task_state.local_input_head] = buffer[copied];
            task_state.local_input_head = next_head;
            copied++;
        }
        return copied;
    }

    while (copied < length)
    {
        _kernel_swi_regs regs;

        regs.r[0] = line_id;
        regs.r[1] = (unsigned int)(unsigned char)buffer[copied];
        if (_kernel_swi(SWI_CONVERSE_PIPES_INPUT_WRITE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] != 0)
        {
            break;  /* Pipe full */
        }

        copied++;
    }

    return copied;
}

static void pipes_output_write_string(int line_id, const char *string)
{
    if (task_state.local_mode)
    {
        /* In local mode, feed directly to terminal since we have no pipe */
        if (task_state.terminal != NULL)
        {
             ansiterm_process_block(task_state.terminal, (const unsigned char *)string, strlen(string));
             ansiterm_invalidate(task_state.terminal);
        }
        return;
    }

    /* Feed output to terminal for sysop snoop */
    if (task_state.terminal && task_state.terminal->snoop_mode)
    {
        ansiterm_process_block(task_state.terminal, (const unsigned char *)string, strlen(string));
        ansiterm_update_dirty(task_state.terminal);
    }

    while (*string != '\0')
    {
        int chunk = (int)strlen(string);
        int written;

        if (chunk > PIPE_TRANSFER_CHUNK)
        {
            chunk = PIPE_TRANSFER_CHUNK;
        }

        written = pipes_output_write_block(line_id, string, chunk);
        if (written <= 0)
        {
            wait_for_pipe_space();
            continue;
        }

        string += written;
    }
}

static void pipes_send_welcome(line_task_state *state)
{
    char banner[128];
    char connected[128];

    snprintf(banner, sizeof(banner), "Converse/RISC OS (v0.01) - Compiled on %s\r\n", app_compiled);
    pipes_output_write_string(state->line_id, banner);
    snprintf(connected, sizeof(connected), "Connection established on Line #%d\r\n", state->line_id);
    pipes_output_write_string(state->line_id, connected);
}

static void wait_for_pipe_space(void)
{
    Desk_event_pollblock event;

    /* Do a Wimp poll to allow the Server to drain the pipe */
    Desk_Wimp_Poll(Desk_Event_mask, &event);
    Desk_Event_Process(&event);
}

/*
 * RiscBBS door glue
 * ------------------
 * The line task now owns the RiscBBS door handshake so we can prototype door launches without involving the server.
 * Once a door starts it posts 0xC0900, we latch the task handle, stream user keystrokes via 0xC0904, and drip-feed
 * acknowledgements (0xC0903) so the door keeps pumping output (0xC0902).  
 */
static void door_process(line_task_state *state)
{
    clock_t now;

    door_flush_output(state);

    now = clock();

    if (state->door_launch_pending != Desk_bool_FALSE && state->door_launch_deadline != 0)
    {
        if (now >= state->door_launch_deadline)
        {
            pipes_output_write_string(state->line_id, "\r\n[Door did not respond]\r\n");
            door_reset_state(state);
            script_notify_door_closed(&state->script);
            return;
        }
    }

    if (state->door_active == Desk_bool_FALSE)
    {
        return;
    }

    if (state->door_next_ack_tick == 0 || now >= state->door_next_ack_tick)
    {
        door_send_acknowledgement(state);
        state->door_next_ack_tick = now + DOOR_ACK_INTERVAL_TICKS;
    }
}

static void door_send_acknowledgement(line_task_state *state)
{
    Desk_message_block message;

    if (state->door_task_handle == 0)
    {
        return;
    }

    memset(&message, 0, sizeof(message));
    message.header.size = 20;
    message.header.action = (Desk_message_action)RISC_BBS_MESSAGE_ACK;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, state->door_task_handle, NULL);
}

static void door_queue_output(line_task_state *state, const char *text, size_t length)
{
    if (state->door_active == Desk_bool_FALSE)
    {
        return;
    }

    if (text == NULL || length == 0)
    {
        return;
    }

    if (state->door_output_buffer == NULL)
    {
        state->door_output_buffer = (char *)malloc(length + 1);
        if (state->door_output_buffer == NULL)
        {
            return;
        }

        memcpy(state->door_output_buffer, text, length);
        state->door_output_buffer[length] = '\0';
        return;
    }

    {
        size_t existing = strlen(state->door_output_buffer);
        char *extended = (char *)realloc(state->door_output_buffer, existing + length + 1);
        if (extended == NULL)
        {
            return;
        }

        memcpy(extended + existing, text, length);
        extended[existing + length] = '\0';
        state->door_output_buffer = extended;
    }
}

static void door_flush_output(line_task_state *state)
{
    if (state->door_output_buffer == NULL)
    {
        return;
    }

    pipes_output_write_string(state->line_id, state->door_output_buffer);
    free(state->door_output_buffer);
    state->door_output_buffer = NULL;
}

static void door_send_user_byte(line_task_state *state, unsigned char byte)
{
    Desk_message_block message;

    if (state->door_active == Desk_bool_FALSE || state->door_task_handle == 0)
    {
        return;
    }

    memset(&message, 0, sizeof(message));
    message.header.size = 24;
    message.header.action = (Desk_message_action)RISC_BBS_MESSAGE_INPUT;
    message.data.bytes[0] = (char)byte;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, state->door_task_handle, NULL);
}

static void door_close_session(line_task_state *state, const char *message)
{
    if (message != NULL)
    {
        pipes_output_write_string(state->line_id, message);
    }

    door_flush_output(state);
    door_reset_state(state);
    script_notify_door_closed(&state->script);
}

/*
 * ARCbbsDoors emulator integration
 * ---------------------------------
 * Unlike RiscBBS doors which use Wimp messages, ARCbbs doors use a shared buffer
 * with status byte polling. The protocol is:
 *   1. LineTask sets status to a request code (1-254) and launches the door
 *   2. Door polls GetStatus until it sees 255 (active)
 *   3. Door uses GetByte/PutByte for I/O
 *   4. When door exits, it sets status to 0 (idle)
 *   5. LineTask detects status=0 and knows door has finished
 */

static void arcbbs_door_reset_state(line_task_state *state)
{
    state->arcbbs_door_active = Desk_bool_FALSE;
    state->arcbbs_door_launch_pending = Desk_bool_FALSE;
    state->arcbbs_door_launch_deadline = 0;
    state->arcbbs_poll_tick = 0;
    state->arcbbs_requested_door_number = 0;

    /* Deactivate line in ARCbbsDoors module */
    arcbbs_deactivate_line(state->line_id);
}

static void arcbbs_door_process(line_task_state *state)
{
    int status;

    /* If door is active, bridge I/O */
    if (state->arcbbs_door_active != Desk_bool_FALSE)
    {
        int byte;
        int output_count = 0;
        int input_count = 0;
        static int debug_poll_count = 0;

        /* Check if door has finished (status back to 0) */
        status = arcbbs_get_status(state->line_id);
        if (status == ARCBBS_STATUS_IDLE)
        {
            debug_printf("LineTask ARCbbs: door finished (status=0)\n");
            arcbbs_door_close_session(state, "");
            return;
        }

        /* Debug: log polling status periodically */
        if (debug_poll_count < 5)
        {
            debug_printf("LineTask ARCbbs: polling line=%d status=%d\n", state->line_id, status);
            debug_poll_count++;
        }

        /* Read output from door and send to pipe (door->user) */
        while (output_count < PIPE_TRANSFER_CHUNK && (byte = arcbbs_read_output(state->line_id)) >= 0)
        {
            char ch = (char)byte;
            pipes_output_write_block(state->line_id, &ch, 1);
            output_count++;
        }

        /* Debug: log if we got output */
        if (output_count > 0)
        {
            debug_printf("LineTask ARCbbs: read %d bytes from door output\n", output_count);
        }

        /* Read input from pipe and send to door (user->door) */
        while (input_count < PIPE_TRANSFER_CHUNK)
        {
            byte = pipes_input_read_byte(state->line_id);
            if (byte < 0)
            {
                break;
            }
            if (arcbbs_write_input(state->line_id, (unsigned char)byte) != 0)
            {
                /* ARCbbs input buffer full - stop for now */
                break;
            }
            input_count++;
        }

        /* Debug: log if we sent input */
        if (input_count > 0)
        {
            debug_printf("LineTask ARCbbs: wrote %d bytes to door input\n", input_count);
        }
    }
}

static void arcbbs_door_close_session(line_task_state *state, const char *message)
{
    if (message != NULL)
    {
        pipes_output_write_string(state->line_id, message);
    }

    arcbbs_door_reset_state(state);
    script_notify_door_closed(&state->script);
}

/* ARCbbsDoors SWI wrappers */

static int arcbbs_activate_line(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_ACTIVATE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return (regs.r[0] == 0) ? 0 : -1;
}

static int arcbbs_deactivate_line(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_DEACTIVATE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return (regs.r[0] == 0) ? 0 : -1;
}

static int arcbbs_set_status(int line_id, unsigned char status)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = status;
    if (_kernel_swi(SWI_ARCBBSDOORS_WRITESTATUS, &regs, &regs) != NULL)
    {
        return -1;
    }

    return 0;
}

static int arcbbs_get_status(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_READSTATUS, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

static int arcbbs_write_input(int line_id, unsigned char byte)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    regs.r[1] = byte;
    if (_kernel_swi(SWI_ARCBBSDOORS_HOSTWRITE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return (regs.r[0] == 0) ? 0 : -1;
}

static int arcbbs_read_output(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = line_id;
    if (_kernel_swi(SWI_ARCBBSDOORS_HOSTREAD, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0]; /* Returns byte or -1 if empty */
}

static void menu_handle_user_byte(line_task_state *state, unsigned char byte)
{
    /* Check if botstopper is active first */
    if (state->botstopper_state == BOTSTOPPER_STATE_WAITING)
    {
        if (botstopper_handle_byte(state, byte))
        {
            /* Botstopper consumed the byte */
            return;
        }
    }

    if (state->door_active != Desk_bool_FALSE)
    {
        door_send_user_byte(state, byte);
        return;
    }

    if (state->arcbbs_door_active != Desk_bool_FALSE)
    {
        /* Write user input to ARCbbsDoors input buffer */
        arcbbs_write_input(state->line_id, byte);
        return;
    }

    if (state->door_launch_pending != Desk_bool_FALSE)
    {
        return;
    }

    if (state->arcbbs_door_launch_pending != Desk_bool_FALSE)
    {
        return;
    }

    /* Handle chat mode - user typing goes to chat system */
    if (state->chat_active)
    {
        chat_handle_user_byte(state, byte);
        return;
    }

    (void)script_handle_user_byte(&state->script, byte);
}

/* ******************************************************************************************************************************************************** */
/* Configuration Helpers                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

/*
 * Check if botstopper is enabled globally (from System config).
 * Returns 1 if enabled, 0 if disabled.
 */
static int config_get_botstopper_enabled(void)
{
    _kernel_swi_regs regs;
    const char *value;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"botstopper";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return 0;
    }

    value = (const char *)regs.r[0];
    if (value == NULL)
    {
        return 0;
    }

    /* Check for "yes", "1", "on", "true" */
    if (value[0] == 'y' || value[0] == 'Y' ||
        value[0] == '1' ||
        value[0] == 'o' || value[0] == 'O' ||
        value[0] == 't' || value[0] == 'T')
    {
        return 1;
    }

    return 0;
}

/*
 * Get the prelogon script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_prelogon_script(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"prelogon";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the postlogon script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_postlogon_script(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"postlogon";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the anykey file path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_anykey_file(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"anykey";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the newuser script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_newuser_script(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"newuser";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the configured sysop name for display purposes.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_sysop_name(void)
{
    _kernel_swi_regs regs;

    regs.r[0] = 0;  /* CONFIG_REASON_GET */
    regs.r[1] = (int)"sysop_name";
    if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the hello message for a specific line.
 * Returns pointer to string or NULL.
 */
static const char *lineconfig_get_hello(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINECONFIG_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINECONFIG_FIELD_HELLO;
    if (_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/*
 * Get the botstopper text for a specific line.
 * Returns pointer to string or NULL.
 */
static const char *lineconfig_get_botstopper(int line_id)
{
    _kernel_swi_regs regs;

    regs.r[0] = LINECONFIG_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINECONFIG_FIELD_BOTSTOPPER;
    if (_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return NULL;
    }

    return (const char *)regs.r[0];
}

/* ******************************************************************************************************************************************************** */
/* Botstopper Challenge                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

/*
 * Start the botstopper challenge.
 * Displays hello message and botstopper text, then waits for user to type ** within timeout.
 */
static void botstopper_start(line_task_state *state)
{
    const char *hello;
    const char *botstopper_text;

    if (state == NULL)
    {
        return;
    }

    /* Get hello message for this line */
    hello = lineconfig_get_hello(state->line_id);
    if (hello != NULL && hello[0] != '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n");
        pipes_output_write_string(state->line_id, hello);
        pipes_output_write_string(state->line_id, "\r\n");
    }

    /* Get botstopper challenge text for this line */
    botstopper_text = lineconfig_get_botstopper(state->line_id);
    if (botstopper_text != NULL && botstopper_text[0] != '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n");
        pipes_output_write_string(state->line_id, botstopper_text);
        pipes_output_write_string(state->line_id, "\r\n\r\n");
    }

    /* Set up challenge state */
    state->botstopper_state = BOTSTOPPER_STATE_WAITING;
    state->botstopper_deadline = time(NULL) + BOTSTOPPER_TIMEOUT_SECS;
    state->botstopper_star_count = 0;

    log_line_event(state->line_id, "Botstopper challenge started");
}

/*
 * Process botstopper timeout.
 * Called from null poll to check if user has timed out.
 */
static void botstopper_process(line_task_state *state)
{
    if (state == NULL || state->botstopper_state != BOTSTOPPER_STATE_WAITING)
    {
        return;
    }

    /* Check for timeout */
    if (time(NULL) >= state->botstopper_deadline)
    {
        pipes_output_write_string(state->line_id, "\r\n[Botstopper timeout - disconnecting]\r\n");
        log_line_event(state->line_id, "Botstopper timeout");
        state->botstopper_state = BOTSTOPPER_STATE_FAILED;
        
        /* Force disconnect */
        script_host_force_disconnect(state);
    }
}

/*
 * Handle user byte during botstopper challenge.
 * Returns 1 if the byte was consumed, 0 otherwise.
 */
static int botstopper_handle_byte(line_task_state *state, unsigned char byte)
{
    if (state == NULL || state->botstopper_state != BOTSTOPPER_STATE_WAITING)
    {
        return 0;
    }

    /* Check if user typed the botstopper character */
    if (byte == BOTSTOPPER_CHAR)
    {
        state->botstopper_star_count++;
        
        /* Echo the character */
        pipes_output_write_block(state->line_id, (const char *)&byte, 1);

        /* Check if we have enough stars */
        if (state->botstopper_star_count >= 2)
        {
            pipes_output_write_string(state->line_id, "\r\n\r\n[Access granted]\r\n\r\n");
            log_line_event(state->line_id, "Botstopper passed");
            state->botstopper_state = BOTSTOPPER_STATE_PASSED;
            
            /* Start the prelogon script */
            script_start_prelogon(state);
        }
    }
    else
    {
        /* Wrong character - reset star count */
        state->botstopper_star_count = 0;
    }

    return 1;  /* Always consume bytes during botstopper */
}

/* ******************************************************************************************************************************************************** */
/* Script Control                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

/*
 * Start the prelogon script (after botstopper or if botstopper is disabled).
 */
static void script_start_prelogon(line_task_state *state)
{
    const char *prelogon_path;

    if (state == NULL)
    {
        return;
    }

    /* Get prelogon script path from config */
    prelogon_path = config_get_prelogon_script();
    
    debug_printf("script_start_prelogon: prelogon_path=%s", 
                 prelogon_path ? prelogon_path : "(null)");
    
    if (prelogon_path != NULL && prelogon_path[0] != '\0')
    {
        log_line_event(state->line_id, "Starting prelogon script");
        if (!script_start(&state->script, prelogon_path))
        {
            const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
            char message[192];
            snprintf(message, sizeof(message), "\r\n[Unable to start prelogon script: %s]\r\n", error);
            pipes_output_write_string(state->line_id, message);
            /* Fall back to Start script */
            script_start_session(state);
            return;
        }
        script_process(&state->script);
    }
    else
    {
        /* No prelogon script - fall back to default Start script */
        log_line_event(state->line_id, "No prelogon script, starting default");
        script_start_session(state);
    }
}

/*
 * Start the postlogon script (after successful authentication).
 */
static void script_start_postlogon(line_task_state *state)
{
    const char *postlogon_path;

    if (state == NULL)
    {
        return;
    }

    /* Get postlogon script path from config */
    postlogon_path = config_get_postlogon_script();
    
    debug_printf("script_start_postlogon: postlogon_path=%s", 
                 postlogon_path ? postlogon_path : "(null)");
    
    if (postlogon_path != NULL && postlogon_path[0] != '\0')
    {
        log_line_event(state->line_id, "Starting postlogon script");
        if (!script_start(&state->script, postlogon_path))
        {
            const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
            char message[192];
            snprintf(message, sizeof(message), "\r\n[Unable to start postlogon script: %s]\r\n", error);
            pipes_output_write_string(state->line_id, message);
            /* Fall back to Start script */
            script_start_session(state);
            return;
        }
        script_process(&state->script);
    }
    else
    {
        /* No postlogon script - fall back to default Start script */
        log_line_event(state->line_id, "No postlogon script, starting default");
        script_start_session(state);
    }
}

/*
 * Start the newuser script (for new user registration).
 */
static void script_start_newuser(line_task_state *state)
{
    const char *newuser_path;

    if (state == NULL)
    {
        return;
    }

    /* Get newuser script path from config */
    newuser_path = config_get_newuser_script();
    
    debug_printf("script_start_newuser: newuser_path=%s", 
                 newuser_path ? newuser_path : "(null)");
    
    if (newuser_path != NULL && newuser_path[0] != '\0')
    {
        log_line_event(state->line_id, "Starting newuser script");
        if (!script_start(&state->script, newuser_path))
        {
            const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
            char message[192];
            snprintf(message, sizeof(message), "\r\n[Unable to start newuser script: %s]\r\n", error);
            pipes_output_write_string(state->line_id, message);
            return;
        }
        script_process(&state->script);
    }
    else
    {
        /* No newuser script configured */
        pipes_output_write_string(state->line_id, "\r\n[New user registration is not available]\r\n");
        log_line_event(state->line_id, "No newuser script configured");
    }
}

static void script_start_session(line_task_state *state)
{
    if (state == NULL)
    {
        return;
    }

    if (!script_start(&state->script, SCRIPT_ENTRY_PATH))
    {
        const char *error = state->script.last_error[0] != '\0' ? state->script.last_error : "Script failed";
        char message[192];
        snprintf(message, sizeof(message), "\r\n[Unable to start script: %s]\r\n", error);
        pipes_output_write_string(state->line_id, message);
        return;
    }

    script_process(&state->script);
}

static void script_stop_session(line_task_state *state)
{
    if (state == NULL)
    {
        return;
    }

    /* Reset session clears both program and variables */
    script_reset_session(&state->script);
}

static void script_print_time(line_task_state *state)
{
    time_t now;
    struct tm *local_tm;
    char formatted[64];
    char message[160];

    if (state == NULL)
    {
        return;
    }

    now = time(NULL);
    local_tm = localtime(&now);
    if (local_tm == NULL || strftime(formatted, sizeof(formatted), "%Y-%m-%d %H:%M:%S", local_tm) == 0)
    {
        pipes_output_write_string(state->line_id, "Unable to read system time.\r\n");
        return;
    }

    snprintf(message, sizeof(message), "Current time: %s\r\n", formatted);
    pipes_output_write_string(state->line_id, message);
}

static void script_print_line_info(line_task_state *state)
{
    char message[192];
    const char *session = (state != NULL && state->session_active != 0) ? "connected" : "idle";
    const char *door_state;

    if (state == NULL)
    {
        return;
    }

    if (state->door_active != Desk_bool_FALSE)
    {
        door_state = "door running";
    }
    else if (state->door_launch_pending != Desk_bool_FALSE)
    {
        door_state = "door starting";
    }
    else
    {
        door_state = "no door";
    }

    snprintf(message,
             sizeof(message),
             "Line %d: %s, %s\r\n",
             state->line_id,
             session,
             door_state);
    pipes_output_write_string(state->line_id, message);
}

static void script_host_write(void *context, const char *text)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL || text == NULL)
    {
        return;
    }

    if (!state->local_mode)
    {
        pipes_output_write_string(state->line_id, text);
    }
    else
    {
        /* In local mode, pipes_output_write_string handles terminal feed internally */
        pipes_output_write_string(state->line_id, text);
    }
}

static void script_host_launch_door(void *context, const char *command_line)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return;
    }

    if (state->session_active == 0)
    {
        pipes_output_write_string(state->line_id, "\r\n[Door unavailable until connected]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_active != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door is already running]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_launch_pending != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door launch is already pending]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (command_line == NULL || *command_line == '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n[Door command missing]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    Desk_Wimp_StartTask(command_line);
    state->door_launch_pending = Desk_bool_TRUE;
    state->door_launch_deadline = clock() + DOOR_LAUNCH_TIMEOUT_TICKS;
    pipes_output_write_string(state->line_id, "\r\n[Launching door]\r\n");
}

static void script_host_launch_arcbbs_door(void *context, int door_number, const char *command_line)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return;
    }

    if (state->session_active == 0)
    {
        pipes_output_write_string(state->line_id, "\r\n[ARCbbs door unavailable until connected]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_active != Desk_bool_FALSE || state->arcbbs_door_active != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door is already running]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (state->door_launch_pending != Desk_bool_FALSE || state->arcbbs_door_launch_pending != Desk_bool_FALSE)
    {
        pipes_output_write_string(state->line_id, "\r\n[A door launch is already pending]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    if (command_line == NULL || *command_line == '\0')
    {
        pipes_output_write_string(state->line_id, "\r\n[ARCbbs door command missing]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    /* Validate door number (1-254) */
    if (door_number < 1 || door_number > 254)
    {
        pipes_output_write_string(state->line_id, "\r\n[Invalid door number]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    /* Activate the line in ARCbbsDoors module */
    if (arcbbs_activate_line(state->line_id) != 0)
    {
        debug_printf("LineTask ARCbbs: activate failed for line %d\n", state->line_id);
        pipes_output_write_string(state->line_id, "\r\n[ARCbbsDoors module not available]\r\n");
        script_notify_door_closed(&state->script);
        return;
    }

    debug_printf("LineTask ARCbbs: activated line %d\n", state->line_id);

    /* Store the door number we're requesting */
    state->arcbbs_requested_door_number = door_number;

    /* Set status to door number (1-254) - door polls for its number, then writes 255 to accept */
    arcbbs_set_status(state->line_id, (unsigned char)door_number);
    debug_printf("LineTask ARCbbs: set status to %d (door number) BEFORE launch\n", door_number);

    debug_printf("LineTask ARCbbs: launching '%s'\n", command_line);

    /* Launch the door */
    Desk_Wimp_StartTask(command_line);

    /* Mark as active immediately */
    state->arcbbs_door_active = Desk_bool_TRUE;
    state->arcbbs_door_launch_pending = Desk_bool_FALSE;
    state->arcbbs_door_launch_deadline = 0;

    debug_printf("LineTask ARCbbs: door launched, active=TRUE\n");
    pipes_output_write_string(state->line_id, "\r\n[Launching ARCbbs door]\r\n");
}

static void script_host_report_time(void *context)
{
    script_print_time((line_task_state *)context);
}

static void script_host_report_line_info(void *context)
{
    script_print_line_info((line_task_state *)context);
}

static void script_host_request_disconnect(void *context)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return;
    }

    pipes_output_write_string(state->line_id, "\r\n[Please hang up to disconnect]\r\n");
}

static void script_host_force_disconnect(void *context)
{
    line_task_state *state = (line_task_state *)context;
    Desk_message_block message;

    if (state == NULL)
    {
        return;
    }

    if (state->session_active == 0)
    {
        return;
    }

    /* Reset user display in Server status window */
    send_user_message(state->line_id, NULL);

    memset(&message, 0, sizeof(message));
    message.header.size = 32;
    message.header.action = (Desk_message_action)LINE_CONTROL_MESSAGE;
    message.data.words[0] = state->line_id;
    message.data.words[1] = LINE_CONTROL_REASON_LOGOFF;
    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);

    pipes_output_write_string(state->line_id, "\r\n[Disconnecting...]\r\n");
}

static void script_host_report_activity(void *context, const char *text)
{
    line_task_state *state = (line_task_state *)context;
    Desk_message_block message;
    size_t payload_len;
    size_t padded_len;
    char payload[LINE_ACTIVITY_MAX_TEXT];

    if (state == NULL)
    {
        return;
    }

    if (text == NULL)
    {
        text = "";
    }

    strncpy(payload, text, sizeof(payload) - 1);
    payload[sizeof(payload) - 1] = '\0';
    payload_len = strlen(payload);

    memset(&message, 0, sizeof(message));
    message.header.action = (Desk_message_action)LINE_ACTIVITY_MESSAGE;
    message.data.words[0] = state->line_id;
    memcpy(&message.data.bytes[4], payload, payload_len + 1);

    padded_len = (payload_len + 1 + 3) & ~3U;
    message.header.size = 24 + (int)padded_len;

    Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);

    if (payload_len > 0)
    {
        log_line_event(state->line_id, payload);
    }
}

static void script_host_report_online_users(void *context)
{
    line_task_state *state = (line_task_state *)context;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int line;
    char output[256];
    int found_any = 0;

    if (state == NULL)
    {
        return;
    }

    /* Print header */
    pipes_output_write_string(state->line_id, "\r\n");
    pipes_output_write_string(state->line_id, "Line  User                           Online  Activity\r\n");
    pipes_output_write_string(state->line_id, "----  ------------------------------  ------  --------\r\n");

    /* Query each line */
    for (line = 0; line < SUPPORT_MAX_LINES; line++)
    {
        int connected = 0;
        int user_id = 0;
        time_t connect_time = 0;
        const char *activity = "Online";
        int online_mins = 0;
        int online_secs = 0;
        char username[64];

        /* Check if line is connected */
        regs.r[0] = LINE_REASON_GET;
        regs.r[1] = line;
        regs.r[2] = LINE_FIELD_CONNECTED;
        err = _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
        if (err != NULL)
        {
            /* Module not loaded - bail out */
            pipes_output_write_string(state->line_id, "[ConverseBBS module not available]\r\n");
            return;
        }
        connected = regs.r[0];

        if (connected == 0)
        {
            continue;
        }

        found_any = 1;

        /* Get user ID */
        regs.r[0] = LINE_REASON_GET;
        regs.r[1] = line;
        regs.r[2] = LINE_FIELD_USER_ID;
        if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL)
        {
            user_id = regs.r[0];
        }

        /* Look up user from Filer userdb */
        if (user_id > 0)
        {
            _kernel_swi_regs filer_regs;
            filer_regs.r[0] = FILER_USERDB_CMD_SEARCH;
            filer_regs.r[1] = user_id;
            if (_kernel_swi(SWI_CONVERSE_FILER_USERDB, &filer_regs, &filer_regs) == NULL && filer_regs.r[0] != 0)
            {
                /* USER_RECORD returned:
                 * - realname at offset 36 (64 bytes)
                 * - user_flags.sysop at offset 600 (int)
                 */
                char *record_bytes = (char *)filer_regs.r[0];
                char realname[64];
                int is_sysop;

                strncpy(realname, record_bytes + 36, sizeof(realname) - 1);
                realname[sizeof(realname) - 1] = '\0';

                is_sysop = *((int *)(record_bytes + 600));

                if (realname[0] != '\0')
                {
                    if (is_sysop)
                    {
                        snprintf(username, sizeof(username), "%s [SYSOP]", realname);
                    }
                    else
                    {
                        strncpy(username, realname, sizeof(username) - 1);
                        username[sizeof(username) - 1] = '\0';
                    }
                }
                else
                {
                    /* No real name, fall back to username at offset 4 */
                    strncpy(username, record_bytes + 4, sizeof(username) - 1);
                    username[sizeof(username) - 1] = '\0';
                    if (is_sysop)
                    {
                        char temp[64];
                        strncpy(temp, username, sizeof(temp) - 1);
                        temp[sizeof(temp) - 1] = '\0';
                        snprintf(username, sizeof(username), "%s [SYSOP]", temp);
                    }
                }
            }
            else
            {
                snprintf(username, sizeof(username), "User #%d", user_id);
            }
        }
        else
        {
            strcpy(username, "Guest");
        }

        /* Get connect time */
        regs.r[0] = LINE_REASON_GET;
        regs.r[1] = line;
        regs.r[2] = LINE_FIELD_CONNECT_TIME;
        if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL)
        {
            connect_time = (time_t)regs.r[0];
        }

        /* Calculate online duration */
        if (connect_time != 0)
        {
            time_t now = time(NULL);
            int elapsed = (int)(now - connect_time);
            if (elapsed < 0) elapsed = 0;
            online_mins = elapsed / 60;
            online_secs = elapsed % 60;
        }

        /* Get activity */
        regs.r[0] = ACTIVITY_REASON_GET;
        regs.r[1] = line;
        if (_kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs) == NULL && regs.r[0] != 0)
        {
            const char *act_ptr = (const char *)regs.r[0];
            if (act_ptr != NULL && act_ptr[0] != '\0')
            {
                activity = act_ptr;
            }
        }

        /* Format and output the line */
        snprintf(output, sizeof(output), "%-4d  %-30s  %02d:%02d   %s\r\n",
                 line, username, online_mins, online_secs, activity);
        pipes_output_write_string(state->line_id, output);
    }

    if (found_any == 0)
    {
        pipes_output_write_string(state->line_id, "No users currently online.\r\n");
    }

    pipes_output_write_string(state->line_id, "\r\n");
}

static int script_host_get_line_id(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->line_id : -1;
}

static int script_host_get_task_handle(void *context)
{
    Desk_UNUSED(context);
    return Desk_Event_taskhandle;
}

static void *script_host_get_filebase_session(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? &state->fb_session : NULL;
}

static void *script_host_get_messagebase_session(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? &state->mb_session : NULL;
}

static int script_host_get_user_accesslevel(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->user_accesslevel : 0;
}

static int script_host_get_user_sysop(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->user_sysop : 0;
}

static const char *script_host_get_user_keys(void *context)
{
    line_task_state *state = (line_task_state *)context;
    return (state != NULL) ? state->user_keys : "";
}

static int script_host_filebase_download(void *context, int base_id, int file_id)
{
    line_task_state *state = (line_task_state *)context;
    long file_size = 0;
    char msg[128];

    if (state == NULL || base_id <= 0 || file_id <= 0)
    {
        return 0;
    }

    /* Get file size from Filer */
    if (!filebase_get_file_size(base_id, file_id, &file_size))
    {
        return 0;
    }

    /* For now, just report the file is ready for download */
    /* Future: integrate with Xmodem/Ymodem/Zmodem transfer protocols */
    snprintf(msg, sizeof(msg), "\r\n[File ready for download: %ld bytes]\r\n", file_size);
    pipes_output_write_string(state->line_id, msg);

    return 1;
}

/*
 * Authenticate user via Filer module.
 * Returns 1 on success, 0 on failure.
 * auth_result is set to:
 *   0 = success
 *   1 = user not found
 *   2 = bad password
 *   3 = account locked
 */
static int script_host_authenticate_user(void *context, const char *username, const char *password, int *auth_result)
{
    line_task_state *state = (line_task_state *)context;
    _kernel_swi_regs regs;
    _kernel_oserror *err;
    int result;
    int user_id;
    int access_level;
    const char *keys;
    char log_msg[128];

    if (state == NULL || username == NULL || password == NULL || auth_result == NULL)
    {
        if (auth_result != NULL)
        {
            *auth_result = 1;  /* User not found */
        }
        return 0;
    }

    /* Call Filer SWI 0x5AA41 with reason 4 (authenticate) */
    regs.r[0] = FILER_USERDB_CMD_AUTHENTICATE;
    regs.r[1] = (int)username;
    regs.r[2] = (int)password;
    
    err = _kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs);
    if (err != NULL)
    {
        debug_printf("script_host_authenticate_user: SWI error %s", err->errmess);
        *auth_result = 1;  /* User not found (or module error) */
        return 0;
    }

    /* R0 = auth result, R1 = USER_RECORD pointer (if success) */
    result = regs.r[0];
    *auth_result = result;

    if (result != 0)
    {
        /* Authentication failed */
        snprintf(log_msg, sizeof(log_msg), "Login failed for '%s' (reason %d)", username, result);
        log_line_event(state->line_id, log_msg);
        return 0;
    }

    /* Authentication successful - extract user data from USER_RECORD */
    if (regs.r[1] != 0)
    {
        /* USER_RECORD layout (from structs.h):
         * int id                   offset 0
         * char username[32]        offset 4
         * char realname[64]        offset 36
         * char email[64]           offset 100
         * char password[32]        offset 164
         * char keys[128]           offset 196
         * char userdir[256]        offset 324
         * USER_FLAGS               offset 580
         *   - sysop is 5 ints (20 bytes) into USER_FLAGS = offset 600
         *   - accesslevel is 15 ints (60 bytes) into USER_FLAGS = offset 640
         */
        #define USER_RECORD_OFFSET_ID          0
        #define USER_RECORD_OFFSET_USERNAME    4
        #define USER_RECORD_OFFSET_REALNAME    36
        #define USER_RECORD_OFFSET_KEYS        196
        #define USER_RECORD_OFFSET_SYSOP       600
        #define USER_RECORD_OFFSET_ACCESSLEVEL 640
        
        char *record_bytes = (char *)regs.r[1];
        const char *realname;
        const char *username_field;
        int is_sysop;
        
        user_id = *((int *)(record_bytes + USER_RECORD_OFFSET_ID));
        realname = record_bytes + USER_RECORD_OFFSET_REALNAME;
        username_field = record_bytes + USER_RECORD_OFFSET_USERNAME;
        keys = record_bytes + USER_RECORD_OFFSET_KEYS;
        is_sysop = *((int *)(record_bytes + USER_RECORD_OFFSET_SYSOP));
        access_level = *((int *)(record_bytes + USER_RECORD_OFFSET_ACCESSLEVEL));
        
        /* Update line state with user ID */
        {
            _kernel_swi_regs line_regs;
            line_regs.r[0] = LINE_REASON_SET;
            line_regs.r[1] = state->line_id;
            line_regs.r[2] = LINE_FIELD_USER_ID;
            line_regs.r[3] = user_id;
            _kernel_swi(SWI_CONVERSEBBS_LINE, &line_regs, &line_regs);
        }
        
        /* Store user info in task state */
        state->user_id = user_id;
        state->user_accesslevel = access_level;
        state->user_sysop = is_sysop;
        strncpy(state->user_keys, keys, sizeof(state->user_keys) - 1);
        state->user_keys[sizeof(state->user_keys) - 1] = '\0';
        state->user_realname[0] = '\0';
        if (realname != NULL && realname[0] != '\0')
        {
            strncpy(state->user_realname, realname, sizeof(state->user_realname) - 1);
            state->user_realname[sizeof(state->user_realname) - 1] = '\0';
        }
        else if (username_field != NULL && username_field[0] != '\0')
        {
            strncpy(state->user_realname, username_field, sizeof(state->user_realname) - 1);
            state->user_realname[sizeof(state->user_realname) - 1] = '\0';
        }
        else
        {
            snprintf(state->user_realname, sizeof(state->user_realname), "User #%d", user_id);
        }
        
        /* Load user's last accessed messagebase/filebase selections from USER_HISTORY */
        {
            /* USER_HISTORY offsets within USER_RECORD:
             * userdir ends at 580, user_flags is 76 bytes (19 ints), so user_history starts at 656 */
            #define USER_RECORD_OFFSET_HISTORY_MESSAGEBASE     656
            #define USER_RECORD_OFFSET_HISTORY_MESSAGEBASEAREA 660
            #define USER_RECORD_OFFSET_HISTORY_FILEBASE        664
            #define USER_RECORD_OFFSET_HISTORY_FILEBASEAREA    668
            /* USER_STATS offsets: starts at 672 (after USER_HISTORY) */
            #define USER_RECORD_OFFSET_STATS_LASTLOGON         672
            #define USER_RECORD_OFFSET_STATS_LASTSCAN          676
            #define USER_RECORD_OFFSET_STATS_CALLS             680
            #define USER_RECORD_OFFSET_STATS_TODAYTIME         684
            #define USER_RECORD_OFFSET_STATS_UPLOADSKB         688
            #define USER_RECORD_OFFSET_STATS_DOWNLOADSKB       692
            #define USER_RECORD_OFFSET_STATS_UPLOADS           696
            #define USER_RECORD_OFFSET_STATS_DOWNLOADS         700
            
            int last_messagebase = *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_MESSAGEBASE));
            int last_messagebasearea = *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_MESSAGEBASEAREA));
            int last_filebase = *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_FILEBASE));
            int last_filebasearea = *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_FILEBASEAREA));
            
            /* Set filebase session state */
            state->fb_session.current_filebase = last_filebase;
            state->fb_session.current_area = last_filebasearea;
            state->fb_session.user_accesslevel = access_level;
            strncpy(state->fb_session.user_keys, state->user_keys, sizeof(state->fb_session.user_keys) - 1);
            state->fb_session.user_keys[sizeof(state->fb_session.user_keys) - 1] = '\0';
            
            /* Set messagebase session state */
            state->mb_session.current_messagebase = last_messagebase;
            state->mb_session.current_area = last_messagebasearea;
            state->mb_session.user_id = user_id;
            state->mb_session.user_accesslevel = access_level;
            strncpy(state->mb_session.user_keys, state->user_keys, sizeof(state->mb_session.user_keys) - 1);
            state->mb_session.user_keys[sizeof(state->mb_session.user_keys) - 1] = '\0';
            strncpy(state->mb_session.user_realname, state->user_realname, sizeof(state->mb_session.user_realname) - 1);
            state->mb_session.user_realname[sizeof(state->mb_session.user_realname) - 1] = '\0';
            
            /* Load user stats from USER_STATS */
            state->user_stats.lastlogon = *((time_t *)(record_bytes + USER_RECORD_OFFSET_STATS_LASTLOGON));
            state->user_stats.lastscan = *((time_t *)(record_bytes + USER_RECORD_OFFSET_STATS_LASTSCAN));
            state->user_stats.calls = *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_CALLS));
            state->user_stats.todaytime = *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_TODAYTIME));
            state->user_stats.uploadskb = *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_UPLOADSKB));
            state->user_stats.downloadskb = *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_DOWNLOADSKB));
            state->user_stats.uploads = *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_UPLOADS));
            state->user_stats.downloads = *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_DOWNLOADS));
            
            /* Load user flags from USER_FLAGS */
            #define USER_RECORD_OFFSET_FLAGS_ANSI           584
            #define USER_RECORD_OFFSET_FLAGS_MORE           588
            #define USER_RECORD_OFFSET_FLAGS_LINES          592
            #define USER_RECORD_OFFSET_FLAGS_CLS            596
            #define USER_RECORD_OFFSET_FLAGS_EXPERT         612
            #define USER_RECORD_OFFSET_FLAGS_NOLIMIT        620
            #define USER_RECORD_OFFSET_FLAGS_INVISIBLE      624
            #define USER_RECORD_OFFSET_FLAGS_CHATACCESS     632
            #define USER_RECORD_OFFSET_FLAGS_RATIOS         644
            #define USER_RECORD_OFFSET_FLAGS_MAXTIME        648
            #define USER_RECORD_OFFSET_FLAGS_DEFAULTPROTOCOL 652
            
            state->user_flags.ansi = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_ANSI));
            state->user_flags.more = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_MORE));
            state->user_flags.lines = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_LINES));
            state->user_flags.cls = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_CLS));
            state->user_flags.expert = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_EXPERT));
            state->user_flags.nolimit = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_NOLIMIT));
            state->user_flags.invisible = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_INVISIBLE));
            state->user_flags.chataccess = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_CHATACCESS));
            state->user_flags.ratios = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_RATIOS));
            state->user_flags.maxtime = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_MAXTIME));
            state->user_flags.defaultprotocol = *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_DEFAULTPROTOCOL));
            
            debug_printf("Loaded user history: fb=%d/%d mb=%d/%d", 
                last_filebase, last_filebasearea, last_messagebase, last_messagebasearea);
            debug_printf("Loaded user stats: calls=%d uploads=%d downloads=%d", 
                state->user_stats.calls, state->user_stats.uploads, state->user_stats.downloads);
        }
        
        /* Send user name to Server to update status window */
        send_user_message(state->line_id, realname);
        
        snprintf(log_msg, sizeof(log_msg), "User '%s' logged in (id=%d, level=%d%s)", username, user_id, access_level, is_sysop ? ", sysop" : "");
        log_line_event(state->line_id, log_msg);
        
        /* Log the call (increments call counter) */
        {
            _kernel_swi_regs call_regs;
            call_regs.r[0] = FILER_LOG_REASON_CALL;
            call_regs.r[1] = state->line_id;
            call_regs.r[2] = user_id;
            call_regs.r[3] = CALL_STATUS_ANSWERED;
            _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &call_regs, &call_regs);
        }
        
        debug_printf("script_host_authenticate_user: success user_id=%d access=%d", user_id, access_level);
    }

    return 1;
}

static void script_host_start_postlogon(void *context)
{
    line_task_state *state = (line_task_state *)context;
    
    if (state == NULL)
    {
        return;
    }
    
    script_start_postlogon(state);
}

static void script_host_start_newuser(void *context)
{
    line_task_state *state = (line_task_state *)context;
    
    if (state == NULL)
    {
        return;
    }
    
    script_start_newuser(state);
}

static const char *script_host_get_anykey_file(void *context)
{
    return config_get_anykey_file();
}

static int script_host_start_transfer(void *context, int base_id, int file_id, int protocol)
{
    line_task_state *state = (line_task_state *)context;
    transfer_protocol xfer_proto;
    char log_msg[128];

    if (state == NULL || base_id <= 0 || file_id <= 0)
    {
        return 0;
    }

    /* Map protocol number to enum */
    switch (protocol)
    {
        case 0:
            xfer_proto = TRANSFER_PROTO_XMODEM;
            break;
        case 2:
            xfer_proto = TRANSFER_PROTO_XMODEM_1K;
            break;
        case 3:
            xfer_proto = TRANSFER_PROTO_YMODEM;
            break;
        case 4:
            xfer_proto = TRANSFER_PROTO_YMODEM_G;
            break;
        case 5:
            xfer_proto = TRANSFER_PROTO_ZMODEM;
            break;
        case 1:
        default:
            xfer_proto = TRANSFER_PROTO_XMODEM_CRC;
            break;
    }

    /* Cancel any existing transfer */
    if (transfer_is_active(&state->xfer_session))
    {
        transfer_cancel(&state->xfer_session);
    }

    /* Start the new transfer */
    if (xfer_proto == TRANSFER_PROTO_ZMODEM)
    {
        /* ZMODEM needs filename from file record */
        _kernel_swi_regs regs;
        char filename[128];
        LINETASK_FILE_RECORD *file_rec;

        regs.r[0] = 11; /* FILEBASE_CMD_FILE_INFO */
        regs.r[1] = base_id;
        regs.r[2] = file_id;

        if (_kernel_swi(0x5AA43, &regs, &regs) == NULL && regs.r[0] > 0)
        {
            file_rec = (LINETASK_FILE_RECORD *)regs.r[0];
            strncpy(filename, file_rec->name, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        else
        {
            snprintf(filename, sizeof(filename), "file%d", file_id);
        }

        if (!transfer_start_send_zmodem(state->line_id, base_id, file_id,
                                        filename, &state->xfer_session))
        {
            debug_printf("script_host_start_transfer: ZMODEM failed to start - %s\n", 
                         state->xfer_session.error_msg);
            return 0;
        }
    }
    else if (xfer_proto == TRANSFER_PROTO_YMODEM || xfer_proto == TRANSFER_PROTO_YMODEM_G)
    {
        /* YMODEM needs filename from file record */
        _kernel_swi_regs regs;
        char filename[128];
        LINETASK_FILE_RECORD *file_rec;

        regs.r[0] = 11; /* FILEBASE_CMD_FILE_INFO */
        regs.r[1] = base_id;
        regs.r[2] = file_id;

        if (_kernel_swi(0x5AA43, &regs, &regs) == NULL && regs.r[0] > 0)
        {
            file_rec = (LINETASK_FILE_RECORD *)regs.r[0];
            strncpy(filename, file_rec->name, sizeof(filename) - 1);
            filename[sizeof(filename) - 1] = '\0';
        }
        else
        {
            snprintf(filename, sizeof(filename), "file%d", file_id);
        }

        if (!transfer_start_send_ymodem(state->line_id, xfer_proto, base_id, file_id,
                                        filename, &state->xfer_session))
        {
            debug_printf("script_host_start_transfer: YMODEM failed to start - %s\n", 
                         state->xfer_session.error_msg);
            return 0;
        }
    }
    else
    {
        if (!transfer_start_send(state->line_id, xfer_proto, base_id, file_id, &state->xfer_session))
        {
            debug_printf("script_host_start_transfer: failed to start - %s\n", 
                         state->xfer_session.error_msg);
            return 0;
        }
    }

    snprintf(log_msg, sizeof(log_msg), "Starting file transfer (base=%d, file=%d, proto=%d)",
             base_id, file_id, protocol);
    log_line_event(state->line_id, log_msg);

    return 1;
}

static int script_host_start_receive_transfer(void *context, const char *temp_path, int protocol)
{
    line_task_state *state = (line_task_state *)context;
    transfer_protocol xfer_proto;
    char log_msg[128];

    if (state == NULL || temp_path == NULL || temp_path[0] == '\0')
    {
        return 0;
    }

    /* Map protocol number to enum */
    switch (protocol)
    {
        case 0:
            xfer_proto = TRANSFER_PROTO_XMODEM;
            break;
        case 2:
            xfer_proto = TRANSFER_PROTO_XMODEM_1K;
            break;
        case 3:
            xfer_proto = TRANSFER_PROTO_YMODEM;
            break;
        case 4:
            xfer_proto = TRANSFER_PROTO_YMODEM_G;
            break;
        case 5:
            xfer_proto = TRANSFER_PROTO_ZMODEM;
            break;
        case 1:
        default:
            xfer_proto = TRANSFER_PROTO_XMODEM_CRC;
            break;
    }

    /* Cancel any existing transfer */
    if (transfer_is_active(&state->xfer_session))
    {
        transfer_cancel(&state->xfer_session);
    }

    /* Start the receive transfer */
    if (xfer_proto == TRANSFER_PROTO_ZMODEM)
    {
        /* ZMODEM receive: temp_path is the directory, filename comes from ZFILE header */
        if (!transfer_start_receive_zmodem(state->line_id, "<Converse$Dir>.Temp", 
                                           &state->xfer_session))
        {
            debug_printf("script_host_start_receive_transfer: ZMODEM failed to start - %s\n", 
                         state->xfer_session.error_msg);
            return 0;
        }
    }
    else if (xfer_proto == TRANSFER_PROTO_YMODEM || xfer_proto == TRANSFER_PROTO_YMODEM_G)
    {
        /* YMODEM receive: temp_path is the directory, filename comes from block 0 */
        if (!transfer_start_receive_ymodem(state->line_id, xfer_proto, "<Converse$Dir>.Temp", 
                                           &state->xfer_session))
        {
            debug_printf("script_host_start_receive_transfer: YMODEM failed to start - %s\n", 
                         state->xfer_session.error_msg);
            return 0;
        }
    }
    else
    {
        if (!transfer_start_receive(state->line_id, xfer_proto, temp_path, &state->xfer_session))
        {
            debug_printf("script_host_start_receive_transfer: failed to start - %s\n", 
                         state->xfer_session.error_msg);
            return 0;
        }
    }

    snprintf(log_msg, sizeof(log_msg), "Starting file receive (path=%s, proto=%d)",
             temp_path, protocol);
    log_line_event(state->line_id, log_msg);

    return 1;
}

static int script_host_get_user_id(void *context)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return 0;
    }

    return state->user_id;
}

static const script_user_stats *script_host_get_user_stats(void *context)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return NULL;
    }

    return &state->user_stats;
}

static const script_user_flags *script_host_get_user_flags(void *context)
{
    line_task_state *state = (line_task_state *)context;

    if (state == NULL)
    {
        return NULL;
    }

    return &state->user_flags;
}

/* ******************************************************************************************************************************************************** */
/* Sysop Chat Functions                                                                                                                                     */
/* ******************************************************************************************************************************************************** */

static void chat_reset_state(line_task_state *state)
{
    state->chat_paging = Desk_bool_FALSE;
    state->chat_active = Desk_bool_FALSE;
    state->chat_pager_deadline = 0;
    state->chat_next_beep = 0;
    state->chat_reason[0] = '\0';
    state->chat_user_buffer[0] = '\0';
    state->chat_sysop_buffer[0] = '\0';
    state->chat_user_len = 0;
    state->chat_sysop_len = 0;
    state->chat_user_row = CHAT_USER_START_ROW;
    state->chat_sysop_row = CHAT_SYSOP_START_ROW;
    state->chat_timer_start = 0;
    state->chat_timer_last_seconds = -1;
    chatpane_clear(&state->chat_user_pane);
    chatpane_clear(&state->chat_sysop_pane);
}

/* ******************************************************************************************************************************************************** */
/* Chat Pane Helpers                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

static int chatpane_current_index(const chat_pane_view *pane)
{
    if (pane == NULL || pane->line_count <= 0)
    {
        return -1;
    }

    return (pane->start_index + pane->line_count - 1) % CHAT_PANE_MAX_LINES;
}

static int chatpane_add_line(chat_pane_view *pane)
{
    int insert_index;

    if (pane == NULL)
    {
        return -1;
    }

    if (pane->line_count < CHAT_PANE_MAX_LINES)
    {
        insert_index = (pane->start_index + pane->line_count) % CHAT_PANE_MAX_LINES;
        pane->line_count++;
    }
    else
    {
        insert_index = pane->start_index;
        if ((int)pane->line_lengths[insert_index] == pane->longest_length)
        {
            pane->longest_valid = Desk_bool_FALSE;
        }
        pane->start_index = (pane->start_index + 1) % CHAT_PANE_MAX_LINES;
    }

    pane->line_lengths[insert_index] = 0;
    pane->lines[insert_index][0] = '\0';
    return insert_index;
}

static void chatpane_recalculate_longest(chat_pane_view *pane)
{
    int i;
    int max_length = CHAT_PANE_MIN_COLUMNS;

    if (pane == NULL)
    {
        return;
    }

    for (i = 0; i < pane->line_count; i++)
    {
        int index = (pane->start_index + i) % CHAT_PANE_MAX_LINES;
        if ((int)pane->line_lengths[index] > max_length)
        {
            max_length = pane->line_lengths[index];
        }
    }

    pane->longest_length = max_length;
    pane->longest_valid = Desk_bool_TRUE;
}

static const char *chatpane_get_line(const chat_pane_view *pane, int row)
{
    if (pane == NULL || row < 0 || row >= pane->line_count)
    {
        return NULL;
    }

    return pane->lines[(pane->start_index + row) % CHAT_PANE_MAX_LINES];
}

static void chatpane_refresh_rectangle(chat_pane_view *pane, Desk_window_redrawblock *redraw)
{
    int left;
    int right;
    int top;
    int bottom;
    int total_rows;

    if (pane == NULL || redraw == NULL)
    {
        return;
    }

    total_rows = pane->line_count;
    if (total_rows <= 0)
    {
        return;
    }

    left = (redraw->cliprect.min.x - redraw->rect.min.x + redraw->scroll.x) >> CHAT_PANE_CHAR_WIDTH_SHIFT;
    right = (redraw->cliprect.max.x - redraw->rect.min.x + redraw->scroll.x) >> CHAT_PANE_CHAR_WIDTH_SHIFT;
    top = (redraw->rect.max.y - redraw->cliprect.max.y - redraw->scroll.y + 1) >> CHAT_PANE_CHAR_HEIGHT_SHIFT;
    bottom = (redraw->rect.max.y - redraw->cliprect.min.y - redraw->scroll.y + 1) >> CHAT_PANE_CHAR_HEIGHT_SHIFT;

    if (left < 0)
    {
        left = 0;
    }
    if (right < 0)
    {
        return;
    }
    if (top < 0)
    {
        top = 0;
    }
    if (bottom >= total_rows)
    {
        bottom = total_rows - 1;
    }
    if (bottom < top)
    {
        return;
    }

    for (; top <= bottom; top++)
    {
        const char *line = chatpane_get_line(pane, top);
        int length;
        int start_col;
        int end_col;
        int count;
        char buffer[CHAT_PANE_LINE_CHARS];
        int i;

        if (line == NULL)
        {
            continue;
        }

        length = (int)strlen(line);
        if (length == 0)
        {
            continue;
        }

        start_col = left;
        end_col = right;
        if (start_col < 0)
        {
            start_col = 0;
        }
        if (end_col >= length)
        {
            end_col = length - 1;
        }

        count = end_col - start_col + 1;
        if (count <= 0)
        {
            continue;
        }
        if (count >= CHAT_PANE_LINE_CHARS)
        {
            count = CHAT_PANE_LINE_CHARS - 1;
        }

        for (i = 0; i < count; i++)
        {
            char ch = line[start_col + i];
            if ((unsigned char)ch < 32)
            {
                ch = '.';
            }
            buffer[i] = ch;
        }
        buffer[count] = '\0';

        Desk_GFX_Move(redraw->rect.min.x - redraw->scroll.x + (start_col << CHAT_PANE_CHAR_WIDTH_SHIFT),
                      redraw->rect.max.y - redraw->scroll.y - (top << CHAT_PANE_CHAR_HEIGHT_SHIFT) - 1);
        Desk_GFX_WriteN(buffer, count);
    }
}

static void chatpane_init(chat_pane_view *pane)
{
    if (pane == NULL)
    {
        return;
    }

    memset(pane, 0, sizeof(*pane));
    pane->longest_length = CHAT_PANE_MIN_COLUMNS;
    pane->longest_valid = Desk_bool_TRUE;
    pane->follow_tail = Desk_bool_TRUE;
    chatpane_add_line(pane);
    chatpane_update_extent(pane);
}

static void chatpane_set_window(chat_pane_view *pane, Desk_window_handle window)
{
    if (pane == NULL)
    {
        return;
    }

    pane->window = window;
    chatpane_update_extent(pane);
    chatpane_force_redraw(pane);
}

static void chatpane_clear(chat_pane_view *pane)
{
    if (pane == NULL)
    {
        return;
    }

    pane->start_index = 0;
    pane->line_count = 0;
    pane->longest_length = CHAT_PANE_MIN_COLUMNS;
    pane->longest_valid = Desk_bool_TRUE;
    pane->follow_tail = Desk_bool_TRUE;
    chatpane_add_line(pane);
    chatpane_update_extent(pane);
    chatpane_force_redraw(pane);
}

static void chatpane_append_char(chat_pane_view *pane, char ch)
{
    int index;
    int length;

    if (pane == NULL)
    {
        return;
    }

    index = chatpane_current_index(pane);
    if (index < 0)
    {
        index = chatpane_add_line(pane);
    }

    length = pane->line_lengths[index];
    if (length >= CHAT_PANE_LINE_CHARS - 1)
    {
        index = chatpane_add_line(pane);
        length = 0;
    }

    pane->lines[index][length++] = ch;
    pane->lines[index][length] = '\0';
    pane->line_lengths[index] = (uint16_t)length;

    if (length > pane->longest_length)
    {
        pane->longest_length = length;
        pane->longest_valid = Desk_bool_TRUE;
    }

    chatpane_update_extent(pane);
    chatpane_force_redraw(pane);
    if (pane->follow_tail)
    {
        chatpane_scroll_to_bottom(pane);
    }
}

static void chatpane_backspace(chat_pane_view *pane)
{
    int index;
    int length;

    if (pane == NULL)
    {
        return;
    }

    index = chatpane_current_index(pane);
    if (index < 0)
    {
        return;
    }

    length = pane->line_lengths[index];
    if (length <= 0)
    {
        return;
    }

    length--;
    pane->lines[index][length] = '\0';
    pane->line_lengths[index] = (uint16_t)length;

    if (pane->longest_length == length + 1)
    {
        pane->longest_valid = Desk_bool_FALSE;
    }

    chatpane_update_extent(pane);
    chatpane_force_redraw(pane);
}

static void chatpane_newline(chat_pane_view *pane)
{
    if (pane == NULL)
    {
        return;
    }

    chatpane_add_line(pane);
    chatpane_update_extent(pane);
    chatpane_force_redraw(pane);
    if (pane->follow_tail)
    {
        chatpane_scroll_to_bottom(pane);
    }
}

static void chatpane_update_extent(chat_pane_view *pane)
{
    int width_cols;
    int height_rows;

    if (pane == NULL)
    {
        return;
    }

    if (!pane->longest_valid)
    {
        chatpane_recalculate_longest(pane);
    }

    width_cols = pane->longest_length;
    height_rows = (pane->line_count > 0) ? pane->line_count : 1;

    if (width_cols < CHAT_PANE_MIN_COLUMNS)
    {
        width_cols = CHAT_PANE_MIN_COLUMNS;
    }

    pane->extent_min_x = 0;
    pane->extent_min_y = -(height_rows * CHAT_PANE_CHAR_HEIGHT);
    pane->extent_max_x = width_cols * CHAT_PANE_CHAR_WIDTH;
    pane->extent_max_y = 0;

    if (pane->window != 0)
    {
        Desk_Window_SetExtent(pane->window,
                              pane->extent_min_x,
                              pane->extent_min_y,
                              pane->extent_max_x,
                              pane->extent_max_y);
    }
}

static void chatpane_force_redraw(chat_pane_view *pane)
{
    if (pane == NULL || pane->window == 0)
    {
        return;
    }

    Desk_Window_ForceRedraw(pane->window,
                            pane->extent_min_x,
                            pane->extent_min_y,
                            pane->extent_max_x,
                            pane->extent_max_y);
}

static void chatpane_scroll_to_bottom(chat_pane_view *pane)
{
    Desk_window_state state;
    int extent_height;
    int visible_height;
    int desired_scroll;

    if (pane == NULL || pane->window == 0)
    {
        return;
    }

    Desk_Wimp_GetWindowState(pane->window, &state);

    extent_height = -pane->extent_min_y;
    visible_height = state.openblock.screenrect.max.y - state.openblock.screenrect.min.y;
    desired_scroll = visible_height - extent_height;
    if (desired_scroll > 0)
    {
        desired_scroll = 0;
    }

    state.openblock.scroll.y = desired_scroll;
    Desk_Wimp_OpenWindow(&state.openblock);
}

static Desk_bool chatpane_handle_redraw(Desk_event_pollblock *event, void *ref)
{
    chat_pane_view *pane = (chat_pane_view *)ref;
    Desk_window_redrawblock redraw;
    Desk_bool more;

    if (pane == NULL || pane->window == 0)
    {
        return Desk_bool_FALSE;
    }

    (void)event;

    redraw.window = pane->window;
    Desk_Wimp_RedrawWindow(&redraw, &more);
    while (more)
    {
        chatpane_refresh_rectangle(pane, &redraw);
        Desk_Wimp_GetRectangle(&redraw, &more);
    }

    return Desk_bool_TRUE;
}

static Desk_bool chatpane_handle_scroll(Desk_event_pollblock *event, void *ref)
{
    chat_pane_view *pane = (chat_pane_view *)ref;

    if (pane == NULL || pane->window == 0 || event == NULL)
    {
        return Desk_bool_FALSE;
    }

    Desk_Wimp_OpenWindow(&event->data.scroll.openblock);
    pane->follow_tail = Desk_bool_FALSE;
    return Desk_bool_TRUE;
}

static void chat_beep(void)
{
    /* Send VDU 7 (bell) to the system */
    _kernel_oswrch(7);
}

static void chat_update_user_timer(line_task_state *state, const char *time_text)
{
    char label[64];
    char buffer[128];
    int timer_col;
    int label_len;

    if (state == NULL || time_text == NULL)
    {
        return;
    }

    snprintf(label, sizeof(label), "Chatting for: %s", time_text);
    label_len = (int)strlen(label);
    timer_col = CHAT_MAX_COLS - label_len + 1;
    if (timer_col < CHAT_HEADER_MARGIN_COL)
    {
        timer_col = CHAT_HEADER_MARGIN_COL;
    }

    snprintf(buffer, sizeof(buffer), "\033[%d;%dH\033[44m\033[37m%s\033[0m", CHAT_HEADER_ROW, timer_col, label);
    pipes_output_write_string(state->line_id, buffer);
}

static void chat_draw_header(line_task_state *state, const char *timer_text)
{
    static const char header_text[] = "Sysop Chat - Press CTRL+X to finish.";
    char buffer[256];
    int i;

    if (state == NULL)
    {
        return;
    }

    pipes_output_write_string(state->line_id, "\033[1;1H\033[44m\033[37m");
    for (i = 0; i < CHAT_MAX_COLS; i++)
    {
        pipes_output_write_string(state->line_id, " ");
    }

    snprintf(buffer, sizeof(buffer), "\033[%d;%dH%s", CHAT_HEADER_ROW, CHAT_HEADER_MARGIN_COL, header_text);
    pipes_output_write_string(state->line_id, buffer);

    chat_update_user_timer(state, timer_text);
}

static void chat_setup_split_screen(line_task_state *state)
{
    char buffer[256];

    /* Clear screen */
    pipes_output_write_string(state->line_id, "\033[2J");
    
    /* Draw header */
    chat_draw_header(state, CHAT_HEADER_TIMER_INIT);
    
    /* Draw divider line at row 13 */
    pipes_output_write_string(state->line_id, "\033[13;1H");
    pipes_output_write_string(state->line_id, "\033[1;33m");
    {
        int i;
        for (i = 0; i < CHAT_MAX_COLS; i++)
        {
            pipes_output_write_string(state->line_id, "-");
        }
    }
    pipes_output_write_string(state->line_id, "\033[0m");
    
    /* Position cursor for user input area */
    snprintf(buffer, sizeof(buffer), "\033[%d;1H", CHAT_USER_START_ROW);
    pipes_output_write_string(state->line_id, buffer);
    pipes_output_write_string(state->line_id, "\033[1;32mYou: \033[0m");
    
    /* Position cursor for user typing */
    snprintf(buffer, sizeof(buffer), "\033[%d;%dH", CHAT_USER_START_ROW, CHAT_TEXT_COLUMN);
    pipes_output_write_string(state->line_id, buffer);
    
    /* Label sysop area */
    snprintf(buffer, sizeof(buffer), "\033[%d;1H", CHAT_SYSOP_START_ROW);
    pipes_output_write_string(state->line_id, buffer);
    pipes_output_write_string(state->line_id, "\033[1;33mSysop: \033[0m");
    
    /* Back to user area */
    snprintf(buffer, sizeof(buffer), "\033[%d;%dH", CHAT_USER_START_ROW, CHAT_TEXT_COLUMN);
    pipes_output_write_string(state->line_id, buffer);
}

static void chat_position_pane_window(Desk_window_handle pane, Desk_icon_handle anchor_icon)
{
    Desk_window_state chat_state;
    Desk_window_state pane_state;
    Desk_icon_block icon_block;
    Desk_window_openblock open;
    int width;
    int height;
    int anchor_x;
    int anchor_y;

    if (pane == 0 || chat_window_handle == 0)
    {
        return;
    }

    Desk_Wimp_GetWindowState(chat_window_handle, &chat_state);
    Desk_Wimp_GetWindowState(pane, &pane_state);
    Desk_Wimp_GetIconState(chat_window_handle, anchor_icon, &icon_block);

    width = pane_state.openblock.screenrect.max.x - pane_state.openblock.screenrect.min.x;
    height = pane_state.openblock.screenrect.max.y - pane_state.openblock.screenrect.min.y;
    if (width <= 0)
    {
        width = icon_block.workarearect.max.x - icon_block.workarearect.min.x;
    }
    if (height <= 0)
    {
        height = icon_block.workarearect.max.y - icon_block.workarearect.min.y;
    }

    anchor_x = icon_block.workarearect.min.x + chat_state.openblock.screenrect.min.x - chat_state.openblock.scroll.x + CHAT_PANE_X_OFFSET;
    anchor_y = icon_block.workarearect.max.y + chat_state.openblock.screenrect.max.y - chat_state.openblock.scroll.y + CHAT_PANE_Y_OFFSET;

    open.window = pane;
    open.screenrect.min.x = anchor_x;
    open.screenrect.max.x = anchor_x + width;
    open.screenrect.max.y = anchor_y;
    open.screenrect.min.y = anchor_y - height;
    open.scroll.x = pane_state.openblock.scroll.x;
    open.scroll.y = pane_state.openblock.scroll.y;
    open.behind = chat_state.openblock.behind;

    Desk_Wimp_OpenWindow(&open);
}

static void chat_update_panes(line_task_state *state)
{
    if (state == NULL || state->chat_active == Desk_bool_FALSE)
    {
        return;
    }

    if (userchat_window_handle != 0)
    {
        chat_position_pane_window(userchat_window_handle, CHAT_USERCHAT);
    }
    if (sysopchat_window_handle != 0)
    {
        chat_position_pane_window(sysopchat_window_handle, CHAT_SYSOPCHAT);
    }
}

static void chat_show_panes(line_task_state *state)
{
    if (state == NULL)
    {
        return;
    }

    chat_update_panes(state);
    chatpane_scroll_to_bottom(&state->chat_user_pane);
    chatpane_scroll_to_bottom(&state->chat_sysop_pane);
}

static void chat_hide_panes(void)
{
    if (userchat_window_handle != 0)
    {
        Desk_Window_Hide(userchat_window_handle);
    }
    if (sysopchat_window_handle != 0)
    {
        Desk_Window_Hide(sysopchat_window_handle);
    }
}

static void chat_start_pager(line_task_state *state, const char *reason)
{
    clock_t now;
    _kernel_swi_regs regs;
    char user_label[128];
    
    /* Store reason */
    strncpy(state->chat_reason, reason, sizeof(state->chat_reason) - 1);
    state->chat_reason[sizeof(state->chat_reason) - 1] = '\0';
    
    /* Get current monotonic time */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    now = regs.r[0];
    
    /* Set timeout (30 seconds = 3000 centiseconds) */
    state->chat_pager_deadline = now + (CHAT_PAGER_TIMEOUT_SECS * 100);
    state->chat_next_beep = now;  /* Beep immediately */
    
    /* Set window icons */
    Desk_Icon_SetText(chatpager_window_handle, CHATPAGER_REASON, state->chat_reason);
    
    /* Build user label prioritising the caller's real name */
    if (state->user_realname[0] != '\0')
    {
        snprintf(user_label, sizeof(user_label), "%s is paging you for a chat about:", state->user_realname);
    }
    else if (state->user_id > 0)
    {
        snprintf(user_label, sizeof(user_label), "User #%d on Line %d is paging you for a chat about:", state->user_id, state->line_id);
    }
    else
    {
        snprintf(user_label, sizeof(user_label), "Line %d (not logged in) is paging you for a chat about:", state->line_id);
    }
    Desk_Icon_SetText(chatpager_window_handle, CHATPAGER_USER, user_label);
    
    /* Open window centered */
    Desk_Window_Show(chatpager_window_handle, Desk_open_CENTERED);
    
    state->chat_paging = Desk_bool_TRUE;
    
    /* Tell user to wait */
    pipes_output_write_string(state->line_id, "\r\n\033[1;33mPaging sysop, please wait...\033[0m\r\n");
    
    /* Set script status */
    state->script.status = SCRIPT_STATUS_WAIT_CHAT;
    
    log_line_event(state->line_id, "Sysop chat pager started");
}

static void chat_close_pager(line_task_state *state, int accepted)
{
    /* Hide pager window */
    Desk_Window_Hide(chatpager_window_handle);
    state->chat_paging = Desk_bool_FALSE;
    
    if (accepted)
    {
        /* Start chat session */
        chat_start_session(state);
    }
    else
    {
        /* Rejected/timeout - sorry message */
        pipes_output_write_string(state->line_id, "\r\n\033[1;31mSorry, the sysop is not available right now.\033[0m\r\n\r\n");
        
        /* Resume script */
        state->script.status = SCRIPT_STATUS_RUNNING;
        script_process(&state->script);
        
        log_line_event(state->line_id, "Sysop chat pager timed out or ignored");
    }
}

static void chat_start_session(line_task_state *state)
{
    char user_label[128];
    char sysop_label[128];
    const char *sysop_name;
    
    /* Initialize chat buffers */
    state->chat_user_buffer[0] = '\0';
    state->chat_sysop_buffer[0] = '\0';
    state->chat_user_len = 0;
    state->chat_sysop_len = 0;
    state->chat_user_row = CHAT_USER_START_ROW;
    state->chat_sysop_row = CHAT_SYSOP_START_ROW;
    chatpane_clear(&state->chat_user_pane);
    chatpane_clear(&state->chat_sysop_pane);
    
    /* Set up chat window icons */
    if (state->user_realname[0] != '\0')
    {
        snprintf(user_label, sizeof(user_label), "%s:", state->user_realname);
    }
    else if (state->user_id > 0)
    {
        snprintf(user_label, sizeof(user_label), "User #%d:", state->user_id);
    }
    else
    {
        snprintf(user_label, sizeof(user_label), "Line %d:", state->line_id);
    }

    sysop_name = config_get_sysop_name();
    if (sysop_name != NULL && sysop_name[0] != '\0')
    {
        snprintf(sysop_label, sizeof(sysop_label), "%s:", sysop_name);
    }
    else
    {
        snprintf(sysop_label, sizeof(sysop_label), "Sysop:");
    }

    Desk_Icon_SetText(chat_window_handle, CHAT_USER, user_label);
    Desk_Icon_SetText(chat_window_handle, CHAT_SYSOP, sysop_label);
    Desk_Icon_SetText(chat_window_handle, CHAT_SYSOPCHAT, "");
    Desk_Icon_SetText(chat_window_handle, CHAT_CHAT, "");
    Desk_Icon_SetText(chat_window_handle, CHAT_TIME, "00:00:00");

    {
        _kernel_swi_regs regs;

        state->chat_timer_start = 0;
        state->chat_timer_last_seconds = -1;
        if (_kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs) == NULL)
        {
            state->chat_timer_start = regs.r[0];
        }
    }
    
    /* Open chat window */
    Desk_Window_Show(chat_window_handle, Desk_open_CENTERED);
    
    /* Place caret in sysop input field */
    Desk_Icon_SetCaret(chat_window_handle, CHAT_CHAT);
    
    state->chat_active = Desk_bool_TRUE;
    chat_show_panes(state);
    
    /* Set up split screen on user's terminal */
    chat_setup_split_screen(state);
    
    /* Position for user typing */
    {
        char buffer[32];
        snprintf(buffer, sizeof(buffer), "\033[%d;%dH", CHAT_USER_START_ROW, CHAT_TEXT_COLUMN);
        pipes_output_write_string(state->line_id, buffer);
    }
    
    log_line_event(state->line_id, "Sysop chat session started");
}

static void chat_end_session(line_task_state *state)
{
    if (state == NULL || state->chat_active == Desk_bool_FALSE)
    {
        return;
    }

    /* Hide chat window */
    chat_hide_panes();
    Desk_Window_Hide(chat_window_handle);
    state->chat_active = Desk_bool_FALSE;
    state->chat_timer_start = 0;
    state->chat_timer_last_seconds = -1;
    Desk_Icon_SetText(chat_window_handle, CHAT_TIME, "00:00:00");
    
    /* Send goodbye to user */
    pipes_output_write_string(state->line_id, "\033[2J\033[1;1H");  /* Clear screen */
    pipes_output_write_string(state->line_id, "\r\n\033[1;36mChat session ended. Thank you!\033[0m\r\n\r\n");
    
    /* Reset chat state */
    chat_reset_state(state);
    
    /* Resume script if it was waiting on the chat session */
    if (state->script.status == SCRIPT_STATUS_WAIT_CHAT ||
        state->script.status == SCRIPT_STATUS_WAIT_CHAT_REASON)
    {
        state->script.status = SCRIPT_STATUS_RUNNING;
        script_process(&state->script);
    }
    
    log_line_event(state->line_id, "Sysop chat session ended");
}

static void chat_handle_user_byte(line_task_state *state, unsigned char byte)
{
    char buffer[64];

    if (state == NULL)
    {
        return;
    }

    /* CTRL+X ends chat immediately */
    if (byte == 0x18)
    {
        chat_end_session(state);
        return;
    }
    
    /* Handle backspace */
    if (byte == 8 || byte == 127)
    {
        if (state->chat_user_len > 0)
        {
            state->chat_user_len--;
            state->chat_user_buffer[state->chat_user_len] = '\0';
            
            /* Send backspace-space-backspace to user terminal */
            pipes_output_write_string(state->line_id, "\b \b");
            chatpane_backspace(&state->chat_user_pane);
        }
        return;
    }
    
    /* Handle CR - new line in user area */
    if (byte == '\r')
    {
        /* Move to next row in user area */
        state->chat_user_row++;
        if (state->chat_user_row > 23)  /* Scroll would happen, cap it */
        {
            state->chat_user_row = 23;
        }
        
        /* Clear buffer for new line */
        state->chat_user_buffer[0] = '\0';
        state->chat_user_len = 0;
        
        /* Send CRLF and move cursor back to chat column */
        pipes_output_write_string(state->line_id, "\r\n");
        chatpane_newline(&state->chat_user_pane);
        snprintf(buffer, sizeof(buffer), "\033[%d;%dH", state->chat_user_row, CHAT_TEXT_COLUMN);
        pipes_output_write_string(state->line_id, buffer);
        return;
    }
    
    /* Ignore LF */
    if (byte == '\n')
    {
        return;
    }
    
    /* Printable character */
    if (byte >= 32 && byte < 127 && state->chat_user_len < (int)(sizeof(state->chat_user_buffer) - 1))
    {
        state->chat_user_buffer[state->chat_user_len++] = (char)byte;
        state->chat_user_buffer[state->chat_user_len] = '\0';
        chatpane_append_char(&state->chat_user_pane, (char)byte);
        
        /* Echo to user terminal */
        buffer[0] = (char)byte;
        buffer[1] = '\0';
        pipes_output_write_string(state->line_id, buffer);
    }
}

static void chat_send_sysop_char(line_task_state *state, char ch)
{
    char buffer[64];
    
    if (state->chat_sysop_len < (int)(sizeof(state->chat_sysop_buffer) - 1))
    {
        state->chat_sysop_buffer[state->chat_sysop_len++] = ch;
        state->chat_sysop_buffer[state->chat_sysop_len] = '\0';
        
        /* Save cursor, move to sysop area, print char, restore cursor */
        snprintf(buffer, sizeof(buffer), "\033[s\033[%d;%dH%c\033[u", 
             state->chat_sysop_row, CHAT_TEXT_COLUMN + state->chat_sysop_len - 1, ch);
        pipes_output_write_string(state->line_id, buffer);
        chatpane_append_char(&state->chat_sysop_pane, ch);
    }
}

static void chat_send_sysop_line(line_task_state *state, const char *text)
{
    size_t i;
    size_t length;

    if (state == NULL || text == NULL)
    {
        return;
    }

    state->chat_sysop_buffer[0] = '\0';
    state->chat_sysop_len = 0;

    length = strlen(text);
    if (length == 0)
    {
        return;
    }

    for (i = 0; i < length; i++)
    {
        chat_send_sysop_char(state, text[i]);
    }

    chatpane_newline(&state->chat_sysop_pane);
}

static void chat_process(line_task_state *state)
{
    _kernel_swi_regs regs;
    clock_t now;

    if (state == NULL)
    {
        return;
    }

    /* Get current time */
    _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
    now = regs.r[0];

    /* Process pager timeout and beeps */
    if (state->chat_paging)
    {
        if (now >= state->chat_pager_deadline)
        {
            chat_close_pager(state, 0);
            return;
        }

        if (now >= state->chat_next_beep)
        {
            chat_beep();
            state->chat_next_beep = now + CHAT_BEEP_INTERVAL_CS;
        }
    }

    /* Update chat timer display once per second */
    if (state->chat_active && state->chat_timer_start != 0)
    {
        clock_t elapsed_cs = now - state->chat_timer_start;
        int elapsed_secs;

        if (elapsed_cs < 0)
        {
            elapsed_cs = 0;
        }

        elapsed_secs = (int)(elapsed_cs / 100);
        if (elapsed_secs != state->chat_timer_last_seconds)
        {
            char time_text[16];
            int hours = elapsed_secs / 3600;
            int minutes = (elapsed_secs / 60) % 60;
            int seconds = elapsed_secs % 60;

            snprintf(time_text, sizeof(time_text), "%02d:%02d:%02d", hours, minutes, seconds);
            Desk_Icon_SetText(chat_window_handle, CHAT_TIME, time_text);
            chat_update_user_timer(state, time_text);
            state->chat_timer_last_seconds = elapsed_secs;
        }
    }
}

static void script_host_start_chat_pager(void *context, const char *reason)
{
    line_task_state *state = (line_task_state *)context;
    
    if (state == NULL || reason == NULL)
    {
        return;
    }
    
    chat_start_pager(state, reason);
}

static Desk_bool handle_chatpager_click(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    int icon;
    
    if (event == NULL || state == NULL)
    {
        return Desk_bool_FALSE;
    }
    
    icon = event->data.mouse.icon;
    
    if (icon == CHATPAGER_START)
    {
        /* Start chat */
        chat_close_pager(state, 1);
        return Desk_bool_TRUE;
    }
    
    if (icon == CHATPAGER_IGNORE)
    {
        /* Ignore/cancel */
        chat_close_pager(state, 0);
        return Desk_bool_TRUE;
    }
    
    return Desk_bool_FALSE;
}

static Desk_bool handle_chat_click(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    int icon;
    
    if (event == NULL || state == NULL)
    {
        return Desk_bool_FALSE;
    }
    
    icon = event->data.mouse.icon;
    
    if (icon == CHAT_ENDCHAT)
    {
        chat_end_session(state);
        return Desk_bool_TRUE;
    }
    
    if (icon == CHAT_SAVECHAT)
    {
        /* TODO: Implement save chat log */
        return Desk_bool_TRUE;
    }
    
    return Desk_bool_FALSE;
}

static Desk_bool handle_chat_key(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    int key;
    
    if (event == NULL || state == NULL)
    {
        return Desk_bool_FALSE;
    }
    
    key = event->data.key.code;
    
    /* Handle Return in sysop field - send the line */
    if (key == 13 && state->chat_active)
    {
        char buffer[64];
        char line_text[1024];

        Desk_Icon_GetText(chat_window_handle, CHAT_CHAT, line_text);
        if (line_text[0] == '\0')
        {
            return Desk_bool_TRUE;
        }
        chat_send_sysop_line(state, line_text);

        state->chat_sysop_row++;
        if (state->chat_sysop_row > 11)
        {
            state->chat_sysop_row = 11;
        }

        state->chat_sysop_buffer[0] = '\0';
        state->chat_sysop_len = 0;

        Desk_Icon_SetText(chat_window_handle, CHAT_CHAT, "");

        snprintf(buffer, sizeof(buffer), "\033[s\033[%d;8H\033[K\033[u", state->chat_sysop_row);
        pipes_output_write_string(state->line_id, buffer);

        Desk_Icon_SetCaret(chat_window_handle, CHAT_CHAT);

        return Desk_bool_TRUE;
    }

    /* Pass other keys to Wimp */
    Desk_Wimp_ProcessKey(key);
    return Desk_bool_TRUE;
}

static void log_line_event(int line_id, const char *message)
{
    _kernel_swi_regs regs;

    if (line_id < 0 || message == NULL || *message == '\0')
    {
        return;
    }

    memset(&regs, 0, sizeof(regs));
    regs.r[0] = FILER_LOG_REASON_LINE;
    regs.r[1] = line_id;
    regs.r[2] = (int)message;
    _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
}

/* ========================================================================
 * ANSI Terminal Implementation
 * ======================================================================== */

static void terminal_send_input(int line_id, const char *data, int len)
{
    pipes_input_write_block(line_id, data, len);
}

static void terminal_init(line_task_state *state)
{
    if (state == NULL)
    {
        return;
    }
    
    /* Allocate terminal state */
    state->terminal = (ansiterm_state *)malloc(sizeof(ansiterm_state));
    if (state->terminal == NULL)
    {
        debug_printf("terminal_init: Failed to allocate terminal state");
        return;
    }
    
    ansiterm_init(state->terminal, state->line_id);
    state->terminal->send_input = terminal_send_input;
    
    /* Load font if available */
    ansiterm_load_font(state->terminal, "<Converse$Dir>.Resources.Font");
}

static void terminal_finalise(line_task_state *state)
{
    if (state == NULL || state->terminal == NULL)
    {
        return;
    }
    
    ansiterm_finalise(state->terminal);
    free(state->terminal);
    state->terminal = NULL;
}

static void terminal_feed_output(line_task_state *state, const char *data, int len)
{
    if (state == NULL || state->terminal == NULL || data == NULL || len <= 0)
    {
        return;
    }
    
    /* Only feed to terminal if snoop mode is active */
    if (state->terminal->snoop_mode)
    {
        ansiterm_process_block(state->terminal, (const unsigned char *)data, len);
        ansiterm_update_dirty(state->terminal);
    }
}

static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    
    if (event == NULL || state == NULL || state->terminal == NULL)
    {
        return Desk_bool_FALSE;
    }
    
    ansiterm_redraw(state->terminal, &event->data);
    return Desk_bool_TRUE;
}

static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    int key_code;
    int result;
    
    if (event == NULL || state == NULL || state->terminal == NULL)
    {
        return Desk_bool_FALSE;
    }
    
    /* If not in input mode, pass key through */
    if (!state->terminal->input_mode)
    {
        Desk_Wimp_ProcessKey(event->data.key.code);
        return Desk_bool_TRUE;
    }
    
    key_code = event->data.key.code;
    result = ansiterm_keypress(state->terminal, key_code);
    
    if (result > 0)
    {
        /* Send the character to the input pipe (so script receives it) */
        char ch = (char)result;
        pipes_input_write_block(state->line_id, &ch, 1);
        
        /* Local echo removed - rely on remote echo */
    }
    else if (result < 0)
    {
        /* Arrow keys - send ANSI escape sequences */
        const char *seq = NULL;
        switch (result)
        {
        case -1: seq = "\033[A"; break;  /* Up */
        case -2: seq = "\033[B"; break;  /* Down */
        case -3: seq = "\033[C"; break;  /* Right */
        case -4: seq = "\033[D"; break;  /* Left */
        }
        if (seq)
        {
            pipes_input_write_block(state->line_id, seq, 3);
            
            /* Local echo removed - rely on remote echo */
        }
    }
    else
    {
        /* Key not handled - pass to Wimp */
        Desk_Wimp_ProcessKey(key_code);
    }
    
    return Desk_bool_TRUE;
}

static Desk_bool handle_terminal_click(Desk_event_pollblock *event, void *ref)
{
    line_task_state *state = (line_task_state *)ref;
    
    if (event == NULL || state == NULL)
    {
        return Desk_bool_FALSE;
    }
    
    /* Claim caret on click */
    Desk_Window_GainCaret(event->data.mouse.window);
    
    return Desk_bool_TRUE;
}
