/* LineTask Wimp helper that proxies Pipes traffic on a specific line. */

#include <kernel.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <swis.h>
#include <time.h>

#include "C:Desk.Core.h"
#include "C:Desk.Event.h"
#include "C:Desk.EventMsg.h"
#include "C:Desk.GFX.h"
#include "C:Desk.Handler.h"
#include "C:Desk.Icon.h"
#include "C:Desk.Msgs.h"
#include "C:Desk.Resource.h"
#include "C:Desk.Screen.h"
#include "C:Desk.Template.h"
#include "C:Desk.Wimp.h"
#include "C:Desk.WimpSWIs.h"
#include "C:Desk.Window.h"
#include "ansi.h"
#include "ansiterm.h"
#include "chat.h"
#include "debug.h"
#include "door_arcbbs.h"
#include "door_native.h"
#include "door_riscbbs.h"
#include "filebase.h"
#include "iconnames.h"
#include "main.h"
#include "messagebase.h"
#include "pipes.h"
#include "script.h"
#include "transfer.h"

#define SWI_OS_BYTE 0x00000006
#define SWI_Wimp_SetCaretPosition 0x400D2

#define PIPE_CONTROL_TOKEN ((unsigned char)0x00)
#define PIPE_CONTROL_CONNECT 'C'
#define PIPE_CONTROL_DISCONNECT 'D'

#define LINE_MESSAGE_BASE 0x5AA00
#define LINE_SHUTDOWN_MESSAGE (LINE_MESSAGE_BASE + 0)
#define LINE_ACTIVITY_MESSAGE (LINE_MESSAGE_BASE + 1)
#define LINE_CONTROL_MESSAGE (LINE_MESSAGE_BASE + 2)
#define LINE_TASK_OPEN_WINDOW_MESSAGE (LINE_MESSAGE_BASE + 3)
#define LINE_TASK_REGISTER_MESSAGE (LINE_MESSAGE_BASE + 4)
#define LINE_USER_MESSAGE (LINE_MESSAGE_BASE + 5)
#define LINE_CONTROL_REASON_LOGOFF 1

#define LINE_ACTIVITY_MAX_TEXT 96

#define CONVERSE_FILER_BASE 0x5AA40
#define FILER_SWI_LOGGING 0
#define FILER_SWI_USERDB 1
#define FILER_LOG_REASON_LINE 1
#define FILER_LOG_REASON_CALL 2
#define FILER_USERDB_CMD_SEARCH 3
#define FILER_USERDB_CMD_AUTHENTICATE 4
#define SWI_CONVERSE_FILER_LOGGING (CONVERSE_FILER_BASE + FILER_SWI_LOGGING)
#define SWI_CONVERSE_FILER_USERDB (CONVERSE_FILER_BASE + FILER_SWI_USERDB)

/* Call status values for FILER_LOG_REASON_CALL */
#define CALL_STATUS_ANSWERED 0
#define CALL_STATUS_HUNGUP 1
#define CALL_STATUS_ABORTED 2
#define CALL_STATUS_REJECTED 3

/* ConverseBBS Support module SWIs */
#define SWI_CONVERSEBBS_CONFIG 0x5AA80
#define SWI_CONVERSEBBS_LINE 0x5AA81
#define SWI_CONVERSEBBS_ACTIVITY 0x5AA82

/* Line state reason codes and field indices */
#define LINE_REASON_SET 0
#define LINE_REASON_GET 1
#define LINE_FIELD_CONFIGURED 0
#define LINE_FIELD_CONNECTED 1
#define LINE_FIELD_USER_ID 2
#define LINE_FIELD_CONNECT_TIME 3
#define LINE_FIELD_HOSTNAME 4
#define LINE_FIELD_TRANSFER 5
#define LINE_FIELD_TYPE 6

/* Line types (from Support module) */
#define LINE_TYPE_TELNET 0
#define LINE_TYPE_SERIAL 1
#define LINE_TYPE_LOCAL 2

/* OS_Module SWI */
#define SWI_OS_MODULE 0x1E
#define OS_MODULE_LOOKUP 18

/* Activity reason codes */
#define ACTIVITY_REASON_GET 1

/* Max lines to query */
#define SUPPORT_MAX_LINES 32

#define BOTSTOPPER_TIMEOUT_SECS 30
#define BOTSTOPPER_CHAR '*'
#define SCRIPT_ENTRY_PATH "<Converse$Dir>.BBS.Start"

#define SWI_OS_READMONOTONICTIME 0x00000042
#define POLL_IDLE_DELAY 1 /* centiseconds between null polls (10ms) */

/* ConverseBBS Support module - LineConfig SWI */
#define SWI_CONVERSEBBS_LINECONFIG 0x5AA83

/* LineConfig reason codes and fields */
#define LINECONFIG_REASON_GET 1
#define LINECONFIG_FIELD_ENABLED 0
#define LINECONFIG_FIELD_BOTSTOPPER 1
#define LINECONFIG_FIELD_HELLO 2

/* Struct definitions are in h/main */

static line_task_state task_state;
static Desk_window_handle main_window_handle;
static Desk_window_handle maininfo_window_handle;
static Desk_window_handle chatpager_window_handle;
static Desk_window_handle chat_window_handle;
static Desk_window_handle userchat_window_handle;
static Desk_window_handle sysopchat_window_handle;

static char app_compiled[] = __DATE__ " at "__TIME__;

static void pipes_send_welcome(line_task_state *state);
static void handle_server_stream(line_task_state *state, const char *buffer,
                                 int length);
static Desk_bool handle_null_poll(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_message_event(Desk_event_pollblock *event, void *ref);
static void process_server_stream(line_task_state *state);
static void initialise_task_state(line_task_state *state, int argc,
                                  char **argv);
static void initialise_resources(void);
static void shutdown_resources(void);
static void show_main_window(void);
static void notify_server_ready(const line_task_state *state);
static void update_main_window_title(line_task_state *state);
static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_open_event(Desk_event_pollblock *event, void *ref);
static void maininfo_initialise(void);
static void maininfo_shutdown(void);
static void maininfo_update_position(void);
static void maininfo_update(line_task_state *state);
static void maininfo_clear(void);
static void menu_handle_user_byte(line_task_state *state, unsigned char byte);
static void botstopper_start(line_task_state *state);
static void botstopper_process(line_task_state *state);
static int botstopper_handle_byte(line_task_state *state, unsigned char byte);
static int config_get_botstopper_enabled(void);
static const char *config_get_prelogon_script(void);
static const char *config_get_postlogon_script(void);
static const char *config_get_anykey_file(void);
static const char *config_get_more_file(void);
static const char *config_get_protocol_file(void);
static const char *config_get_newuser_script(void);
const char *config_get_sysop_name(void);
static const char *lineconfig_get_hello(int line_id);
static const char *lineconfig_get_botstopper(int line_id);
static void script_start_session(line_task_state *state);
static void script_start_prelogon(line_task_state *state);
static void script_start_postlogon(line_task_state *state);
static void script_start_newuser(line_task_state *state);
static void script_stop_session(line_task_state *state);
static void script_print_time(line_task_state *state);
static void script_print_line_info(line_task_state *state);
static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_terminal_click(Desk_event_pollblock *event, void *ref);
static void script_host_write(void *context, const char *text);
static void script_host_launch_riscbbs_door(void *context,
                                            const char *command_line,
                                            int use_26bit);
static void script_host_launch_arcbbs_door(void *context, int door_number,
                                           const char *command_line,
                                           int use_26bit);
static void script_host_launch_door(void *context, const char *command_line,
                                    int use_26bit);
static void script_host_report_time(void *context);
static void script_host_report_line_info(void *context);
static void script_host_request_disconnect(void *context);
static void script_host_force_disconnect(void *context);
static void script_host_report_activity(void *context, const char *text);
static void script_host_report_online_users(void *context);
static int script_host_get_line_id(void *context);
static int script_host_get_task_handle(void *context);
static void *script_host_get_filebase_session(void *context);
static void *script_host_get_messagebase_session(void *context);
static int script_host_get_user_accesslevel(void *context);
static int script_host_get_user_sysop(void *context);
static const char *script_host_get_user_keys(void *context);
static const char *script_host_get_user_realname(void *context);
static int script_host_filebase_download(void *context, int base_id,
                                         int file_id);
static int script_host_authenticate_user(void *context, const char *username,
                                         const char *password,
                                         int *auth_result);
static void script_host_start_postlogon(void *context);
static void script_host_start_newuser(void *context);
static const char *script_host_get_anykey_file(void *context);
static const char *script_host_get_more_file(void *context);
static const char *script_host_get_protocol_file(void *context);
static int script_host_start_transfer(void *context, int base_id, int file_id,
                                      int protocol);
static int script_host_start_receive_transfer(void *context,
                                              const char *temp_path,
                                              int protocol);
static int script_host_get_user_id(void *context);
static const script_user_stats *script_host_get_user_stats(void *context);
static const script_user_flags *script_host_get_user_flags(void *context);
static void script_host_start_chat_pager(void *context, const char *reason);
static void script_host_update_lastscan(void *context, time_t new_lastscan);
static int script_host_create_user(void *context, const char *username,
                                   const char *password, const char *realname,
                                   const char *email);
static int script_host_check_username_available(void *context,
                                                const char *username);
void log_line_event(int line_id,
                    const char *message); /* Non-static for transfer.c */
static void send_user_message(int line_id, const char *real_name);
static void perform_session_disconnect(line_task_state *state);
static void send_user_message(int line_id, const char *real_name);
static void save_user_stats(line_task_state *state);
static void poll_idle(void);
static Desk_bool handle_chatpager_click(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_chat_click(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_chat_key(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_maininfo_click(Desk_event_pollblock *event, void *ref);
/* ANSI terminal functions */
static void terminal_init(line_task_state *state);
static void terminal_finalise(line_task_state *state);
static void terminal_feed_output(line_task_state *state, const char *data,
                                 int len);
static void terminal_send_input(int line_id, const char *data, int len);
static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event, void *ref);
static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref);

static void poll_idle(void) {
  _kernel_swi_regs regs;
  Desk_event_pollblock event;
  int earliest;

  /* Get current monotonic time and add delay */
  _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
  earliest = regs.r[0] + POLL_IDLE_DELAY;

  /* Poll with idle time - won't return null events until 'earliest' */
  Desk_Wimp_PollIdle(Desk_Event_mask, &event, earliest);
  Desk_Event_Process(&event);
}

/* Send user name message to Server to update the status window user column.
 * Pass NULL or empty string to reset to waiting state.
 */
static void send_user_message(int line_id, const char *real_name) {
  Desk_message_block message;

  memset(&message, 0, sizeof(message));
  message.header.size = sizeof(Desk_message_header) + 4 +
                        100; /* word for line_id + name buffer */
  message.header.action = (Desk_message_action)LINE_USER_MESSAGE;
  message.data.words[0] = line_id;

  if (real_name != NULL && real_name[0] != '\0') {
    strncpy((char *)&message.data.bytes[4], real_name, 96);
    message.data.bytes[99] = '\0';
  } else {
    message.data.bytes[4] = '\0'; /* Empty string to reset */
  }

  Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

int main(int argc, char **argv) {
  initialise_task_state(&task_state, argc, argv);

  {
    char task_name[32];
    snprintf(task_name, sizeof(task_name), "Converse Line [%d]",
             task_state.line_id);
    Desk_Event_Initialise(task_name);
  }
  Desk_EventMsg_Initialise();
  Desk_Screen_CacheModeInfo();
  Desk_Event_Claim(Desk_event_REDRAW, Desk_event_ANY, Desk_event_ANY,
                   Desk_Handler_NullRedraw, NULL);
  Desk_Event_Claim(Desk_event_OPEN, Desk_event_ANY, Desk_event_ANY,
                   handle_open_event, NULL);
  Desk_Event_Claim(Desk_event_CLOSE, Desk_event_ANY, Desk_event_ANY,
                   handle_window_close, NULL);
  Desk_Event_Claim(Desk_event_NULL, Desk_event_ANY, Desk_event_ANY,
                   handle_null_poll, &task_state);
  Desk_Event_Claim(Desk_event_USERMESSAGE, Desk_event_ANY, Desk_event_ANY,
                   handle_message_event, &task_state);
  Desk_Event_Claim(Desk_event_USERMESSAGERECORDED, Desk_event_ANY,
                   Desk_event_ANY, handle_message_event, &task_state);

  initialise_resources();

  /* Register terminal handlers */
  if (main_window_handle != 0) {
    Desk_Event_Claim(Desk_event_REDRAW, main_window_handle, Desk_event_ANY,
                     handle_terminal_redraw, &task_state);
    Desk_Event_Claim(Desk_event_KEY, main_window_handle, Desk_event_ANY,
                     handle_terminal_key, &task_state);
    Desk_Event_Claim(Desk_event_CLICK, main_window_handle, Desk_event_ANY,
                     handle_terminal_click, &task_state);
  }

  /* Register click handlers for chat windows */
  Desk_Event_Claim(Desk_event_CLICK, chatpager_window_handle, Desk_event_ANY,
                   handle_chatpager_click, &task_state);
  Desk_Event_Claim(Desk_event_CLICK, chat_window_handle, Desk_event_ANY,
                   handle_chat_click, &task_state);
  Desk_Event_Claim(Desk_event_KEY, chat_window_handle, Desk_event_ANY,
                   handle_chat_key, &task_state);

  /* Register click handler for maininfo pane */
  Desk_Event_Claim(Desk_event_CLICK, maininfo_window_handle, Desk_event_ANY,
                   handle_maininfo_click, &task_state);

  notify_server_ready(&task_state);

  while (task_state.quit_requested == Desk_bool_FALSE) {
    poll_idle();
  }

  log_line_event(task_state.line_id, "LineTask shutting down");

  script_dispose(&task_state.script);
  shutdown_resources();
  Desk_Event_CloseDown();
  return 0;
}

static void initialise_task_state(line_task_state *state, int argc,
                                  char **argv) {
  int line_id = 0;
  const char *line_arg = "0";

  if (argc > 1 && argv[1] != NULL) {
    line_arg = argv[1];
    line_id = atoi(argv[1]);
  }

  if (line_id < 0) {
    line_id = 0;
  }
  if (line_id > 31) {
    line_id = 31;
  }

  state->line_id = line_id;
  /* Query line type from Support module (defaults to telnet on failure) */
  {
    _kernel_swi_regs regs;
    regs.r[0] = LINE_REASON_GET;
    regs.r[1] = line_id;
    regs.r[2] = LINE_FIELD_TYPE;
    if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL) {
      state->line_type = regs.r[0];
    } else {
      state->line_type = LINE_TYPE_TELNET;
    }
  }
  strncpy(state->line_label, line_arg, sizeof(state->line_label) - 1);
  state->line_label[sizeof(state->line_label) - 1] = '\0';
  state->session_active = 0;
  /* Initialise local mode state */
  memset(&state->local, 0, sizeof(state->local));
  state->local.active = 0;
  state->control_stage = 0;
  state->control_code = 0;
  state->quit_requested = Desk_bool_FALSE;
  state->botstopper.state = BOTSTOPPER_STATE_INACTIVE;
  state->botstopper.deadline = 0;
  state->botstopper.star_count = 0;
  door_riscbbs_reset_state(state);
  door_arcbbs_reset_state(state);
  door_native_reset_state(state);
  chat_init(state);

  {
    script_host host;
    memset(&host, 0, sizeof(host));
    host.context = state;
    host.write_text = script_host_write;
    host.launch_riscbbs_door = script_host_launch_riscbbs_door;
    host.launch_arcbbs_door = script_host_launch_arcbbs_door;
    host.launch_door = script_host_launch_door;
    host.report_time = script_host_report_time;
    host.report_line_info = script_host_report_line_info;
    host.request_disconnect = script_host_request_disconnect;
    host.force_disconnect = script_host_force_disconnect;
    host.report_activity = script_host_report_activity;
    host.report_online_users = script_host_report_online_users;
    host.get_line_id = script_host_get_line_id;
    host.get_task_handle = script_host_get_task_handle;
    host.get_filebase_session = script_host_get_filebase_session;
    host.get_messagebase_session = script_host_get_messagebase_session;
    host.get_user_accesslevel = script_host_get_user_accesslevel;
    host.get_user_sysop = script_host_get_user_sysop;
    host.get_user_keys = script_host_get_user_keys;
    host.get_user_realname = script_host_get_user_realname;
    host.filebase_download = script_host_filebase_download;
    host.authenticate_user = script_host_authenticate_user;
    host.start_postlogon = script_host_start_postlogon;
    host.start_newuser = script_host_start_newuser;
    host.get_anykey_file = script_host_get_anykey_file;
    host.get_more_file = script_host_get_more_file;
    host.get_protocol_file = script_host_get_protocol_file;
    host.start_transfer = script_host_start_transfer;
    host.start_receive_transfer = script_host_start_receive_transfer;
    host.get_user_id = script_host_get_user_id;
    host.get_user_stats = script_host_get_user_stats;
    host.get_user_flags = script_host_get_user_flags;
    host.start_chat_pager = script_host_start_chat_pager;
    host.update_lastscan = script_host_update_lastscan;
    host.create_user = script_host_create_user;
    host.check_username_available = script_host_check_username_available;
    script_initialise(&state->script, &host);
  }

  /* Initialise filebase session */
  filebase_session_init(&state->fb_session);

  /* Initialise messagebase session */
  messagebase_session_init(&state->mb_session);

  /* Initialise transfer session */
  memset(&state->xfer_session, 0, sizeof(state->xfer_session));

  /* Initialise chat state */
  chat_reset_state(state);

  /* Initialise ANSI terminal (pointer starts as NULL) */
  state->terminal = NULL;
  terminal_init(state);

  state->user.id = 0;
  state->user.accesslevel = 0;
  state->user.sysop = 0;
  state->user.keys[0] = '\0';
  state->user.realname[0] = '\0';
  memset(&state->user.stats, 0, sizeof(state->user.stats));
  memset(&state->user.flags, 0, sizeof(state->user.flags));
}

static void initialise_resources(void) {
  Desk_Resource_Initialise("ConverseRes");
  Desk_Msgs_LoadFile("Messages");
  Desk_Template_Initialise();
  Desk_Template_UseOutlineFonts();
  Desk_Template_LoadFile("Templates");
  main_window_handle = Desk_Window_Create("main", NULL);
  maininfo_window_handle =
      Desk_Window_Create("maininfo", Desk_template_TITLEMIN);
  chatpager_window_handle = Desk_Window_Create("chatpager", NULL);
  chat_window_handle = Desk_Window_Create("chat", NULL);
  userchat_window_handle = Desk_Window_Create("userchat", NULL);
  sysopchat_window_handle = Desk_Window_Create("sysopchat", NULL);

  if (main_window_handle != 0) {
    Desk_Window_SetExtent(main_window_handle, 0, -ANSITERM_HEIGHT,
                          ANSITERM_WIDTH, 0);
  }

  /* Pass window handles to chat module */
  chat_set_window_handles(chat_window_handle, chatpager_window_handle,
                          userchat_window_handle, sysopchat_window_handle);
  chat_setup_pane_windows(&task_state);

  if (userchat_window_handle != 0) {
    Desk_Event_Claim(Desk_event_REDRAW, userchat_window_handle, Desk_event_ANY,
                     chat_handle_pane_redraw, &task_state.chat.user_pane);
    Desk_Event_Claim(Desk_event_SCROLL, userchat_window_handle, Desk_event_ANY,
                     chat_handle_pane_scroll, &task_state.chat.user_pane);
  }

  if (sysopchat_window_handle != 0) {
    Desk_Event_Claim(Desk_event_REDRAW, sysopchat_window_handle, Desk_event_ANY,
                     chat_handle_pane_redraw, &task_state.chat.sysop_pane);
    Desk_Event_Claim(Desk_event_SCROLL, sysopchat_window_handle, Desk_event_ANY,
                     chat_handle_pane_scroll, &task_state.chat.sysop_pane);
  }

  /* Main window IS the terminal - register terminal handlers for it */
  if (main_window_handle != 0 && task_state.terminal != NULL) {
    task_state.terminal->window = main_window_handle;
  }

  /* Initialise the maininfo pane */
  maininfo_initialise();

  update_main_window_title(&task_state);
}

static void shutdown_resources(void) {
  terminal_finalise(&task_state);
  maininfo_shutdown();
  Desk_Template_ClearAll();
  main_window_handle = 0;
  maininfo_window_handle = 0;
  chatpager_window_handle = 0;
  chat_window_handle = 0;
  userchat_window_handle = 0;
  sysopchat_window_handle = 0;
}

static void show_main_window(void) {
  if (main_window_handle != 0) {
    /* Open window at full terminal size, centered on screen */
    {
      Desk_window_state state;
      int screen_width, screen_height;
      int window_width = ANSITERM_WIDTH;
      int window_height = ANSITERM_HEIGHT;

      /* Get current screen mode dimensions */
      {
        _kernel_swi_regs regs;
        int xeig, yeig, xpixels, ypixels;

        regs.r[0] = -1;
        regs.r[1] = 4;                   /* XEigFactor */
        _kernel_swi(0x35, &regs, &regs); /* OS_ReadModeVariable */
        xeig = regs.r[2];

        regs.r[0] = -1;
        regs.r[1] = 5; /* YEigFactor */
        _kernel_swi(0x35, &regs, &regs);
        yeig = regs.r[2];

        regs.r[0] = -1;
        regs.r[1] = 11; /* XWindLimit */
        _kernel_swi(0x35, &regs, &regs);
        xpixels = regs.r[2] + 1;

        regs.r[0] = -1;
        regs.r[1] = 12; /* YWindLimit */
        _kernel_swi(0x35, &regs, &regs);
        ypixels = regs.r[2] + 1;

        screen_width = xpixels << xeig;
        screen_height = ypixels << yeig;
      }

      Desk_Wimp_GetWindowState(main_window_handle, &state);

      /* Center the window on screen with full terminal dimensions */
      state.openblock.screenrect.min.x = (screen_width - window_width) / 2;
      state.openblock.screenrect.max.x =
          state.openblock.screenrect.min.x + window_width;
      state.openblock.screenrect.max.y = (screen_height + window_height) / 2;
      state.openblock.screenrect.min.y =
          state.openblock.screenrect.max.y - window_height;
      state.openblock.scroll.x = 0;
      state.openblock.scroll.y = 0;
      state.openblock.behind = -1; /* Open at front */

      Desk_Wimp_OpenWindow(&state.openblock);
    }

    /* Set input focus to the window */
    {
      _kernel_swi_regs regs;
      regs.r[0] = main_window_handle;
      regs.r[1] = -1; /* Icon handle (-1 for window) */
      regs.r[2] = 0;  /* X offset */
      regs.r[3] = 0;  /* Y offset */
      regs.r[4] = -1; /* Height (-1 for default) */
      regs.r[5] = 0;  /* Index */
      _kernel_swi(SWI_Wimp_SetCaretPosition, &regs, &regs);
    }

    /* Enable terminal snoop and input modes when window is shown */
    if (task_state.terminal != NULL) {
      ansiterm_set_snoop(task_state.terminal, 1);
      ansiterm_set_input(task_state.terminal, 1);

      /* Tell pipes module about the snoop terminal */
      pipes_set_snoop_terminal(task_state.terminal);

      /* Display status message in terminal */
      if (task_state.session_active) {
        ansiterm_process_block(
            task_state.terminal,
            (const unsigned char *)"\033[1;32m[Snoop Mode Active]\033[0m\r\n",
            32);
      } else {
        ansiterm_process_block(
            task_state.terminal,
            (const unsigned char
                 *)"\033[1;33m[Sysop Login Mode - Starting Session]\033[0m\r\n",
            52);

        /* Start local session if not already running */
        if (script_get_status(&task_state.script) == SCRIPT_STATUS_IDLE) {
          _kernel_swi_regs regs;

          task_state.local.active = 1;
          task_state.local.terminal = task_state.terminal;
          pipes_set_local_state(&task_state.local);
          task_state.session_active = 1;
          task_state.user.connect_time =
              time(NULL); /* Store connect time locally */
          task_state.user.current_activity[0] = '\0'; /* Clear activity text */

          /* Update Support module state */
          regs.r[0] = LINE_REASON_SET;
          regs.r[1] = task_state.line_id;
          regs.r[2] = LINE_FIELD_CONNECTED;
          regs.r[3] = 1;
          _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

          regs.r[0] = LINE_REASON_SET;
          regs.r[1] = task_state.line_id;
          regs.r[2] = LINE_FIELD_HOSTNAME;
          regs.r[3] = (int)"Local";
          _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

          regs.r[0] = LINE_REASON_SET;
          regs.r[1] = task_state.line_id;
          regs.r[2] = LINE_FIELD_CONNECT_TIME;
          regs.r[3] = (int)task_state.user.connect_time;
          _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

          pipes_send_welcome(&task_state);
          script_start_prelogon(&task_state);
        }
      }
      ansiterm_invalidate(task_state.terminal);
    }

    /* Show and update the maininfo pane */
    maininfo_update(&task_state);
    maininfo_update_position();
  }
}

static void perform_session_disconnect(line_task_state *state) {
  if (state->session_active != 0) {
    if (state->local.active) {
      pipes_write_string(state->line_id, "\r\n[Local session ended]\r\n");
    } else {
      pipes_write_string(state->line_id, "\r\n[LINETASK CLOSED]\r\n");
    }
  }

  /* Update todaytime (minutes used this session) before clearing user state */
  if (state->user.id > 0 && state->user.connect_time > 0) {
    time_t now = time(NULL);
    int session_minutes = (int)((now - state->user.connect_time) / 60);
    if (session_minutes > 0) {
      state->user.stats.todaytime += session_minutes;
      save_user_stats(state);
      debug_printf("Session ended: added %d minutes to todaytime (total=%d)",
                   session_minutes, state->user.stats.todaytime);
    }
  }

  state->session_active = 0;
  state->botstopper.state = BOTSTOPPER_STATE_INACTIVE;
  state->user.connect_time = 0;           /* Clear connection time */
  state->user.current_activity[0] = '\0'; /* Clear activity text */

  if (state->riscbbs.active != Desk_bool_FALSE ||
      state->riscbbs.launch_pending != Desk_bool_FALSE) {
    door_riscbbs_close_session(state, "\r\n[Door session ended]\r\n");
  }
  if (state->arcbbs.active != Desk_bool_FALSE ||
      state->arcbbs.launch_pending != Desk_bool_FALSE) {
    door_arcbbs_close_session(state, "\r\n[ARCbbs door session ended]\r\n");
  }
  if (state->native.active != Desk_bool_FALSE ||
      state->native.launch_pending != Desk_bool_FALSE) {
    door_native_close_session(state, "\r\n[Native door session ended]\r\n");
  }

  /* Reset filebase and messagebase session and user state on disconnect */
  filebase_session_reset(&state->fb_session);
  messagebase_session_reset(&state->mb_session);

  state->user.id = 0;
  state->user.accesslevel = 0;
  state->user.sysop = 0;
  state->user.keys[0] = '\0';
  state->user.realname[0] = '\0';
  memset(&state->user.stats, 0, sizeof(state->user.stats));
  memset(&state->user.flags, 0, sizeof(state->user.flags));

  /* Reset user display in Server status window */
  send_user_message(state->line_id, NULL);

  /* Clear and redraw the ANSI terminal */
  if (state->terminal != NULL) {
    ansiterm_clear(state->terminal);
    ansiterm_invalidate(state->terminal);
  }

  /* Update maininfo pane to show cleared state */
  maininfo_update(state);

  log_line_event(state->line_id, "Session disconnected");
  script_stop_session(state);
}

static Desk_bool handle_window_close(Desk_event_pollblock *event, void *ref) {
  Desk_UNUSED(ref);

  if (event != NULL) {
    if (event->data.openblock.window == main_window_handle) {
      /* Disable terminal modes when main window is closed */
      if (task_state.terminal != NULL) {
        ansiterm_set_snoop(task_state.terminal, 0);
        ansiterm_set_input(task_state.terminal, 0);
        pipes_set_snoop_terminal(NULL);
      }

      /* If running a local sysop session, stop it */
      if (task_state.local.active) {
        _kernel_swi_regs regs;

        perform_session_disconnect(&task_state);
        task_state.local.active = 0;
        pipes_set_local_state(NULL);

        /* Reset Support module state */
        regs.r[0] = LINE_REASON_SET;
        regs.r[1] = task_state.line_id;
        regs.r[2] = LINE_FIELD_CONNECTED;
        regs.r[3] = 0;
        _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

        regs.r[0] = LINE_REASON_SET;
        regs.r[1] = task_state.line_id;
        regs.r[2] = LINE_FIELD_USER_ID;
        regs.r[3] = 0;
        _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

        /* Reset Hostname */
        regs.r[0] = LINE_REASON_SET;
        regs.r[1] = task_state.line_id;
        regs.r[2] = LINE_FIELD_HOSTNAME;
        regs.r[3] = (int)"";
        _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);

        /* Reset Activity text */
        regs.r[0] = 0; /* ACTIVITY_REASON_SET */
        regs.r[1] = task_state.line_id;
        regs.r[2] = (int)"";
        _kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs);

        /* Also send Wimp message to Server to update UI immediately */
        script_host_report_activity(&task_state, "");
      }

      /* Also hide the maininfo pane */
      if (maininfo_window_handle != 0) {
        Desk_Window_Hide(maininfo_window_handle);
      }
    }
    Desk_Window_Hide(event->data.openblock.window);
  }

  return Desk_bool_TRUE;
}

static Desk_bool handle_open_event(Desk_event_pollblock *event, void *ref) {
  Desk_Handler_OpenWindow(event, ref);

  if (event != NULL && event->data.openblock.window == chat_window_handle) {
    chat_update_panes(&task_state);
  }

  /* Update maininfo pane position when main window moves */
  if (event != NULL && event->data.openblock.window == main_window_handle) {
    maininfo_update_position();
  }

  return Desk_bool_TRUE;
}

static void notify_server_ready(const line_task_state *state) {
  Desk_message_block message;

  if (state == NULL) {
    return;
  }

  memset(&message, 0, sizeof(message));
  message.header.size = 24;
  message.header.action = (Desk_message_action)LINE_TASK_REGISTER_MESSAGE;
  message.data.words[0] = state->line_id;
  Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);
}

static void update_main_window_title(line_task_state *state) {
  char title[32];
  const char *label = "000";

  if (state == NULL || main_window_handle == 0) {
    return;
  }

  if (state->line_label[0] != '\0') {
    label = state->line_label;
  } else {
    snprintf(state->line_label, sizeof(state->line_label), "%d",
             state->line_id);
    label = state->line_label;
  }

  snprintf(title, sizeof(title), "Converse Line #%s", label);
  Desk_Window_SetTitle(main_window_handle, title);
}

static Desk_bool handle_null_poll(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;
  static unsigned int last_blink_time = 0;
  static unsigned int last_maininfo_time = 0;
  _kernel_swi_regs regs;
  unsigned int now;
  Desk_UNUSED(event);

  /* Get current monotonic time in centiseconds */
  _kernel_swi(SWI_OS_READMONOTONICTIME, &regs, &regs);
  now = (unsigned int)regs.r[0];

  /* Handle terminal blink every 0.5 seconds */
  if (now - last_blink_time >= 50) /* 50cs = 0.5s */
  {
    if (state->terminal)
      ansiterm_blink(state->terminal);
    last_blink_time = now;
  }

  /* Update maininfo pane time display every second */
  if (now - last_maininfo_time >= 100) /* 100cs = 1s */
  {
    if (state->session_active && maininfo_window_handle != 0) {
      maininfo_update(state);
    }
    last_maininfo_time = now;
  }

  /* Poll file transfer if active - do this FIRST to consume raw bytes */
  if (transfer_is_active(&state->xfer_session)) {
    if (!transfer_poll(&state->xfer_session)) {
      /* Transfer completed - notify script engine */
      if (state->xfer_session.result == XFER_RESULT_OK) {
        /* Calculate KB transferred (round up) */
        int kb_transferred =
            (int)((state->xfer_session.bytes_transferred + 1023) / 1024);

        /* Check if this was a receive (upload) transfer */
        if (state->xfer_session.direction == TRANSFER_DIR_RECEIVE) {
          /* Format size nicely */
          char size_str[32];
          long bytes = state->xfer_session.bytes_transferred;
          if (bytes >= 1048576) /* 1 MB */
          {
            snprintf(size_str, sizeof(size_str), "%.1f MB",
                     (double)bytes / 1048576.0);
          } else if (bytes >= 1024) /* 1 KB */
          {
            snprintf(size_str, sizeof(size_str), "%.1f KB",
                     (double)bytes / 1024.0);
          } else {
            snprintf(size_str, sizeof(size_str), "%ld bytes", bytes);
          }

          /* Update user stats for upload */
          if (state->user.id > 0) {
            state->user.stats.uploads++;
            state->user.stats.uploadskb += kb_transferred;
            save_user_stats(state);
          }

          /* Register the uploaded file in the filebase */
          const char *fb_str =
              script_get_variable(&state->script, "_upload_filebase");
          const char *area_str =
              script_get_variable(&state->script, "_upload_area");
          const char *filename =
              script_get_variable(&state->script, "_upload_filename");
          const char *description =
              script_get_variable(&state->script, "_upload_description");
          int base_id = fb_str ? atoi(fb_str) : 0;
          int area_id = area_str ? atoi(area_str) : 0;

          if (base_id > 0 && filename && filename[0] != '\0') {
            int file_id = filebase_register_upload(
                base_id, area_id, state->xfer_session.temp_path, filename,
                description,       /* Now using the user's description */
                state->user.id, 0, /* Default access level */
                NULL               /* No keys required */
            );

            if (file_id > 0) {
              char msg[256];
              snprintf(msg, sizeof(msg),
                       "\r\n\033[1;32mUpload complete! %s received (File ID: "
                       "%d)\033[0m\r\n",
                       size_str, file_id);
              pipes_write_string(state->line_id, msg);

              snprintf(msg, sizeof(msg),
                       "Upload registered: %s (file_id=%d, %s)", filename,
                       file_id, size_str);
              log_line_event(state->line_id, msg);
            } else {
              char msg[256];
              snprintf(msg, sizeof(msg),
                       "\r\n\033[1;33mFile received (%s) but registration "
                       "failed.\033[0m\r\n",
                       size_str);
              pipes_write_string(state->line_id, msg);
            }
          } else {
            char msg[128];
            snprintf(msg, sizeof(msg),
                     "\r\n\033[1;32mFile received (%s).\033[0m\r\n", size_str);
            pipes_write_string(state->line_id, msg);
          }
        } else {
          /* Update user stats for download */
          if (state->user.id > 0) {
            state->user.stats.downloads++;
            state->user.stats.downloadskb += kb_transferred;
            save_user_stats(state);
          }

          pipes_write_string(state->line_id,
                             "\r\n\033[1;32mTransfer complete!\033[0m\r\n");
        }
      } else {
        char msg[128];
        snprintf(
            msg, sizeof(msg), "\r\n\033[1;31mTransfer failed: %s\033[0m\r\n",
            state->xfer_session.error_msg[0] ? state->xfer_session.error_msg
                                             : "Unknown error");
        pipes_write_string(state->line_id, msg);
      }
      script_notify_transfer_complete(&state->script);
    }
    /* Don't process normal input during active transfer */
  } else {
    /* Normal input processing when no transfer is active */
    process_server_stream(state);
    botstopper_process(state);
    door_riscbbs_process(state);
    door_arcbbs_process(state);
    door_native_process(state);
    chat_process(state);
  }

  script_process(&state->script);

  /* Check for script errors and report them to user */
  if (script_get_status(&state->script) == SCRIPT_STATUS_ERROR) {
    char error_msg[256];
    snprintf(error_msg, sizeof(error_msg),
             "\r\n\033[1;31m[Script Error: %s]\033[0m\r\n",
             script_get_last_error(&state->script));
    pipes_write_string(state->line_id, error_msg);
    snprintf(error_msg, sizeof(error_msg), "Script error: %s",
             script_get_last_error(&state->script));
    log_line_event(state->line_id, error_msg);
    script_stop(&state->script);
  }

  return Desk_bool_TRUE;
}

static Desk_bool handle_message_event(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;
  unsigned int action = event->data.message.header.action;

  if (action == Desk_message_QUIT) {
    state->quit_requested = Desk_bool_TRUE;
    return Desk_bool_TRUE;
  }

  if (action == LINE_SHUTDOWN_MESSAGE) {
    int reason = event->data.message.data.words[0];
    if (reason == 0) {
      state->quit_requested = Desk_bool_TRUE;
      return Desk_bool_TRUE;
    }
    return Desk_bool_FALSE;
  }

  if (action == LINE_TASK_OPEN_WINDOW_MESSAGE) {
    int target_line = event->data.message.data.words[0];
    if (target_line == state->line_id) {
      show_main_window();
      return Desk_bool_TRUE;
    }
    return Desk_bool_FALSE;
  }

  /* Handle RiscBBS door messages via the door module */
  if (door_riscbbs_handle_message(event, state)) {
    return Desk_bool_TRUE;
  }

  return Desk_bool_FALSE;
}

static void process_server_stream(line_task_state *state) {
  int iteration = 0;

  while (iteration < 4) {
    char buffer[PIPE_TRANSFER_CHUNK];
    int copied =
        pipes_read_block(state->line_id, (uint8_t *)buffer, sizeof(buffer));

    if (copied <= 0) {
      break;
    }

    handle_server_stream(state, buffer, copied);
    iteration++;
  }
}

static void handle_plain_server_byte(line_task_state *state,
                                     unsigned char byte) {
  /* Note: We do NOT echo input to the terminal here (snoop).
     The script engine or door will echo the input to the output stream if
     appropriate. The output stream is snooped in pipes_output_write_string, so
     we will see the echo there. Echoing here would cause double characters (one
     from input snoop, one from output snoop).
  */

  if (state->session_active != 0 ||
      (state->terminal && state->terminal->input_mode &&
       script_get_status(&state->script) != SCRIPT_STATUS_IDLE)) {
    menu_handle_user_byte(state, byte);
  }
}

static void handle_server_stream(line_task_state *state, const char *buffer,
                                 int length) {
  int index = 0;

  while (index < length) {
    unsigned char byte = (unsigned char)buffer[index++];

    if (state->control_stage == 0) {
      if (byte == PIPE_CONTROL_TOKEN) {
        state->control_stage = 1;
        continue;
      }

      handle_plain_server_byte(state, byte);
      continue;
    }

    if (state->control_stage == 1) {
      state->control_code = byte;
      state->control_stage = 2;
      continue;
    }

    /* control_stage == 2: expecting trailing token */
    if (byte != PIPE_CONTROL_TOKEN) {
      handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
      handle_plain_server_byte(state, state->control_code);
      handle_plain_server_byte(state, byte);
      state->control_stage = 0;
      continue;
    }

    state->control_stage = 0;

    if (state->control_code == PIPE_CONTROL_CONNECT) {
      state->session_active = 1;
      state->user.connect_time = time(NULL);  /* Record connection time */
      state->user.current_activity[0] = '\0'; /* Clear activity text */
      log_line_event(state->line_id, "Session connected");
      pipes_send_welcome(state);
      maininfo_update(state); /* Update maininfo pane */

      /* Botstopper only applies to telnet lines and when enabled globally */
      if (state->line_type == LINE_TYPE_TELNET &&
          config_get_botstopper_enabled()) {
        botstopper_start(state);
      } else {
        /* No botstopper - go straight to prelogon script */
        script_start_prelogon(state);
      }
      continue;
    }

    if (state->control_code == PIPE_CONTROL_DISCONNECT) {
      perform_session_disconnect(state);
      continue;
    }

    handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
    handle_plain_server_byte(state, state->control_code);
    handle_plain_server_byte(state, PIPE_CONTROL_TOKEN);
  }
}

static void pipes_send_welcome(line_task_state *state) {
  char banner[128];
  char connected[128];

  snprintf(banner, sizeof(banner),
           "Converse/RISC OS (v0.01) - Compiled on %s\r\n", app_compiled);
  pipes_write_string(state->line_id, banner);
  snprintf(connected, sizeof(connected),
           "Connection established on Line #%d\r\n", state->line_id);
  pipes_write_string(state->line_id, connected);
}

static void menu_handle_user_byte(line_task_state *state, unsigned char byte) {
  /* Check if botstopper is active first */
  if (state->botstopper.state == BOTSTOPPER_STATE_WAITING) {
    if (botstopper_handle_byte(state, byte)) {
      /* Botstopper consumed the byte */
      return;
    }
  }

  if (state->riscbbs.active != Desk_bool_FALSE) {
    door_riscbbs_send_user_byte(state, byte);
    return;
  }

  if (state->arcbbs.active != Desk_bool_FALSE) {
    /* Write user input to ARCbbsDoors input buffer */
    door_arcbbs_write_input(state->line_id, byte);
    return;
  }

  if (state->riscbbs.launch_pending != Desk_bool_FALSE) {
    return;
  }

  if (state->arcbbs.launch_pending != Desk_bool_FALSE) {
    return;
  }

  /* Handle chat mode - user typing goes to chat system */
  if (state->chat.active) {
    chat_handle_user_byte(state, byte);
    return;
  }

  (void)script_handle_user_byte(&state->script, byte);
}

/* ********************************************************************************************************************************************************
 */
/* Configuration Helpers */
/* ********************************************************************************************************************************************************
 */

/*
 * Check if botstopper is enabled globally (from System config).
 * Returns 1 if enabled, 0 if disabled.
 */
static int config_get_botstopper_enabled(void) {
  _kernel_swi_regs regs;
  const char *value;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"botstopper";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return 0;
  }

  value = (const char *)regs.r[0];
  if (value == NULL) {
    return 0;
  }

  /* Check for "yes", "1", "on", "true" */
  if (value[0] == 'y' || value[0] == 'Y' || value[0] == '1' ||
      value[0] == 'o' || value[0] == 'O' || value[0] == 't' ||
      value[0] == 'T') {
    return 1;
  }

  return 0;
}

/*
 * Get the prelogon script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_prelogon_script(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"prelogon";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the postlogon script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_postlogon_script(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"postlogon";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the anykey file path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_anykey_file(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"anykey";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the more prompt file path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_more_file(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"more";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the protocol prompt file path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_protocol_file(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"protocol";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the newuser script path from config.
 * Returns pointer to static string or NULL if not configured.
 */
static const char *config_get_newuser_script(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"newuser";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the configured sysop name for display purposes.
 * Returns pointer to static string or NULL if not configured.
 */
const char *config_get_sysop_name(void) {
  _kernel_swi_regs regs;

  regs.r[0] = 0; /* CONFIG_REASON_GET */
  regs.r[1] = (int)"sysop_name";
  if (_kernel_swi(SWI_CONVERSEBBS_CONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the hello message for a specific line.
 * Returns pointer to string or NULL.
 */
static const char *lineconfig_get_hello(int line_id) {
  _kernel_swi_regs regs;

  regs.r[0] = LINECONFIG_REASON_GET;
  regs.r[1] = line_id;
  regs.r[2] = LINECONFIG_FIELD_HELLO;
  if (_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/*
 * Get the botstopper text for a specific line.
 * Returns pointer to string or NULL.
 */
static const char *lineconfig_get_botstopper(int line_id) {
  _kernel_swi_regs regs;

  regs.r[0] = LINECONFIG_REASON_GET;
  regs.r[1] = line_id;
  regs.r[2] = LINECONFIG_FIELD_BOTSTOPPER;
  if (_kernel_swi(SWI_CONVERSEBBS_LINECONFIG, &regs, &regs) != NULL ||
      regs.r[0] == 0) {
    return NULL;
  }

  return (const char *)regs.r[0];
}

/* ********************************************************************************************************************************************************
 */
/* Botstopper Challenge */
/* ********************************************************************************************************************************************************
 */

/*
 * Start the botstopper challenge.
 * Displays hello message and botstopper text, then waits for user to type **
 * within timeout.
 */
static void botstopper_start(line_task_state *state) {
  const char *hello;
  const char *botstopper_text;

  if (state == NULL) {
    return;
  }

  /* Get hello message for this line */
  hello = lineconfig_get_hello(state->line_id);
  if (hello != NULL && hello[0] != '\0') {
    pipes_write_string(state->line_id, "\r\n");
    pipes_write_string(state->line_id, hello);
    pipes_write_string(state->line_id, "\r\n");
  }

  /* Get botstopper challenge text for this line */
  botstopper_text = lineconfig_get_botstopper(state->line_id);
  if (botstopper_text != NULL && botstopper_text[0] != '\0') {
    pipes_write_string(state->line_id, "\r\n");
    pipes_write_string(state->line_id, botstopper_text);
    pipes_write_string(state->line_id, "\r\n\r\n");
  }

  /* Set up challenge state */
  state->botstopper.state = BOTSTOPPER_STATE_WAITING;
  state->botstopper.deadline = time(NULL) + BOTSTOPPER_TIMEOUT_SECS;
  state->botstopper.star_count = 0;

  log_line_event(state->line_id, "Botstopper challenge started");
}

/*
 * Process botstopper timeout.
 * Called from null poll to check if user has timed out.
 */
static void botstopper_process(line_task_state *state) {
  if (state == NULL || state->botstopper.state != BOTSTOPPER_STATE_WAITING) {
    return;
  }

  /* Check for timeout */
  if (time(NULL) >= state->botstopper.deadline) {
    pipes_write_string(state->line_id,
                       "\r\n[Botstopper timeout - disconnecting]\r\n");
    log_line_event(state->line_id, "Botstopper timeout");
    state->botstopper.state = BOTSTOPPER_STATE_FAILED;

    /* Force disconnect */
    script_host_force_disconnect(state);
  }
}

/*
 * Handle user byte during botstopper challenge.
 * Returns 1 if the byte was consumed, 0 otherwise.
 */
static int botstopper_handle_byte(line_task_state *state, unsigned char byte) {
  if (state == NULL || state->botstopper.state != BOTSTOPPER_STATE_WAITING) {
    return 0;
  }

  /* Check if user typed the botstopper character */
  if (byte == BOTSTOPPER_CHAR) {
    state->botstopper.star_count++;

    /* Echo the character */
    pipes_write_block(state->line_id, (const uint8_t *)&byte, 1);

    /* Check if we have enough stars */
    if (state->botstopper.star_count >= 2) {
      pipes_write_string(state->line_id, "\r\n\r\n[Access granted]\r\n\r\n");
      log_line_event(state->line_id, "Botstopper passed");
      state->botstopper.state = BOTSTOPPER_STATE_PASSED;

      /* Start the prelogon script */
      script_start_prelogon(state);
    }
  } else {
    /* Wrong character - reset star count */
    state->botstopper.star_count = 0;
  }

  return 1; /* Always consume bytes during botstopper */
}

/* ********************************************************************************************************************************************************
 */
/* Script Control */
/* ********************************************************************************************************************************************************
 */

/*
 * Start the prelogon script (after botstopper or if botstopper is disabled).
 */
static void script_start_prelogon(line_task_state *state) {
  const char *prelogon_path;

  if (state == NULL) {
    return;
  }

  /* Get prelogon script path from config */
  prelogon_path = config_get_prelogon_script();

  debug_printf("script_start_prelogon: prelogon_path=%s",
               prelogon_path ? prelogon_path : "(null)");

  if (prelogon_path != NULL && prelogon_path[0] != '\0') {
    log_line_event(state->line_id, "Starting prelogon script");
    if (!script_start(&state->script, prelogon_path)) {
      const char *error = state->script.last_error[0] != '\0'
                              ? state->script.last_error
                              : "Script failed";
      char message[192];
      snprintf(message, sizeof(message),
               "\r\n[Unable to start prelogon script: %s]\r\n", error);
      pipes_write_string(state->line_id, message);
      /* Fall back to Start script */
      script_start_session(state);
      return;
    }
    script_process(&state->script);
  } else {
    /* No prelogon script - fall back to default Start script */
    log_line_event(state->line_id, "No prelogon script, starting default");
    script_start_session(state);
  }
}

/*
 * Start the postlogon script (after successful authentication).
 */
static void script_start_postlogon(line_task_state *state) {
  const char *postlogon_path;

  if (state == NULL) {
    return;
  }

  /* Get postlogon script path from config */
  postlogon_path = config_get_postlogon_script();

  debug_printf("script_start_postlogon: postlogon_path=%s",
               postlogon_path ? postlogon_path : "(null)");

  if (postlogon_path != NULL && postlogon_path[0] != '\0') {
    log_line_event(state->line_id, "Starting postlogon script");
    if (!script_start(&state->script, postlogon_path)) {
      const char *error = state->script.last_error[0] != '\0'
                              ? state->script.last_error
                              : "Script failed";
      char message[192];
      snprintf(message, sizeof(message),
               "\r\n[Unable to start postlogon script: %s]\r\n", error);
      pipes_write_string(state->line_id, message);
      /* Fall back to Start script */
      script_start_session(state);
      return;
    }
    script_process(&state->script);
  } else {
    /* No postlogon script - fall back to default Start script */
    log_line_event(state->line_id, "No postlogon script, starting default");
    script_start_session(state);
  }
}

/*
 * Start the newuser script (for new user registration).
 */
static void script_start_newuser(line_task_state *state) {
  const char *newuser_path;

  if (state == NULL) {
    return;
  }

  /* Get newuser script path from config */
  newuser_path = config_get_newuser_script();

  debug_printf("script_start_newuser: newuser_path=%s",
               newuser_path ? newuser_path : "(null)");

  if (newuser_path != NULL && newuser_path[0] != '\0') {
    log_line_event(state->line_id, "Starting newuser script");
    if (!script_start(&state->script, newuser_path)) {
      const char *error = state->script.last_error[0] != '\0'
                              ? state->script.last_error
                              : "Script failed";
      char message[192];
      snprintf(message, sizeof(message),
               "\r\n[Unable to start newuser script: %s]\r\n", error);
      pipes_write_string(state->line_id, message);
      return;
    }
    script_process(&state->script);
  } else {
    /* No newuser script configured */
    pipes_write_string(state->line_id,
                       "\r\n[New user registration is not available]\r\n");
    log_line_event(state->line_id, "No newuser script configured");
  }
}

static void script_start_session(line_task_state *state) {
  if (state == NULL) {
    return;
  }

  if (!script_start(&state->script, SCRIPT_ENTRY_PATH)) {
    const char *error = state->script.last_error[0] != '\0'
                            ? state->script.last_error
                            : "Script failed";
    char message[192];
    snprintf(message, sizeof(message), "\r\n[Unable to start script: %s]\r\n",
             error);
    pipes_write_string(state->line_id, message);
    return;
  }

  script_process(&state->script);
}

static void script_stop_session(line_task_state *state) {
  if (state == NULL) {
    return;
  }

  /* Reset session clears both program and variables */
  script_reset_session(&state->script);
}

static void script_print_time(line_task_state *state) {
  time_t now;
  struct tm *local_tm;
  char formatted[64];
  char message[160];

  if (state == NULL) {
    return;
  }

  now = time(NULL);
  local_tm = localtime(&now);
  if (local_tm == NULL || strftime(formatted, sizeof(formatted),
                                   "%Y-%m-%d %H:%M:%S", local_tm) == 0) {
    pipes_write_string(state->line_id, "Unable to read system time.\r\n");
    return;
  }

  snprintf(message, sizeof(message), "Current time: %s\r\n", formatted);
  pipes_write_string(state->line_id, message);
}

static void script_print_line_info(line_task_state *state) {
  char message[192];
  const char *session =
      (state != NULL && state->session_active != 0) ? "connected" : "idle";
  const char *door_state;

  if (state == NULL) {
    return;
  }

  if (state->riscbbs.active != Desk_bool_FALSE) {
    door_state = "door running";
  } else if (state->riscbbs.launch_pending != Desk_bool_FALSE) {
    door_state = "door starting";
  } else {
    door_state = "no door";
  }

  snprintf(message, sizeof(message), "Line %d: %s, %s\r\n", state->line_id,
           session, door_state);
  pipes_write_string(state->line_id, message);
}

static void script_host_write(void *context, const char *text) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL || text == NULL) {
    return;
  }

  /* pipes_write_string handles both local and network mode */
  pipes_write_string(state->line_id, text);
}

static void script_host_launch_riscbbs_door(void *context,
                                            const char *command_line,
                                            int use_26bit) {
  line_task_state *state = (line_task_state *)context;
  if (state != NULL) {
    door_riscbbs_launch(state, command_line, use_26bit);
  }
}

static void script_host_launch_arcbbs_door(void *context, int door_number,
                                           const char *command_line,
                                           int use_26bit) {
  line_task_state *state = (line_task_state *)context;
  if (state != NULL) {
    door_arcbbs_launch(state, door_number, command_line, use_26bit);
  }
}

static void script_host_launch_door(void *context, const char *command_line,
                                    int use_26bit) {
  line_task_state *state = (line_task_state *)context;
  if (state != NULL) {
    door_native_launch(state, command_line, use_26bit);
  }
}

static void script_host_report_time(void *context) {
  script_print_time((line_task_state *)context);
}

static void script_host_report_line_info(void *context) {
  script_print_line_info((line_task_state *)context);
}

static void script_host_request_disconnect(void *context) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return;
  }

  pipes_write_string(state->line_id, "\r\n[Please hang up to disconnect]\r\n");
}

static void script_host_force_disconnect(void *context) {
  line_task_state *state = (line_task_state *)context;
  Desk_message_block message;

  if (state == NULL) {
    return;
  }

  if (state->session_active == 0) {
    return;
  }

  pipes_write_string(state->line_id, "\r\n[Disconnecting...]\r\n");

  /* Notify Server to close the socket connection */
  memset(&message, 0, sizeof(message));
  message.header.size = 32;
  message.header.action = (Desk_message_action)LINE_CONTROL_MESSAGE;
  message.data.words[0] = state->line_id;
  message.data.words[1] = LINE_CONTROL_REASON_LOGOFF;
  Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);

  /* Perform local session cleanup (clears user state, terminal, maininfo) */
  perform_session_disconnect(state);
}

static void script_host_report_activity(void *context, const char *text) {
  line_task_state *state = (line_task_state *)context;
  Desk_message_block message;
  size_t payload_len;
  size_t padded_len;
  char payload[LINE_ACTIVITY_MAX_TEXT];

  if (state == NULL) {
    return;
  }

  if (text == NULL) {
    text = "";
  }

  /* Store activity locally for maininfo pane */
  strncpy(state->user.current_activity, text,
          sizeof(state->user.current_activity) - 1);
  state->user.current_activity[sizeof(state->user.current_activity) - 1] = '\0';

  strncpy(payload, text, sizeof(payload) - 1);
  payload[sizeof(payload) - 1] = '\0';
  payload_len = strlen(payload);

  memset(&message, 0, sizeof(message));
  message.header.action = (Desk_message_action)LINE_ACTIVITY_MESSAGE;
  message.data.words[0] = state->line_id;
  memcpy(&message.data.bytes[4], payload, payload_len + 1);

  padded_len = (payload_len + 1 + 3) & ~3U;
  message.header.size = 24 + (int)padded_len;

  Desk_Wimp_SendMessage(Desk_event_SEND, &message, 0, NULL);

  /* Update maininfo pane */
  maininfo_update(state);

  if (payload_len > 0) {
    log_line_event(state->line_id, payload);
  }
}

static void script_host_report_online_users(void *context) {
  line_task_state *state = (line_task_state *)context;
  _kernel_swi_regs regs;
  _kernel_oserror *err;
  int line;
  char output[256];
  int found_any = 0;

  if (state == NULL) {
    return;
  }

  /* Print header */
  pipes_write_string(state->line_id, "\r\n");
  pipes_write_string(
      state->line_id,
      "Line  User                           Online  Activity\r\n");
  pipes_write_string(
      state->line_id,
      "----  ------------------------------  ------  --------\r\n");

  /* Query each line */
  for (line = 0; line < SUPPORT_MAX_LINES; line++) {
    int connected = 0;
    int user_id = 0;
    time_t connect_time = 0;
    const char *activity = "Online";
    int online_mins = 0;
    int online_secs = 0;
    char username[64];

    /* Check if line is connected */
    regs.r[0] = LINE_REASON_GET;
    regs.r[1] = line;
    regs.r[2] = LINE_FIELD_CONNECTED;
    err = _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
    if (err != NULL) {
      /* Module not loaded - bail out */
      pipes_write_string(state->line_id,
                         "[ConverseBBS module not available]\r\n");
      return;
    }
    connected = regs.r[0];

    if (connected == 0) {
      continue;
    }

    found_any = 1;

    /* Get user ID */
    regs.r[0] = LINE_REASON_GET;
    regs.r[1] = line;
    regs.r[2] = LINE_FIELD_USER_ID;
    if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL) {
      user_id = regs.r[0];
    }

    /* Look up user from Filer userdb */
    if (user_id > 0) {
      _kernel_swi_regs filer_regs;
      filer_regs.r[0] = FILER_USERDB_CMD_SEARCH;
      filer_regs.r[1] = user_id;
      if (_kernel_swi(SWI_CONVERSE_FILER_USERDB, &filer_regs, &filer_regs) ==
              NULL &&
          filer_regs.r[0] != 0) {
        /* USER_RECORD returned:
         * - realname at offset 36 (64 bytes)
         * - user_flags.sysop at offset 600 (int)
         */
        char *record_bytes = (char *)filer_regs.r[0];
        char realname[64];
        int is_sysop;

        strncpy(realname, record_bytes + 36, sizeof(realname) - 1);
        realname[sizeof(realname) - 1] = '\0';

        is_sysop = *((int *)(record_bytes + 600));

        if (realname[0] != '\0') {
          if (is_sysop) {
            snprintf(username, sizeof(username), "%s [SYSOP]", realname);
          } else {
            strncpy(username, realname, sizeof(username) - 1);
            username[sizeof(username) - 1] = '\0';
          }
        } else {
          /* No real name, fall back to username at offset 4 */
          strncpy(username, record_bytes + 4, sizeof(username) - 1);
          username[sizeof(username) - 1] = '\0';
          if (is_sysop) {
            char temp[64];
            strncpy(temp, username, sizeof(temp) - 1);
            temp[sizeof(temp) - 1] = '\0';
            snprintf(username, sizeof(username), "%s [SYSOP]", temp);
          }
        }
      } else {
        snprintf(username, sizeof(username), "User #%d", user_id);
      }
    } else {
      strcpy(username, "Guest");
    }

    /* Get connect time */
    regs.r[0] = LINE_REASON_GET;
    regs.r[1] = line;
    regs.r[2] = LINE_FIELD_CONNECT_TIME;
    if (_kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs) == NULL) {
      connect_time = (time_t)regs.r[0];
    }

    /* Calculate online duration */
    if (connect_time != 0) {
      time_t now = time(NULL);
      int elapsed = (int)(now - connect_time);
      if (elapsed < 0)
        elapsed = 0;
      online_mins = elapsed / 60;
      online_secs = elapsed % 60;
    }

    /* Get activity */
    regs.r[0] = ACTIVITY_REASON_GET;
    regs.r[1] = line;
    if (_kernel_swi(SWI_CONVERSEBBS_ACTIVITY, &regs, &regs) == NULL &&
        regs.r[0] != 0) {
      const char *act_ptr = (const char *)regs.r[0];
      if (act_ptr != NULL && act_ptr[0] != '\0') {
        activity = act_ptr;
      }
    }

    /* Format and output the line */
    snprintf(output, sizeof(output), "%-4d  %-30s  %02d:%02d   %s\r\n", line,
             username, online_mins, online_secs, activity);
    pipes_write_string(state->line_id, output);
  }

  if (found_any == 0) {
    pipes_write_string(state->line_id, "No users currently online.\r\n");
  }

  pipes_write_string(state->line_id, "\r\n");
}

static int script_host_get_line_id(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? state->line_id : -1;
}

static int script_host_get_task_handle(void *context) {
  Desk_UNUSED(context);
  return Desk_Event_taskhandle;
}

static void *script_host_get_filebase_session(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? &state->fb_session : NULL;
}

static void *script_host_get_messagebase_session(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? &state->mb_session : NULL;
}

static int script_host_get_user_accesslevel(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? state->user.accesslevel : 0;
}

static int script_host_get_user_sysop(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? state->user.sysop : 0;
}

static const char *script_host_get_user_keys(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? state->user.keys : "";
}

static const char *script_host_get_user_realname(void *context) {
  line_task_state *state = (line_task_state *)context;
  return (state != NULL) ? state->user.realname : "";
}

static int script_host_filebase_download(void *context, int base_id,
                                         int file_id) {
  line_task_state *state = (line_task_state *)context;
  long file_size = 0;
  char msg[128];

  if (state == NULL || base_id <= 0 || file_id <= 0) {
    return 0;
  }

  /* Get file size from Filer */
  if (!filebase_get_file_size(base_id, file_id, &file_size)) {
    return 0;
  }

  /* For now, just report the file is ready for download */
  /* Future: integrate with Xmodem/Ymodem/Zmodem transfer protocols */
  snprintf(msg, sizeof(msg), "\r\n[File ready for download: %ld bytes]\r\n",
           file_size);
  pipes_write_string(state->line_id, msg);

  return 1;
}

/*
 * Authenticate user via Filer module.
 * Returns 1 on success, 0 on failure.
 * auth_result is set to:
 *   0 = success
 *   1 = user not found
 *   2 = bad password
 *   3 = account locked
 */
static int script_host_authenticate_user(void *context, const char *username,
                                         const char *password,
                                         int *auth_result) {
  line_task_state *state = (line_task_state *)context;
  _kernel_swi_regs regs;
  _kernel_oserror *err;
  int result;
  int user_id;
  int access_level;
  const char *keys;
  char log_msg[128];

  if (state == NULL || username == NULL || password == NULL ||
      auth_result == NULL) {
    if (auth_result != NULL) {
      *auth_result = 1; /* User not found */
    }
    return 0;
  }

  /* Call Filer SWI 0x5AA41 with reason 4 (authenticate) */
  regs.r[0] = FILER_USERDB_CMD_AUTHENTICATE;
  regs.r[1] = (int)username;
  regs.r[2] = (int)password;

  err = _kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs);
  if (err != NULL) {
    debug_printf("script_host_authenticate_user: SWI error %s", err->errmess);
    *auth_result = 1; /* User not found (or module error) */
    return 0;
  }

  /* R0 = auth result, R1 = USER_RECORD pointer (if success) */
  result = regs.r[0];
  *auth_result = result;

  if (result != 0) {
    /* Authentication failed */
    snprintf(log_msg, sizeof(log_msg), "Login failed for '%s' (reason %d)",
             username, result);
    log_line_event(state->line_id, log_msg);
    return 0;
  }

  /* Authentication successful - extract user data from USER_RECORD */
  if (regs.r[1] != 0) {
/* USER_RECORD layout (from structs.h):
 * int id                   offset 0
 * char username[32]        offset 4
 * char realname[64]        offset 36
 * char email[64]           offset 100
 * char password[32]        offset 164
 * char keys[128]           offset 196
 * char userdir[256]        offset 324
 * USER_FLAGS               offset 580
 *   - sysop is 5 ints (20 bytes) into USER_FLAGS = offset 600
 *   - accesslevel is 15 ints (60 bytes) into USER_FLAGS = offset 640
 */
#define USER_RECORD_OFFSET_ID 0
#define USER_RECORD_OFFSET_USERNAME 4
#define USER_RECORD_OFFSET_REALNAME 36
#define USER_RECORD_OFFSET_KEYS 196
#define USER_RECORD_OFFSET_SYSOP 600
#define USER_RECORD_OFFSET_ACCESSLEVEL 640

    char *record_bytes = (char *)regs.r[1];
    const char *realname;
    const char *username_field;
    int is_sysop;

    user_id = *((int *)(record_bytes + USER_RECORD_OFFSET_ID));
    realname = record_bytes + USER_RECORD_OFFSET_REALNAME;
    username_field = record_bytes + USER_RECORD_OFFSET_USERNAME;
    keys = record_bytes + USER_RECORD_OFFSET_KEYS;
    is_sysop = *((int *)(record_bytes + USER_RECORD_OFFSET_SYSOP));
    access_level = *((int *)(record_bytes + USER_RECORD_OFFSET_ACCESSLEVEL));

    /* Update line state with user ID */
    {
      _kernel_swi_regs line_regs;
      line_regs.r[0] = LINE_REASON_SET;
      line_regs.r[1] = state->line_id;
      line_regs.r[2] = LINE_FIELD_USER_ID;
      line_regs.r[3] = user_id;
      _kernel_swi(SWI_CONVERSEBBS_LINE, &line_regs, &line_regs);
    }

    /* Store user info in task state */
    state->user.id = user_id;
    state->user.accesslevel = access_level;
    state->user.sysop = is_sysop;
    strncpy(state->user.keys, keys, sizeof(state->user.keys) - 1);
    state->user.keys[sizeof(state->user.keys) - 1] = '\0';
    state->user.realname[0] = '\0';
    if (realname != NULL && realname[0] != '\0') {
      strncpy(state->user.realname, realname, sizeof(state->user.realname) - 1);
      state->user.realname[sizeof(state->user.realname) - 1] = '\0';
    } else if (username_field != NULL && username_field[0] != '\0') {
      strncpy(state->user.realname, username_field,
              sizeof(state->user.realname) - 1);
      state->user.realname[sizeof(state->user.realname) - 1] = '\0';
    } else {
      snprintf(state->user.realname, sizeof(state->user.realname), "User #%d",
               user_id);
    }

    /* Load user's last accessed messagebase/filebase selections from
     * USER_HISTORY */
    {
/* USER_HISTORY offsets within USER_RECORD:
 * userdir ends at 580, user_flags is 76 bytes (19 ints), so user_history starts
 * at 656 */
#define USER_RECORD_OFFSET_HISTORY_MESSAGEBASE 656
#define USER_RECORD_OFFSET_HISTORY_MESSAGEBASEAREA 660
#define USER_RECORD_OFFSET_HISTORY_FILEBASE 664
#define USER_RECORD_OFFSET_HISTORY_FILEBASEAREA 668
/* USER_STATS offsets: starts at 672 (after USER_HISTORY) */
#define USER_RECORD_OFFSET_STATS_LASTLOGON 672
#define USER_RECORD_OFFSET_STATS_LASTSCAN 676
#define USER_RECORD_OFFSET_STATS_CALLS 680
#define USER_RECORD_OFFSET_STATS_TODAYTIME 684
#define USER_RECORD_OFFSET_STATS_UPLOADSKB 688
#define USER_RECORD_OFFSET_STATS_DOWNLOADSKB 692
#define USER_RECORD_OFFSET_STATS_UPLOADS 696
#define USER_RECORD_OFFSET_STATS_DOWNLOADS 700

      int last_messagebase =
          *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_MESSAGEBASE));
      int last_messagebasearea =
          *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_MESSAGEBASEAREA));
      int last_filebase =
          *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_FILEBASE));
      int last_filebasearea =
          *((int *)(record_bytes + USER_RECORD_OFFSET_HISTORY_FILEBASEAREA));

      /* Set filebase session state */
      state->fb_session.current_filebase = last_filebase;
      state->fb_session.current_area = last_filebasearea;
      state->fb_session.user_accesslevel = access_level;
      strncpy(state->fb_session.user_keys, state->user.keys,
              sizeof(state->fb_session.user_keys) - 1);
      state->fb_session.user_keys[sizeof(state->fb_session.user_keys) - 1] =
          '\0';

      /* Set messagebase session state */
      state->mb_session.current_messagebase = last_messagebase;
      state->mb_session.current_area = last_messagebasearea;
      state->mb_session.user_id = user_id;
      state->mb_session.user_accesslevel = access_level;
      strncpy(state->mb_session.user_keys, state->user.keys,
              sizeof(state->mb_session.user_keys) - 1);
      state->mb_session.user_keys[sizeof(state->mb_session.user_keys) - 1] =
          '\0';
      strncpy(state->mb_session.user_realname, state->user.realname,
              sizeof(state->mb_session.user_realname) - 1);
      state->mb_session
          .user_realname[sizeof(state->mb_session.user_realname) - 1] = '\0';

      /* Load user stats from USER_STATS */
      state->user.stats.lastlogon =
          *((time_t *)(record_bytes + USER_RECORD_OFFSET_STATS_LASTLOGON));
      state->user.stats.lastscan =
          *((time_t *)(record_bytes + USER_RECORD_OFFSET_STATS_LASTSCAN));
      state->user.stats.calls =
          *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_CALLS));
      state->user.stats.todaytime =
          *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_TODAYTIME));
      state->user.stats.uploadskb =
          *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_UPLOADSKB));
      state->user.stats.downloadskb =
          *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_DOWNLOADSKB));
      state->user.stats.uploads =
          *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_UPLOADS));
      state->user.stats.downloads =
          *((int *)(record_bytes + USER_RECORD_OFFSET_STATS_DOWNLOADS));

/* Load user flags from USER_FLAGS */
#define USER_RECORD_OFFSET_FLAGS_ANSI 584
#define USER_RECORD_OFFSET_FLAGS_MORE 588
#define USER_RECORD_OFFSET_FLAGS_LINES 592
#define USER_RECORD_OFFSET_FLAGS_CLS 596
#define USER_RECORD_OFFSET_FLAGS_EXPERT 612
#define USER_RECORD_OFFSET_FLAGS_NOLIMIT 620
#define USER_RECORD_OFFSET_FLAGS_INVISIBLE 624
#define USER_RECORD_OFFSET_FLAGS_CHATACCESS 632
#define USER_RECORD_OFFSET_FLAGS_RATIOS 644
#define USER_RECORD_OFFSET_FLAGS_MAXTIME 648
#define USER_RECORD_OFFSET_FLAGS_DEFAULTPROTOCOL 652

      state->user.flags.ansi =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_ANSI));
      state->user.flags.more =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_MORE));
      state->user.flags.lines =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_LINES));
      state->user.flags.cls =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_CLS));
      state->user.flags.expert =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_EXPERT));
      state->user.flags.nolimit =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_NOLIMIT));
      state->user.flags.invisible =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_INVISIBLE));
      state->user.flags.chataccess =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_CHATACCESS));
      state->user.flags.ratios =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_RATIOS));
      state->user.flags.maxtime =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_MAXTIME));
      state->user.flags.defaultprotocol =
          *((int *)(record_bytes + USER_RECORD_OFFSET_FLAGS_DEFAULTPROTOCOL));

      debug_printf("Loaded user history: fb=%d/%d mb=%d/%d", last_filebase,
                   last_filebasearea, last_messagebase, last_messagebasearea);
      debug_printf("Loaded user stats: calls=%d uploads=%d downloads=%d",
                   state->user.stats.calls, state->user.stats.uploads,
                   state->user.stats.downloads);
    }

    /* Send user name to Server to update status window */
    send_user_message(state->line_id, realname);

    /* Update maininfo pane with logged-in user info */
    maininfo_update(state);

    /* Update user stats: set lastlogon to now and increment calls */
    state->user.stats.lastlogon = time(NULL);
    state->user.stats.calls++;
    save_user_stats(state);

    snprintf(log_msg, sizeof(log_msg),
             "User '%s' logged in (id=%d, level=%d%s)", username, user_id,
             access_level, is_sysop ? ", sysop" : "");
    log_line_event(state->line_id, log_msg);

    /* Log the call (increments call counter) */
    {
      _kernel_swi_regs call_regs;
      call_regs.r[0] = FILER_LOG_REASON_CALL;
      call_regs.r[1] = state->line_id;
      call_regs.r[2] = user_id;
      call_regs.r[3] = CALL_STATUS_ANSWERED;
      _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &call_regs, &call_regs);
    }

    debug_printf("script_host_authenticate_user: success user_id=%d access=%d",
                 user_id, access_level);
  }

  return 1;
}

static void script_host_start_postlogon(void *context) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return;
  }

  script_start_postlogon(state);
}

static void script_host_start_newuser(void *context) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return;
  }

  script_start_newuser(state);
}

static const char *script_host_get_anykey_file(void *context) {
  return config_get_anykey_file();
}

static const char *script_host_get_more_file(void *context) {
  return config_get_more_file();
}

static const char *script_host_get_protocol_file(void *context) {
  return config_get_protocol_file();
}

static int script_host_start_transfer(void *context, int base_id, int file_id,
                                      int protocol) {
  line_task_state *state = (line_task_state *)context;
  int result;
  transfer_protocol proto;

  if (state == NULL) {
    return 0;
  }

  /* Map protocol number to enum */
  switch (protocol)
  {
    case 0:  proto = TRANSFER_PROTO_XMODEM;     break;
    case 1:  proto = TRANSFER_PROTO_XMODEM_CRC; break;
    case 2:  proto = TRANSFER_PROTO_XMODEM_1K;  break;
    case 3:  proto = TRANSFER_PROTO_YMODEM;     break;
    case 4:  proto = TRANSFER_PROTO_YMODEM_G;   break;
    case 5:  proto = TRANSFER_PROTO_ZMODEM;     break;
    default: proto = TRANSFER_PROTO_XMODEM_CRC; break;
  }

  /* Only XMODEM variants currently implemented */
  if (proto > TRANSFER_PROTO_XMODEM_1K) {
    pipes_write_string(state->line_id, "\r\n\033[1;31m[Protocol not yet implemented]\033[0m\r\n");
    return 0;
  }

  /* Clear any previous session */
  transfer_cleanup(&state->xfer_session);

  /* Initialise the send transfer */
  result = transfer_start_send(&state->xfer_session, state->line_id,
                                proto, base_id, file_id);
  
  if (result < 0) {
    char msg[128];
    snprintf(msg, sizeof(msg), "\r\n\033[1;31m[%s]\033[0m\r\n",
             state->xfer_session.error_msg[0] ? state->xfer_session.error_msg : "Transfer failed");
    pipes_write_string(state->line_id, msg);
    transfer_cleanup(&state->xfer_session);
    return 0;
  }

  debug_printf("main: started send transfer (base=%d, file=%d, proto=%d)\n",
               base_id, file_id, protocol);
  return 1;
}

static int script_host_start_receive_transfer(void *context,
                                              const char *temp_path,
                                              int protocol) {
  line_task_state *state = (line_task_state *)context;
  const char *filename;
  const char *description;
  int result;
  transfer_protocol proto;

  if (state == NULL) {
    return 0;
  }

  /* Map protocol number to enum */
  switch (protocol)
  {
    case 0:  proto = TRANSFER_PROTO_XMODEM;     break;
    case 1:  proto = TRANSFER_PROTO_XMODEM_CRC; break;
    case 2:  proto = TRANSFER_PROTO_XMODEM_1K;  break;
    case 3:  proto = TRANSFER_PROTO_YMODEM;     break;
    case 4:  proto = TRANSFER_PROTO_YMODEM_G;   break;
    case 5:  proto = TRANSFER_PROTO_ZMODEM;     break;
    default: proto = TRANSFER_PROTO_XMODEM_CRC; break;
  }

  /* Only XMODEM variants currently implemented */
  if (proto > TRANSFER_PROTO_XMODEM_1K) {
    pipes_write_string(state->line_id, "\r\n\033[1;31m[Protocol not yet implemented]\033[0m\r\n");
    return 0;
  }

  /* Get filename and description from script variables */
  filename = script_get_variable(&state->script, "_upload_filename");
  description = script_get_variable(&state->script, "_upload_description");
  
  if (filename == NULL || filename[0] == '\0') {
    pipes_write_string(state->line_id, "\r\n\033[1;31m[No filename specified]\033[0m\r\n");
    return 0;
  }

  /* Clear any previous session */
  transfer_cleanup(&state->xfer_session);

  /* Initialise the receive transfer - temp_path is set up inside transfer_start_receive */
  result = transfer_start_receive(&state->xfer_session, state->line_id,
                                   proto, filename, description ? description : "");
  
  if (result < 0) {
    char msg[128];
    snprintf(msg, sizeof(msg), "\r\n\033[1;31m[%s]\033[0m\r\n",
             state->xfer_session.error_msg[0] ? state->xfer_session.error_msg : "Transfer failed");
    pipes_write_string(state->line_id, msg);
    transfer_cleanup(&state->xfer_session);
    return 0;
  }

  debug_printf("main: started receive transfer (file=%s, proto=%d)\n",
               filename, protocol);
  return 1;
}

static int script_host_get_user_id(void *context) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return 0;
  }

  return state->user.id;
}

static const script_user_stats *script_host_get_user_stats(void *context) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return NULL;
  }

  return &state->user.stats;
}

static const script_user_flags *script_host_get_user_flags(void *context) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return NULL;
  }

  return &state->user.flags;
}

/* ********************************************************************************************************************************************************
 */
/* Maininfo Pane Functions */
/* ********************************************************************************************************************************************************
 */

static void maininfo_initialise(void) {
  /* Window already created in initialise_resources */
  maininfo_clear();
}

static void maininfo_shutdown(void) {
  if (maininfo_window_handle != 0) {
    Desk_Window_Delete(maininfo_window_handle);
    maininfo_window_handle = 0;
  }
}

static void maininfo_clear(void) {
  if (maininfo_window_handle == 0) {
    return;
  }

  /* Clear text fields */
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_LINE, "");
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_USERNAME, "");
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_USERID, "");
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_DOING, "");
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_KEYS, "");
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_TIME, "");
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_TOTALCALLS, "");

  /* Clear radio buttons */
  Desk_Icon_Deselect(maininfo_window_handle, MAININFO_SYSOP);
  Desk_Icon_Deselect(maininfo_window_handle, MAININFO_REGISTERED);
  Desk_Icon_Deselect(maininfo_window_handle, MAININFO_INVISIBLE);
}

/* Height of window scroll bar furniture in OS units */
#define MAININFO_SCROLLBAR_HEIGHT 40

static void maininfo_update_position(void) {
  Desk_window_state main_state;
  Desk_window_state pane_state;
  Desk_window_openblock open;
  int pane_width;
  int pane_height;

  if (maininfo_window_handle == 0 || main_window_handle == 0) {
    return;
  }

  /* Get current states */
  Desk_Wimp_GetWindowState(main_window_handle, &main_state);
  Desk_Wimp_GetWindowState(maininfo_window_handle, &pane_state);

  /* Calculate pane dimensions */
  pane_width = pane_state.openblock.screenrect.max.x -
               pane_state.openblock.screenrect.min.x;
  pane_height = pane_state.openblock.screenrect.max.y -
                pane_state.openblock.screenrect.min.y;

  /* If pane has no size yet, use main window width */
  if (pane_width <= 0) {
    pane_width = main_state.openblock.screenrect.max.x -
                 main_state.openblock.screenrect.min.x;
  }
  if (pane_height <= 0) {
    pane_height = 160; /* Default pane height */
  }

  /* Position pane at bottom of main window, below the scroll bar furniture */
  open.window = maininfo_window_handle;
  open.screenrect.min.x = main_state.openblock.screenrect.min.x;
  open.screenrect.max.x = main_state.openblock.screenrect.max.x;
  open.screenrect.max.y = main_state.openblock.screenrect.min.y -
                          MAININFO_SCROLLBAR_HEIGHT; /* Below scroll bar */
  open.screenrect.min.y = open.screenrect.max.y - pane_height;
  open.scroll.x = 0;
  open.scroll.y = 0;
  open.behind = main_state.openblock.behind;

  Desk_Wimp_OpenWindow(&open);
}

static void maininfo_update(line_task_state *state) {
  char buffer[64];
  time_t now;
  int elapsed;
  int hours, minutes, seconds;

  if (maininfo_window_handle == 0 || state == NULL) {
    return;
  }

  /* Line number */
  snprintf(buffer, sizeof(buffer), "%d", state->line_id);
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_LINE, buffer);

  /* Username */
  if (state->user.id > 0) {
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_USERNAME,
                      state->user.realname[0] ? state->user.realname
                                              : "(Unknown)");
  } else {
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_USERNAME,
                      "(Not logged in)");
  }

  /* User ID */
  if (state->user.id > 0) {
    snprintf(buffer, sizeof(buffer), "%d", state->user.id);
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_USERID, buffer);
  } else {
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_USERID, "");
  }

  /* Activity (DOING) */
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_DOING,
                    state->user.current_activity);

  /* Keys */
  Desk_Icon_SetText(maininfo_window_handle, MAININFO_KEYS, state->user.keys);

  /* Connect time (elapsed session time) */
  if (state->session_active && state->user.connect_time > 0) {
    now = time(NULL);
    elapsed = (int)(now - state->user.connect_time);
    hours = elapsed / 3600;
    minutes = (elapsed % 3600) / 60;
    seconds = elapsed % 60;
    snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d", hours, minutes, seconds);
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_TIME, buffer);
  } else {
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_TIME, "");
  }

  /* Sysop radio */
  if (state->user.sysop) {
    Desk_Icon_Select(maininfo_window_handle, MAININFO_SYSOP);
  } else {
    Desk_Icon_Deselect(maininfo_window_handle, MAININFO_SYSOP);
  }

  /* Registered radio - user is registered if logged in */
  if (state->user.id > 0) {
    Desk_Icon_Select(maininfo_window_handle, MAININFO_REGISTERED);
  } else {
    Desk_Icon_Deselect(maininfo_window_handle, MAININFO_REGISTERED);
  }

  /* Invisible radio - check user flag */
  if (state->user.flags.invisible) {
    Desk_Icon_Select(maininfo_window_handle, MAININFO_INVISIBLE);
  } else {
    Desk_Icon_Deselect(maininfo_window_handle, MAININFO_INVISIBLE);
  }

  /* Total calls from user stats */
  if (state->user.id > 0) {
    snprintf(buffer, sizeof(buffer), "%d", state->user.stats.calls);
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_TOTALCALLS, buffer);
  } else {
    Desk_Icon_SetText(maininfo_window_handle, MAININFO_TOTALCALLS, "");
  }
}

static void script_host_start_chat_pager(void *context, const char *reason) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL || reason == NULL) {
    return;
  }

  chat_start_pager(state, reason);
}

static void script_host_update_lastscan(void *context, time_t new_lastscan) {
  line_task_state *state = (line_task_state *)context;

  if (state == NULL) {
    return;
  }

  /* Update the local cached copy so subsequent saves include the new value */
  state->user.stats.lastscan = new_lastscan;
  debug_printf("script_host_update_lastscan: updated to %ld",
               (long)new_lastscan);
}

/*
 * Check if a username is available (not already taken).
 * Returns 1 if available, 0 if taken.
 */
static int script_host_check_username_available(void *context,
                                                const char *username) {
  _kernel_swi_regs regs;

  (void)context;

  if (username == NULL || username[0] == '\0') {
    return 0;
  }

  /* Call Filer SWI to find username */
  regs.r[0] = 7; /* FILER_USERDB_CMD_FIND_USERNAME */
  regs.r[1] = (int)username;

  if (_kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs) != NULL) {
    /* SWI error - assume not available for safety */
    return 0;
  }

  /* If r0 is 0, username was not found (available) */
  /* If r0 is non-zero, username exists (not available) */
  return (regs.r[0] == 0) ? 1 : 0;
}

/*
 * Create a new user account.
 * Returns the new user_id on success, 0 on failure.
 */
static int script_host_create_user(void *context, const char *username,
                                   const char *password, const char *realname,
                                   const char *email) {
  _kernel_swi_regs regs;
  line_task_state *state = (line_task_state *)context;

  /* Build a USER_RECORD on the stack */
  /* We need a structure matching the Filer's USER_RECORD */
  struct {
    int id;
    char username[32];
    char realname[64];
    char email[64];
    char password[32];
    char keys[128];
    char userdir[256];
    /* USER_FLAGS (76 bytes based on struct) */
    int deleted;
    int ansi;
    int more;
    int lines;
    int cls;
    int sysop;
    int cli;
    int registered;
    int expert;
    int lockedout;
    int nolimit;
    int invisible;
    int userdir_flag;
    int chataccess;
    int resettime;
    int accesslevel;
    int ratios;
    int maxtime;
    int defaultprotocol;
    /* USER_HISTORY (16 bytes) */
    int messagebase;
    int messagebasearea;
    int filebase;
    int filebasearea;
    /* USER_STATS (32 bytes) */
    time_t lastlogon;
    time_t lastscan;
    int calls;
    int todaytime;
    int uploadskb;
    int downloadskb;
    int uploads;
    int downloads;
  } user_record;

  if (username == NULL || password == NULL || realname == NULL) {
    return 0;
  }

  /* Zero out the record */
  memset(&user_record, 0, sizeof(user_record));

  /* Fill in the user data */
  user_record.id = 0; /* 0 means assign next available ID */
  strncpy(user_record.username, username, sizeof(user_record.username) - 1);
  strncpy(user_record.realname, realname, sizeof(user_record.realname) - 1);
  if (email != NULL) {
    strncpy(user_record.email, email, sizeof(user_record.email) - 1);
  }
  strncpy(user_record.password, password, sizeof(user_record.password) - 1);

  /* Set reasonable defaults for a new user */
  user_record.deleted = 0;
  user_record.ansi = 1;            /* Assume ANSI terminal */
  user_record.more = 1;            /* Enable more prompts */
  user_record.lines = 24;          /* Standard screen height */
  user_record.cls = 1;             /* Allow screen clearing */
  user_record.sysop = 0;           /* Not a sysop */
  user_record.cli = 0;             /* No CLI access */
  user_record.registered = 1;      /* Is registered */
  user_record.expert = 0;          /* Not expert mode */
  user_record.lockedout = 0;       /* Not locked out */
  user_record.nolimit = 0;         /* Has time limits */
  user_record.invisible = 0;       /* Visible */
  user_record.userdir_flag = 0;    /* No user directory */
  user_record.chataccess = 0;      /* Normal chat access */
  user_record.resettime = 0;       /* Don't reset time */
  user_record.accesslevel = 10;    /* Default access level for new users */
  user_record.ratios = 0;          /* No ratio enforcement */
  user_record.maxtime = 60;        /* 60 minutes per day */
  user_record.defaultprotocol = 5; /* ZMODEM */

  /* Stats */
  user_record.lastlogon = time(NULL);
  user_record.lastscan = time(NULL);
  user_record.calls = 0;

  /* Call Filer SWI to add the user */
  regs.r[0] = 0; /* FILER_USERDB_CMD_ADD */
  regs.r[1] = (int)&user_record;

  if (_kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs) != NULL) {
    debug_printf("script_host_create_user: SWI error");
    return 0;
  }

  /* r0 contains the new user ID, or 0/-1 on failure */
  if (regs.r[0] <= 0) {
    debug_printf("script_host_create_user: add failed, r0=%d", regs.r[0]);
    return 0;
  }

  debug_printf("script_host_create_user: created user %s with id %d", username,
               regs.r[0]);

  /* Log the new user registration */
  if (state != NULL) {
    char log_msg[128];
    snprintf(log_msg, sizeof(log_msg), "New user registered: %s (%s)", username,
             realname);
    log_line_event(state->line_id, log_msg);
  }

  return regs.r[0];
}

static Desk_bool handle_chatpager_click(Desk_event_pollblock *event,
                                        void *ref) {
  line_task_state *state = (line_task_state *)ref;
  int icon;

  if (event == NULL || state == NULL) {
    return Desk_bool_FALSE;
  }

  icon = event->data.mouse.icon;

  if (icon == CHATPAGER_START) {
    /* Start chat */
    chat_close_pager(state, 1);
    return Desk_bool_TRUE;
  }

  if (icon == CHATPAGER_IGNORE) {
    /* Ignore/cancel */
    chat_close_pager(state, 0);
    return Desk_bool_TRUE;
  }

  return Desk_bool_FALSE;
}

static Desk_bool handle_chat_click(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;
  int icon;

  if (event == NULL || state == NULL) {
    return Desk_bool_FALSE;
  }

  icon = event->data.mouse.icon;

  if (icon == CHAT_ENDCHAT) {
    chat_end_session(state);
    return Desk_bool_TRUE;
  }

  if (icon == CHAT_SAVECHAT) {
    /* TODO: Implement save chat log */
    return Desk_bool_TRUE;
  }

  return Desk_bool_FALSE;
}

static Desk_bool handle_maininfo_click(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;
  int icon;

  if (event == NULL || state == NULL) {
    return Desk_bool_FALSE;
  }

  icon = event->data.mouse.icon;

  if (icon == MAININFO_DISCONNECT) {
    /* Disconnect the current user */
    if (state->session_active) {
      perform_session_disconnect(state);
    }
    return Desk_bool_TRUE;
  }

  if (icon == MAININFO_CHAT) {
    /* Start chat with the user (if logged in) */
    if (state->user.id > 0 && !state->chat.active) {
      chat_start_pager(state, "Sysop initiated chat");
    }
    return Desk_bool_TRUE;
  }

  return Desk_bool_FALSE;
}

static Desk_bool handle_chat_key(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;
  int key;

  if (event == NULL || state == NULL) {
    return Desk_bool_FALSE;
  }

  key = event->data.key.code;

  /* Handle Return in sysop field - send the line */
  if (key == 13 && state->chat.active) {
    char buffer[64];
    char line_text[1024];

    Desk_Icon_GetText(chat_window_handle, CHAT_CHAT, line_text);
    if (line_text[0] == '\0') {
      return Desk_bool_TRUE;
    }
    chat_send_sysop_line(state, line_text);

    state->chat.sysop_row++;
    if (state->chat.sysop_row > 11) {
      state->chat.sysop_row = 11;
    }

    state->chat.sysop_buffer[0] = '\0';
    state->chat.sysop_len = 0;

    Desk_Icon_SetText(chat_window_handle, CHAT_CHAT, "");

    snprintf(buffer, sizeof(buffer), "\033[s\033[%d;8H\033[K\033[u",
             state->chat.sysop_row);
    pipes_write_string(state->line_id, buffer);

    Desk_Icon_SetCaret(chat_window_handle, CHAT_CHAT);

    return Desk_bool_TRUE;
  }

  /* Pass other keys to Wimp */
  Desk_Wimp_ProcessKey(key);
  return Desk_bool_TRUE;
}

/* Make log_line_event non-static so transfer.c can use it */
void log_line_event(int line_id, const char *message) {
  _kernel_swi_regs regs;

  if (line_id < 0 || message == NULL || *message == '\0') {
    return;
  }

  memset(&regs, 0, sizeof(regs));
  regs.r[0] = FILER_LOG_REASON_LINE;
  regs.r[1] = line_id;
  regs.r[2] = (int)message;
  _kernel_swi(SWI_CONVERSE_FILER_LOGGING, &regs, &regs);
}

/* Save user statistics to the Filer module.
 * Call this after modifying state->user.stats to persist changes.
 */
static void save_user_stats(line_task_state *state) {
  _kernel_swi_regs regs;

  /* Structure to pass to Filer - must match USER_STATS layout */
  struct {
    time_t lastlogon;
    time_t lastscan;
    int calls;
    int todaytime;
    int uploadskb;
    int downloadskb;
    int uploads;
    int downloads;
  } stats_block;

  if (state == NULL || state->user.id <= 0) {
    return;
  }

  /* Copy current stats to block */
  stats_block.lastlogon = state->user.stats.lastlogon;
  stats_block.lastscan = state->user.stats.lastscan;
  stats_block.calls = state->user.stats.calls;
  stats_block.todaytime = state->user.stats.todaytime;
  stats_block.uploadskb = state->user.stats.uploadskb;
  stats_block.downloadskb = state->user.stats.downloadskb;
  stats_block.uploads = state->user.stats.uploads;
  stats_block.downloads = state->user.stats.downloads;

  /* SWI Filer_Userdb with UPDATE_STATS command (reason 6) */
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = 6; /* FILER_USERDB_CMD_UPDATE_STATS */
  regs.r[1] = state->user.id;
  regs.r[2] = (int)&stats_block;

  if (_kernel_swi(SWI_CONVERSE_FILER_USERDB, &regs, &regs) == NULL &&
      regs.r[0] == 1) {
    debug_printf("save_user_stats: Updated stats for user %d", state->user.id);
  } else {
    debug_printf("save_user_stats: Failed to update stats for user %d",
                 state->user.id);
  }
}

/* ========================================================================
 * ANSI Terminal Implementation
 * ======================================================================== */

static void terminal_send_input(int line_id, const char *data, int len) {
  pipes_inject_input(line_id, data, len);
}

static void terminal_init(line_task_state *state) {
  if (state == NULL) {
    return;
  }

  /* Allocate terminal state */
  state->terminal = (ansiterm_state *)malloc(sizeof(ansiterm_state));
  if (state->terminal == NULL) {
    debug_printf("terminal_init: Failed to allocate terminal state");
    return;
  }

  ansiterm_init(state->terminal, state->line_id);
  state->terminal->send_input = terminal_send_input;

  /* Load font if available */
  ansiterm_load_font(state->terminal, "<Converse$Dir>.Resources.Font");
}

static void terminal_finalise(line_task_state *state) {
  if (state == NULL || state->terminal == NULL) {
    return;
  }

  ansiterm_finalise(state->terminal);
  free(state->terminal);
  state->terminal = NULL;
}

static void terminal_feed_output(line_task_state *state, const char *data,
                                 int len) {
  if (state == NULL || state->terminal == NULL || data == NULL || len <= 0) {
    return;
  }

  /* Only feed to terminal if snoop mode is active */
  if (state->terminal->snoop_mode) {
    ansiterm_process_block(state->terminal, (const unsigned char *)data, len);
    ansiterm_update_dirty(state->terminal);
  }
}

static Desk_bool handle_terminal_redraw(Desk_event_pollblock *event,
                                        void *ref) {
  line_task_state *state = (line_task_state *)ref;

  if (event == NULL || state == NULL || state->terminal == NULL) {
    return Desk_bool_FALSE;
  }

  ansiterm_redraw(state->terminal, &event->data);
  return Desk_bool_TRUE;
}

static Desk_bool handle_terminal_key(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;
  int key_code;
  int result;

  if (event == NULL || state == NULL || state->terminal == NULL) {
    return Desk_bool_FALSE;
  }

  /* If not in input mode, pass key through */
  if (!state->terminal->input_mode) {
    Desk_Wimp_ProcessKey(event->data.key.code);
    return Desk_bool_TRUE;
  }

  key_code = event->data.key.code;
  result = ansiterm_keypress(state->terminal, key_code);

  if (result > 0) {
    /* Send the character to the input pipe (so script receives it) */
    char ch = (char)result;
    pipes_inject_input(state->line_id, &ch, 1);

    /* Local echo removed - rely on remote echo */
  } else if (result < 0) {
    /* Arrow keys - send ANSI escape sequences */
    const char *seq = NULL;
    switch (result) {
    case -1:
      seq = "\033[A";
      break; /* Up */
    case -2:
      seq = "\033[B";
      break; /* Down */
    case -3:
      seq = "\033[C";
      break; /* Right */
    case -4:
      seq = "\033[D";
      break; /* Left */
    }
    if (seq) {
      pipes_inject_input(state->line_id, seq, 3);

      /* Local echo removed - rely on remote echo */
    }
  } else {
    /* Key not handled - pass to Wimp */
    Desk_Wimp_ProcessKey(key_code);
  }

  return Desk_bool_TRUE;
}

static Desk_bool handle_terminal_click(Desk_event_pollblock *event, void *ref) {
  line_task_state *state = (line_task_state *)ref;

  if (event == NULL || state == NULL) {
    return Desk_bool_FALSE;
  }

  /* Claim caret on click */
  Desk_Window_GainCaret(event->data.mouse.window);

  return Desk_bool_TRUE;
}
