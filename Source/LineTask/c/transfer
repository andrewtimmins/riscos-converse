/* ******************************************************************************************************************************************************** */
/* LineTask File Transfer Module                                                                                                                              */
/*                                                                                                                                                            */
/* Dispatcher and common utilities for file transfer protocols.                                                                                               */
/* Protocol-specific code lives in separate files (xmodem.c, ymodem.c, zmodem.c).                                                                             */
/* ******************************************************************************************************************************************************** */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <kernel.h>
#include <swis.h>

#include "transfer.h"
#include "xmodem.h"
#include "pipes.h"
#include "crc.h"
#include "debug.h"

/* ******************************************************************************************************************************************************** */
/* Support Module SWI Definitions (for transfer_active flag)                                                                                                  */
/* ******************************************************************************************************************************************************** */

#define SWI_CONVERSEBBS_LINE            0x5AA81
#define LINE_REASON_SET                 0
#define LINE_FIELD_TRANSFER             5

/* ******************************************************************************************************************************************************** */
/* Filer SWI Definitions                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

#define SWI_CONVERSE_FILER_FILEBASE     0x5AA43

#define FILER_FILEBASE_CMD_DOWNLOAD     5
#define FILER_FILEBASE_CMD_FILE_INFO    11

/* FILE_RECORD field offsets */
#define FILE_RECORD_OFFSET_ID           0
#define FILE_RECORD_OFFSET_FILEBASEID   4
#define FILE_RECORD_OFFSET_AREAID       8
#define FILE_RECORD_OFFSET_DELETED      12
#define FILE_RECORD_OFFSET_ACCESSLEVEL  16
#define FILE_RECORD_OFFSET_KEYS         20
#define FILE_RECORD_OFFSET_NAME         148
#define FILE_RECORD_OFFSET_DESCRIPTION  220
#define FILE_RECORD_OFFSET_FILESIZE     476

/* ******************************************************************************************************************************************************** */
/* Module Initialisation                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

void transfer_init(void)
{
    debug_printf("transfer: module initialised\n");
}

/* ******************************************************************************************************************************************************** */
/* Transfer State Notification                                                                                                                                */
/* ******************************************************************************************************************************************************** */

/*
 * Notify the Support module that a transfer is active/inactive on this line.
 * This tells the Server to skip telnet filtering during binary transfers.
 */
static void transfer_set_active_flag(int line, int active)
{
    _kernel_swi_regs regs;
    
    regs.r[0] = LINE_REASON_SET;
    regs.r[1] = line;
    regs.r[2] = LINE_FIELD_TRANSFER;
    regs.r[3] = active;
    _kernel_swi(SWI_CONVERSEBBS_LINE, &regs, &regs);
    
    debug_printf("transfer: set transfer_active=%d for line %d\n", active, line);
}

/* ******************************************************************************************************************************************************** */
/* Session Initialisation Helper                                                                                                                              */
/* ******************************************************************************************************************************************************** */

static void transfer_init_session(transfer_session *session)
{
    memset(session, 0, sizeof(transfer_session));
    session->state = XFER_IDLE;
    session->result = XFER_RESULT_OK;
}

/* ******************************************************************************************************************************************************** */
/* Start Sending (Download to User)                                                                                                                           */
/* ******************************************************************************************************************************************************** */

int transfer_start_send(transfer_session *session, int line,
                        transfer_protocol protocol, int filebase_id, int file_id)
{
    _kernel_swi_regs regs;
    char *record_ptr;
    
    if (session == NULL)
    {
        return -1;
    }
    
    transfer_init_session(session);
    
    session->line = line;
    session->protocol = protocol;
    session->direction = TRANSFER_DIR_SEND;
    session->filebase_id = filebase_id;
    session->file_id = file_id;
    
    /* Query file info from Filer */
    regs.r[0] = FILER_FILEBASE_CMD_FILE_INFO;
    regs.r[1] = filebase_id;
    regs.r[2] = file_id;
    
    if (_kernel_swi(SWI_CONVERSE_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        snprintf(session->error_msg, sizeof(session->error_msg), "File database error");
        session->state = XFER_ERROR;
        session->result = XFER_RESULT_FILE_ERROR;
        return -1;
    }
    
    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        snprintf(session->error_msg, sizeof(session->error_msg), "File not found");
        session->state = XFER_ERROR;
        session->result = XFER_RESULT_FILE_ERROR;
        return -1;
    }
    
    record_ptr = (char *)regs.r[0];
    
    /* Check if file is deleted */
    if (*(int *)(record_ptr + FILE_RECORD_OFFSET_DELETED) != 0)
    {
        snprintf(session->error_msg, sizeof(session->error_msg), "File has been deleted");
        session->state = XFER_ERROR;
        session->result = XFER_RESULT_FILE_ERROR;
        return -1;
    }
    
    /* Extract file info */
    strncpy(session->filename, record_ptr + FILE_RECORD_OFFSET_NAME, TRANSFER_MAX_FILENAME - 1);
    session->filename[TRANSFER_MAX_FILENAME - 1] = '\0';
    session->file_size = *(long *)(record_ptr + FILE_RECORD_OFFSET_FILESIZE);
    
    debug_printf("transfer: starting send of '%s' (%ld bytes) via protocol %d\n",
                 session->filename, session->file_size, protocol);
    
    /* Initialise protocol-specific state */
    switch (protocol)
    {
        case TRANSFER_PROTO_XMODEM:
        case TRANSFER_PROTO_XMODEM_CRC:
        case TRANSFER_PROTO_XMODEM_1K:
            if (xmodem_init_send(session) != 0)
            {
                return -1;
            }
            break;
            
        case TRANSFER_PROTO_YMODEM:
        case TRANSFER_PROTO_YMODEM_G:
        case TRANSFER_PROTO_ZMODEM:
            snprintf(session->error_msg, sizeof(session->error_msg), "Protocol not implemented");
            session->state = XFER_ERROR;
            session->result = XFER_RESULT_PROTOCOL_ERROR;
            return -1;
            
        default:
            snprintf(session->error_msg, sizeof(session->error_msg), "Unknown protocol");
            session->state = XFER_ERROR;
            session->result = XFER_RESULT_PROTOCOL_ERROR;
            return -1;
    }
    
    session->active = 1;
    session->state = XFER_ACTIVE;
    session->start_time = transfer_get_time();
    
    /* Clear any pending output data before enabling binary mode.
     * This prevents leftover text data from contaminating the XMODEM stream.
     * The text has already been written by the script but may not have been
     * pumped to the socket yet. Clearing ensures clean binary data. */
    {
        int space_free = pipes_space_available(line);
        int pending = 4096 - space_free;  /* Pipe buffer is 4096 bytes */
        debug_printf("transfer: pipe check - space_free=%d, pending=%d\n", space_free, pending);
        if (pending > 0)
        {
            debug_printf("transfer: clearing %d pending bytes from output pipe\n", pending);
            pipes_clear_output(line);
        }
    }
    
    /* Notify Support module - disables telnet filtering for binary data */
    transfer_set_active_flag(line, 1);
    debug_printf("transfer: set transfer_active=1 for line %d\n", line);
    
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Start Receiving (Upload from User)                                                                                                                         */
/* ******************************************************************************************************************************************************** */

int transfer_start_receive(transfer_session *session, int line,
                           transfer_protocol protocol,
                           const char *filename, const char *description)
{
    FILE *fp;
    
    if (session == NULL)
    {
        return -1;
    }
    
    /* XMODEM requires filename to be provided */
    if ((protocol == TRANSFER_PROTO_XMODEM || 
         protocol == TRANSFER_PROTO_XMODEM_CRC ||
         protocol == TRANSFER_PROTO_XMODEM_1K) &&
        (filename == NULL || filename[0] == '\0'))
    {
        snprintf(session->error_msg, sizeof(session->error_msg), "XMODEM requires filename");
        session->state = XFER_ERROR;
        session->result = XFER_RESULT_PROTOCOL_ERROR;
        return -1;
    }
    
    transfer_init_session(session);
    
    session->line = line;
    session->protocol = protocol;
    session->direction = TRANSFER_DIR_RECEIVE;
    
    /* Store filename and description */
    if (filename != NULL)
    {
        strncpy(session->filename, filename, TRANSFER_MAX_FILENAME - 1);
        session->filename[TRANSFER_MAX_FILENAME - 1] = '\0';
    }
    
    if (description != NULL)
    {
        strncpy(session->description, description, TRANSFER_MAX_DESCRIPTION - 1);
        session->description[TRANSFER_MAX_DESCRIPTION - 1] = '\0';
    }
    
    /* Generate temp file path */
    snprintf(session->temp_path, sizeof(session->temp_path),
             "<Converse$Dir>.Temp.Upload_%d_%lx", line, (unsigned long)time(NULL));
    
    /* Create temp file */
    fp = fopen(session->temp_path, "wb");
    if (fp == NULL)
    {
        snprintf(session->error_msg, sizeof(session->error_msg), "Cannot create temp file");
        session->state = XFER_ERROR;
        session->result = XFER_RESULT_FILE_ERROR;
        return -1;
    }
    session->file_handle = fp;
    
    debug_printf("transfer: starting receive of '%s' to '%s' via protocol %d\n",
                 session->filename, session->temp_path, protocol);
    
    /* Initialise protocol-specific state */
    switch (protocol)
    {
        case TRANSFER_PROTO_XMODEM:
        case TRANSFER_PROTO_XMODEM_CRC:
        case TRANSFER_PROTO_XMODEM_1K:
            if (xmodem_init_receive(session) != 0)
            {
                fclose(fp);
                session->file_handle = NULL;
                remove(session->temp_path);
                return -1;
            }
            break;
            
        case TRANSFER_PROTO_YMODEM:
        case TRANSFER_PROTO_YMODEM_G:
        case TRANSFER_PROTO_ZMODEM:
            fclose(fp);
            session->file_handle = NULL;
            remove(session->temp_path);
            snprintf(session->error_msg, sizeof(session->error_msg), "Protocol not implemented");
            session->state = XFER_ERROR;
            session->result = XFER_RESULT_PROTOCOL_ERROR;
            return -1;
            
        default:
            fclose(fp);
            session->file_handle = NULL;
            remove(session->temp_path);
            snprintf(session->error_msg, sizeof(session->error_msg), "Unknown protocol");
            session->state = XFER_ERROR;
            session->result = XFER_RESULT_PROTOCOL_ERROR;
            return -1;
    }
    
    session->active = 1;
    session->state = XFER_ACTIVE;
    session->start_time = transfer_get_time();
    
    /* Notify Support module - disables telnet filtering for binary data */
    transfer_set_active_flag(line, 1);
    
    return 0;
}

/* ******************************************************************************************************************************************************** */
/* Poll Transfer                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

int transfer_poll(transfer_session *session)
{
    int result;
    
    if (session == NULL || !session->active)
    {
        return 0;
    }
    
    /* Check for cancel request */
    if (session->cancel_requested)
    {
        debug_printf("transfer: cancel requested\n");
        session->state = XFER_ERROR;
        session->result = XFER_RESULT_CANCELLED;
        session->active = 0;
        transfer_set_active_flag(session->line, 0);
        return 0;
    }
    
    /* Dispatch to protocol handler */
    switch (session->protocol)
    {
        case TRANSFER_PROTO_XMODEM:
        case TRANSFER_PROTO_XMODEM_CRC:
        case TRANSFER_PROTO_XMODEM_1K:
            result = xmodem_poll(session);
            break;
            
        default:
            result = 0;
            session->state = XFER_ERROR;
            session->result = XFER_RESULT_PROTOCOL_ERROR;
            break;
    }
    
    /* Check if transfer completed */
    if (session->state == XFER_COMPLETE || session->state == XFER_ERROR)
    {
        session->active = 0;
        transfer_set_active_flag(session->line, 0);
        
        /* Close temp file if receiving */
        if (session->file_handle != NULL)
        {
            fclose((FILE *)session->file_handle);
            session->file_handle = NULL;
        }
        
        /* Delete temp file on error */
        if (session->state == XFER_ERROR && session->direction == TRANSFER_DIR_RECEIVE)
        {
            remove(session->temp_path);
        }
        
        return 0;
    }
    
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Cancel Transfer                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

void transfer_cancel(transfer_session *session)
{
    if (session != NULL && session->active)
    {
        session->cancel_requested = 1;
    }
}

/* ******************************************************************************************************************************************************** */
/* Cleanup                                                                                                                                                    */
/* ******************************************************************************************************************************************************** */

void transfer_cleanup(transfer_session *session)
{
    if (session == NULL)
    {
        return;
    }
    
    /* Clear transfer active flag if was active */
    if (session->active)
    {
        transfer_set_active_flag(session->line, 0);
    }
    
    /* Close temp file if still open */
    if (session->file_handle != NULL)
    {
        fclose((FILE *)session->file_handle);
        session->file_handle = NULL;
    }
    
    /* Free protocol state */
    if (session->protocol_state != NULL)
    {
        switch (session->protocol)
        {
            case TRANSFER_PROTO_XMODEM:
            case TRANSFER_PROTO_XMODEM_CRC:
            case TRANSFER_PROTO_XMODEM_1K:
                xmodem_cleanup(session);
                break;
                
            default:
                free(session->protocol_state);
                break;
        }
        session->protocol_state = NULL;
    }
    
    session->active = 0;
}

/* ******************************************************************************************************************************************************** */
/* Status Queries                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

int transfer_is_active(transfer_session *session)
{
    return (session != NULL && session->active);
}

int transfer_get_progress(transfer_session *session)
{
    if (session == NULL || session->file_size == 0)
    {
        return -1;
    }
    
    return (int)((session->bytes_transferred * 100) / session->file_size);
}

void transfer_get_status(transfer_session *session, char *buffer, int buffer_size)
{
    if (session == NULL)
    {
        snprintf(buffer, buffer_size, "No session");
        return;
    }
    
    switch (session->state)
    {
        case XFER_IDLE:
            snprintf(buffer, buffer_size, "Idle");
            break;
            
        case XFER_ACTIVE:
            if (session->file_size > 0)
            {
                snprintf(buffer, buffer_size, "%s %ld/%ld bytes",
                         session->direction == TRANSFER_DIR_SEND ? "Sending" : "Receiving",
                         session->bytes_transferred, session->file_size);
            }
            else
            {
                snprintf(buffer, buffer_size, "%s %ld bytes",
                         session->direction == TRANSFER_DIR_SEND ? "Sending" : "Receiving",
                         session->bytes_transferred);
            }
            break;
            
        case XFER_COMPLETE:
            snprintf(buffer, buffer_size, "Complete");
            break;
            
        case XFER_ERROR:
            snprintf(buffer, buffer_size, "Error: %s", session->error_msg);
            break;
    }
}

const char *transfer_get_filename(transfer_session *session)
{
    if (session == NULL)
    {
        return "";
    }
    return session->filename;
}

const char *transfer_get_temp_path(transfer_session *session)
{
    if (session == NULL)
    {
        return "";
    }
    return session->temp_path;
}

/* ******************************************************************************************************************************************************** */
/* Timer Utilities                                                                                                                                            */
/* ******************************************************************************************************************************************************** */

uint32_t transfer_get_time(void)
{
    _kernel_swi_regs regs;
    _kernel_swi(0x42, &regs, &regs);  /* OS_ReadMonotonicTime */
    return (uint32_t)regs.r[0];
}

void transfer_set_timeout(transfer_session *session, int centiseconds)
{
    if (session != NULL)
    {
        session->timeout_target = transfer_get_time() + centiseconds;
    }
}

int transfer_timeout_expired(transfer_session *session)
{
    if (session == NULL)
    {
        return 1;
    }
    return (transfer_get_time() >= session->timeout_target);
}

/* ******************************************************************************************************************************************************** */
/* File I/O                                                                                                                                                   */
/* ******************************************************************************************************************************************************** */

int transfer_read_file_block(transfer_session *session, uint8_t *buffer,
                             long offset, int length)
{
    _kernel_swi_regs regs;
    
    if (session == NULL || buffer == NULL)
    {
        return -1;
    }
    
    /* Use Filer SWI to read from filebase */
    regs.r[0] = FILER_FILEBASE_CMD_DOWNLOAD;
    regs.r[1] = session->filebase_id;
    regs.r[2] = session->file_id;
    regs.r[3] = (int)buffer;
    regs.r[4] = offset;
    regs.r[5] = length;
    
    if (_kernel_swi(SWI_CONVERSE_FILER_FILEBASE, &regs, &regs) != NULL)
    {
        debug_printf("transfer: file read error at offset %ld\n", offset);
        return -1;
    }
    
    return regs.r[0];  /* Returns bytes read */
}

int transfer_write_file_block(transfer_session *session, const uint8_t *data, int length)
{
    FILE *fp;
    size_t written;
    
    if (session == NULL || data == NULL || session->file_handle == NULL)
    {
        return -1;
    }
    
    fp = (FILE *)session->file_handle;
    written = fwrite(data, 1, length, fp);
    
    if (written != (size_t)length)
    {
        debug_printf("transfer: file write error\n");
        return -1;
    }
    
    return (int)written;
}

long transfer_get_file_size(transfer_session *session)
{
    if (session == NULL)
    {
        return 0;
    }
    return session->file_size;
}
