/* ******************************************************************************************************************************************************** */
/* LineTask Messagebase Support                                                                                                                             */
/*                                                                                                                                                          */
/* Provides messagebase browsing, message viewing, and composition via the Filer module SWIs.                                                               */
/* ******************************************************************************************************************************************************** */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "kernel.h"
#include "swis.h"

#include "messagebase.h"
#include "debug.h"

/* Safety limit for enumeration loops to prevent infinite loops on corrupted data */
#define MAX_ENUM_ITERATIONS 100000

/* ******************************************************************************************************************************************************** */
/* Session Management                                                                                                                                       */
/* ******************************************************************************************************************************************************** */

void messagebase_session_init(messagebase_session *session)
{
    if (session == NULL)
    {
        return;
    }

    memset(session, 0, sizeof(messagebase_session));
}

void messagebase_session_reset(messagebase_session *session)
{
    if (session == NULL)
    {
        return;
    }

    session->current_messagebase = 0;
    session->current_area = 0;
    memset(&session->viewer, 0, sizeof(session->viewer));
    memset(&session->composer, 0, sizeof(session->composer));
}

void messagebase_session_set_access(messagebase_session *session, int user_id,
                                    int accesslevel, const char *keys, const char *realname)
{
    if (session == NULL)
    {
        return;
    }

    session->user_id = user_id;
    session->user_accesslevel = accesslevel;

    if (keys != NULL)
    {
        strncpy(session->user_keys, keys, sizeof(session->user_keys) - 1);
        session->user_keys[sizeof(session->user_keys) - 1] = '\0';
    }
    else
    {
        session->user_keys[0] = '\0';
    }

    /* Only update realname if provided - don't clear existing value */
    if (realname != NULL && realname[0] != '\0')
    {
        strncpy(session->user_realname, realname, sizeof(session->user_realname) - 1);
        session->user_realname[sizeof(session->user_realname) - 1] = '\0';
    }
}

/* ******************************************************************************************************************************************************** */
/* SWI Wrappers                                                                                                                                             */
/* ******************************************************************************************************************************************************** */

int messagebase_get_info(int base_id, LINETASK_MESSAGEBASE_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_RECORD *result;

    if (base_id <= 0 || record_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_INFO;
    regs.r[1] = base_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    result = (LINETASK_MESSAGEBASE_RECORD *)regs.r[0];
    memcpy(record_out, result, sizeof(LINETASK_MESSAGEBASE_RECORD));

    return 1;
}

int messagebase_get_area_info(int base_id, int area_id, LINETASK_MESSAGEBASE_AREA_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *result;

    if (base_id <= 0 || area_id <= 0 || record_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_AREA_INFO;
    regs.r[1] = base_id;
    regs.r[2] = area_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    result = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];
    memcpy(record_out, result, sizeof(LINETASK_MESSAGEBASE_AREA_RECORD));

    return 1;
}

int messagebase_get_message_info(int base_id, int message_id, LINETASK_MESSAGE_RECORD *record_out)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *result;

    if (base_id <= 0 || message_id <= 0 || record_out == NULL)
    {
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_MESSAGE_INFO;
    regs.r[1] = base_id;
    regs.r[2] = message_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == -1 || regs.r[0] == 0)
    {
        return 0;
    }

    result = (LINETASK_MESSAGE_RECORD *)regs.r[0];
    memcpy(record_out, result, sizeof(LINETASK_MESSAGE_RECORD));

    return 1;
}

int messagebase_download_block(int base_id, int message_id, void *buffer, long offset, int length)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || message_id <= 0 || buffer == NULL || length <= 0)
    {
        return -1;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_DOWNLOAD_BLOCK;
    regs.r[1] = base_id;
    regs.r[2] = message_id;
    regs.r[3] = (int)buffer;
    regs.r[4] = offset;
    regs.r[5] = length;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        return -1;
    }

    return regs.r[0];
}

int messagebase_update_message(int base_id, LINETASK_MESSAGE_RECORD *record)
{
    _kernel_swi_regs regs;

    if (base_id <= 0 || record == NULL)
    {
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_UPDATE_MESSAGE;
    regs.r[1] = base_id;
    regs.r[2] = (int)record;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        return 0;
    }

    return (regs.r[0] == 0) ? 1 : 0;
}

/* ******************************************************************************************************************************************************** */
/* Access Control                                                                                                                                           */
/* ******************************************************************************************************************************************************** */

int messagebase_check_access(int required_level, const char *required_keys,
                             int user_level, const char *user_keys)
{
    const char *rk;

    if (user_level < required_level)
    {
        return 0;
    }

    if (required_keys != NULL && required_keys[0] != '\0')
    {
        if (user_keys == NULL || user_keys[0] == '\0')
        {
            return 0;
        }

        for (rk = required_keys; *rk != '\0'; rk++)
        {
            if (*rk == ' ' || *rk == ',')
            {
                continue;
            }

            if (strchr(user_keys, *rk) == NULL)
            {
                return 0;
            }
        }
    }

    return 1;
}

int messagebase_can_read_message(messagebase_session *session, const LINETASK_MESSAGE_RECORD *msg)
{
    int area_type;

    if (session == NULL || msg == NULL)
    {
        return 0;
    }

    /* Check basic access level/keys */
    if (!messagebase_check_access(msg->accesslevel, msg->keys,
                                  session->user_accesslevel, session->user_keys))
    {
        return 0;
    }

    /* Private messages: only sender or receiver can read */
    if (msg->type == MSG_TYPE_PRIVATE)
    {
        if (msg->sentby != session->user_id && msg->receivedby != session->user_id)
        {
            return 0;
        }
    }

    /* Netmail: only sender or receiver can read */
    if (msg->type == MSG_TYPE_NETMAIL && msg->receivedby > 0)
    {
        if (msg->sentby != session->user_id && msg->receivedby != session->user_id)
        {
            return 0;
        }
    }

    /* Check area type - Private and Netmail areas only show messages for this user */
    area_type = messagebase_get_area_type(session, session->current_area);
    
    /* Private area (areatype 4): only show messages received by or sent by this user */
    if (area_type == 4)
    {
        if (msg->receivedby != session->user_id && msg->sentby != session->user_id)
        {
            return 0;
        }
    }
    
    /* Netmail area (areatype 2): only show messages received by or sent by this user */
    if (area_type == 2)
    {
        if (msg->receivedby != session->user_id && msg->sentby != session->user_id)
        {
            return 0;
        }
    }

    return 1;
}

int messagebase_can_post_to_area(messagebase_session *session, int base_id, int area_id)
{
    LINETASK_MESSAGEBASE_RECORD base_rec;
    LINETASK_MESSAGEBASE_AREA_RECORD area_rec;

    if (session == NULL || base_id <= 0)
    {
        return 0;
    }

    if (!messagebase_get_info(base_id, &base_rec))
    {
        return 0;
    }

    if (!messagebase_check_access(base_rec.accesslevel, base_rec.keys,
                                  session->user_accesslevel, session->user_keys))
    {
        return 0;
    }

    if (area_id > 0)
    {
        if (!messagebase_get_area_info(base_id, area_id, &area_rec))
        {
            return 0;
        }
        /* Area may have its own restrictions - check areatype */
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Utility Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

void messagebase_format_date(time_t timestamp, char *buffer, int buffer_size)
{
    struct tm *tm_info;

    if (buffer == NULL || buffer_size <= 0)
    {
        return;
    }

    if (timestamp == 0)
    {
        snprintf(buffer, buffer_size, "Unknown");
        return;
    }

    tm_info = localtime(&timestamp);
    if (tm_info != NULL)
    {
        snprintf(buffer, buffer_size, "%02d %s %04d",
                 tm_info->tm_mday,
                 (tm_info->tm_mon == 0) ? "Jan" :
                 (tm_info->tm_mon == 1) ? "Feb" :
                 (tm_info->tm_mon == 2) ? "Mar" :
                 (tm_info->tm_mon == 3) ? "Apr" :
                 (tm_info->tm_mon == 4) ? "May" :
                 (tm_info->tm_mon == 5) ? "Jun" :
                 (tm_info->tm_mon == 6) ? "Jul" :
                 (tm_info->tm_mon == 7) ? "Aug" :
                 (tm_info->tm_mon == 8) ? "Sep" :
                 (tm_info->tm_mon == 9) ? "Oct" :
                 (tm_info->tm_mon == 10) ? "Nov" : "Dec",
                 tm_info->tm_year + 1900);
    }
    else
    {
        snprintf(buffer, buffer_size, "Invalid");
    }
}

void messagebase_format_datetime(time_t timestamp, char *buffer, int buffer_size)
{
    struct tm *tm_info;

    if (buffer == NULL || buffer_size <= 0)
    {
        return;
    }

    if (timestamp == 0)
    {
        snprintf(buffer, buffer_size, "Unknown");
        return;
    }

    tm_info = localtime(&timestamp);
    if (tm_info != NULL)
    {
        snprintf(buffer, buffer_size, "%02d %s %04d %02d:%02d",
                 tm_info->tm_mday,
                 (tm_info->tm_mon == 0) ? "Jan" :
                 (tm_info->tm_mon == 1) ? "Feb" :
                 (tm_info->tm_mon == 2) ? "Mar" :
                 (tm_info->tm_mon == 3) ? "Apr" :
                 (tm_info->tm_mon == 4) ? "May" :
                 (tm_info->tm_mon == 5) ? "Jun" :
                 (tm_info->tm_mon == 6) ? "Jul" :
                 (tm_info->tm_mon == 7) ? "Aug" :
                 (tm_info->tm_mon == 8) ? "Sep" :
                 (tm_info->tm_mon == 9) ? "Oct" :
                 (tm_info->tm_mon == 10) ? "Nov" : "Dec",
                 tm_info->tm_year + 1900,
                 tm_info->tm_hour,
                 tm_info->tm_min);
    }
    else
    {
        snprintf(buffer, buffer_size, "Invalid");
    }
}

/* ******************************************************************************************************************************************************** */
/* FTN Address Helpers                                                                                                                                      */
/* ******************************************************************************************************************************************************** */

int messagebase_parse_ftn_address(const char *str, LINETASK_FTN_ADDRESS *addr)
{
    int zone = 0, net = 0, node = 0, point = 0;
    const char *p;

    if (str == NULL || addr == NULL)
    {
        return 0;
    }

    memset(addr, 0, sizeof(LINETASK_FTN_ADDRESS));
    p = str;

    /* Skip leading whitespace */
    while (*p == ' ' || *p == '\t')
    {
        p++;
    }

    /* Parse zone:net/node.point or zone:net/node */
    if (sscanf(p, "%d:%d/%d.%d", &zone, &net, &node, &point) >= 3)
    {
        addr->zone = zone;
        addr->net = net;
        addr->node = node;
        addr->point = point;
        return 1;
    }

    /* Try without zone */
    if (sscanf(p, "%d/%d.%d", &net, &node, &point) >= 2)
    {
        addr->zone = 2; /* Default to zone 2 */
        addr->net = net;
        addr->node = node;
        addr->point = point;
        return 1;
    }

    return 0;
}

void messagebase_format_ftn_address(const LINETASK_FTN_ADDRESS *addr, char *buffer, int size)
{
    if (addr == NULL || buffer == NULL || size <= 0)
    {
        return;
    }

    if (addr->point > 0)
    {
        snprintf(buffer, size, "%d:%d/%d.%d", addr->zone, addr->net, addr->node, addr->point);
    }
    else
    {
        snprintf(buffer, size, "%d:%d/%d", addr->zone, addr->net, addr->node);
    }
}

int messagebase_get_aka(int aka_index, LINETASK_FTN_ADDRESS *addr)
{
    _kernel_swi_regs regs;

    if (addr == NULL || aka_index < 1)
    {
        return 0;
    }

    memset(addr, 0, sizeof(LINETASK_FTN_ADDRESS));

    regs.r[0] = FTN_CONFIG_GET_ADDRESS;
    regs.r[1] = aka_index;

    if (_kernel_swi(SWI_SUPPORT_FTNCONFIG, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == 0 || regs.r[0] == -1)
    {
        return 0;
    }

    /* FTN_ADDRESS_CONFIG structure starts with id, then network name, then zone/net/node/point */
    {
        typedef struct
        {
            int id;
            char network[64];
            int zone;
            int net;
            int node;
            int point;
        } FTN_ADDR_CFG;

        FTN_ADDR_CFG *cfg = (FTN_ADDR_CFG *)regs.r[0];
        addr->zone = cfg->zone;
        addr->net = cfg->net;
        addr->node = cfg->node;
        addr->point = cfg->point;
    }

    return 1;
}

/* ******************************************************************************************************************************************************** */
/* User Lookup                                                                                                                                              */
/* ******************************************************************************************************************************************************** */

int messagebase_lookup_user_by_id(int user_id, char *realname_out, int realname_size)
{
    _kernel_swi_regs regs;

    if (user_id <= 0 || realname_out == NULL || realname_size <= 0)
    {
        return 0;
    }

    regs.r[0] = USERDB_CMD_SEARCH;
    regs.r[1] = user_id;

    if (_kernel_swi(SWI_FILER_USERDB, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == 0 || regs.r[0] == -1)
    {
        return 0;
    }

    /* USER_RECORD: id(4) + username(32) + realname(64) */
    {
        char *record = (char *)regs.r[0];
        char *realname = record + 4 + 32; /* Offset to realname */
        strncpy(realname_out, realname, realname_size - 1);
        realname_out[realname_size - 1] = '\0';
    }

    return 1;
}

int messagebase_lookup_user_by_name(const char *username, int *user_id_out)
{
    _kernel_swi_regs regs;

    if (username == NULL || username[0] == '\0' || user_id_out == NULL)
    {
        return 0;
    }

    /* SWI 0x5AA41 (Filer Userdb) reason 7 = FIND_USERNAME */
    regs.r[0] = 7;  /* FILER_USERDB_CMD_FIND_USERNAME */
    regs.r[1] = (int)username;

    if (_kernel_swi(SWI_FILER_USERDB, &regs, &regs) != NULL)
    {
        return 0;
    }

    if (regs.r[0] == 0 || regs.r[0] == -1)
    {
        return 0;
    }

    /* User record returned - extract ID from offset 0 */
    *user_id_out = *((int *)regs.r[0]);
    return 1;
}

/* ******************************************************************************************************************************************************** */
/* Listing Functions                                                                                                                                        */
/* ******************************************************************************************************************************************************** */

int messagebase_list_bases(messagebase_session *session,
                           void (*output)(void *ctx, const char *text),
                           void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_RECORD *record;
    char line[256];
    int count = 0;          /* entries stored for display */
    int total_count = 0;    /* total entries enumerated */
    int index = 0;
    /* Collect entries to render side-by-side - limit to avoid stack overflow */
    #define MAX_MB_ENTRIES 64
    struct mb_entry
    {
        int id;
        char name[64];
        char type[16];
    } entries[MAX_MB_ENTRIES];

    if (output == NULL)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_BASES;
        regs.r[1] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record = (LINETASK_MESSAGEBASE_RECORD *)regs.r[0];
        if (record == NULL)
        {
            break;
        }

        if (session != NULL)
        {
            if (!messagebase_check_access(record->accesslevel, record->keys,
                                          session->user_accesslevel, session->user_keys))
            {
                index++;
                continue;
            }
        }

        {
            const char *type_str;
            switch (record->type)
            {
                case 0: type_str = "Normal"; break;
                case 1: type_str = "FTN"; break;
                case 2: type_str = "Internet"; break;
                case 3: type_str = "Private"; break;
                default: type_str = "Unknown"; break;
            }

            if (count < MAX_MB_ENTRIES)
            {
                char *p;
                entries[count].id = record->id;
                strncpy(entries[count].name, record->name, sizeof(entries[count].name) - 1);
                entries[count].name[sizeof(entries[count].name) - 1] = '\0';
                /* Strip any control characters from name */
                for (p = entries[count].name; *p != '\0'; p++)
                {
                    if (*p < 32) *p = ' ';
                }
                strncpy(entries[count].type, type_str, sizeof(entries[count].type) - 1);
                entries[count].type[sizeof(entries[count].type) - 1] = '\0';
            }
        }

        if (count < MAX_MB_ENTRIES)
        {
            count++;
        }
        total_count++;
        index++;
    }

    if (total_count == 0)
    {
        output(ctx, "[No messagebases available]\r\n");
    }
    else
    {
        int i = 0;
        /* Blue bar header with white text - exactly 80 chars */
        output(ctx, "\033[1;37;44m Available Messagebases                                                         \033[0m\r\n");
        output(ctx, "\r\n");
        /* Yellow column headers - centered (8 space indent) */
        output(ctx, "        \033[1;33m#   Name                 Type    #   Name                 Type\033[0m\r\n");

        while (i < count)
        {
            int has_right = (i + 1 < count);

            if (has_right)
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type,
                         entries[i + 1].id, entries[i + 1].name, entries[i + 1].type);
                i += 2;
            }
            else
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type);
                i++;
            }
            output(ctx, line);
        }
    }

    return total_count;
}

int messagebase_list_areas(messagebase_session *session,
                           void (*output)(void *ctx, const char *text),
                           void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *record_ptr;
    LINETASK_MESSAGEBASE_RECORD base_record;
    char line[256];
    int count = 0;          /* entries stored for display */
    int total_count = 0;    /* total entries enumerated */
    int index = 0;
    /* Collect entries so we can render two columns side-by-side */
    #define MAX_AREA_ENTRIES 256
    struct area_entry
    {
        int id;
        char name[64];
        char type[16];
    } entries[MAX_AREA_ENTRIES];

    if (output == NULL || session == NULL)
    {
        return 0;
    }

    if (session->current_messagebase <= 0)
    {
        output(ctx, "\r\n[No messagebase selected. Use MESSAGEBASE SELECT <id> first.]\r\n");
        return 0;
    }

    if (!messagebase_get_info(session->current_messagebase, &base_record))
    {
        output(ctx, "\r\n[Invalid messagebase selected.]\r\n");
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == -1)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

        {
            const char *type_str;
            char *p;
            switch (record_ptr->areatype)
            {
                case AREA_TYPE_LOCAL: type_str = "Local"; break;
                case AREA_TYPE_ECHO: type_str = "Echo"; break;
                case AREA_TYPE_NETMAIL: type_str = "Netmail"; break;
                case AREA_TYPE_JUNK: type_str = "Junk"; break;
                case AREA_TYPE_OTHER: type_str = "Private"; break;
                default: type_str = "Other"; break;
            }

            if (count < MAX_AREA_ENTRIES)
            {
                entries[count].id = record_ptr->id;
                strncpy(entries[count].name, record_ptr->name, sizeof(entries[count].name) - 1);
                entries[count].name[sizeof(entries[count].name) - 1] = '\0';
                /* Strip any control characters from name */
                for (p = entries[count].name; *p != '\0'; p++)
                {
                    if (*p < 32) *p = ' ';
                }
                strncpy(entries[count].type, type_str, sizeof(entries[count].type) - 1);
                entries[count].type[sizeof(entries[count].type) - 1] = '\0';
            }
        }

        if (count < MAX_AREA_ENTRIES)
        {
            count++;
        }
        total_count++;
        index++;
    }

    /* Blue bar header with white text - exactly 80 chars */
    snprintf(line, sizeof(line), "\033[1;37;44m Areas in: %-69.69s\033[0m\r\n", base_record.name);
    output(ctx, line);
    output(ctx, "\r\n");
    /* Yellow column headers - centered (8 space indent) */
    output(ctx, "        \033[1;33m#   Name                 Type    #   Name                 Type\033[0m\r\n");

    {
        int i = 0;
        while (i < count)
        {
            int has_right = (i + 1 < count);
            
            if (has_right)
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type,
                         entries[i + 1].id, entries[i + 1].name, entries[i + 1].type);
                i += 2;
            }
            else
            {
                snprintf(line, sizeof(line),
                         "        \033[1;31m%03d\033[0m \033[1;32m%-20.20s\033[0m \033[1;36m%-7.7s\033[0m\r\n",
                         entries[i].id, entries[i].name, entries[i].type);
                i++;
            }
            output(ctx, line);
        }
    }

    return total_count;
}

/* ============================================================
 * CONTINUOUS MESSAGE READER
 * Enters the message reader at the newest unread message
 * ============================================================ */

int messagebase_enter_reader(messagebase_session *session,
                             void (*output)(void *ctx, const char *text),
                             void *ctx)
{
    int start_message_id;
    LINETASK_MESSAGE_RECORD msg_record;

    if (output == NULL || session == NULL)
    {
        return 0;
    }

    if (session->current_messagebase <= 0)
    {
        output(ctx, "\r\n[No messagebase selected.]\r\n");
        return 0;
    }

    if (session->current_area <= 0)
    {
        output(ctx, "\r\n[No area selected.]\r\n");
        return 0;
    }

    /* Count total messages and find starting point */
    session->viewer.total_messages = messagebase_count_messages(session);

    if (session->viewer.total_messages == 0)
    {
        output(ctx, "\r\n[No messages in this area.]\r\n");
        return 0;
    }

    /* Start at newest unread, or first message if all read */
    start_message_id = messagebase_get_newest_unread_id(session);

    if (start_message_id <= 0)
    {
        start_message_id = messagebase_get_first_message_id(session);
    }

    if (start_message_id <= 0)
    {
        output(ctx, "\r\n[No accessible messages.]\r\n");
        return 0;
    }

    /* Verify access */
    if (!messagebase_get_message_info(session->current_messagebase, start_message_id, &msg_record))
    {
        output(ctx, "\r\n[Error loading message.]\r\n");
        return 0;
    }

    if (!messagebase_can_read_message(session, &msg_record))
    {
        output(ctx, "\r\n[Access denied.]\r\n");
        return 0;
    }

    /* Initialize viewer state */
    session->viewer.reading_direction = READER_DIR_FORWARD;
    session->viewer.message_position = messagebase_get_message_position(session, start_message_id);

    /* Initialize and show the message */
    messagebase_viewer_init(session, start_message_id);
    messagebase_mark_as_read(session, start_message_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

int messagebase_show_message_info(messagebase_session *session,
                                  int message_id,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    LINETASK_MESSAGE_RECORD record;
    char line[256];
    char date_str[32];
    char from_name[MAX_FROM_NAME];
    char to_name[MAX_TO_NAME];

    if (output == NULL || session == NULL || message_id <= 0)
    {
        return 0;
    }

    if (session->current_messagebase <= 0)
    {
        output(ctx, "\r\n[No messagebase selected.]\r\n");
        return 0;
    }

    if (!messagebase_get_message_info(session->current_messagebase, message_id, &record))
    {
        output(ctx, "\r\n[Message not found.]\r\n");
        return 0;
    }

    if (!messagebase_can_read_message(session, &record))
    {
        output(ctx, "\r\n[Access denied.]\r\n");
        return 0;
    }

    /* Get names */
    if (record.sentby > 0)
    {
        if (!messagebase_lookup_user_by_id(record.sentby, from_name, sizeof(from_name)))
        {
            snprintf(from_name, sizeof(from_name), "User #%d", record.sentby);
        }
    }
    else if (record.fromname[0] != '\0')
    {
        /* FTN message with name - show name and address if available */
        if (record.orgaddr.zone > 0)
        {
            char addr_str[32];
            messagebase_format_ftn_address(&record.orgaddr, addr_str, sizeof(addr_str));
            snprintf(from_name, sizeof(from_name), "%s (%s)", record.fromname, addr_str);
        }
        else
        {
            strncpy(from_name, record.fromname, sizeof(from_name) - 1);
            from_name[sizeof(from_name) - 1] = '\0';
        }
    }
    else if (record.orgaddr.zone > 0)
    {
        messagebase_format_ftn_address(&record.orgaddr, from_name, sizeof(from_name));
    }
    else
    {
        strncpy(from_name, "Unknown", sizeof(from_name));
    }

    if (record.receivedby > 0)
    {
        if (!messagebase_lookup_user_by_id(record.receivedby, to_name, sizeof(to_name)))
        {
            snprintf(to_name, sizeof(to_name), "User #%d", record.receivedby);
        }
    }
    else if (record.toname[0] != '\0')
    {
        /* FTN message with name - show name and address if available */
        if (record.dstaddr.zone > 0)
        {
            char addr_str[32];
            messagebase_format_ftn_address(&record.dstaddr, addr_str, sizeof(addr_str));
            snprintf(to_name, sizeof(to_name), "%s (%s)", record.toname, addr_str);
        }
        else
        {
            strncpy(to_name, record.toname, sizeof(to_name) - 1);
            to_name[sizeof(to_name) - 1] = '\0';
        }
    }
    else if (record.dstaddr.zone > 0)
    {
        messagebase_format_ftn_address(&record.dstaddr, to_name, sizeof(to_name));
    }
    else
    {
        strncpy(to_name, "All", sizeof(to_name));
    }

    output(ctx, "\r\n\033[1;36m=== Message Information ===\033[0m\r\n\r\n");

    snprintf(line, sizeof(line), "\033[1;37mMessage ID:\033[0m   %d\r\n", record.id);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mFrom:\033[0m         %s\r\n", from_name);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mTo:\033[0m           %s\r\n", to_name);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mSubject:\033[0m      %s\r\n", record.subject);
    output(ctx, line);

    messagebase_format_datetime(record.sent, date_str, sizeof(date_str));
    snprintf(line, sizeof(line), "\033[1;37mDate:\033[0m         %s\r\n", date_str);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mSize:\033[0m         %ld bytes\r\n", record.bodysize);
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;37mTimes Read:\033[0m   %d\r\n", record.timesread);
    output(ctx, line);

    output(ctx, "\r\n");

    return 1;
}

/* ============================================================
 * MESSAGE VIEWER
 * ============================================================ */

int messagebase_viewer_init(messagebase_session *session, int message_id)
{
    if (session == NULL)
    {
        return 0;
    }

    session->viewer.phase = MESSAGE_VIEW_IDLE;
    session->viewer.message_id = message_id;
    session->viewer.body_offset = 0;
    session->viewer.body_size = 0;
    session->viewer.current_line = 0;
    session->viewer.page_lines = 20;
    session->viewer.is_ansi = 1;

    return 1;
}

int messagebase_viewer_close(messagebase_session *session)
{
    if (session == NULL)
    {
        return 0;
    }

    /* Restore saved selection if we were in inbox mode */
    if (session->viewer.saved_messagebase > 0 || session->viewer.saved_area > 0)
    {
        session->current_messagebase = session->viewer.saved_messagebase;
        session->current_area = session->viewer.saved_area;
        session->viewer.saved_messagebase = 0;
        session->viewer.saved_area = 0;
    }

    session->viewer.phase = MESSAGE_VIEW_IDLE;
    session->viewer.message_id = 0;
    session->viewer.body_offset = 0;
    session->viewer.body_size = 0;
    session->viewer.current_line = 0;

    /* Clear search mode state */
    session->viewer.search_mode = 0;
    session->viewer.search_result_count = 0;
    session->viewer.search_result_index = 0;
    session->viewer.search_term[0] = '\0';

    return 1;
}

int messagebase_viewer_show_header(messagebase_session *session,
                                    void (*output)(void *ctx, const char *text),
                                    void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    LINETASK_MESSAGEBASE_AREA_RECORD area_rec;
    char line[256];
    char from_name[MAX_FROM_NAME];
    char to_name[MAX_TO_NAME];
    char date_str[MAX_DATE_STR];
    const char *months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    struct tm *tm_info;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    if (session->viewer.message_id <= 0)
    {
        output(ctx, "\r\n[No message selected.]\r\n");
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_MESSAGE_INFO;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = session->viewer.message_id;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        return 0;
    }

    if (regs.r[0] == 0)
    {
        output(ctx, "\r\n[Message not found.]\r\n");
        return 0;
    }

    record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

    debug_printf("viewer_show_header: msg=%d bodysize=%ld", record_ptr->id, record_ptr->bodysize);

    session->viewer.body_size = record_ptr->bodysize;
    session->viewer.times_read = record_ptr->timesread;

    /* Get sender name */
    if (record_ptr->sentby > 0)
    {
        if (!messagebase_lookup_user_by_id(record_ptr->sentby, from_name, sizeof(from_name)))
        {
            snprintf(from_name, sizeof(from_name), "User #%d", record_ptr->sentby);
        }
    }
    else if (record_ptr->fromname[0] != '\0')
    {
        /* FTN message with name - show name and address if available */
        if (record_ptr->orgaddr.zone > 0)
        {
            char addr_str[32];
            messagebase_format_ftn_address(&record_ptr->orgaddr, addr_str, sizeof(addr_str));
            snprintf(from_name, sizeof(from_name), "%s (%s)", record_ptr->fromname, addr_str);
        }
        else
        {
            strncpy(from_name, record_ptr->fromname, sizeof(from_name) - 1);
            from_name[sizeof(from_name) - 1] = '\0';
        }
    }
    else if (record_ptr->orgaddr.zone > 0)
    {
        messagebase_format_ftn_address(&record_ptr->orgaddr, from_name, sizeof(from_name));
    }
    else
    {
        strncpy(from_name, "Unknown", sizeof(from_name));
    }

    /* Get recipient name */
    if (record_ptr->receivedby > 0)
    {
        if (!messagebase_lookup_user_by_id(record_ptr->receivedby, to_name, sizeof(to_name)))
        {
            snprintf(to_name, sizeof(to_name), "User #%d", record_ptr->receivedby);
        }
    }
    else if (record_ptr->toname[0] != '\0')
    {
        /* FTN message with name - show name and address if available */
        if (record_ptr->dstaddr.zone > 0)
        {
            char addr_str[32];
            messagebase_format_ftn_address(&record_ptr->dstaddr, addr_str, sizeof(addr_str));
            snprintf(to_name, sizeof(to_name), "%s (%s)", record_ptr->toname, addr_str);
        }
        else
        {
            strncpy(to_name, record_ptr->toname, sizeof(to_name) - 1);
            to_name[sizeof(to_name) - 1] = '\0';
        }
    }
    else if (record_ptr->dstaddr.zone > 0)
    {
        messagebase_format_ftn_address(&record_ptr->dstaddr, to_name, sizeof(to_name));
    }
    else
    {
        strncpy(to_name, "All", sizeof(to_name));
    }

    /* Get area name */
    if (messagebase_get_area_info(session->current_messagebase, session->current_area, &area_rec))
    {
        snprintf(line, sizeof(line), "\r\n\033[1;36mArea    :\033[0m \033[1;32m%s\033[0m \033[1;33m(%03d)\033[0m\r\n",
                 area_rec.name, session->current_area);
    }
    else
    {
        snprintf(line, sizeof(line), "\r\n\033[1;36mArea    :\033[0m \033[1;33m(%03d)\033[0m\r\n",
                 session->current_area);
    }
    output(ctx, line);

    /* Message line: #ID (Read N times, N bytes) */
    snprintf(line, sizeof(line), "\033[1;36mMessage :\033[0m \033[1;37m#%d\033[0m (Read %d times, %ld bytes)\r\n",
             record_ptr->id, record_ptr->timesread, record_ptr->bodysize);
    output(ctx, line);

    /* Date line: DD Mon YY HH:MM:SS */
    tm_info = localtime(&record_ptr->sent);
    if (tm_info != NULL)
    {
        snprintf(date_str, sizeof(date_str), "%02d %s %02d %02d:%02d:%02d",
                 tm_info->tm_mday,
                 months[tm_info->tm_mon],
                 tm_info->tm_year % 100,
                 tm_info->tm_hour,
                 tm_info->tm_min,
                 tm_info->tm_sec);
    }
    else
    {
        strncpy(date_str, "Unknown", sizeof(date_str));
    }
    snprintf(line, sizeof(line), "\033[1;36mDate    :\033[0m %s\r\n", date_str);
    output(ctx, line);

    /* From line */
    snprintf(line, sizeof(line), "\033[1;36mFrom    :\033[0m \033[1;33m%s\033[0m\r\n", from_name);
    output(ctx, line);

    /* To line */
    snprintf(line, sizeof(line), "\033[1;36mTo      :\033[0m \033[1;32m%s\033[0m\r\n", to_name);
    output(ctx, line);

    /* Subject line */
    snprintf(line, sizeof(line), "\033[1;36mSubject :\033[0m \033[1;37m%s\033[0m\r\n", record_ptr->subject);
    output(ctx, line);

    /* Blank line before body */
    output(ctx, "\r\n");

    session->viewer.phase = MESSAGE_VIEW_HEADER;
    session->viewer.current_line = 0;

    return 1;
}

int messagebase_viewer_show_body(messagebase_session *session,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    char buffer[VIEWER_LINE_BUFFER_SIZE];
    char line[MAX_LINE_WIDTH + 8];
    long bytes_to_read;
    long bytes_read;
    int lines_shown = 0;
    int i;
    int line_pos = 0;

    if (session == NULL || output == NULL)
    {
        debug_printf("viewer_show_body: null session or output");
        return 0;
    }

    if (session->viewer.message_id <= 0)
    {
        debug_printf("viewer_show_body: no message_id");
        return 0;
    }

    debug_printf("viewer_show_body: msg=%d body_size=%ld body_offset=%ld page_lines=%d",
                 session->viewer.message_id, session->viewer.body_size,
                 session->viewer.body_offset, session->viewer.page_lines);

    session->viewer.phase = MESSAGE_VIEW_BODY;

    while (lines_shown < session->viewer.page_lines &&
           session->viewer.body_offset < session->viewer.body_size)
    {
        bytes_to_read = session->viewer.body_size - session->viewer.body_offset;
        if (bytes_to_read > VIEWER_LINE_BUFFER_SIZE - 1)
        {
            bytes_to_read = VIEWER_LINE_BUFFER_SIZE - 1;
        }

        debug_printf("viewer_show_body: requesting %ld bytes at offset %ld", bytes_to_read, session->viewer.body_offset);

        bytes_read = messagebase_download_block(
            session->current_messagebase,
            session->viewer.message_id,
            (unsigned char *)buffer,
            session->viewer.body_offset,
            (int)bytes_to_read
        );

        debug_printf("viewer_show_body: got %ld bytes", bytes_read);

        if (bytes_read <= 0)
        {
            break;
        }

        for (i = 0; i < bytes_read && lines_shown < session->viewer.page_lines; i++)
        {
            char ch = buffer[i];

            if (ch == '\n' || ch == '\r')
            {
                line[line_pos] = '\r';
                line[line_pos + 1] = '\n';
                line[line_pos + 2] = '\0';
                output(ctx, line);
                line_pos = 0;
                lines_shown++;
                session->viewer.current_line++;

                if (ch == '\r' && i + 1 < bytes_read && buffer[i + 1] == '\n')
                {
                    i++;
                }
            }
            else if (line_pos < MAX_LINE_WIDTH - 1)
            {
                line[line_pos++] = ch;
            }
            else
            {
                line[line_pos] = '\r';
                line[line_pos + 1] = '\n';
                line[line_pos + 2] = '\0';
                output(ctx, line);
                line_pos = 0;
                line[line_pos++] = ch;
                lines_shown++;
                session->viewer.current_line++;
            }

            session->viewer.body_offset++;
        }
    }

    if (line_pos > 0)
    {
        line[line_pos] = '\r';
        line[line_pos + 1] = '\n';
        line[line_pos + 2] = '\0';
        output(ctx, line);
        lines_shown++;
    }

    return lines_shown;
}

int messagebase_viewer_show_prompt(messagebase_session *session,
                                    void (*output)(void *ctx, const char *text),
                                    void *ctx)
{
    char line[256];
    int more;
    const char *dir_str;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    more = (session->viewer.body_offset < session->viewer.body_size);
    dir_str = (session->viewer.reading_direction == READER_DIR_BACKWARD) ? "<<" : ">>";

    session->viewer.phase = MESSAGE_VIEW_PROMPT;

    /* Full navigation prompt matching screenshot style */
    output(ctx, "\r\n");

    /* Show search mode indicator if active */
    if (session->viewer.search_mode)
    {
        snprintf(line, sizeof(line),
                 "\033[1;44;37m SEARCH: Result %d of %d for '%s' \033[0m\r\n",
                 session->viewer.search_result_index + 1,
                 session->viewer.search_result_count,
                 session->viewer.search_term);
        output(ctx, line);
    }
    
    /* Line 1: Basic navigation */
    snprintf(line, sizeof(line),
             "\033[1;32mRead msgs:\033[0m [\033[1;36mCR\033[0m/\033[1;36mSPC\033[0m] Next  "
             "[\033[1;33mF\033[0m]orward  [\033[1;33mB\033[0m]ackward  "
             "[\033[1;33mC\033[0m]urrent  [\033[1;33mR\033[0m]eply\r\n");
    output(ctx, line);
    
    /* Line 2: Area navigation */
    snprintf(line, sizeof(line),
             "\033[1;32mDir: %s\033[0m    [\033[1;33mS\033[0m]tart of area  "
             "[\033[1;33mE\033[0m]nd of area  [\033[1;33mP\033[0m]rivate reply\r\n",
             dir_str);
    output(ctx, line);
    
    /* Line 3: Area switching, search/exit and abort */
    if (session->viewer.search_mode)
    {
        snprintf(line, sizeof(line),
                 "           [\033[1;33m+\033[0m] Next area  [\033[1;33m-\033[0m] Previous area  "
                 "[\033[1;33mX\033[0m] Exit search  [\033[1;31mA\033[0m]bort  Select: ");
    }
    else
    {
        snprintf(line, sizeof(line),
                 "           [\033[1;33m+\033[0m] Next area  [\033[1;33m-\033[0m] Previous area  "
                 "[\033[1;33mZ\033[0m] Search  [\033[1;31mA\033[0m]bort  Select: ");
    }
    output(ctx, line);

    return more;
}

int messagebase_viewer_at_end(messagebase_session *session)
{
    if (session == NULL)
    {
        return 1;
    }

    return (session->viewer.body_offset >= session->viewer.body_size);
}

int messagebase_viewer_is_active(messagebase_session *session)
{
    if (session == NULL)
    {
        return 0;
    }

    return (session->viewer.phase != MESSAGE_VIEW_IDLE);
}

/* Handle viewer input: returns action code
 * VIEWER_ACTION_CONTINUE = 0 - continue showing current message (more pages)
 * VIEWER_ACTION_NEXT = 1 - go to next message
 * VIEWER_ACTION_PREV = 2 - go to previous message
 * VIEWER_ACTION_REPLY = 3 - reply to current message
 * VIEWER_ACTION_QUIT = 4 - quit viewer
 * VIEWER_ACTION_INVALID = -1 - invalid input, re-prompt
 */
int messagebase_viewer_handle_input(messagebase_session *session, char input,
                                     void (*output)(void *ctx, const char *text),
                                     void *ctx)
{
    int more;

    if (session == NULL)
    {
        return VIEWER_ACTION_QUIT;
    }

    more = (session->viewer.body_offset < session->viewer.body_size);

    switch (input)
    {
        case '\r':
        case '\n':
        case ' ':
            /* Enter/Space - show more or go to next/prev based on direction */
            if (more)
            {
                /* Show next page of current message */
                output(ctx, "\r\n");
                messagebase_viewer_show_body(session, output, ctx);
                messagebase_viewer_show_prompt(session, output, ctx);
                return VIEWER_ACTION_CONTINUE;
            }
            else
            {
                /* At end - go to next or prev based on direction */
                if (session->viewer.reading_direction == READER_DIR_BACKWARD)
                {
                    return VIEWER_ACTION_PREV;
                }
                return VIEWER_ACTION_NEXT;
            }

        case 'n':
        case 'N':
            /* Next message (skip remaining body) */
            return VIEWER_ACTION_NEXT;

        case 'f':
        case 'F':
            /* Set direction forward */
            session->viewer.reading_direction = READER_DIR_FORWARD;
            output(ctx, "\r\n[Direction: Forward >>]\r\n");
            messagebase_viewer_show_prompt(session, output, ctx);
            return VIEWER_ACTION_CONTINUE;

        case 'b':
        case 'B':
            /* Set direction backward */
            session->viewer.reading_direction = READER_DIR_BACKWARD;
            output(ctx, "\r\n[Direction: Backward <<]\r\n");
            messagebase_viewer_show_prompt(session, output, ctx);
            return VIEWER_ACTION_CONTINUE;

        case 'c':
        case 'C':
            /* Re-display current message */
            return VIEWER_ACTION_CURRENT;

        case 's':
        case 'S':
            /* Start of area (first message) */
            return VIEWER_ACTION_START;

        case 'e':
        case 'E':
            /* End of area (last message) */
            return VIEWER_ACTION_END;

        case 'r':
        case 'R':
            /* Public Reply */
            return VIEWER_ACTION_REPLY;

        case 'p':
        case 'P':
            /* Private Reply */
            return VIEWER_ACTION_PRIVATE_REPLY;

        case '+':
        case '=':
            /* Next area */
            return VIEWER_ACTION_NEXT_AREA;

        case '-':
        case '_':
            /* Previous area */
            return VIEWER_ACTION_PREV_AREA;

        case 'z':
        case 'Z':
        case '/':
            /* Search - but if already in search mode, treat Z as exit */
            if (session->viewer.search_mode)
            {
                return VIEWER_ACTION_EXIT_SEARCH;
            }
            return VIEWER_ACTION_SEARCH;

        case 'x':
        case 'X':
            /* Exit search mode (only when in search mode) */
            if (session->viewer.search_mode)
            {
                return VIEWER_ACTION_EXIT_SEARCH;
            }
            /* If not in search mode, treat as invalid key */
            output(ctx, "\r\n");
            messagebase_viewer_show_prompt(session, output, ctx);
            return VIEWER_ACTION_CONTINUE;

        case 'a':
        case 'A':
        case 'q':
        case 'Q':
        case 27: /* ESC */
            /* Abort/Quit */
            return VIEWER_ACTION_QUIT;

        default:
            /* Invalid key - re-prompt */
            output(ctx, "\r\n");
            messagebase_viewer_show_prompt(session, output, ctx);
            return VIEWER_ACTION_CONTINUE;
    }
}

/* Navigate to next message and display it */
int messagebase_viewer_goto_next(messagebase_session *session,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    int next_id;
    LINETASK_MESSAGE_RECORD msg_record;

    if (session == NULL)
    {
        return 0;
    }

    /* In search mode, navigate through search results instead of all messages */
    if (session->viewer.search_mode)
    {
        int next_idx = session->viewer.search_result_index + 1;
        
        if (next_idx >= session->viewer.search_result_count)
        {
            output(ctx, "\r\n\r\n[No more search results.]\r\n");
            messagebase_viewer_show_prompt(session, output, ctx);
            return 1;  /* Stay in viewer */
        }

        next_id = session->viewer.search_results[next_idx];

        if (!messagebase_get_message_info(session->current_messagebase, next_id, &msg_record))
        {
            output(ctx, "\r\n[Error getting message.]\r\n");
            messagebase_viewer_close(session);
            return 0;
        }

        session->viewer.search_result_index = next_idx;
        session->viewer.message_position = messagebase_get_message_position(session, next_id);
        messagebase_viewer_init(session, next_id);
        messagebase_mark_as_read(session, next_id);
        messagebase_viewer_show_header(session, output, ctx);
        messagebase_viewer_show_body(session, output, ctx);
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    /* Normal navigation - go to next message in area */
    next_id = messagebase_get_next_message_id(session, session->viewer.message_id);
    if (next_id <= 0)
    {
        output(ctx, "\r\n\r\n[No more messages.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;  /* Stay in viewer */
    }

    if (!messagebase_get_message_info(session->current_messagebase, next_id, &msg_record))
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        messagebase_viewer_close(session);
        return 0;
    }

    if (!messagebase_can_read_message(session, &msg_record))
    {
        output(ctx, "\r\n[Access denied to next message.]\r\n");
        messagebase_viewer_close(session);
        return 0;
    }

    session->viewer.message_position++;
    messagebase_viewer_init(session, next_id);
    messagebase_mark_as_read(session, next_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Navigate to previous message and display it */
int messagebase_viewer_goto_prev(messagebase_session *session,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    int prev_id;
    LINETASK_MESSAGE_RECORD msg_record;

    if (session == NULL)
    {
        return 0;
    }

    /* In search mode, navigate through search results instead of all messages */
    if (session->viewer.search_mode)
    {
        int prev_idx = session->viewer.search_result_index - 1;
        
        if (prev_idx < 0)
        {
            output(ctx, "\r\n[No previous search results.]\r\n");
            messagebase_viewer_show_prompt(session, output, ctx);
            return 1;  /* Stay in viewer */
        }

        prev_id = session->viewer.search_results[prev_idx];

        if (!messagebase_get_message_info(session->current_messagebase, prev_id, &msg_record))
        {
            output(ctx, "\r\n[Error getting message.]\r\n");
            messagebase_viewer_close(session);
            return 0;
        }

        session->viewer.search_result_index = prev_idx;
        session->viewer.message_position = messagebase_get_message_position(session, prev_id);
        messagebase_viewer_init(session, prev_id);
        messagebase_mark_as_read(session, prev_id);
        messagebase_viewer_show_header(session, output, ctx);
        messagebase_viewer_show_body(session, output, ctx);
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    /* Normal navigation - go to previous message in area */
    prev_id = messagebase_get_prev_message_id(session, session->viewer.message_id);
    if (prev_id <= 0)
    {
        output(ctx, "\r\n[No previous message.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1; /* Stay in viewer */
    }

    if (!messagebase_get_message_info(session->current_messagebase, prev_id, &msg_record))
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        messagebase_viewer_close(session);
        return 0;
    }

    if (!messagebase_can_read_message(session, &msg_record))
    {
        output(ctx, "\r\n[Access denied to previous message.]\r\n");
        messagebase_viewer_close(session);
        return 0;
    }

    session->viewer.message_position--;
    if (session->viewer.message_position < 1) session->viewer.message_position = 1;
    messagebase_viewer_init(session, prev_id);
    messagebase_mark_as_read(session, prev_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Jump to start of area (first message) */
int messagebase_viewer_goto_start(messagebase_session *session,
                                   void (*output)(void *ctx, const char *text),
                                   void *ctx)
{
    int first_id;
    LINETASK_MESSAGE_RECORD msg_record;

    if (session == NULL)
    {
        return 0;
    }

    first_id = messagebase_get_first_message_id(session);
    if (first_id <= 0)
    {
        output(ctx, "\r\n[No messages in area.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    if (!messagebase_get_message_info(session->current_messagebase, first_id, &msg_record))
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        return 0;
    }

    session->viewer.message_position = 1;
    messagebase_viewer_init(session, first_id);
    messagebase_mark_as_read(session, first_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Jump to end of area (last message) */
int messagebase_viewer_goto_end(messagebase_session *session,
                                 void (*output)(void *ctx, const char *text),
                                 void *ctx)
{
    int last_id;
    LINETASK_MESSAGE_RECORD msg_record;

    if (session == NULL)
    {
        return 0;
    }

    last_id = messagebase_get_last_message_id(session);
    if (last_id <= 0)
    {
        output(ctx, "\r\n[No messages in area.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    if (!messagebase_get_message_info(session->current_messagebase, last_id, &msg_record))
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        return 0;
    }

    session->viewer.message_position = session->viewer.total_messages;
    messagebase_viewer_init(session, last_id);
    messagebase_mark_as_read(session, last_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Switch to next area and show first message */
int messagebase_viewer_next_area(messagebase_session *session,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    int next_area;
    int first_id;
    LINETASK_MESSAGEBASE_AREA_RECORD area_rec;
    char line[256];

    if (session == NULL)
    {
        return 0;
    }

    next_area = messagebase_get_next_area_id(session);
    if (next_area <= 0)
    {
        output(ctx, "\r\n[No more areas.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->current_area = next_area;

    /* Get area name for display */
    if (messagebase_get_area_info(session->current_messagebase, next_area, &area_rec))
    {
        snprintf(line, sizeof(line), "\r\n[Entering area: %s]\r\n", area_rec.name);
        output(ctx, line);
    }

    /* Update counts and find first message */
    session->viewer.total_messages = messagebase_count_messages(session);
    first_id = messagebase_get_first_message_id(session);

    if (first_id <= 0)
    {
        output(ctx, "[No messages in this area.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->viewer.message_position = 1;
    messagebase_viewer_init(session, first_id);
    messagebase_mark_as_read(session, first_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Switch to previous area and show first message */
int messagebase_viewer_prev_area(messagebase_session *session,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    int prev_area;
    int first_id;
    LINETASK_MESSAGEBASE_AREA_RECORD area_rec;
    char line[256];

    if (session == NULL)
    {
        return 0;
    }

    prev_area = messagebase_get_prev_area_id(session);
    if (prev_area <= 0)
    {
        output(ctx, "\r\n[No previous area.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->current_area = prev_area;

    /* Get area name for display */
    if (messagebase_get_area_info(session->current_messagebase, prev_area, &area_rec))
    {
        snprintf(line, sizeof(line), "\r\n[Entering area: %s]\r\n", area_rec.name);
        output(ctx, line);
    }

    /* Update counts and find first message */
    session->viewer.total_messages = messagebase_count_messages(session);
    first_id = messagebase_get_first_message_id(session);

    if (first_id <= 0)
    {
        output(ctx, "[No messages in this area.]\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
        return 1;
    }

    session->viewer.message_position = 1;
    messagebase_viewer_init(session, first_id);
    messagebase_mark_as_read(session, first_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Re-display current message from beginning */
int messagebase_viewer_show_current(messagebase_session *session,
                                     void (*output)(void *ctx, const char *text),
                                     void *ctx)
{
    if (session == NULL || session->viewer.message_id <= 0)
    {
        return 0;
    }

    /* Reset body offset to show from beginning */
    session->viewer.body_offset = 0;
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);
    return 1;
}

/* Start private reply to current message */
int messagebase_viewer_start_private_reply(messagebase_session *session,
                                            void (*output)(void *ctx, const char *text),
                                            void *ctx)
{
    LINETASK_MESSAGE_RECORD msg_record;
    char from_name[MAX_FROM_NAME];
    int message_id;

    if (session == NULL)
    {
        return 0;
    }

    message_id = session->viewer.message_id;

    /* Get original message to find sender */
    if (!messagebase_get_message_info(session->current_messagebase, message_id, &msg_record))
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        return 0;
    }

    /* Get sender name */
    if (msg_record.sentby > 0)
    {
        if (!messagebase_lookup_user_by_id(msg_record.sentby, from_name, sizeof(from_name)))
        {
            output(ctx, "\r\n[Cannot send private reply - unknown sender.]\r\n");
            return 0;
        }
    }
    else
    {
        output(ctx, "\r\n[Cannot send private reply - sender is not a local user.]\r\n");
        return 0;
    }

    messagebase_viewer_close(session);

    /* Start private mail composer to the original sender */
    return messagebase_composer_start_private(session, from_name, output, ctx);
}

/* Mark a message as read - updates read time and increments timesread */
int messagebase_mark_as_read(messagebase_session *session, int message_id)
{
    LINETASK_MESSAGE_RECORD msg_record;

    if (session == NULL || message_id <= 0)
    {
        return 0;
    }

    if (!messagebase_get_message_info(session->current_messagebase, message_id, &msg_record))
    {
        return 0;
    }

    /* Update read time and counter */
    msg_record.read_time = time(NULL);
    msg_record.timesread++;

    return messagebase_update_message(session->current_messagebase, &msg_record);
}

/* ============================================================
 * MESSAGE SEARCH
 * ============================================================ */

/* Case-insensitive substring search */
static int str_contains_ci(const char *haystack, const char *needle)
{
    const char *h, *n;
    size_t needle_len, haystack_len;
    size_t i;

    if (haystack == NULL || needle == NULL || *needle == '\0')
    {
        return 0;
    }

    needle_len = strlen(needle);
    haystack_len = strlen(haystack);

    if (needle_len > haystack_len)
    {
        return 0;
    }

    for (i = 0; i <= haystack_len - needle_len; i++)
    {
        h = haystack + i;
        n = needle;
        while (*n != '\0')
        {
            char hc = (*h >= 'A' && *h <= 'Z') ? (*h + 32) : *h;
            char nc = (*n >= 'A' && *n <= 'Z') ? (*n + 32) : *n;
            if (hc != nc)
            {
                break;
            }
            h++;
            n++;
        }
        if (*n == '\0')
        {
            return 1;
        }
    }
    return 0;
}

/* Start the search prompt */
int messagebase_viewer_start_search(messagebase_session *session,
                                     void (*output)(void *ctx, const char *text),
                                     void *ctx)
{
    if (session == NULL || output == NULL)
    {
        return 0;
    }

    /* Clear search state */
    session->viewer.search_mode = 0;
    session->viewer.search_term[0] = '\0';
    session->viewer.search_result_count = 0;
    session->viewer.search_result_index = 0;

    output(ctx, "\r\n\r\n\033[1;36mSearch for:\033[0m ");
    session->viewer.phase = MESSAGE_VIEW_SEARCH_INPUT;

    return 1;
}

/* Perform the actual search across messages in current area.
 * In continuous reader mode: finds all matches, enters search_mode, shows first result.
 * Navigation (N/P) will cycle through search_results instead of all messages. */
int messagebase_viewer_do_search(messagebase_session *session,
                                  const char *term,
                                  void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *msg_ptr;
    LINETASK_MESSAGE_RECORD first_msg;
    int index;
    char from_name[MAX_FROM_NAME];
    char msg_line[256];
    int was_in_viewer;
    int first_id;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    /* Track if we were already in viewer (have a message) or came from script */
    was_in_viewer = (session->viewer.message_id > 0);

    /* Cancel search if term is empty */
    if (term == NULL || *term == '\0')
    {
        output(ctx, "\r\n[Search cancelled]\r\n");
        if (was_in_viewer)
        {
            session->viewer.phase = MESSAGE_VIEW_PROMPT;
            messagebase_viewer_show_prompt(session, output, ctx);
        }
        else
        {
            session->viewer.phase = MESSAGE_VIEW_IDLE;
        }
        return 0;
    }

    /* Store search term - sanitize control characters to prevent terminal corruption */
    {
        char *dst = session->viewer.search_term;
        const char *src = term;
        int i = 0;
        while (*src != '\0' && i < MAX_SEARCH_TERM - 1)
        {
            /* Skip control characters except space */
            if (*src >= 32 || *src == '\t')
            {
                *dst++ = *src;
                i++;
            }
            src++;
        }
        *dst = '\0';
    }
    session->viewer.search_result_count = 0;

    output(ctx, "\r\n\r\n\033[1;33mSearching...\033[0m\r\n");

    /* Enumerate messages in current area and search */
    index = 0;
    while (session->viewer.search_result_count < MAX_SEARCH_RESULTS)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
        {
            break;
        }

        if (regs.r[0] == 0 || regs.r[0] == -1)
        {
            break;  /* No more messages */
        }

        msg_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        /* Skip deleted messages */
        if (msg_ptr->deleted)
        {
            index++;
            continue;
        }

        /* Check access */
        if (!messagebase_can_read_message(session, msg_ptr))
        {
            index++;
            continue;
        }

        /* Search in subject */
        if (str_contains_ci(msg_ptr->subject, term))
        {
            session->viewer.search_results[session->viewer.search_result_count] = msg_ptr->id;
            session->viewer.search_result_count++;
            index++;
            continue;
        }

        /* Get sender name and search in it */
        from_name[0] = '\0';
        if (msg_ptr->sentby > 0)
        {
            messagebase_lookup_user_by_id(msg_ptr->sentby, from_name, sizeof(from_name));
        }
        else if (msg_ptr->fromname[0] != '\0')
        {
            strncpy(from_name, msg_ptr->fromname, sizeof(from_name) - 1);
            from_name[sizeof(from_name) - 1] = '\0';
        }

        if (str_contains_ci(from_name, term))
        {
            session->viewer.search_results[session->viewer.search_result_count] = msg_ptr->id;
            session->viewer.search_result_count++;
        }

        index++;
    }

    if (session->viewer.search_result_count == 0)
    {
        snprintf(msg_line, sizeof(msg_line), "\r\n\033[1;31mNo messages found matching '%s'\033[0m\r\n", term);
        output(ctx, msg_line);
        if (was_in_viewer)
        {
            session->viewer.phase = MESSAGE_VIEW_PROMPT;
            messagebase_viewer_show_prompt(session, output, ctx);
        }
        else
        {
            session->viewer.phase = MESSAGE_VIEW_IDLE;
        }
        return 0;
    }

    /* Enter search mode - navigation will use search results */
    session->viewer.search_mode = 1;
    session->viewer.search_result_index = 0;

    snprintf(msg_line, sizeof(msg_line), "\r\n\033[1;32mFound %d message%s matching '%s'\033[0m\r\n",
             session->viewer.search_result_count,
             session->viewer.search_result_count == 1 ? "" : "s",
             term);
    output(ctx, msg_line);
    output(ctx, "\033[1;33mPress X to exit search mode and return to normal navigation.\033[0m\r\n");

    /* Show the first search result */
    first_id = session->viewer.search_results[0];

    if (!messagebase_get_message_info(session->current_messagebase, first_id, &first_msg))
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        session->viewer.search_mode = 0;
        session->viewer.phase = MESSAGE_VIEW_IDLE;
        return 0;
    }

    /* Update total messages count if not already set */
    if (session->viewer.total_messages <= 0)
    {
        session->viewer.total_messages = messagebase_count_messages(session);
    }

    /* Update position tracking */
    session->viewer.message_position = messagebase_get_message_position(session, first_id);

    /* Show the message - enter continuous reader */
    messagebase_viewer_init(session, first_id);
    messagebase_mark_as_read(session, first_id);
    messagebase_viewer_show_header(session, output, ctx);
    messagebase_viewer_show_body(session, output, ctx);
    messagebase_viewer_show_prompt(session, output, ctx);

    return 1;
}

/* Exit search mode and return to normal navigation */
int messagebase_viewer_exit_search_mode(messagebase_session *session,
                                         void (*output)(void *ctx, const char *text),
                                         void *ctx)
{
    if (session == NULL)
    {
        return 0;
    }

    if (!session->viewer.search_mode)
    {
        /* Not in search mode, nothing to do */
        return 0;
    }

    session->viewer.search_mode = 0;
    session->viewer.search_result_count = 0;
    session->viewer.search_result_index = 0;
    session->viewer.search_term[0] = '\0';

    if (output != NULL)
    {
        output(ctx, "\r\n\033[1;32m[Exited search mode - normal navigation restored]\033[0m\r\n");
        messagebase_viewer_show_prompt(session, output, ctx);
    }

    return 1;
}

/* Start reply to current message being viewed */
int messagebase_viewer_start_reply(messagebase_session *session,
                                    void (*output)(void *ctx, const char *text),
                                    void *ctx)
{
    int message_id;

    if (session == NULL)
    {
        return 0;
    }

    message_id = session->viewer.message_id;
    messagebase_viewer_close(session);

    return messagebase_composer_start_reply(session, message_id, output, ctx);
}

/* ============================================================
 * MESSAGE COMPOSER
 * ============================================================ */

int messagebase_composer_init(messagebase_session *session, int reply_to_id)
{
    if (session == NULL)
    {
        return 0;
    }

    memset(&session->composer, 0, sizeof(session->composer));
    session->composer.phase = MESSAGE_COMPOSE_IDLE;
    session->composer.reply_to_id = reply_to_id;
    session->composer.body_lines = 0;
    session->composer.is_ftn = 0;
    session->composer.is_private = 0;
    session->composer.is_netmail = 0;
    session->composer.editor_line = 0;
    session->composer.editor_insert_mode = 0;
    session->composer.editor_priority = 0;
    session->composer.editor_recorded = 0;

    return 1;
}

int messagebase_composer_reset(messagebase_session *session)
{
    if (session == NULL)
    {
        return 0;
    }

    memset(&session->composer, 0, sizeof(session->composer));
    session->composer.phase = MESSAGE_COMPOSE_IDLE;

    return 1;
}

/* ============================================================
 * COMPOSER HEADER DISPLAY
 * ============================================================ */

void messagebase_composer_show_header(messagebase_session *session,
                                      void (*output)(void *ctx, const char *text),
                                      void *ctx,
                                      int cursor_field)
{
    char line[256];
    char date_str[64];
    char from_str[128];
    char to_str[128];
    time_t now;
    struct tm *tm_info;

    if (session == NULL || output == NULL)
    {
        return;
    }

    /* Format current date/time */
    now = time(NULL);
    tm_info = localtime(&now);
    if (tm_info != NULL)
    {
        snprintf(date_str, sizeof(date_str), "%02d %s %02d %02d:%02d:%02d",
                 tm_info->tm_mday,
                 (tm_info->tm_mon == 0) ? "Jan" :
                 (tm_info->tm_mon == 1) ? "Feb" :
                 (tm_info->tm_mon == 2) ? "Mar" :
                 (tm_info->tm_mon == 3) ? "Apr" :
                 (tm_info->tm_mon == 4) ? "May" :
                 (tm_info->tm_mon == 5) ? "Jun" :
                 (tm_info->tm_mon == 6) ? "Jul" :
                 (tm_info->tm_mon == 7) ? "Aug" :
                 (tm_info->tm_mon == 8) ? "Sep" :
                 (tm_info->tm_mon == 9) ? "Oct" :
                 (tm_info->tm_mon == 10) ? "Nov" : "Dec",
                 tm_info->tm_year % 100,
                 tm_info->tm_hour,
                 tm_info->tm_min,
                 tm_info->tm_sec);
    }
    else
    {
        strncpy(date_str, "Unknown", sizeof(date_str));
    }

    /* Build From string */
    if (session->composer.is_ftn && session->composer.from_ftn_address.zone > 0)
    {
        char addr_str[64];
        messagebase_format_ftn_address(&session->composer.from_ftn_address, addr_str, sizeof(addr_str));
        snprintf(from_str, sizeof(from_str), "%s at %s", 
                 session->user_realname[0] ? session->user_realname : "Unknown",
                 addr_str);
    }
    else
    {
        strncpy(from_str, session->user_realname[0] ? session->user_realname : "Unknown", sizeof(from_str));
    }
    from_str[sizeof(from_str) - 1] = '\0';

    /* Build To string */
    if (session->composer.is_netmail && session->composer.to_address_str[0])
    {
        snprintf(to_str, sizeof(to_str), "%s at %s",
                 session->composer.to_name[0] ? session->composer.to_name : "",
                 session->composer.to_address_str);
    }
    else if (session->composer.to_name[0])
    {
        if (session->composer.to_user_id > 0)
        {
            snprintf(to_str, sizeof(to_str), "%s (#%d)", 
                     session->composer.to_name, session->composer.to_user_id);
        }
        else
        {
            strncpy(to_str, session->composer.to_name, sizeof(to_str));
        }
    }
    else
    {
        to_str[0] = '\0';
    }
    to_str[sizeof(to_str) - 1] = '\0';

    /* Display header based on area type */
    if (session->composer.area_type == AREA_TYPE_OTHER)
    {
        /* Private Mail - different format */
        output(ctx, "\033[1;36mPrivate Mail\033[0m\r\n\r\n");
    }
    else
    {
        /* Area-based format */
        snprintf(line, sizeof(line), "\033[1;36mArea    :\033[0m %s (%03d)\r\n\r\n",
                 session->composer.area_name, session->composer.area_id);
        output(ctx, line);
    }

    /* Date line */
    snprintf(line, sizeof(line), "\033[1;33mDate    :\033[0m %s\r\n", date_str);
    output(ctx, line);

    /* From line */
    snprintf(line, sizeof(line), "\033[1;33mFrom    :\033[0m %s\r\n", from_str);
    output(ctx, line);

    /* To line */
    if (cursor_field == 0)
    {
        output(ctx, "\033[1;33mTo      :\033[0m ");
    }
    else
    {
        snprintf(line, sizeof(line), "\033[1;33mTo      :\033[0m %s\r\n", to_str);
        output(ctx, line);
    }

    /* Address line (netmail only) */
    if (session->composer.is_netmail && cursor_field != 0)
    {
        if (cursor_field == 1)
        {
            output(ctx, "\033[1;33mAddress :\033[0m ");
        }
        else
        {
            snprintf(line, sizeof(line), "\033[1;33mAddress :\033[0m %s\r\n", 
                     session->composer.to_address_str[0] ? session->composer.to_address_str : "");
            output(ctx, line);
        }
    }

    /* Subject line */
    if (cursor_field != 0 && cursor_field != 1)
    {
        if (cursor_field == 2)
        {
            output(ctx, "\033[1;33mSubject :\033[0m ");
        }
        else
        {
            snprintf(line, sizeof(line), "\033[1;33mSubject :\033[0m %s\r\n", session->composer.subject);
            output(ctx, line);
        }
    }
}

/* ============================================================
 * LINE EDITOR FUNCTIONS
 * ============================================================ */

void messagebase_editor_show_prompt(messagebase_session *session,
                                    void (*output)(void *ctx, const char *text),
                                    void *ctx)
{
    char prompt[16];

    if (session == NULL || output == NULL)
    {
        return;
    }

    snprintf(prompt, sizeof(prompt), "\033[1;36m%03d\033[0m ", session->composer.editor_line);
    output(ctx, prompt);
}

void messagebase_editor_show_help(void (*output)(void *ctx, const char *text),
                                  void *ctx)
{
    if (output == NULL)
    {
        return;
    }

    output(ctx, "\033[1;33mConverse line editor commands help:\033[0m\r\n\r\n");
    output(ctx, "/a ............ abort writing message and quit editor\r\n");
    output(ctx, "/c [(x)]....... centre/uncentre previous line [or line x]\r\n");
    output(ctx, "/d <x> [(y)] .. delete line(s) x [to y]\r\n");
    output(ctx, "/e <x> ........ edit line x (and continue writing at that point)\r\n");
    output(ctx, "/i <x> ........ insert at line x (continue writing from line x)\r\n");
    output(ctx, "/l [(x) [(y)]] . list message [from x [to y]]\r\n");
    output(ctx, "/p ............ toggle priority flag (private mailbox only)\r\n");
    output(ctx, "/r ............ toggle recorded delivery flag (private mailbox only)\r\n");
    output(ctx, "/s ............ save message and quit editor\r\n");
    output(ctx, "/z ............ move to last line of message\r\n");
    output(ctx, "\r\n");
    output(ctx, "Key:parameters within < and > are mandatory, [ and ] are optional.\r\n\r\n");
    output(ctx, "Examples: /l 1 20       list message from lines 1 to 20\r\n");
    output(ctx, "          /d 2 5        delete lines 2 to 5\r\n");
    output(ctx, "          /e 3          edit line 3\r\n");
    output(ctx, "          /i 4          continue writing text from line 4\r\n");
    output(ctx, "\r\n");
}

void messagebase_editor_show_intro(messagebase_session *session,
                                   void (*output)(void *ctx, const char *text),
                                   void *ctx)
{
    if (output == NULL)
    {
        return;
    }

    output(ctx, "\r\n\033[1;32mConverse LineEd: Press <ESC> or *enter* /? or /h for help (000 = line number)\033[0m\r\n\r\n");

    /* If we have pre-populated lines (e.g., quoted text), display them */
    if (session != NULL && session->composer.body_lines > 0)
    {
        char line_info[80];
        snprintf(line_info, sizeof(line_info),
                 "\033[1;33m[%d lines pre-filled - use /l to list, /d to delete]\033[0m\r\n\r\n",
                 session->composer.body_lines);
        output(ctx, line_info);
    }
}

void messagebase_editor_list_lines(messagebase_session *session,
                                   int from_line, int to_line,
                                   void (*output)(void *ctx, const char *text),
                                   void *ctx)
{
    char line[MAX_LINE_WIDTH + 16];
    int i;

    if (session == NULL || output == NULL)
    {
        return;
    }

    /* Default: list all lines */
    if (from_line < 0)
    {
        from_line = 0;
    }
    if (to_line < 0 || to_line >= session->composer.body_lines)
    {
        to_line = session->composer.body_lines - 1;
    }

    for (i = from_line; i <= to_line && i < session->composer.body_lines; i++)
    {
        snprintf(line, sizeof(line), "\033[1;36m%03d\033[0m %s\r\n", i, session->composer.body[i]);
        output(ctx, line);
    }
}

int messagebase_editor_delete_lines(messagebase_session *session,
                                    int from_line, int to_line)
{
    int i, count;

    if (session == NULL)
    {
        return 0;
    }

    if (from_line < 0 || from_line >= session->composer.body_lines)
    {
        return 0;
    }

    if (to_line < from_line)
    {
        to_line = from_line;
    }

    if (to_line >= session->composer.body_lines)
    {
        to_line = session->composer.body_lines - 1;
    }

    count = to_line - from_line + 1;

    /* Shift lines up */
    for (i = from_line; i + count < session->composer.body_lines; i++)
    {
        strncpy(session->composer.body[i], session->composer.body[i + count], MAX_LINE_WIDTH - 1);
        session->composer.body[i][MAX_LINE_WIDTH - 1] = '\0';
    }

    session->composer.body_lines -= count;

    /* Adjust editor position if needed */
    if (session->composer.editor_line > session->composer.body_lines)
    {
        session->composer.editor_line = session->composer.body_lines;
    }

    return count;
}

int messagebase_editor_insert_line(messagebase_session *session,
                                   int at_line, const char *text)
{
    int i;

    if (session == NULL || text == NULL)
    {
        return 0;
    }

    if (session->composer.body_lines >= MAX_COMPOSER_LINES)
    {
        return 0;
    }

    if (at_line < 0)
    {
        at_line = 0;
    }

    if (at_line > session->composer.body_lines)
    {
        at_line = session->composer.body_lines;
    }

    /* Shift lines down to make room */
    for (i = session->composer.body_lines; i > at_line; i--)
    {
        strncpy(session->composer.body[i], session->composer.body[i - 1], MAX_LINE_WIDTH - 1);
        session->composer.body[i][MAX_LINE_WIDTH - 1] = '\0';
    }

    /* Insert new line */
    strncpy(session->composer.body[at_line], text, MAX_LINE_WIDTH - 1);
    session->composer.body[at_line][MAX_LINE_WIDTH - 1] = '\0';
    session->composer.body_lines++;

    return 1;
}

int messagebase_editor_centre_line(messagebase_session *session, int line_num)
{
    char *line;
    char temp[MAX_LINE_WIDTH];
    int len, pad, i;
    int is_centred = 0;

    if (session == NULL)
    {
        return 0;
    }

    if (line_num < 0 || line_num >= session->composer.body_lines)
    {
        return 0;
    }

    line = session->composer.body[line_num];
    len = strlen(line);

    /* Skip leading spaces to find actual content */
    i = 0;
    while (i < len && line[i] == ' ')
    {
        i++;
    }

    /* Check if line is already centred (has leading spaces and trailing spaces are similar) */
    if (i > 0)
    {
        /* It's centred, uncentre it by removing leading spaces */
        memmove(line, line + i, len - i + 1);
        return 1;
    }

    /* Centre the line */
    len = strlen(line);
    
    /* Trim trailing spaces */
    while (len > 0 && line[len - 1] == ' ')
    {
        len--;
    }
    line[len] = '\0';

    if (len >= MAX_LINE_WIDTH - 2)
    {
        return 0;  /* Too long to centre */
    }

    pad = (MAX_LINE_WIDTH - 2 - len) / 2;
    if (pad > 0)
    {
        strncpy(temp, line, sizeof(temp));
        memset(line, ' ', pad);
        strncpy(line + pad, temp, MAX_LINE_WIDTH - pad - 1);
        line[MAX_LINE_WIDTH - 1] = '\0';
    }

    return 1;
}

int messagebase_editor_handle_command(messagebase_session *session,
                                      const char *command,
                                      void (*output)(void *ctx, const char *text),
                                      void *ctx)
{
    char cmd;
    int arg1 = -1, arg2 = -1;
    char line[128];

    if (session == NULL || command == NULL || output == NULL)
    {
        return 0;
    }

    /* Skip the leading / */
    if (*command == '/')
    {
        command++;
    }

    if (*command == '\0')
    {
        return 0;
    }

    cmd = *command;
    command++;

    /* Parse arguments */
    while (*command == ' ')
    {
        command++;
    }

    if (*command >= '0' && *command <= '9')
    {
        arg1 = atoi(command);
        while (*command >= '0' && *command <= '9')
        {
            command++;
        }
        while (*command == ' ')
        {
            command++;
        }
        if (*command >= '0' && *command <= '9')
        {
            arg2 = atoi(command);
        }
    }

    switch (cmd)
    {
        case 'a':
        case 'A':
            /* Abort - return special code to trigger confirmation */
            return -1;  /* Signal to caller to ask for confirmation */

        case 'c':
        case 'C':
            /* Centre line */
            if (arg1 < 0)
            {
                arg1 = session->composer.editor_line - 1;  /* Previous line */
            }
            if (messagebase_editor_centre_line(session, arg1))
            {
                snprintf(line, sizeof(line), "[Line %03d centred/uncentred]\r\n", arg1);
                output(ctx, line);
            }
            else
            {
                output(ctx, "[Invalid line number]\r\n");
            }
            break;

        case 'd':
        case 'D':
            /* Delete lines */
            if (arg1 < 0)
            {
                output(ctx, "[Usage: /d <line> [end_line]]\r\n");
            }
            else
            {
                int count = messagebase_editor_delete_lines(session, arg1, arg2 >= 0 ? arg2 : arg1);
                if (count > 0)
                {
                    snprintf(line, sizeof(line), "[Deleted %d line(s)]\r\n", count);
                    output(ctx, line);
                }
                else
                {
                    output(ctx, "[Invalid line range]\r\n");
                }
            }
            break;

        case 'e':
        case 'E':
            /* Edit line - set position to continue from that line */
            if (arg1 < 0 || arg1 >= session->composer.body_lines)
            {
                output(ctx, "[Invalid line number]\r\n");
            }
            else
            {
                session->composer.editor_line = arg1;
                session->composer.editor_insert_mode = 0;
                snprintf(line, sizeof(line), "[Editing from line %03d]\r\n", arg1);
                output(ctx, line);
            }
            break;

        case 'i':
        case 'I':
            /* Insert at line */
            if (arg1 < 0 || arg1 > session->composer.body_lines)
            {
                output(ctx, "[Invalid line number]\r\n");
            }
            else
            {
                session->composer.editor_line = arg1;
                session->composer.editor_insert_mode = 1;
                snprintf(line, sizeof(line), "[Inserting at line %03d]\r\n", arg1);
                output(ctx, line);
            }
            break;

        case 'l':
        case 'L':
            /* List lines */
            if (session->composer.body_lines == 0)
            {
                output(ctx, "[No lines to list]\r\n");
            }
            else
            {
                messagebase_editor_list_lines(session, arg1, arg2, output, ctx);
            }
            break;

        case 'p':
        case 'P':
            /* Toggle priority flag (private mail only) */
            if (!session->composer.is_private)
            {
                output(ctx, "[Priority flag only available for private mail]\r\n");
            }
            else
            {
                session->composer.editor_priority = !session->composer.editor_priority;
                snprintf(line, sizeof(line), "[Priority flag: %s]\r\n",
                         session->composer.editor_priority ? "ON" : "OFF");
                output(ctx, line);
            }
            break;

        case 'r':
        case 'R':
            /* Toggle recorded delivery flag (private mail only) */
            if (!session->composer.is_private)
            {
                output(ctx, "[Recorded delivery only available for private mail]\r\n");
            }
            else
            {
                session->composer.editor_recorded = !session->composer.editor_recorded;
                snprintf(line, sizeof(line), "[Recorded delivery: %s]\r\n",
                         session->composer.editor_recorded ? "ON" : "OFF");
                output(ctx, line);
            }
            break;

        case 's':
        case 'S':
            /* Save - return special code to trigger send */
            return -2;  /* Signal to caller to save/send message */

        case 'z':
        case 'Z':
            /* Move to last line */
            session->composer.editor_line = session->composer.body_lines;
            snprintf(line, sizeof(line), "[Moved to line %03d]\r\n", session->composer.editor_line);
            output(ctx, line);
            break;

        case '?':
        case 'h':
        case 'H':
            /* Show help */
            messagebase_editor_show_help(output, ctx);
            break;

        default:
            snprintf(line, sizeof(line), "[Unknown command: /%c]\r\n", cmd);
            output(ctx, line);
            break;
    }

    return 1;
}

int messagebase_composer_start_post(messagebase_session *session,
                                     void (*output)(void *ctx, const char *text),
                                     void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    if (session->current_messagebase <= 0 || session->current_area <= 0)
    {
        output(ctx, "\r\n[No messagebase/area selected.]\r\n");
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_AREA_INFO;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = session->current_area;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        output(ctx, "\r\n[Error getting area info.]\r\n");
        return 0;
    }

    area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

    /* Initialize composer */
    messagebase_composer_init(session, 0);

    /* Store area info in composer state */
    session->composer.area_type = area_ptr->areatype;
    session->composer.area_id = session->current_area;
    strncpy(session->composer.area_name, area_ptr->name, sizeof(session->composer.area_name) - 1);
    session->composer.area_name[sizeof(session->composer.area_name) - 1] = '\0';

    session->composer.is_ftn = (area_ptr->areatype == AREA_TYPE_ECHO ||
                                 area_ptr->areatype == AREA_TYPE_NETMAIL);
    session->composer.is_netmail = (area_ptr->areatype == AREA_TYPE_NETMAIL);
    session->composer.is_private = (area_ptr->areatype == AREA_TYPE_NETMAIL ||
                                     area_ptr->areatype == AREA_TYPE_OTHER);

    /* For echomail/local, default To is "All" */
    if (!session->composer.is_private)
    {
        strncpy(session->composer.to_name, "All", sizeof(session->composer.to_name) - 1);
        session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
    }

    /* Clear screen and paint a blue banner on the first line */
    output(ctx, "\033[2J\033[H\033[44;37m New Message \033[K\033[0m\r\n\r\n");

    /* Show header with cursor on To field (cursor_field=0) */
    messagebase_composer_show_header(session, output, ctx, 0);

    /* Always start with To field, even for echomail */
    session->composer.phase = MESSAGE_COMPOSE_TO_NAME;

    return 1;
}

/* Load original message body and add quoted lines to composer */
static int messagebase_quote_original(messagebase_session *session,
                                       int base_id, int message_id,
                                       const char *from_name,
                                       time_t sent_time)
{
    char buffer[VIEWER_LINE_BUFFER_SIZE];
    char line[MAX_LINE_WIDTH];
    char quoted_line[MAX_LINE_WIDTH];
    struct tm *tm_ptr;
    long offset = 0;
    long bytes_to_read;
    int bytes_read;
    int line_pos = 0;
    int i;

    if (session == NULL || base_id <= 0 || message_id <= 0)
    {
        return 0;
    }

    /* Add attribution line */
    tm_ptr = localtime(&sent_time);
    if (tm_ptr != NULL && from_name != NULL && from_name[0] != '\0')
    {
        snprintf(quoted_line, sizeof(quoted_line),
                 "%s wrote on %02d/%02d/%02d:",
                 from_name,
                 tm_ptr->tm_mday, tm_ptr->tm_mon + 1, (tm_ptr->tm_year % 100));
    }
    else if (from_name != NULL && from_name[0] != '\0')
    {
        snprintf(quoted_line, sizeof(quoted_line), "%s wrote:", from_name);
    }
    else
    {
        strncpy(quoted_line, "Original message:", sizeof(quoted_line) - 1);
        quoted_line[sizeof(quoted_line) - 1] = '\0';
    }

    if (session->composer.body_lines < MAX_COMPOSER_LINES)
    {
        strncpy(session->composer.body[session->composer.body_lines],
                quoted_line, MAX_LINE_WIDTH - 1);
        session->composer.body[session->composer.body_lines][MAX_LINE_WIDTH - 1] = '\0';
        session->composer.body_lines++;
    }

    /* Add empty line after attribution */
    if (session->composer.body_lines < MAX_COMPOSER_LINES)
    {
        session->composer.body[session->composer.body_lines][0] = '\0';
        session->composer.body_lines++;
    }

    /* Get the body size from message info */
    {
        _kernel_swi_regs regs;
        LINETASK_MESSAGE_RECORD *msg_ptr;

        regs.r[0] = FILER_MESSAGEBASE_CMD_MESSAGE_INFO;
        regs.r[1] = base_id;
        regs.r[2] = message_id;
        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
        {
            return session->composer.body_lines;
        }
        msg_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        /* Download and quote body - limit to half of max lines for reply space */
        while (offset < msg_ptr->bodysize &&
               session->composer.body_lines < (MAX_COMPOSER_LINES / 2))
        {
            bytes_to_read = msg_ptr->bodysize - offset;
            if (bytes_to_read > VIEWER_LINE_BUFFER_SIZE - 1)
            {
                bytes_to_read = VIEWER_LINE_BUFFER_SIZE - 1;
            }

            bytes_read = messagebase_download_block(base_id, message_id,
                                                     buffer, offset, (int)bytes_to_read);
            if (bytes_read <= 0)
            {
                break;
            }

            for (i = 0; i < bytes_read &&
                 session->composer.body_lines < (MAX_COMPOSER_LINES / 2); i++)
            {
                char ch = buffer[i];

                if (ch == '\n' || ch == '\r')
                {
                    line[line_pos] = '\0';

                    /* Build quoted line with "> " prefix */
                    snprintf(quoted_line, sizeof(quoted_line), "> %s", line);
                    strncpy(session->composer.body[session->composer.body_lines],
                            quoted_line, MAX_LINE_WIDTH - 1);
                    session->composer.body[session->composer.body_lines][MAX_LINE_WIDTH - 1] = '\0';
                    session->composer.body_lines++;
                    line_pos = 0;

                    /* Skip LF after CR */
                    if (ch == '\r' && i + 1 < bytes_read && buffer[i + 1] == '\n')
                    {
                        i++;
                    }
                }
                else if (line_pos < MAX_LINE_WIDTH - 4) /* Leave room for "> " prefix */
                {
                    line[line_pos++] = ch;
                }
                else
                {
                    /* Line too long - wrap */
                    line[line_pos] = '\0';
                    snprintf(quoted_line, sizeof(quoted_line), "> %s", line);
                    strncpy(session->composer.body[session->composer.body_lines],
                            quoted_line, MAX_LINE_WIDTH - 1);
                    session->composer.body[session->composer.body_lines][MAX_LINE_WIDTH - 1] = '\0';
                    session->composer.body_lines++;
                    line_pos = 0;
                    line[line_pos++] = ch;
                }

                offset++;
            }
        }

        /* Handle final line if any */
        if (line_pos > 0 && session->composer.body_lines < (MAX_COMPOSER_LINES / 2))
        {
            line[line_pos] = '\0';
            snprintf(quoted_line, sizeof(quoted_line), "> %s", line);
            strncpy(session->composer.body[session->composer.body_lines],
                    quoted_line, MAX_LINE_WIDTH - 1);
            session->composer.body[session->composer.body_lines][MAX_LINE_WIDTH - 1] = '\0';
            session->composer.body_lines++;
        }
    }

    /* Add blank line before reply text */
    if (session->composer.body_lines < MAX_COMPOSER_LINES)
    {
        session->composer.body[session->composer.body_lines][0] = '\0';
        session->composer.body_lines++;
    }

    return session->composer.body_lines;
}

int messagebase_composer_start_reply(messagebase_session *session,
                                      int message_id,
                                      void (*output)(void *ctx, const char *text),
                                      void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *msg_ptr;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    char from_name[MAX_FROM_NAME];
    time_t original_sent;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    if (message_id <= 0)
    {
        output(ctx, "\r\n[No message to reply to.]\r\n");
        return 0;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_MESSAGE_INFO;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = message_id;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        output(ctx, "\r\n[Error getting message.]\r\n");
        return 0;
    }

    msg_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

    regs.r[0] = FILER_MESSAGEBASE_CMD_AREA_INFO;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = msg_ptr->messagebaseareaid;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        output(ctx, "\r\n[Error getting area info.]\r\n");
        return 0;
    }

    area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

    regs.r[0] = FILER_MESSAGEBASE_CMD_MESSAGE_INFO;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = message_id;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        output(ctx, "\r\n[Error re-reading message.]\r\n");
        return 0;
    }
    msg_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

    messagebase_composer_init(session, message_id);

    /* Update current_area to match the message's area - critical for send */
    session->current_area = msg_ptr->messagebaseareaid;

    /* Store area info in composer state */
    session->composer.area_type = area_ptr->areatype;
    session->composer.area_id = msg_ptr->messagebaseareaid;
    strncpy(session->composer.area_name, area_ptr->name, sizeof(session->composer.area_name) - 1);
    session->composer.area_name[sizeof(session->composer.area_name) - 1] = '\0';

    session->composer.is_ftn = (area_ptr->areatype == AREA_TYPE_ECHO ||
                                 area_ptr->areatype == AREA_TYPE_NETMAIL);
    session->composer.is_netmail = (area_ptr->areatype == AREA_TYPE_NETMAIL);
    session->composer.is_private = (area_ptr->areatype == AREA_TYPE_NETMAIL ||
                                     area_ptr->areatype == AREA_TYPE_OTHER);

    if (msg_ptr->sentby > 0)
    {
        if (!messagebase_lookup_user_by_id(msg_ptr->sentby, from_name, sizeof(from_name)))
        {
            snprintf(from_name, sizeof(from_name), "User #%d", msg_ptr->sentby);
        }
        strncpy(session->composer.to_name, from_name, sizeof(session->composer.to_name) - 1);
        session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
        session->composer.to_user_id = msg_ptr->sentby;
    }
    else if (msg_ptr->orgaddr.zone > 0)
    {
        /* FTN message - use fromname if available, otherwise format address */
        if (msg_ptr->fromname[0] != '\0')
        {
            strncpy(from_name, msg_ptr->fromname, sizeof(from_name) - 1);
            from_name[sizeof(from_name) - 1] = '\0';
            strncpy(session->composer.to_name, msg_ptr->fromname, sizeof(session->composer.to_name) - 1);
            session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
        }
        else
        {
            messagebase_format_ftn_address(&msg_ptr->orgaddr, from_name, sizeof(from_name));
            strncpy(session->composer.to_name, from_name, sizeof(session->composer.to_name) - 1);
            session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
        }
        memcpy(&session->composer.to_ftn_address, &msg_ptr->orgaddr, sizeof(LINETASK_FTN_ADDRESS));
        /* Store address as string for netmail */
        if (session->composer.is_netmail)
        {
            messagebase_format_ftn_address(&msg_ptr->orgaddr, 
                                           session->composer.to_address_str, 
                                           sizeof(session->composer.to_address_str));
        }
    }
    else
    {
        strncpy(from_name, "Unknown", sizeof(from_name) - 1);
        from_name[sizeof(from_name) - 1] = '\0';
        strncpy(session->composer.to_name, "Unknown", sizeof(session->composer.to_name) - 1);
        session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
    }

    /* Capture sent time for attribution line */
    original_sent = (msg_ptr->sent > 0) ? msg_ptr->sent : msg_ptr->imported;

    if (strncmp(msg_ptr->subject, "Re: ", 4) == 0)
    {
        strncpy(session->composer.subject, msg_ptr->subject, sizeof(session->composer.subject) - 1);
        session->composer.subject[sizeof(session->composer.subject) - 1] = '\0';
    }
    else
    {
        snprintf(session->composer.subject, sizeof(session->composer.subject),
                 "Re: %s", msg_ptr->subject);
    }

    /* Quote original message body */
    messagebase_quote_original(session, session->current_messagebase, message_id,
                               from_name, original_sent);

    /* Clear screen and paint a blue banner on the first line */
    output(ctx, "\033[2J\033[H\033[44;37m Reply to Message \033[K\033[0m\r\n\r\n");

    /* Show header with cursor beyond all fields (cursor_field=3) */
    messagebase_composer_show_header(session, output, ctx, 3);

    /* Show editor intro and start body entry */
    messagebase_editor_show_intro(session, output, ctx);
    messagebase_editor_show_prompt(session, output, ctx);

    session->composer.phase = MESSAGE_COMPOSE_BODY;

    return 1;
}

int messagebase_composer_is_active(messagebase_session *session)
{
    if (session == NULL)
    {
        return 0;
    }

    return (session->composer.phase != MESSAGE_COMPOSE_IDLE);
}

int messagebase_composer_handle_line(messagebase_session *session,
                                      const char *line,
                                      void (*output)(void *ctx, const char *text),
                                      void *ctx)
{
    int cmd_result;

    if (session == NULL || output == NULL)
    {
        return -1;
    }

    if (session->composer.phase == MESSAGE_COMPOSE_IDLE)
    {
        return -1;
    }

    switch (session->composer.phase)
    {
        case MESSAGE_COMPOSE_TO_NAME:
            if (line == NULL || *line == '\0')
            {
                /* For non-private areas, empty To: means "All" */
                if (!session->composer.is_private)
                {
                    strncpy(session->composer.to_name, "All", sizeof(session->composer.to_name) - 1);
                    session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
                    output(ctx, "All\r\n");
                    output(ctx, "\033[1;33mSubject :\033[0m ");
                    session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
                }
                else
                {
                    output(ctx, "\r\n[Recipient required. Cancelled.]\r\n");
                    messagebase_composer_reset(session);
                    return 0;
                }
            }
            else
            {
                /* Store the name temporarily */
                strncpy(session->composer.to_name, line, sizeof(session->composer.to_name) - 1);
                session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';

                if (session->composer.is_netmail)
                {
                    /* For netmail, go straight to address prompt */
                    output(ctx, "\r\n\033[1;33mAddress :\033[0m ");
                    session->composer.phase = MESSAGE_COMPOSE_ADDRESS;
                }
                else if (session->composer.is_private)
                {
                    /* For private mail, validate user exists using our lookup function */
                    int to_user_id = 0;
                    if (messagebase_lookup_user_by_name(line, &to_user_id) && to_user_id > 0)
                    {
                        char found_msg[128];
                        session->composer.to_user_id = to_user_id;
                        /* Look up their real name for display */
                        char realname[MAX_FROM_NAME];
                        if (messagebase_lookup_user_by_id(to_user_id, realname, sizeof(realname)))
                        {
                            strncpy(session->composer.to_name, realname, sizeof(session->composer.to_name) - 1);
                            session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
                        }
                        /* Show confirmation of found user */
                        snprintf(found_msg, sizeof(found_msg), "\r\n\033[1;32m%s (#%d)\033[0m\r\n",
                                 session->composer.to_name, to_user_id);
                        output(ctx, found_msg);
                        /* Prompt for subject */
                        output(ctx, "\033[1;33mSubject :\033[0m ");
                        session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
                    }
                    else
                    {
                        output(ctx, "\r\n[User not found.]\r\n\033[1;33mTo      :\033[0m ");
                    }
                }
                else
                {
                    /* For echomail/local, any name is fine - prompt subject */
                    output(ctx, "\r\n\033[1;33mSubject :\033[0m ");
                    session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
                }
            }
            return 1;

        case MESSAGE_COMPOSE_ADDRESS:
            if (line == NULL || *line == '\0')
            {
                output(ctx, "\r\n[FTN address required. Cancelled.]\r\n");
                messagebase_composer_reset(session);
                return 0;
            }
            /* Validate FTN address */
            if (messagebase_parse_ftn_address(line, &session->composer.to_ftn_address))
            {
                char addr_msg[128];
                strncpy(session->composer.to_address_str, line, sizeof(session->composer.to_address_str) - 1);
                session->composer.to_address_str[sizeof(session->composer.to_address_str) - 1] = '\0';
                /* Show confirmation of validated address */
                snprintf(addr_msg, sizeof(addr_msg), "\r\n\033[1;32m%s at %s\033[0m\r\n",
                         session->composer.to_name[0] ? session->composer.to_name : "User",
                         session->composer.to_address_str);
                output(ctx, addr_msg);
                /* Prompt for subject */
                output(ctx, "\033[1;33mSubject :\033[0m ");
                session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
            }
            else
            {
                output(ctx, "\r\n[Invalid FTN address. Format: zone:net/node.point]\r\n\033[1;33mAddress :\033[0m ");
            }
            return 1;

        case MESSAGE_COMPOSE_SUBJECT:
            if (line == NULL || *line == '\0')
            {
                /* Default subject instead of aborting */
                strncpy(session->composer.subject, "(No subject)", sizeof(session->composer.subject) - 1);
                session->composer.subject[sizeof(session->composer.subject) - 1] = '\0';
                messagebase_editor_show_intro(session, output, ctx);
                messagebase_editor_show_prompt(session, output, ctx);
                session->composer.phase = MESSAGE_COMPOSE_BODY;
                return 1;
            }
            strncpy(session->composer.subject, line, sizeof(session->composer.subject) - 1);
            session->composer.subject[sizeof(session->composer.subject) - 1] = '\0';
            
            /* Show editor intro and first line prompt */
            messagebase_editor_show_intro(session, output, ctx);
            messagebase_editor_show_prompt(session, output, ctx);
            
            session->composer.phase = MESSAGE_COMPOSE_BODY;
            return 1;

        case MESSAGE_COMPOSE_BODY:
            /* Check for ESC key (single byte 27) */
            if (line != NULL && line[0] == 27 && line[1] == '\0')
            {
                messagebase_editor_show_help(output, ctx);
                messagebase_editor_show_prompt(session, output, ctx);
                return 1;
            }
            
            /* Check for editor commands */
            if (line != NULL && line[0] == '/')
            {
                cmd_result = messagebase_editor_handle_command(session, line, output, ctx);
                if (cmd_result == -1)
                {
                    /* Abort requested - ask for confirmation */
                    output(ctx, "\r\n\033[1;31mAbort message? All text will be lost. [Y/N]\033[0m ");
                    session->composer.phase = MESSAGE_COMPOSE_CONFIRM_ABORT;
                    return 1;
                }
                else if (cmd_result == -2)
                {
                    /* Save requested - show preview and confirm */
                    messagebase_composer_show_preview(session, output, ctx);
                    return 1;
                }
                /* Command handled, show next prompt */
                messagebase_editor_show_prompt(session, output, ctx);
                return 1;
            }
            
            /* Empty line with no content yet - ask what to do */
            if ((line == NULL || *line == '\0') && session->composer.body_lines == 0)
            {
                output(ctx, "\r\n\033[1;31mNo message entered. [A]bort or [C]ontinue?\033[0m ");
                session->composer.phase = MESSAGE_COMPOSE_CONFIRM_ABORT;
                return 1;
            }
            
            /* Empty line with content - show preview */
            if (line == NULL || *line == '\0')
            {
                messagebase_composer_show_preview(session, output, ctx);
                return 1;
            }
            
            /* Add the line to the message */
            if (session->composer.editor_insert_mode && 
                session->composer.editor_line < session->composer.body_lines)
            {
                /* Insert mode - insert at current position */
                if (!messagebase_editor_insert_line(session, session->composer.editor_line, line))
                {
                    output(ctx, "\r\n\033[1;31m[Maximum lines reached - use /s to save]\033[0m\r\n");
                }
            }
            else if (session->composer.editor_line < session->composer.body_lines)
            {
                /* Edit/overwrite mode */
                strncpy(session->composer.body[session->composer.editor_line], line, MAX_LINE_WIDTH - 1);
                session->composer.body[session->composer.editor_line][MAX_LINE_WIDTH - 1] = '\0';
            }
            else
            {
                /* Append mode */
                if (!messagebase_composer_add_line(session, line))
                {
                    output(ctx, "\r\n\033[1;31m[Maximum lines reached - use /s to save]\033[0m\r\n");
                }
            }
            
            session->composer.editor_line++;;
            messagebase_editor_show_prompt(session, output, ctx);
            return 1;

        case MESSAGE_COMPOSE_CONFIRM_ABORT:
            if (line != NULL && (*line == 'Y' || *line == 'y'))
            {
                output(ctx, "\r\n[Message aborted.]\r\n");
                messagebase_composer_reset(session);
                return 0;
            }
            else if (line != NULL && (*line == 'N' || *line == 'n' || *line == 'C' || *line == 'c'))
            {
                output(ctx, "\r\n[Continuing...]\r\n");
                messagebase_editor_show_prompt(session, output, ctx);
                session->composer.phase = MESSAGE_COMPOSE_BODY;
                return 1;
            }
            else
            {
                output(ctx, "\r\n[Please enter Y or N.]\r\n\033[1;31mAbort? [Y/N]\033[0m ");
                return 1;
            }

        case MESSAGE_COMPOSE_CONFIRM:
            if (line != NULL && (*line == 'S' || *line == 's'))
            {
                messagebase_composer_send(session, output, ctx);
                return 0;
            }
            else if (line != NULL && (*line == 'E' || *line == 'e'))
            {
                output(ctx, "\r\n[Returning to editor...]\r\n");
                messagebase_editor_list_lines(session, -1, -1, output, ctx);
                output(ctx, "\r\n");
                messagebase_editor_show_prompt(session, output, ctx);
                session->composer.phase = MESSAGE_COMPOSE_BODY;
                return 1;
            }
            else if (line != NULL && (*line == 'A' || *line == 'a'))
            {
                output(ctx, "\r\n\033[1;31mAbort message? All text will be lost. [Y/N]\033[0m ");
                session->composer.phase = MESSAGE_COMPOSE_CONFIRM_ABORT;
                return 1;
            }
            else
            {
                output(ctx, "\r\n[Please enter S, E, or A.]\r\n");
                output(ctx, "\033[1;33m[S]end, [E]dit, [A]bort?\033[0m ");
                return 1;
            }

        default:
            return -1;
    }
}

int messagebase_composer_set_to(messagebase_session *session,
                                 const char *to_name,
                                 void (*output)(void *ctx, const char *text),
                                 void *ctx)
{
    if (session == NULL || to_name == NULL)
    {
        return 0;
    }

    strncpy(session->composer.to_name, to_name, sizeof(session->composer.to_name) - 1);
    session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';

    if (session->composer.is_ftn &&
        messagebase_parse_ftn_address(to_name, &session->composer.to_ftn_address))
    {
        session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
        if (output)
        {
            output(ctx, "\r\n\033[1;33mSubject:\033[0m ");
        }
    }
    else
    {
        _kernel_swi_regs regs;
        regs.r[0] = 4;
        regs.r[1] = (int)to_name;
        regs.r[2] = 0;
        if (_kernel_swi(SWI_FILER_USERDB, &regs, &regs) == NULL &&
            regs.r[0] == 0 && regs.r[1] != 0)
        {
            int *rec = (int *)regs.r[1];
            session->composer.to_user_id = rec[0];
            session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
            if (output)
            {
                output(ctx, "\r\n\033[1;33mSubject:\033[0m ");
            }
        }
        else if (session->composer.is_ftn)
        {
            if (output)
            {
                output(ctx, "\r\n[Invalid FTN address. Format: zone:net/node.point]\r\n");
                output(ctx, "\033[1;33mTo:\033[0m ");
            }
            return 0;
        }
        else
        {
            if (output)
            {
                output(ctx, "\r\n[User not found.]\r\n");
                output(ctx, "\033[1;33mTo:\033[0m ");
            }
            return 0;
        }
    }

    return 1;
}

int messagebase_composer_set_subject(messagebase_session *session,
                                      const char *subject,
                                      void (*output)(void *ctx, const char *text),
                                      void *ctx)
{
    if (session == NULL || subject == NULL)
    {
        return 0;
    }

    if (strlen(subject) == 0)
    {
        if (output)
        {
            output(ctx, "[Subject cannot be empty.]\r\n");
            output(ctx, "\033[1;33mSubject :\033[0m ");
        }
        return 0;
    }

    strncpy(session->composer.subject, subject, sizeof(session->composer.subject) - 1);
    session->composer.subject[sizeof(session->composer.subject) - 1] = '\0';

    session->composer.phase = MESSAGE_COMPOSE_BODY;

    if (output)
    {
        messagebase_editor_show_intro(session, output, ctx);
        messagebase_editor_show_prompt(session, output, ctx);
    }

    return 1;
}

int messagebase_composer_add_line(messagebase_session *session,
                                   const char *line)
{
    int line_len;

    if (session == NULL || line == NULL)
    {
        return 0;
    }

    if (session->composer.body_lines >= MAX_COMPOSER_LINES)
    {
        return 0;
    }

    line_len = strlen(line);
    if (line_len > MAX_LINE_WIDTH - 1)
    {
        line_len = MAX_LINE_WIDTH - 1;
    }

    strncpy(session->composer.body[session->composer.body_lines], line, line_len);
    session->composer.body[session->composer.body_lines][line_len] = '\0';
    session->composer.body_lines++;

    return 1;
}

int messagebase_composer_show_preview(messagebase_session *session,
                                       void (*output)(void *ctx, const char *text),
                                       void *ctx)
{
    char line[256];
    int i;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    output(ctx, "\r\n\033[1;44;37m Message Preview \033[0m\r\n\r\n");

    /* Show To field with FTN address if netmail */
    if (session->composer.is_netmail && session->composer.to_address_str[0])
    {
        snprintf(line, sizeof(line), "\033[1;36mTo:\033[0m      %s (%s)\r\n", 
                 session->composer.to_name, session->composer.to_address_str);
    }
    else if (session->composer.to_user_id > 0)
    {
        snprintf(line, sizeof(line), "\033[1;36mTo:\033[0m      %s (#%d)\r\n", 
                 session->composer.to_name, session->composer.to_user_id);
    }
    else
    {
        snprintf(line, sizeof(line), "\033[1;36mTo:\033[0m      %s\r\n", session->composer.to_name);
    }
    output(ctx, line);

    snprintf(line, sizeof(line), "\033[1;36mSubject:\033[0m %s\r\n", 
             session->composer.subject[0] ? session->composer.subject : "(No subject)");
    output(ctx, line);

    output(ctx, "\033[1;30m");
    output(ctx, "------------------------------------------------------------------------");
    output(ctx, "\033[0m\r\n");

    for (i = 0; i < session->composer.body_lines; i++)
    {
        output(ctx, session->composer.body[i]);
        output(ctx, "\r\n");
    }

    output(ctx, "\r\n\033[1;33m[S]end, [E]dit, [A]bort?\033[0m ");

    session->composer.phase = MESSAGE_COMPOSE_CONFIRM;

    return 1;
}

int messagebase_composer_send(messagebase_session *session,
                               void (*output)(void *ctx, const char *text),
                               void *ctx)
{
    _kernel_swi_regs regs;
    char body_buffer[MAX_COMPOSER_LINES * (MAX_LINE_WIDTH + 2) + 1];
    int body_len = 0;
    int i;
    int message_id;
    time_t now;
    LINETASK_MESSAGE_RECORD msg;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    debug_printf("composer_send: %d body lines", session->composer.body_lines);

    /* Build message body from composed lines */
    for (i = 0; i < session->composer.body_lines; i++)
    {
        int line_len = strlen(session->composer.body[i]);
        debug_printf("composer_send: line %d len=%d: %.40s", i, line_len, session->composer.body[i]);
        if (body_len + line_len + 2 >= (int)sizeof(body_buffer))
        {
            break;
        }
        memcpy(body_buffer + body_len, session->composer.body[i], line_len);
        body_len += line_len;
        body_buffer[body_len++] = '\r';
        body_buffer[body_len++] = '\n';
    }

    /* Ensure body is not empty so uploads do not fail */
    if (body_len == 0)
    {
        body_buffer[0] = '\r';
        body_buffer[1] = '\n';
        body_len = 2;
    }

    body_buffer[body_len] = '\0';

    debug_printf("composer_send: total body_len=%d", body_len);

    /* Prepare message record template */
    time(&now);
    memset(&msg, 0, sizeof(msg));
    msg.messagebaseid = session->current_messagebase;
    msg.messagebaseareaid = session->composer.area_id;  /* Use composer's cached area, not session->current_area */
    msg.type = session->composer.is_ftn ?
               (session->composer.is_private ? 2 : 1) :
               (session->composer.is_private ? 3 : 0);
    msg.deleted = 0;
    msg.accesslevel = 0;
    msg.exported = 0;  /* Not yet exported */
    strncpy(msg.subject, session->composer.subject, sizeof(msg.subject) - 1);
    msg.subject[sizeof(msg.subject) - 1] = '\0';
    msg.sentby = session->user_id;
    msg.receivedby = session->composer.to_user_id;

    /* Set from/to names for FTN messages */
    strncpy(msg.fromname, session->user_realname, sizeof(msg.fromname) - 1);
    msg.fromname[sizeof(msg.fromname) - 1] = '\0';
    strncpy(msg.toname, session->composer.to_name, sizeof(msg.toname) - 1);
    msg.toname[sizeof(msg.toname) - 1] = '\0';

    if (session->composer.to_ftn_address.zone > 0)
    {
        memcpy(&msg.dstaddr, &session->composer.to_ftn_address, sizeof(msg.dstaddr));
    }

    msg.sent = now;
    msg.bodysize = body_len;

    debug_printf("composer_send: base=%d area=%d to_user=%d type=%d", 
                 msg.messagebaseid, msg.messagebaseareaid, msg.receivedby, msg.type);

    /* Begin upload - pass message template */
    regs.r[0] = FILER_MESSAGEBASE_CMD_BEGIN_UPLOAD;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = (int)&msg;

    debug_printf("composer_send: calling BEGIN_UPLOAD base=%d", session->current_messagebase);

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] <= 0)
    {
        debug_printf("composer_send: BEGIN_UPLOAD failed, r0=%d", regs.r[0]);
        output(ctx, "\r\n[Error creating message.]\r\n");
        return 0;
    }

    message_id = regs.r[0];
    debug_printf("composer_send: got message_id=%d", message_id);

    /* Upload message body */
    regs.r[0] = FILER_MESSAGEBASE_CMD_UPLOAD_BLOCK;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = message_id;
    regs.r[3] = (int)body_buffer;
    regs.r[4] = body_len;

    debug_printf("composer_send: calling UPLOAD_BLOCK len=%d", body_len);

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL)
    {
        output(ctx, "\r\n[Error writing message body.]\r\n");
        return 0;
    }

    /* End upload - flush and close cached file handle */
    regs.r[0] = FILER_MESSAGEBASE_CMD_END_UPLOAD;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = message_id;
    _kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs);

    output(ctx, "\r\n\033[1;32mMessage sent successfully.\033[0m\r\n");

    messagebase_composer_reset(session);

    return message_id;
}

/* ============================================================
 * FTN AKA Lookup Helpers
 * ============================================================ */

int messagebase_get_aka_for_zone(int zone, LINETASK_FTN_ADDRESS *aka)
{
    _kernel_swi_regs regs;
    int count;
    int i;

    if (aka == NULL || zone <= 0)
    {
        return 0;
    }

    regs.r[0] = 6;
    if (_kernel_swi(SWI_SUPPORT_FTNCONFIG, &regs, &regs) != NULL)
    {
        return 0;
    }
    count = regs.r[0];

    for (i = 0; i < count; i++)
    {
        regs.r[0] = 2;
        regs.r[1] = i;
        if (_kernel_swi(SWI_SUPPORT_FTNCONFIG, &regs, &regs) == NULL && regs.r[0] != 0)
        {
            int *addr_config = (int *)regs.r[0];
            int addr_zone = addr_config[0];

            if (addr_zone == zone)
            {
                aka->zone = addr_config[0];
                aka->net = addr_config[1];
                aka->node = addr_config[2];
                aka->point = addr_config[3];
                return 1;
            }
        }
    }

    regs.r[0] = 2;
    regs.r[1] = 0;
    if (_kernel_swi(SWI_SUPPORT_FTNCONFIG, &regs, &regs) == NULL && regs.r[0] != 0)
    {
        int *addr_config = (int *)regs.r[0];
        aka->zone = addr_config[0];
        aka->net = addr_config[1];
        aka->node = addr_config[2];
        aka->point = addr_config[3];
        return 1;
    }

    return 0;
}

int messagebase_get_area_type(messagebase_session *session, int area_id)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return -1;
    }

    regs.r[0] = FILER_MESSAGEBASE_CMD_AREA_INFO;
    regs.r[1] = session->current_messagebase;
    regs.r[2] = area_id;

    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        return -1;
    }

    area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

    return area_ptr->areatype;
}

/* ============================================================
 * NAVIGATION HELPERS
 * ============================================================ */

int messagebase_get_next_message_id(messagebase_session *session, int current_id)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int found_current = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (record_ptr->deleted)
        {
            index++;
            continue;
        }

        if (found_current)
        {
            if (messagebase_can_read_message(session, record_ptr))
            {
                return record_ptr->id;
            }
        }

        if (record_ptr->id == current_id)
        {
            found_current = 1;
        }

        index++;
    }

    return 0;
}

int messagebase_get_prev_message_id(messagebase_session *session, int current_id)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int prev_id = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (record_ptr->deleted)
        {
            index++;
            continue;
        }

        if (record_ptr->id == current_id)
        {
            return prev_id;
        }

        if (messagebase_can_read_message(session, record_ptr))
        {
            prev_id = record_ptr->id;
        }

        index++;
    }

    return 0;
}

int messagebase_get_first_message_id(messagebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (!record_ptr->deleted && messagebase_can_read_message(session, record_ptr))
        {
            return record_ptr->id;
        }

        index++;
    }

    return 0;
}

int messagebase_get_last_message_id(messagebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int last_id = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (!record_ptr->deleted && messagebase_can_read_message(session, record_ptr))
        {
            last_id = record_ptr->id;
        }

        index++;
    }

    return last_id;
}

int messagebase_get_newest_unread_id(messagebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int newest_unread_id = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    /* Iterate through messages finding the first unread one (read_time == 0) */
    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (!record_ptr->deleted && messagebase_can_read_message(session, record_ptr))
        {
            /* If we haven't found an unread yet, track the latest one we see */
            if (record_ptr->read_time == 0 && newest_unread_id == 0)
            {
                newest_unread_id = record_ptr->id;
                break;  /* Found first unread, use it */
            }
        }

        index++;
    }

    /* If no unread found, return first message */
    if (newest_unread_id == 0)
    {
        return messagebase_get_first_message_id(session);
    }

    return newest_unread_id;
}

int messagebase_count_messages(messagebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int count = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (!record_ptr->deleted && messagebase_can_read_message(session, record_ptr))
        {
            count++;
        }

        index++;
    }

    return count;
}

int messagebase_get_message_position(messagebase_session *session, int message_id)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGE_RECORD *record_ptr;
    int position = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_MESSAGES;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = session->current_area;
        regs.r[3] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        record_ptr = (LINETASK_MESSAGE_RECORD *)regs.r[0];

        if (!record_ptr->deleted && messagebase_can_read_message(session, record_ptr))
        {
            position++;
            if (record_ptr->id == message_id)
            {
                return position;
            }
        }

        index++;
    }

    return 0;
}

int messagebase_get_next_area_id(messagebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    int found_current = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

        if (found_current)
        {
            return area_ptr->id;
        }

        if (area_ptr->id == session->current_area)
        {
            found_current = 1;
        }

        index++;
    }

    return 0;
}

int messagebase_get_prev_area_id(messagebase_session *session)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    int prev_id = 0;
    int index = 0;

    if (session == NULL || session->current_messagebase <= 0)
    {
        return 0;
    }

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = session->current_messagebase;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

        if (area_ptr->id == session->current_area)
        {
            return prev_id;
        }

        prev_id = area_ptr->id;
        index++;
    }

    return 0;
}

/* ============================================================
 * Area Auto-Discovery
 * ============================================================ */

int messagebase_find_private_area_global(int *base_id_out, int *area_id_out)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_RECORD *base_ptr;
    int base_index = 0;
    int area_id;

    if (base_id_out == NULL || area_id_out == NULL)
    {
        return 0;
    }

    /* Iterate through all messagebases */
    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_BASES;
        regs.r[1] = base_index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL ||
            regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        base_ptr = (LINETASK_MESSAGEBASE_RECORD *)regs.r[0];

        /* Look for private area in this messagebase */
        area_id = messagebase_find_private_area(base_ptr->id);
        if (area_id > 0)
        {
            *base_id_out = base_ptr->id;
            *area_id_out = area_id;
            return 1;
        }

        base_index++;
    }

    return 0;
}

int messagebase_find_netmail_area_global(int *base_id_out, int *area_id_out)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_RECORD *base_ptr;
    int base_index = 0;
    int area_id;

    if (base_id_out == NULL || area_id_out == NULL)
    {
        return 0;
    }

    /* Iterate through all messagebases */
    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_BASES;
        regs.r[1] = base_index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL ||
            regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        base_ptr = (LINETASK_MESSAGEBASE_RECORD *)regs.r[0];

        /* Look for netmail area in this messagebase */
        area_id = messagebase_find_netmail_area(base_ptr->id);
        if (area_id > 0)
        {
            *base_id_out = base_ptr->id;
            *area_id_out = area_id;
            return 1;
        }

        base_index++;
    }

    return 0;
}

/* Forward declaration for area lookup */
int messagebase_find_private_area(int base_id);
int messagebase_find_netmail_area(int base_id);

/* ============================================================
 * Composer Start Functions (compose private/netmail)
 * ============================================================ */

int messagebase_composer_start_private(messagebase_session *session,
                                        const char *to_username,
                                        void (*output)(void *ctx, const char *text),
                                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    int base_id = 0, area_id = 0;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    /* Find a private mail area globally */
    if (!messagebase_find_private_area_global(&base_id, &area_id))
    {
        output(ctx, "\r\n[No Private Mail area configured]\r\n");
        return 0;
    }

    /* Get area info */
    regs.r[0] = FILER_MESSAGEBASE_CMD_AREA_INFO;
    regs.r[1] = base_id;
    regs.r[2] = area_id;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        output(ctx, "\r\n[Error getting area info]\r\n");
        return 0;
    }

    area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

    /* Initialize composer */
    messagebase_composer_init(session, 0);

    /* Store area info in session (temporarily use this area) */
    session->current_messagebase = base_id;
    session->current_area = area_id;

    /* Store area info in composer state */
    session->composer.area_type = area_ptr->areatype;
    session->composer.area_id = area_id;
    strncpy(session->composer.area_name, area_ptr->name, sizeof(session->composer.area_name) - 1);
    session->composer.area_name[sizeof(session->composer.area_name) - 1] = '\0';

    session->composer.is_ftn = 0;
    session->composer.is_netmail = 0;
    session->composer.is_private = 1;

    /* Clear screen and paint a blue banner on the first line */
    output(ctx, "\033[2J\033[H\033[44;37m Private Mail \033[K\033[0m\r\n\r\n");

    /* If username provided, validate and pre-fill */
    if (to_username != NULL && to_username[0] != '\0')
    {
        int to_user_id = 0;
        if (messagebase_lookup_user_by_name(to_username, &to_user_id) && to_user_id > 0)
        {
            char realname[MAX_FROM_NAME];
            char found_msg[128];
            if (messagebase_lookup_user_by_id(to_user_id, realname, sizeof(realname)))
            {
                strncpy(session->composer.to_name, realname, sizeof(session->composer.to_name) - 1);
            }
            else
            {
                strncpy(session->composer.to_name, to_username, sizeof(session->composer.to_name) - 1);
            }
            session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
            session->composer.to_user_id = to_user_id;

            /* Show confirmation of found user */
            snprintf(found_msg, sizeof(found_msg), "\033[1;33mTo      :\033[0m \033[1;32m%s (#%d)\033[0m\r\n",
                     session->composer.to_name, to_user_id);
            output(ctx, found_msg);

            /* Prompt for subject */
            output(ctx, "\033[1;33mSubject :\033[0m ");
            session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
        }
        else
        {
            output(ctx, "[User not found]\r\n");
            /* Show header with cursor on To field */
            messagebase_composer_show_header(session, output, ctx, 0);
            session->composer.phase = MESSAGE_COMPOSE_TO_NAME;
        }
    }
    else
    {
        /* Show header with cursor on To field */
        messagebase_composer_show_header(session, output, ctx, 0);
        session->composer.phase = MESSAGE_COMPOSE_TO_NAME;
    }

    return 1;
}

int messagebase_composer_start_netmail(messagebase_session *session,
                                        const char *to_name,
                                        const char *to_address,
                                        void (*output)(void *ctx, const char *text),
                                        void *ctx)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    int base_id = 0, area_id = 0;

    if (session == NULL || output == NULL)
    {
        return 0;
    }

    /* Find a netmail area globally */
    if (!messagebase_find_netmail_area_global(&base_id, &area_id))
    {
        output(ctx, "\r\n[No Netmail area configured]\r\n");
        return 0;
    }

    /* Get area info */
    regs.r[0] = FILER_MESSAGEBASE_CMD_AREA_INFO;
    regs.r[1] = base_id;
    regs.r[2] = area_id;
    if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || regs.r[0] == 0)
    {
        output(ctx, "\r\n[Error getting area info]\r\n");
        return 0;
    }

    area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];

    /* Initialize composer */
    messagebase_composer_init(session, 0);

    /* Store area info in session */
    session->current_messagebase = base_id;
    session->current_area = area_id;

    /* Store area info in composer state */
    session->composer.area_type = area_ptr->areatype;
    session->composer.area_id = area_id;
    strncpy(session->composer.area_name, area_ptr->name, sizeof(session->composer.area_name) - 1);
    session->composer.area_name[sizeof(session->composer.area_name) - 1] = '\0';

    session->composer.is_ftn = 1;
    session->composer.is_netmail = 1;
    session->composer.is_private = 1;

    /* Get user's FTN AKA if available */
    messagebase_get_aka(area_ptr->akause, &session->composer.from_ftn_address);

    /* Clear screen and paint a blue banner on the first line */
    output(ctx, "\033[2J\033[H\033[44;37m FTN Netmail \033[K\033[0m\r\n\r\n");

    /* If name and address provided, validate and pre-fill */
    if (to_name != NULL && to_name[0] != '\0' &&
        to_address != NULL && to_address[0] != '\0')
    {
        if (messagebase_parse_ftn_address(to_address, &session->composer.to_ftn_address))
        {
            strncpy(session->composer.to_name, to_name, sizeof(session->composer.to_name) - 1);
            session->composer.to_name[sizeof(session->composer.to_name) - 1] = '\0';
            strncpy(session->composer.to_address_str, to_address, sizeof(session->composer.to_address_str) - 1);
            session->composer.to_address_str[sizeof(session->composer.to_address_str) - 1] = '\0';

            /* Show header with cursor on subject */
            messagebase_composer_show_header(session, output, ctx, 2);
            session->composer.phase = MESSAGE_COMPOSE_SUBJECT;
        }
        else
        {
            output(ctx, "[Invalid FTN address format]\r\n");
            /* Show header with cursor on To field */
            messagebase_composer_show_header(session, output, ctx, 0);
            session->composer.phase = MESSAGE_COMPOSE_TO_NAME;
        }
    }
    else
    {
        /* Show header with cursor on To field */
        messagebase_composer_show_header(session, output, ctx, 0);
        session->composer.phase = MESSAGE_COMPOSE_TO_NAME;
    }

    return 1;
}

/* ============================================================
 * Area Finding Helpers
 * ============================================================ */

int messagebase_find_private_area(int base_id)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    int index = 0;

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = base_id;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || 
            regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];
        if (area_ptr->areatype == AREA_TYPE_OTHER)
        {
            return area_ptr->id;
        }
        index++;
    }

    return 0;
}

int messagebase_find_netmail_area(int base_id)
{
    _kernel_swi_regs regs;
    LINETASK_MESSAGEBASE_AREA_RECORD *area_ptr;
    int index = 0;

    while (1)
    {
        regs.r[0] = FILER_MESSAGEBASE_CMD_ENUMERATE_AREAS;
        regs.r[1] = base_id;
        regs.r[2] = index;

        if (_kernel_swi(SWI_FILER_MESSAGEBASE, &regs, &regs) != NULL || 
            regs.r[0] == -1 || regs.r[0] == 0)
        {
            break;
        }

        area_ptr = (LINETASK_MESSAGEBASE_AREA_RECORD *)regs.r[0];
        if (area_ptr->areatype == AREA_TYPE_NETMAIL)
        {
            return area_ptr->id;
        }
        index++;
    }

    return 0;
}
