#ifndef LINE_TASK_SCRIPT_H
#define LINE_TASK_SCRIPT_H

#include <stddef.h>
#include <time.h>

/* User flags for macro expansion */
typedef struct script_user_flags
{
    int ansi;
    int more;
    int lines;
    int cls;
    int expert;
    int nolimit;
    int invisible;
    int chataccess;
    int ratios;
    int maxtime;
    int defaultprotocol;
} script_user_flags;

/* User statistics for macro expansion */
typedef struct script_user_stats
{
    time_t lastlogon;
    time_t lastscan;
    int calls;
    int todaytime;
    int uploadskb;
    int downloadskb;
    int uploads;
    int downloads;
} script_user_stats;

typedef struct script_host
{
    void *context;
    void (*write_text)(void *context, const char *text);
    void (*launch_riscbbs_door)(void *context, const char *command_line, int use_26bit);
    void (*launch_arcbbs_door)(void *context, int door_number, const char *command_line, int use_26bit);
    void (*launch_door)(void *context, const char *command_line, int use_26bit);
    void (*report_time)(void *context);
    void (*report_line_info)(void *context);
    void (*request_disconnect)(void *context);
    void (*force_disconnect)(void *context);
    void (*report_activity)(void *context, const char *text);
    void (*report_online_users)(void *context);
    int (*get_line_id)(void *context);
    int (*get_task_handle)(void *context);
    /* Filebase callbacks */
    void *(*get_filebase_session)(void *context);
    int (*get_user_accesslevel)(void *context);
    int (*get_user_sysop)(void *context);
    const char *(*get_user_keys)(void *context);
    int (*filebase_download)(void *context, int base_id, int file_id);
    /* Messagebase callbacks */
    void *(*get_messagebase_session)(void *context);
    /* Authentication callbacks */
    int (*authenticate_user)(void *context, const char *username, const char *password, int *auth_result);
    void (*start_postlogon)(void *context);
    void (*start_newuser)(void *context);
    /* File transfer callback - protocol: 0=XMODEM, 1=XMODEM-CRC, 2=XMODEM-1K */
    int (*start_transfer)(void *context, int base_id, int file_id, int protocol);
    /* Receive transfer callback - returns 1 on success, 0 on failure */
    int (*start_receive_transfer)(void *context, const char *temp_path, int protocol);
    /* Get current user ID for upload attribution */
    int (*get_user_id)(void *context);
    /* Sysop chat callback - starts the pager with given reason */
    void (*start_chat_pager)(void *context, const char *reason);
    /* Get the configured anykey file path */
    const char *(*get_anykey_file)(void *context);
    /* Get user statistics */
    const script_user_stats *(*get_user_stats)(void *context);
    /* Get user flags */
    const script_user_flags *(*get_user_flags)(void *context);
    /* Update lastscan timestamp - called after LOGINSCAN completes */
    void (*update_lastscan)(void *context, time_t new_lastscan);
} script_host;

typedef enum
{
    SCRIPT_STATUS_IDLE = 0,
    SCRIPT_STATUS_RUNNING,
    SCRIPT_STATUS_WAIT_INPUT_CHAR,
    SCRIPT_STATUS_WAIT_INPUT_LINE,
    SCRIPT_STATUS_WAIT_DOOR,
    SCRIPT_STATUS_WAIT_SLEEP,
    SCRIPT_STATUS_WAIT_LOGON_USERNAME,
    SCRIPT_STATUS_WAIT_LOGON_PASSWORD,
    SCRIPT_STATUS_WAIT_TRANSFER,
    SCRIPT_STATUS_WAIT_ANSI,
    SCRIPT_STATUS_WAIT_CHAT_REASON,
    SCRIPT_STATUS_WAIT_CHAT,
    SCRIPT_STATUS_WAIT_MORE,
    SCRIPT_STATUS_COMPLETED,
    SCRIPT_STATUS_ERROR
} script_status;

typedef enum
{
    SCRIPT_CMD_NONE = 0,
    SCRIPT_CMD_PRINT,
    SCRIPT_CMD_GOTO,
    SCRIPT_CMD_PROMPT,
    SCRIPT_CMD_IF,
    SCRIPT_CMD_SET,
    SCRIPT_CMD_CALL,
    SCRIPT_CMD_RETURN,
    SCRIPT_CMD_PAUSE,
    SCRIPT_CMD_TYPE,
    SCRIPT_CMD_ANYKEY,
    SCRIPT_CMD_FG,
    SCRIPT_CMD_BG,
    SCRIPT_CMD_FGBG,
    SCRIPT_CMD_CLS,
    SCRIPT_CMD_POS,
    SCRIPT_CMD_SCRIPT,
    SCRIPT_CMD_DOING,
    SCRIPT_CMD_LOGOFF,
    SCRIPT_CMD_ONLINE,
    SCRIPT_CMD_FILEBASE,
    SCRIPT_CMD_LOGON,
    SCRIPT_CMD_SENDFILE,
    SCRIPT_CMD_RECEIVEFILE,
    SCRIPT_CMD_ADD,
    SCRIPT_CMD_SUB,
    SCRIPT_CMD_MUL,
    SCRIPT_CMD_DIV,
    SCRIPT_CMD_MOD,
    SCRIPT_CMD_RANDOM,
    SCRIPT_CMD_STRLEN,
    SCRIPT_CMD_HASKEY,
    SCRIPT_CMD_DETECTANSI,
    SCRIPT_CMD_SYSOPCHAT,
    SCRIPT_CMD_MESSAGEBASE,
    SCRIPT_CMD_SENDMAIL,
    SCRIPT_CMD_SENDNETMAIL,
    SCRIPT_CMD_FLASH,
    SCRIPT_CMD_OSCLI,
    SCRIPT_CMD_CLL,
    SCRIPT_CMD_LOGINSCAN,
    SCRIPT_CMD_MORE,
    SCRIPT_CMD_BOLD,
    SCRIPT_CMD_STD,
    SCRIPT_CMD_READLINE,
    SCRIPT_CMD_YESNO,
    /* Loop commands */
    SCRIPT_CMD_FOR,
    SCRIPT_CMD_ENDFOR,
    SCRIPT_CMD_WHILE,
    SCRIPT_CMD_ENDWHILE,
    SCRIPT_CMD_BREAK,
    SCRIPT_CMD_CONTINUE
} script_command_type;

typedef enum
{
    SCRIPT_INPUT_NONE = 0,
    SCRIPT_INPUT_CHAR,
    SCRIPT_INPUT_LINE,
    SCRIPT_INPUT_YESNO
} script_input_mode;

typedef struct script_instruction
{
    script_command_type type;
    char *arg1;
    char *arg2;
    char *arg3;
    char *arg4;
    char *arg5;  /* Used by FOR to pass start_label for post-append registration */
} script_instruction;

typedef struct script_label
{
    char *name;
    size_t instruction_index;
} script_label;

typedef struct script_variable
{
    char name[32];
    char *value;
} script_variable;

/* Call stack frame for subscript calls */
#define SCRIPT_MAX_CALL_DEPTH 8

typedef struct script_call_frame
{
    script_instruction *instructions;
    size_t instruction_count;
    size_t instruction_capacity;
    script_label *labels;
    size_t label_count;
    size_t label_capacity;
    size_t return_pc;  /* Program counter to return to */
} script_call_frame;

typedef struct script_state
{
    script_host host;
    script_instruction *instructions;
    size_t instruction_count;
    size_t instruction_capacity;
    script_label *labels;
    size_t label_count;
    size_t label_capacity;
    script_variable *variables;
    size_t variable_count;
    size_t variable_capacity;
    size_t program_counter;
    script_status status;
    script_input_mode input_mode;
    int input_echo;
    char input_target[32];
    char *input_buffer;
    size_t input_length;
    size_t input_capacity;
    clock_t sleep_deadline;
    char last_error[128];
    /* Logon state */
    char logon_username[64];
    int logon_attempts;
    /* ANSI detection state */
    clock_t ansi_deadline;
    char ansi_result_var[32];
    int ansi_parse_state;  /* 0=idle, 1=got ESC, 2=got [, 3=reading digits, 4=got ; */
    char ansi_response[32];
    int ansi_response_len;
    /* Call stack for subscripts */
    script_call_frame call_stack[SCRIPT_MAX_CALL_DEPTH];
    int call_depth;
    /* More prompt state */
    int more_override;              /* -1 = use user setting, 0 = disabled, 1 = enabled */
    int more_line_count;            /* Current line count since last reset */
    int more_screen_lines;          /* Lines per screen (from user settings, default 24) */
} script_state;

void script_initialise(script_state *state, const script_host *host);
void script_dispose(script_state *state);
int script_start(script_state *state, const char *path);
void script_stop(script_state *state);
void script_reset_session(script_state *state);  /* Clears variables - call on disconnect */
void script_process(script_state *state);
int script_handle_user_byte(script_state *state, unsigned char byte);
void script_notify_door_closed(script_state *state);
void script_notify_transfer_complete(script_state *state);
script_status script_get_status(const script_state *state);
const char *script_get_last_error(const script_state *state);
const char *script_get_variable(const script_state *state, const char *name);

#endif
