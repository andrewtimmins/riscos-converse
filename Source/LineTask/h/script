#ifndef LINE_TASK_SCRIPT_H
#define LINE_TASK_SCRIPT_H

#include <stddef.h>
#include <time.h>

/* User flags for macro expansion */
typedef struct script_user_flags
{
    int ansi;
    int more;
    int lines;
    int cls;
    int expert;
    int nolimit;
    int invisible;
    int chataccess;
    int ratios;
    int maxtime;
    int defaultprotocol;
} script_user_flags;

/* User statistics for macro expansion */
typedef struct script_user_stats
{
    time_t lastlogon;
    time_t lastscan;
    int calls;
    int todaytime;
    int uploadskb;
    int downloadskb;
    int uploads;
    int downloads;
} script_user_stats;

typedef struct script_host
{
    void *context;
    void (*write_text)(void *context, const char *text);
    void (*launch_riscbbs_door)(void *context, const char *command_line, int use_26bit);
    void (*launch_arcbbs_door)(void *context, int door_number, const char *command_line, int use_26bit);
    void (*launch_door)(void *context, const char *command_line, int use_26bit);
    void (*report_time)(void *context);
    void (*report_line_info)(void *context);
    void (*request_disconnect)(void *context);
    void (*force_disconnect)(void *context);
    void (*report_activity)(void *context, const char *text);
    void (*report_online_users)(void *context);
    int (*get_line_id)(void *context);
    int (*get_task_handle)(void *context);
    /* Filebase callbacks */
    void *(*get_filebase_session)(void *context);
    int (*get_user_accesslevel)(void *context);
    int (*get_user_sysop)(void *context);
    const char *(*get_user_keys)(void *context);
    const char *(*get_user_realname)(void *context);
    int (*filebase_download)(void *context, int base_id, int file_id);
    /* Messagebase callbacks */
    void *(*get_messagebase_session)(void *context);
    /* Authentication callbacks */
    int (*authenticate_user)(void *context, const char *username, const char *password, int *auth_result);
    void (*start_postlogon)(void *context);
    void (*start_newuser)(void *context);
    /* File transfer callback - protocol: 0=XMODEM, 1=XMODEM-CRC, 2=XMODEM-1K */
    int (*start_transfer)(void *context, int base_id, int file_id, int protocol);
    /* Receive transfer callback - returns 1 on success, 0 on failure */
    int (*start_receive_transfer)(void *context, const char *temp_path, int protocol);
    /* Get current user ID for upload attribution */
    int (*get_user_id)(void *context);
    /* Sysop chat callback - starts the pager with given reason */
    void (*start_chat_pager)(void *context, const char *reason);
    /* Get the configured anykey file path */
    const char *(*get_anykey_file)(void *context);
    /* Get the configured more prompt file path */
    const char *(*get_more_file)(void *context);
    /* Get the configured protocol prompt file path */
    const char *(*get_protocol_file)(void *context);
    /* Get user statistics */
    const script_user_stats *(*get_user_stats)(void *context);
    /* Get user flags */
    const script_user_flags *(*get_user_flags)(void *context);
    /* Update lastscan timestamp - called after LOGINSCAN completes */
    void (*update_lastscan)(void *context, time_t new_lastscan);
    /* Create new user - returns user_id on success, 0 on failure */
    int (*create_user)(void *context, const char *username, const char *password,
                       const char *realname, const char *email);
    /* Check if username is available - returns 1 if available, 0 if taken */
    int (*check_username_available)(void *context, const char *username);
} script_host;

typedef enum
{
    SCRIPT_STATUS_IDLE = 0,
    SCRIPT_STATUS_RUNNING,
    SCRIPT_STATUS_WAITING,          /* Waiting for input - check input_mode for type */
    SCRIPT_STATUS_WAIT_DOOR,        /* Waiting for external door process */
    SCRIPT_STATUS_WAIT_SLEEP,       /* Waiting for timer */
    SCRIPT_STATUS_WAIT_TRANSFER,    /* Waiting for file transfer */
    SCRIPT_STATUS_WAIT_CHAT,        /* In active chat session */
    SCRIPT_STATUS_COMPLETED,
    SCRIPT_STATUS_ERROR
    
    /* === LEGACY STATUS VALUES (REMOVED) ===
     * All legacy WAIT_* statuses have been migrated to the unified input system.
     * The script_handle_user_byte() function now routes based on:
     * - state->status == SCRIPT_STATUS_WAITING
     * - state->input_context (WHY we're waiting)
     * - state->input_mode (HOW to collect input)
     *
     * Migrated statuses:
     * - SCRIPT_STATUS_WAIT_INPUT_CHAR -> WAITING + CTX_MB_VIEWER or CTX_FB_BROWSE
     * - SCRIPT_STATUS_WAIT_INPUT_LINE -> WAITING + CTX_MB_COMPOSE or CTX_MB_SEARCH
     * - SCRIPT_STATUS_WAIT_ANSI -> WAITING + CTX_ANSI_DETECT + MODE_SPECIAL
     * - SCRIPT_STATUS_WAIT_FB_BROWSE -> WAITING + CTX_FB_BROWSE
     * - SCRIPT_STATUS_WAIT_UPLOAD_FILENAME -> WAITING + CTX_UPLOAD_FILE
     * - SCRIPT_STATUS_WAIT_UPLOAD_DESCRIPTION -> WAITING + CTX_UPLOAD_DESC
     * - SCRIPT_STATUS_WAIT_LOGON_* -> WAITING + CTX_LOGON_*
     * - SCRIPT_STATUS_WAIT_NEWUSER_* -> WAITING + CTX_NEWUSER_*
     * - SCRIPT_STATUS_WAIT_CHAT_REASON -> WAITING + CTX_CHAT_REASON
     * - SCRIPT_STATUS_WAIT_MB_SELECT -> WAITING + CTX_MB_SELECT
     * - SCRIPT_STATUS_WAIT_MORE -> WAITING + CTX_MORE
     * - SCRIPT_STATUS_WAIT_PROTOCOL -> WAITING + CTX_PROTOCOL
     */
} script_status;

/* Input collection mode - HOW we collect input */
typedef enum
{
    SCRIPT_INPUT_MODE_NONE = 0,     /* Not waiting for input */
    SCRIPT_INPUT_MODE_CHAR,         /* Single character, no echo */
    SCRIPT_INPUT_MODE_CHAR_ECHO,    /* Single character with echo */
    SCRIPT_INPUT_MODE_LINE,         /* Line input with echo */
    SCRIPT_INPUT_MODE_LINE_NOECHO,  /* Line input without echo (passwords) */
    SCRIPT_INPUT_MODE_YESNO,        /* Y/N only input */
    SCRIPT_INPUT_MODE_KEY,          /* Single key from set (protocol selection etc) */
    SCRIPT_INPUT_MODE_SPECIAL       /* Custom parsing (ANSI detection) */
} script_input_mode_t;

/* Input context - WHY we're waiting for input */
typedef enum
{
    SCRIPT_INPUT_CTX_NONE = 0,
    /* Script commands */
    SCRIPT_INPUT_CTX_PROMPT,        /* PROMPT/READLINE command */
    SCRIPT_INPUT_CTX_ANYKEY,        /* ANYKEY command */
    /* Authentication */
    SCRIPT_INPUT_CTX_LOGON_USER,    /* LOGON - username */
    SCRIPT_INPUT_CTX_LOGON_PASS,    /* LOGON - password */
    /* New user registration */
    SCRIPT_INPUT_CTX_NEWUSER_USER,  /* NEWUSER - username */
    SCRIPT_INPUT_CTX_NEWUSER_PASS,  /* NEWUSER - password */
    SCRIPT_INPUT_CTX_NEWUSER_PASS2, /* NEWUSER - confirm password */
    SCRIPT_INPUT_CTX_NEWUSER_NAME,  /* NEWUSER - real name */
    SCRIPT_INPUT_CTX_NEWUSER_EMAIL, /* NEWUSER - email */
    SCRIPT_INPUT_CTX_NEWUSER_CONFIRM, /* NEWUSER - Y/N confirm */
    /* Browser selection */
    SCRIPT_INPUT_CTX_MB_SELECT,     /* Messagebase selection */
    SCRIPT_INPUT_CTX_MB_AREA,       /* Messagebase area selection */
    SCRIPT_INPUT_CTX_FB_SELECT,     /* Filebase selection */
    SCRIPT_INPUT_CTX_FB_AREA,       /* Filebase area selection */
    SCRIPT_INPUT_CTX_FB_BROWSE,     /* Filebase browser navigation */
    SCRIPT_INPUT_CTX_MB_VIEWER,     /* Message viewer navigation */
    SCRIPT_INPUT_CTX_MB_COMPOSE,    /* Message composer line input */
    SCRIPT_INPUT_CTX_MB_SEARCH,     /* Message search term input */
    /* Upload flow */
    SCRIPT_INPUT_CTX_UPLOAD_FILE,   /* Upload filename */
    SCRIPT_INPUT_CTX_UPLOAD_DESC,   /* Upload description */
    SCRIPT_INPUT_CTX_PROTOCOL,      /* Protocol selection */
    /* Misc */
    SCRIPT_INPUT_CTX_CHAT_REASON,   /* Chat pager reason */
    SCRIPT_INPUT_CTX_MORE,          /* More? prompt */
    SCRIPT_INPUT_CTX_ANSI_DETECT    /* ANSI terminal detection */
} script_input_context;

typedef enum
{
    SCRIPT_CMD_NONE = 0,
    SCRIPT_CMD_PRINT,
    SCRIPT_CMD_GOTO,
    SCRIPT_CMD_PROMPT,
    SCRIPT_CMD_IF,
    SCRIPT_CMD_SET,
    SCRIPT_CMD_CALL,
    SCRIPT_CMD_RETURN,
    SCRIPT_CMD_PAUSE,
    SCRIPT_CMD_TYPE,
    SCRIPT_CMD_ANYKEY,
    SCRIPT_CMD_FG,
    SCRIPT_CMD_BG,
    SCRIPT_CMD_FGBG,
    SCRIPT_CMD_CLS,
    SCRIPT_CMD_POS,
    SCRIPT_CMD_SCRIPT,
    SCRIPT_CMD_DOING,
    SCRIPT_CMD_LOGOFF,
    SCRIPT_CMD_ONLINE,
    SCRIPT_CMD_FILEBASE,
    SCRIPT_CMD_LOGON,
    SCRIPT_CMD_SENDFILE,
    SCRIPT_CMD_RECEIVEFILE,
    SCRIPT_CMD_ADD,
    SCRIPT_CMD_SUB,
    SCRIPT_CMD_MUL,
    SCRIPT_CMD_DIV,
    SCRIPT_CMD_MOD,
    SCRIPT_CMD_RANDOM,
    SCRIPT_CMD_STRLEN,
    SCRIPT_CMD_HASKEY,
    SCRIPT_CMD_DETECTANSI,
    SCRIPT_CMD_SYSOPCHAT,
    SCRIPT_CMD_MESSAGEBASE,
    SCRIPT_CMD_FLASH,
    SCRIPT_CMD_OSCLI,
    SCRIPT_CMD_CLL,
    SCRIPT_CMD_LOGINSCAN,
    SCRIPT_CMD_MORE,
    SCRIPT_CMD_BOLD,
    SCRIPT_CMD_STD,
    SCRIPT_CMD_READLINE,
    SCRIPT_CMD_YESNO,
    SCRIPT_CMD_NEWUSER,
    /* Loop commands */
    SCRIPT_CMD_FOR,
    SCRIPT_CMD_ENDFOR,
    SCRIPT_CMD_WHILE,
    SCRIPT_CMD_ENDWHILE,
    SCRIPT_CMD_BREAK,
    SCRIPT_CMD_CONTINUE
} script_command_type;

/* Legacy enum - used by PROMPT command only, to be phased out */
typedef enum
{
    SCRIPT_PROMPT_NONE = 0,
    SCRIPT_PROMPT_CHAR,
    SCRIPT_PROMPT_LINE,
    SCRIPT_PROMPT_YESNO
} script_prompt_type;

typedef struct script_instruction
{
    script_command_type type;
    char *arg1;
    char *arg2;
    char *arg3;
    char *arg4;
    char *arg5;  /* Used by FOR to pass start_label for post-append registration */
} script_instruction;

typedef struct script_label
{
    char *name;
    size_t instruction_index;
} script_label;

typedef struct script_variable
{
    char name[32];
    char *value;
} script_variable;

/* Call stack frame for subscript calls */
#define SCRIPT_MAX_CALL_DEPTH 8

typedef struct script_call_frame
{
    script_instruction *instructions;
    size_t instruction_count;
    size_t instruction_capacity;
    script_label *labels;
    size_t label_count;
    size_t label_capacity;
    size_t return_pc;  /* Program counter to return to */
} script_call_frame;

typedef enum script_upload_stage
{
    SCRIPT_UPLOAD_STAGE_NONE = 0,
    SCRIPT_UPLOAD_STAGE_WAIT_FILENAME,
    SCRIPT_UPLOAD_STAGE_WAIT_DESCRIPTION,
    SCRIPT_UPLOAD_STAGE_WAIT_PROTOCOL
} script_upload_stage;

typedef struct script_state
{
    script_host host;
    script_instruction *instructions;
    size_t instruction_count;
    size_t instruction_capacity;
    script_label *labels;
    size_t label_count;
    size_t label_capacity;
    script_variable *variables;
    size_t variable_count;
    size_t variable_capacity;
    size_t program_counter;
    script_status status;
    
    /* Unified input system */
    script_input_mode_t input_mode;     /* HOW to collect input */
    script_input_context input_context; /* WHY we're waiting for input */
    int input_echo;                     /* Echo input to terminal? */
    char input_target[32];              /* Variable to store result */
    char *input_buffer;                 /* Accumulated input */
    size_t input_length;
    size_t input_capacity;
    char input_valid_keys[32];          /* Valid keys for MODE_KEY */
    
    /* Legacy field for PROMPT command - to be phased out */
    script_prompt_type prompt_type;
    
    clock_t sleep_deadline;
    char last_error[128];
    /* Logon state */
    char logon_username[64];
    int logon_attempts;
    /* ANSI detection state */
    clock_t ansi_deadline;
    char ansi_result_var[32];
    int ansi_parse_state;  /* 0=idle, 1=got ESC, 2=got [, 3=reading digits, 4=got ; */
    char ansi_response[32];
    int ansi_response_len;
    /* Call stack for subscripts */
    script_call_frame call_stack[SCRIPT_MAX_CALL_DEPTH];
    int call_depth;
    /* More prompt state */
    int more_override;              /* -1 = use user setting, 0 = disabled, 1 = enabled */
    int more_line_count;            /* Current line count since last reset */
    int more_screen_lines;          /* Lines per screen (from user settings, default 24) */
    char *more_pending_text;        /* Text waiting to be output after More? response */
    /* New user registration state */
    char newuser_username[32];
    char newuser_password[32];
    char newuser_realname[64];
    char newuser_email[64];
    /* Pending upload state for protocol selection */
    char pending_upload_filename[128];
    char pending_upload_description[256];
    int pending_upload_filebase;
    int pending_upload_area;
    int pending_upload_protocol;
    script_upload_stage pending_upload_stage;
    /* Pending download state for protocol selection from browser */
    int pending_download_file_id;
    int pending_download_filebase;
    int is_browser_download;
} script_state;

void script_initialise(script_state *state, const script_host *host);
void script_dispose(script_state *state);
int script_start(script_state *state, const char *path);
void script_stop(script_state *state);
void script_reset_session(script_state *state);  /* Clears variables - call on disconnect */
void script_process(script_state *state);
int script_handle_user_byte(script_state *state, unsigned char byte);
void script_notify_door_closed(script_state *state);
void script_notify_transfer_complete(script_state *state);
script_status script_get_status(const script_state *state);
const char *script_get_last_error(const script_state *state);
const char *script_get_variable(const script_state *state, const char *name);
void script_set_variable_value(script_state *state, const char *name, const char *value);

/* Input helpers - start waiting for input in a specific context */
void script_begin_input(script_state *state, script_input_mode_t mode, 
                        script_input_context context);
void script_begin_input_keys(script_state *state, script_input_context context,
                             const char *valid_keys, const char *target);
void script_clear_input(script_state *state);

#endif
