
--------------------------------------------------------------------------------

Converse Filer Technical Summary

--------------------------------------------------------------------------------

* SWI chunk base: 0x5AA40 (registered as ConverseFiler_). Current groups are
  Logging, Userbase, Messagebase, Filebase, and Statistics.
* Persistent data is stored beneath <Converse$Dir>, using USERDB/USERIDX for
  user records, FileDB/FileIDX/AreaDB/AreaIDX for filebases, and MsgDB/MsgIDX/
  AreaDB/AreaIDX for messagebases. Payloads live inside per-base directories.
* All SWIs operate on the Norcroft-compiled structs defined in h/structs. Callers
  should fully initialise those structs and allow the module to normalise strings
  and clamp numeric fields.

SWI Decoding Table
------------------
  ConverseFiler_Logging      0x5AA40
  ConverseFiler_Userbase     0x5AA41
  ConverseFiler_Messagebase  0x5AA42
  ConverseFiler_Filebase     0x5AA43
  ConverseFiler_Statistics   0x5AA44

--------------------------------------------------------------------------------

SWI USAGE GUIDELINES

* Every SWI validates its register block and returns 0 on success or -1 on error;
  the V flag is not used.
* R0 always carries the command enumerator for the selected SWI group. Remaining
  registers hold integer arguments or pointers as described per command.
* NULL pointers are legal; the module rejects the call and reports -1.
* Strings must be writable so the module can normalise and copy them into local
  buffers before writing to disc or logs.

--------------------------------------------------------------------------------

0x5AA40 - ConverseFiler_Logging

On Entry:
            R0: Reason code (0-3).
            R1..R3: Dependent on reason code.

Reason codes:
            0 (System)
              R1: Pointer to C string to append to <Converse$Dir>.Logs.System.

            1 (Line)
              R1: Line number.
              R2: Pointer to C string to write to Line_<n> log.

            2 (Call)
              R1: Line ID.
              R2: User ID.
              R3: Status ID (0..3).
              (Stored in <Converse$Dir>.Logs.Calls CSV)

            3 (FTN)
              R1: Pointer to C string to append to <Converse$Dir>.Logs.FTN.

On Exit:
            R0: 0 on success, -1 if the parameters are invalid or a file write
                fails.

Notes:
            * Strings are truncated/padded to 255 bytes prior to writing.
            * The CALL log lazily creates its CSV file and emits the header row
              when it does not already exist.

--------------------------------------------------------------------------------

0x5AA41 - ConverseFiler_Userbase

On Entry:
            R0: Reason code (0-4).
            R1..R2: Dependent on reason code.

Reason codes:
            0 (Add)
              R1: Pointer to USER_RECORD to insert.
              Returns: New user ID in R0.

            1 (Update)
              R1: Existing user ID.
              R2: Pointer to USER_RECORD with updated data.
              Returns: 1 on success in R0.

            2 (Delete)
              R1: User ID to remove.
              Returns: 1 on success in R0.

            3 (Search)
              R1: User ID to locate.
              Returns: Pointer to module-owned USER_RECORD cache in R0 on success.

            4 (Authenticate)
              R1: Pointer to username (C string).
              R2: Pointer to password (C string).
              Returns: R0 = status code (0 success, 1 unknown user, 2 invalid
                       password, 3 locked). R1 = pointer to USER_RECORD cache
                       on success (NULL otherwise).

            5 (UpdateHistory)
              R1: User ID.
              R2: Pointer to USER_HISTORY structure.
              Returns: 1 on success in R0.

            6 (UpdateStats)
              R1: User ID.
              R2: Pointer to USER_STATS structure.
              Returns: 1 on success in R0.

On Exit:
            R0: Command-specific result, -1 if validation fails. Search returns
                NULL when no record matches. Authenticate returns the status
                code described above.

Notes:
            * USERIDX is advanced automatically; callers never touch the index.
            * The returned USER_RECORD pointer is invalidated by the next SWI.
            * Text fields are normalised and encrypted internally; provide plain
              ASCII data in the struct.

--------------------------------------------------------------------------------

0x5AA42 - ConverseFiler_Messagebase

On Entry:
            R0: Reason code (0-7).
            R1..R5: Dependent on reason code.

Reason codes:
            0 (Create)
              R1: Pointer to MESSAGEBASE_RECORD template.
              Returns: New ID in R0.

            1 (Update)
              R1: Base ID.
              R2: Pointer to MESSAGEBASE_RECORD with updates.

            2 (Info)
              R1: Base ID.
              Returns: Pointer to internal cache in R0.

            3 (BeginUpload)
              R1: Base ID.
              R2: Pointer to MESSAGE_RECORD template.
              Returns: New message ID in R0 (creates payload file).

            4 (UploadBlock)
              R1: Base ID.
              R2: Message ID.
              R3: Pointer to data.
              R4: Length.

            5 (DownloadBlock)
              R1: Base ID.
              R2: Message ID.
              R3: Pointer to buffer.
              R4: Offset.
              R5: Requested length.

            6 (StoreArea)
              R1: Base ID.
              R2: Pointer to MESSAGEBASE_AREA metadata.
              Returns: Area ID in R0 (allocated/returned).

            7 (AreaInfo)
              R1: Base ID.
              R2: Area ID.
              Returns: Pointer to cached MESSAGEBASE_AREA in R0 on success.

            8 (EnumerateBases)
              R1: Index (0-based).
              Returns: Pointer to MESSAGEBASE_RECORD in R0, or 0 if end of list.

            9 (EnumerateAreas)
              R1: Base ID.
              R2: Index (0-based).
              Returns: Pointer to MESSAGEBASE_AREA in R0, or 0 if end of list.

            10 (EnumerateMessages)
              R1: Base ID.
              R2: Area ID (0 for all areas).
              R3: Index (0-based).
              Returns: Pointer to MESSAGE_RECORD in R0, or 0 if end of list.

            11 (MessageInfo)
              R1: Base ID.
              R2: Message ID.
              Returns: Pointer to cached MESSAGE_RECORD in R0 on success.

            12 (SaveMessageRecord)
              R1: Base ID.
              R2: Pointer to MESSAGE_RECORD with updates.
              Returns: 1 on success in R0.

            13 (FindUnexported)
              R1: Base ID.
              R2: Area ID.
              R3: Buffer for message ID array.
              R4: Maximum count.
              Returns: Count of unexported messages in R0.

            14 (MarkExported)
              R1: Base ID.
              R2: Message ID.
              Returns: 1 on success in R0.

On Exit:
            R0: Command-specific value (IDs, byte counts, or 0). -1 signals an
                argument/database error.

Notes:
            * BeginUpload/Create/StoreArea normalise strings and ignore caller-
              supplied IDs unless performing an update.
            * UploadBlock appends directly to disc and updates metadata after
              every successful write. DownloadBlock clamps negative offsets.
            * StoreArea ensures <base>.Messages.Annnn directories exist and keeps
              `.AreaDB/.AreaIDX` in sync with the module's allocator.

--------------------------------------------------------------------------------

0x5AA43 - ConverseFiler_Filebase

On Entry:
            R0: Reason code (0-7).
            R1..R5: Dependent on reason code.

Reason codes:
            0 (Create)
              R1: Pointer to FILEBASE_RECORD template.
              Returns: New ID in R0.

            1 (Update)
              R1: Base ID.
              R2: Pointer to FILEBASE_RECORD updates.

            2 (Info)
              R1: Base ID.
              Returns: Pointer to internal cache in R0.

            3 (BeginUpload)
              R1: Base ID.
              R2: Pointer to FILE_RECORD template.
              Returns: New file ID in R0 (creates payload file).

            4 (UploadBlock)
              R1: Base ID.
              R2: File ID.
              R3: Pointer to data.
              R4: Length.

            5 (DownloadBlock)
              R1: Base ID.
              R2: File ID.
              R3: Pointer to buffer.
              R4: Offset.
              R5: Requested length.

            6 (StoreArea)
              R1: Base ID.
              R2: Pointer to FILEBASE_AREA_RECORD metadata.
              Returns: Area ID in R0 (automatically allocated).

            7 (AreaInfo)
              R1: Base ID.
              R2: Area ID.
              Returns: Pointer to cached FILEBASE_AREA_RECORD in R0 on success.

            8 (EnumerateBases)
              R1: Index (0-based).
              Returns: Pointer to FILEBASE_RECORD in R0, or 0 if end of list.

            9 (EnumerateAreas)
              R1: Base ID.
              R2: Index (0-based).
              Returns: Pointer to FILEBASE_AREA_RECORD in R0, or 0 if end of list.

            10 (EnumerateFiles)
              R1: Base ID.
              R2: Area ID (0 for all areas).
              R3: Index (0-based).
              Returns: Pointer to FILE_RECORD in R0, or 0 if end of list.

            11 (FileInfo)
              R1: Base ID.
              R2: File ID.
              Returns: Pointer to cached FILE_RECORD in R0 on success.

            12 (SaveFileRecord)
              R1: Base ID.
              R2: Pointer to FILE_RECORD with updates.
              Returns: 1 on success in R0.

On Exit:
            R0: Command-specific value (IDs, byte counts, or 0). -1 signals an
                argument or storage failure.

Notes:
            * Create/BeginUpload/StoreArea normalise strings, populate IDs, and
              ensure `<base>.Files`/`<base>.Files.Annnn` directories exist.
            * UploadBlock streams to disc and updates recorded sizes atomically.
            * DownloadBlock clamps negative offsets and returns 0 on EOF.
            * EnumerateBases/EnumerateAreas/EnumerateFiles return pointers to
              internal cache; callers should copy needed data before next SWI.

--------------------------------------------------------------------------------

0x5AA44 - ConverseFiler_Statistics

On Entry:
            R0: Reason code (0-1).
            R1: Dependent on reason code.

Reason codes:
            0 (ReadCallTotals)
              Returns: Current call total counter in R0.

            1 (WriteCallTotals)
              R1: New call total value.
              Returns: 0 in R0 on success when the value is persisted.

On Exit:
            R0: Command-specific result or -1 if the reason code is unsupported.

Notes:
            * Call totals are stored in <Converse$Dir>.Resources.Data.CallCount.
              The module creates this file with "0" when it is missing at startup.
            * Call totals also increment automatically whenever the module logs
              a call via ConverseFiler_Logging reason code 2.
            * WriteCallTotals lets supervisory tools restore persisted totals
              after a reload or perform manual corrections.

--------------------------------------------------------------------------------

CLI COMMANDS

  *Filer_Status      : Lists the log and database files the module relies on,
                       showing existence and size for quick diagnostics.
  *Filer_Stats       : Prints aggregate stats (record counts, next IDs, payload
                       totals) for users, filebases, and messagebases.
  *Filer_FileBases   : Administrative helper for filebases (list/files/upload/
                       delete/edit) that wraps the Filebase SWIs.
  *Filer_MessageBases: Administrative helper for messagebases (list/messages/
                       import/delete) mirroring the Filebase CLI shape.
  *Filer_FileAreas   : Lists file areas for all or individual bases, including
                       the owning base name, access level, keys, and area name.
  *Filer_MessageAreas: Lists message areas grouped by base, reporting type,
                       retention days, AKA, tag, and area name alongside the
                       base name.

--------------------------------------------------------------------------------

DATA STRUCTURES

The following structures are defined in Filer/h/structs and passed to/from SWIs.
Callers should initialise all fields and allow the module to normalise strings.

USER_RECORD (size ~712 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field        | Type        | Size   |
|--------|--------------|-------------|--------|
| 0      | id           | int         | 4      |
| 4      | username     | char[]      | 32     |
| 36     | realname     | char[]      | 64     |
| 100    | email        | char[]      | 64     |
| 164    | password     | char[]      | 32     |
| 196    | keys         | char[]      | 128    |
| 324    | userdir      | char[]      | 256    |
| 580    | user_flags   | USER_FLAGS  | 76     |
| 656    | user_history | USER_HISTORY| 16     |
| 672    | user_stats   | USER_STATS  | 40     |

USER_FLAGS (size 76 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field       | Type | Description              |
|--------|-------------|------|--------------------------|
| +0     | locked      | int  | Account locked flag      |
| +4     | validated   | int  | Email validated flag     |
| +20    | sysop       | int  | Sysop privilege flag     |
| +60    | accesslevel | int  | Access level (0-255)     |

USER_HISTORY (size 16 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field           | Type | Description                  |
|--------|-----------------|------|------------------------------|
| +0     | messagebase     | int  | Last selected messagebase ID |
| +4     | messagebasearea | int  | Last selected area ID        |
| +8     | filebase        | int  | Last selected filebase ID    |
| +12    | filebasearea    | int  | Last selected area ID        |

USER_STATS (size 40 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field         | Type   | Description              |
|--------|---------------|--------|--------------------------|
| +0     | firstlogin    | time_t | First login timestamp    |
| +4     | lastlogin     | time_t | Last login timestamp     |
| +8     | totalcalls    | int    | Total login count        |
| +12    | totalmessages | int    | Total messages posted    |
| +16    | totaluploads  | int    | Total files uploaded     |
| +20    | totaldownloads| int    | Total files downloaded   |
| +24    | lastscan      | time_t | Last newfiles scan time  |

FILEBASE_RECORD (size ~464 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field       | Type   | Size   |
|--------|-------------|--------|--------|
| 0      | id          | int    | 4      |
| 4      | type        | int    | 4      |
| 8      | accesslevel | int    | 4      |
| 12     | keys        | char[] | 128    |
| 140    | name        | char[] | 64     |
| 204    | filebasedir | char[] | 256    |

FILE_RECORD (size ~484 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field          | Type   | Size   |
|--------|----------------|--------|--------|
| 0      | id             | int    | 4      |
| 4      | filebaseid     | int    | 4      |
| 8      | filebaseareaid | int    | 4      |
| 12     | deleted        | int    | 4      |
| 16     | accesslevel    | int    | 4      |
| 20     | keys           | char[] | 128    |
| 148    | name           | char[] | 64     |
| 212    | uploadedby     | int    | 4      |
| 216    | uploaddate     | time_t | 4      |
| 220    | description    | char[] | 256    |
| 476    | filesize       | long   | 4      |
| 480    | downloads      | int    | 4      |

MESSAGEBASE_RECORD (size ~464 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field          | Type   | Size   |
|--------|----------------|--------|--------|
| 0      | id             | int    | 4      |
| 4      | type           | int    | 4      |
| 8      | accesslevel    | int    | 4      |
| 12     | keys           | char[] | 128    |
| 140    | name           | char[] | 64     |
| 204    | messagebasedir | char[] | 256    |

MESSAGE_RECORD (size ~512 bytes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
| Offset | Field           | Type        | Size   |
|--------|-----------------|-------------|--------|
| 0      | id              | int         | 4      |
| 4      | messagebaseid   | int         | 4      |
| 8      | messagebaseareaid| int        | 4      |
| 12     | type            | int         | 4      |
| 16     | deleted         | int         | 4      |
| 20     | accesslevel     | int         | 4      |
| 24     | keys            | char[]      | 128    |
| 152    | subject         | char[]      | 256    |
| 408    | sentby          | int         | 4      |
| 412    | receivedby      | int         | 4      |
| 416    | orgaddr         | FTN_ADDRESS | 8      |
| 424    | dstaddr         | FTN_ADDRESS | 8      |
| 432    | imported        | time_t      | 4      |
| 436    | sent            | time_t      | 4      |
| 440    | read            | time_t      | 4      |
| 444    | timesread       | int         | 4      |
| 448    | bodysize        | long        | 4      |
| 452    | exported        | int         | 4      |

--------------------------------------------------------------------------------
