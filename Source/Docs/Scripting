Converse LineTask Script Language
=================================

Technical Reference
-------------------
This document provides comprehensive technical documentation for the Converse
script engine. For a user-friendly introduction, see Docs/NewSysop.

Overview
--------
LineTask drives caller interaction via scripts stored in `<Converse$Dir>.BBS`.
The prelogon script (configured in System config) runs when a session connects.
After successful authentication, the postlogon script runs.

The script engine is implemented in `LineTask/c/script` and supports:
- 40+ built-in commands across multiple categories
- 50+ macro variables for runtime substitution
- Block-structured IF/THEN/ELSE/ENDIF control flow
- Compound conditions with AND/OR logic
- Subscript calls with 8-level nesting
- Two script formats (plain text and embedded blocks)

Technical Limits
----------------
- Maximum call stack depth: 8 levels (SCRIPT_MAX_CALL_DEPTH)
- Maximum IF nesting depth: 16 levels (SCRIPT_MAX_IF_DEPTH)
- Maximum variable name length: 64 characters
- Maximum variable value length: 1024 characters
- Maximum line length: 1024 characters
- Maximum filename length: 256 characters

Script Format
-------------
Scripts support two formats:

**Plain Text Format**
One instruction per line. Labels end with `:` and serve as jump targets.
Comments start with `#`.

**Embedded Block Format**
Text outside `{...}` blocks is sent directly to the caller as output.
Commands inside `{...}` blocks are executed. This allows mixing ANSI art
with script logic:

    Welcome to the BBS!
    {
        set name `Guest`
        prompt name line echo
    }
    Hello, %{name}!
    {
        goto menu
    }

Use `{{` to output a literal `{` character in embedded format.

General Rules
-------------
- Leading/trailing whitespace is ignored.
- Block comments `/* ... */` work in both formats.
- Commands and labels are case-insensitive.
- Multi-word arguments can be wrapped in backticks (`` `like this` ``) to
  preserve spacing; otherwise tokens are split on whitespace.
- Unknown commands produce an error and halt the script.

Instructions
------------

Flow Control
~~~~~~~~~~~~
`LABEL <name>` or `<name>:`
    Defines a jump target. Example:
        label main_menu
        main_menu:

`GOTO <label>`
    Moves execution to the named label. Example:
        goto main_menu

`IF <condition> [&& <condition>]... [|| <condition>]... GOTO <label>`
    Evaluates conditions and jumps if the result is true.
    
    Each condition: `<operand> <op> <operand>`
    
    Both operands are macro-expanded before comparison, so you can use
    macros like `%{hour}` directly:
    
        if %{hour} < 12 goto morning
        if %{day} == 25 && %{month} == 12 goto christmas
    
    String operators (case-insensitive):
    - `==` — equals
    - `!=` — not equals
    - `contains` — left operand contains right operand as substring
    
    Numeric operators (converted to integers):
    - `>` — greater than
    - `<` — less than
    - `>=` — greater than or equal
    - `<=` — less than or equal
    
    Compound conditions:
    - `&&` — AND (both must be true)
    - `||` — OR (either can be true)
    
    Conditions are evaluated left-to-right with no operator precedence.
    
    Examples:
        if selection == `1` goto option_one
        if counter > 10 goto too_many
        if %{accesslevel} >= 100 goto sysop_menu
        if %{hour} >= 18 || %{hour} < 6 goto after_hours
        if %{registered} == 1 && %{accesslevel} >= 50 goto premium
        if userinput contains `quit` goto exit

Block IF/THEN/ELSE/ENDIF
~~~~~~~~~~~~~~~~~~~~~~~~
For multi-statement conditional execution, use block IF syntax:

    IF <condition> THEN
        ... statements executed if true ...
    ELSE
        ... statements executed if false ...
    ENDIF

The ELSE block is optional:

    IF <condition> THEN
        ... statements executed if true ...
    ENDIF

Block IFs can be nested up to 16 levels deep:

    if %{registered} == 1 then
        print `Welcome back!\r\n`
        if %{sysop} == 1 then
            print `You have sysop privileges.\r\n`
        else
            print `Access level: %{accesslevel}\r\n`
        endif
    else
        print `Welcome, guest! Type NEW to register.\r\n`
    endif

Compound conditions work with block IF:

    if %{hour} >= 9 && %{hour} < 17 then
        print `Chat available during business hours.\r\n`
        sysopchat
    else
        print `Sorry, chat only available 9am-5pm.\r\n`
    endif

**Technical Notes:**
- THEN must be on the same line as IF
- ELSE and ENDIF must be on their own lines
- Nesting depth tracked per-script (resets on subscript call)
- When condition is false, parser skips to matching ELSE/ENDIF
- Labels inside skipped blocks are NOT registered

Loop Commands (FOR, WHILE)
~~~~~~~~~~~~~~~~~~~~~~~~~~
The script engine supports structured iteration with FOR and WHILE loops:

`FOR var = start TO end [STEP n]` ... `ENDFOR` (or `NEXT`)
    Iterates from start to end (inclusive). STEP defaults to 1 if omitted.
    Use negative STEP to count down. The loop variable is updated each iteration.
    
    Examples:
        ; Count 1 to 10
        for i = 1 to 10
            print `%{i} `
        endfor
        
        ; Count by twos
        for j = 0 to 100 step 2
            print `%{j}\r\n`
        next
        
        ; Countdown
        for k = 10 to 1 step -1
            print `%{k}...`
        endfor
        print `Blast off!\r\n`
    
    **Technical Notes:**
    - Start, end, and step values are macro-expanded and converted to integers
    - FOR initializes the variable, then falls through to the loop body
    - ENDFOR increments, tests, and jumps back if continuing
    - If step > 0 and start > end, the loop body is skipped entirely
    - If step < 0 and start < end, the loop body is skipped entirely
    - Internal variables `_for_end_<var>` and `_for_step_<var>` store limits

`WHILE condition` ... `ENDWHILE`
    Repeats while the condition is true. Uses the same condition syntax as IF,
    supporting all operators (`==`, `!=`, `>`, `<`, `>=`, `<=`) and compound
    conditions (`&&`, `||`).
    
    Examples:
        ; Double until > 100
        set x `1`
        while x <= 100
            print `%{x} `
            mul x %{x} 2
        endwhile
        
        ; Wait for specific input
        set done `0`
        while done == 0
            prompt choice char echo
            if choice == `Q` then
                set done `1`
            end if
        endwhile

`BREAK`
    Exits the innermost loop immediately, continuing after ENDFOR/ENDWHILE.
    
    Example:
        for i = 1 to 100
            if i == 50 then
                print `Stopping at 50!\r\n`
                break
            end if
            print `%{i} `
        endfor
        print `Done.\r\n`

`CONTINUE`
    Skips the rest of the current iteration and jumps to the next:
    - For FOR loops: jumps to ENDFOR (which increments and tests)
    - For WHILE loops: jumps to WHILE (which re-tests the condition)
    
    Example (print only even numbers):
        for i = 1 to 10
            mod remainder %{i} 2
            if remainder == 1 then
                continue
            end if
            print `%{i} `
        endfor

**Nested Loops:**
    Loops can be nested up to 16 levels deep. BREAK and CONTINUE always
    operate on the innermost loop.
    
    Example (multiplication table):
        for row = 1 to 5
            for col = 1 to 5
                mul product %{row} %{col}
                print `%{product}\t`
            endfor
            print `\r\n`
        endfor

**Technical Notes:**
- Loop state is tracked in a static stack during parsing
- Labels are generated internally: `_for_start_N`, `_for_test_N`, `_for_end_N`
- BREAK uses the end_label to exit
- CONTINUE uses the test_label (ENDFOR for FOR, WHILE for WHILE)
- Loop state is reset on session disconnect via `script_reset_loop_state()`

`RETURN` or `STOP`
    Ends the current script immediately. If called from a subscript,
    returns to the calling script. If called from the top-level script,
    disconnects the session.

`SCRIPT <filename>`
    Loads and runs another script as a subscript. When the subscript
    ends (via RETURN, STOP, or reaching end-of-file), execution returns
    to the line after the SCRIPT command in the calling script.
    
    Subscripts share variables with the calling script, so any SET or
    PROMPT commands in the subscript affect the caller's variables.
    
    Call stack is limited to 8 levels. Deeper calls produce an error.
    
    Example:
        script `<Converse$Dir>.BBS.SubMenu`
        print `Back from submenu!\r\n`

`PAUSE <milliseconds>`
    Pauses execution for the specified duration. Uses OS_ReadMonotonicTime
    internally, so accuracy is ±10ms.

Output
~~~~~~
`PRINT <text>`
    Sends text to the caller. Supports macros and escape sequences
    (`\r`, `\n`, `\t`, `\\`). Example:
        print `Welcome to Converse, line %{line}!\r\n`

`TYPE <filename>`
    Streams a text/ANSI file to the caller. Example:
        type `<Converse$Dir>.BBS.Art.Welcome`

`CLS`
    Clears the terminal (ESC[2J) and homes the cursor (ESC[H).

`POS <column> <row>`
    Moves cursor to 1-based position using ANSI escape.

`CLL`
    Clears the current line (ESC[2K) and returns cursor to column 1.

`FG <colour>`
    Sets foreground colour (0-7).

`BG <colour>`
    Sets background colour (0-7).

`FGBG <fg> <bg>`
    Sets both foreground and background colours.

`FLASH <0|1>`
    Toggles blinking text attribute. 0=off, 1=on. Subsequent text
    output will blink until FLASH is called again or colours are reset.
    Example:
        flash 1
        print `ALERT!`
        flash 0
        print ` Important message.\r\n`

`BOLD`
    Enables the bold/bright ANSI attribute. Subsequent text will be
    displayed in high intensity until STD is called to reset.
    Example:
        bold
        print `Important!`
        std

`STD`
    Resets terminal attributes to standard white text on black
    background with no bold, flash, or other effects.
    Equivalent to sending ESC[0m ESC[37m ESC[40m.
    Example:
        bold
        fg 1
        print `Red alert!`
        std
        print ` Back to normal.\r\n`

Terminal Detection
~~~~~~~~~~~~~~~~~~
`DETECTANSI <result> [timeout_ms]`
    Sends ANSI Device Status Report query (ESC[6n) and waits for a
    cursor position response. Stores "1" in result if an ANSI terminal
    is detected, "0" if timeout expires.
    
    Default timeout is 3000ms. The `ansi` variable is typically set
    in Prelogon and available throughout the session.
    
    Example:
        detectansi ansi 5000
        if ansi == 0 goto text_mode
        type `<Converse$Dir>.BBS.Art.Welcome`
        goto continue
        label text_mode
        print `Welcome to Converse BBS!\r\n`
        label continue

Input
~~~~~
`PROMPT <variable> <mode> <echo>`
    Requests input from the caller.
    - `mode`: `char` (single character) or `line` (full line)
    - `echo`: `echo` (show input) or `noecho` (hide input)
    
    Example:
        prompt selection char echo
        prompt password line noecho

`ANYKEY [file]`
    Waits for a single keypress. Optionally displays an ANSI file first.
    If no file is specified, displays a default "Press any key" prompt.
    Example:
        anykey
        anykey `<Converse$Dir>.BBS.Menus.Anykey`

`READLINE <variable> [echo|noecho]`
    Reads a line of input into the specified variable. This is a
    shorthand for `PROMPT <variable> line <echo>`. Defaults to echo.
    Example:
        print `Enter your name: `
        readline username
        readline password noecho

`YESNO <variable>`
    Prompts for a Yes/No response. Waits for Y, y, N, or n keypress,
    ignoring all other keys. Stores "1" for Yes or "0" for No.
    Echoes the uppercase response (Y or N) followed by newline.
    Example:
        print `Download file? (Y/N): `
        yesno confirm
        if confirm == 1 goto do_download
        print `Cancelled.\r\n`
        stop
        label do_download
        sendfile %{file_id} zmodem

Variables
~~~~~~~~~
`SET <variable> <value>`
    Assigns a value (with macro expansion) to a variable. Example:
        set greeting `Hello %{line}`
        set counter 0

Math Operations
~~~~~~~~~~~~~~~
All math commands perform integer arithmetic. Operands are macro-expanded
and converted to integers.

`ADD <result> <operand1> <operand2>`
    Stores operand1 + operand2 in result. Example:
        add total count 1

`SUB <result> <operand1> <operand2>`
    Stores operand1 - operand2 in result. Example:
        sub remaining total used

`MUL <result> <operand1> <operand2>`
    Stores operand1 * operand2 in result. Example:
        mul doubled value 2

`DIV <result> <operand1> <operand2>`
    Stores operand1 / operand2 in result. Division by zero returns 0.

`MOD <result> <operand1> <operand2>`
    Stores operand1 % operand2 in result. Modulo by zero returns 0.

`RANDOM <result> <min> <max>`
    Generates random integer in [min, max] inclusive. Example:
        random dice 1 6
        print `You rolled a %{dice}!\r\n`

String Operations
~~~~~~~~~~~~~~~~~
`STRLEN <result> <source_variable>`
    Stores the length of the source variable's value in result. Example:
        strlen len username
        if len == 0 goto no_input

`HASKEY <result> <key>`
    Checks if the logged-in user has a specific access key. Stores "1"
    in result if the key is found, "0" otherwise. Keys are case-insensitive.
    Example:
        haskey has_download D
        if has_download == 0 goto no_download_access
        
        haskey is_premium P
        if is_premium == 1 goto premium_features

User Authentication
~~~~~~~~~~~~~~~~~~~
`LOGON`
    Initiates user login. Prompts for username and password.
    
    - Users can type "NEW" to begin registration
    - Authenticates via Filer module
    - Allows up to 3 retries before disconnect
    - On success, runs postlogon script
    - Sets user_id, access_level, keys in session state

`LOGOFF`
    Ends the session and disconnects the caller.

`ONLINE`
    Lists all connected users showing:
    - Line number
    - Real name (or "Guest")
    - Online duration
    - Current activity
    - [SYSOP] tag for administrators

`LOGINSCAN`
    Scans all accessible messagebases and filebases for new content since
    the user's last login. Reports counts of:
    - New private messages addressed to the user (unread)
    - New files uploaded since user's last scan timestamp
    
    After scanning, updates the user's `lastscan` timestamp in USER_STATS.
    Typically called in the Postlogon script.
    
    Example (in Postlogon):
        print `Checking for new content...\r\n`
        loginscan

System Commands
~~~~~~~~~~~~~~~
`OSCLI <command>`
    Executes a RISC OS CLI command. Use with caution - this provides
    direct access to the operating system. The command runs in the
    context of the LineTask Wimp application.
    
    Example:
        oscli `Set MyVar$Path <Converse$Dir>.Custom`
        oscli `Remove <Converse$Dir>.Temp.scratch`
    
    **Security Note:** This command should only be used in scripts that
    are not user-modifiable. Consider access level checks before use.

Status & Information
~~~~~~~~~~~~~~~~~~~~
`DOING <text>`
    Updates the server's activity display for this line. Example:
        doing `Reading messages`
        doing ``  /* Reset to default */

`CALL <action> [argument]`
    Invokes host callbacks:
    - `time` — prints current timestamp
    - `lineinfo` — prints session/door status
    - `door <command>` — launches a native ConverseDoors door
    - `riscbbsdoor <command>` — launches a RiscBBS door
    - `arcbbsdoor <number> <command>` — launches an ARCbbs door
    - `disconnect` — prints hangup reminder
    - `message <text>` — prints text with macro expansion

    Door Example:
        call door `<Converse$Dir>.BBS.Doors.MyDoor %{line}`

    The door receives the line number as a command-line argument and registers
    itself with the ConverseDoors module. See Doors/docs/ConverseDoors for the
    full door API specification.

Filebase Commands
~~~~~~~~~~~~~~~~~
`FILEBASE <subcommand> [argument]`
    Interacts with the filebase system:
    - `list` — Lists accessible filebases
    - `select <id>` — Selects a filebase
    - `areas` — Lists areas in selected filebase
    - `area <id>` — Selects an area (0 = all files)
    - `files` — Lists files in current selection
    - `info <file_id>` — Shows file details
    - `download <file_id>` — Initiates download
    - `reset` — Clears selection

Messagebase Commands
~~~~~~~~~~~~~~~~~~~~
`MESSAGEBASE <subcommand> [argument]`
    Interacts with the messagebase system:
    - `list` — Lists accessible messagebases
    - `select <id>` — Selects a messagebase
    - `areas` — Lists areas in selected messagebase
    - `area <id>` — Selects an area (0 = all messages)
    - `messages` — Lists messages in current selection
    - `read [id]` — Opens message viewer (or first unread)
    - `info <id>` — Shows message details
    - `post` — Starts message composer
    - `reset` — Clears selection

    Area types determine posting behaviour:
    - LOCAL — Local-only messages
    - ECHO — FTN echomail (exported to uplink)
    - NETMAIL — FTN netmail (requires destination address)
    - OTHER — Private user-to-user mail (local only)

    The message viewer displays messages with ANSI formatting:
    - Header shows From, To, Subject, Date
    - Body is paginated (press Enter for more)
    - Navigation: [N]ext, [P]rev, [R]eply, [Q]uit

    The message composer prompts for:
    - To (for private/netmail areas)
    - FTN address (for netmail only, e.g., 1:234/567)
    - Subject line
    - Body text (line by line, blank line to finish)
    - Confirmation before posting

    Example:
        messagebase list
        messagebase select 1
        messagebase areas
        messagebase area 3
        messagebase messages
        messagebase read 1
        messagebase post

Direct Mail Commands
~~~~~~~~~~~~~~~~~~~~
`SENDMAIL <username> <subject> <body>`
    Sends a private message to a local user. Requires a messagebase with
    a Private (areatype 4) area to be configured. The sender's messagebase
    selection is used; if not set, the command searches all messagebases.
    
    All arguments support macro expansion and backtick quoting.
    Use `\r\n` in body for line breaks.
    
    Example:
        sendmail sysop `Welcome!` `Hello,\r\n\r\nWelcome to the BBS!\r\n\r\n- System`
        sendmail %{username} `Re: %{subject}` `Thanks for your message!`

`SENDNETMAIL <address> <name> <subject> <body>`
    Queues a netmail message to an FTN address for export. Requires a
    messagebase with a Netmail (areatype 2) area. The message is stored
    locally and exported when the mailer runs a Scan.
    
    - address: FTN address (e.g., 2:2500/622 or 2:2500/622.1 for points)
    - name: Recipient's name (for display in message)
    - subject: Subject line
    - body: Message body (use \r\n for line breaks)
    
    Example:
        sendnetmail 2:2500/622 `John Smith` `Hello!` `Greetings from Converse BBS!`
        sendnetmail 1:234/567.1 `Sysop` `Test` `Testing point netmail.`

File Transfer
~~~~~~~~~~~~~
`SENDFILE <file_id> [protocol]`
    Downloads a file to the user. Protocols:
    - `xmodem` — 128-byte blocks, checksum
    - `xmodem-crc` — 128-byte blocks, CRC-16
    - `xmodem-1k` — 1024-byte blocks, CRC-16
    - `ymodem` — Batch mode with filename/size header
    - `ymodem-g` — Streaming YMODEM (no per-block ACK)
    - `zmodem` — Full ZMODEM with CRC-32 and streaming (recommended)
    
    Example:
        filebase select 1
        filebase files
        prompt file_id line echo
        sendfile %{file_id} zmodem

`RECEIVEFILE <path> [protocol]`
    Uploads a file from the user to the specified path.
    Same protocol options as SENDFILE.

Macros
------
Macros substitute runtime values. Use `%{name}` syntax (or legacy `§name§`).

System Macros
~~~~~~~~~~~~~
- `%{line}` — Current line number
- `%{t_handle}` — Wimp task handle (for doors)
- `%{time}` — Current time (HH:MM:SS)
- `%{date}` — Current date (YYYY-MM-DD)

Time Macros
~~~~~~~~~~~
- `%{hour}` — Hour (0-23)
- `%{minute}` — Minute (0-59)
- `%{dayofweek}` — Day of week (0=Sunday, 6=Saturday)
- `%{day}` — Day of month (1-31)
- `%{month}` — Month (1-12)
- `%{year}` — Four-digit year (e.g., 2025)

User Macros
~~~~~~~~~~~
- `%{userid}` — User's ID (0 if not logged in)
- `%{username}` — User's login name
- `%{realname}` — User's full name
- `%{accesslevel}` — User's access level (0 if not logged in)
- `%{registered}` — "1" if logged in, "0" if guest
- `%{sysop}` — "1" if user is a sysop, "0" otherwise
- `%{keys}` — User's access keys string (e.g., "A B C")

Selection Macros
~~~~~~~~~~~~~~~~
These macros reflect the user's current filebase/messagebase selection:

- `%{filebaseid}` — Currently selected filebase ID (0 if none)
- `%{filebasename}` — Currently selected filebase name (empty if none)
- `%{filebaseareaid}` — Currently selected filebase area ID (0 if none)
- `%{filebaseareaname}` — Currently selected filebase area name (empty if none)
- `%{messagebaseid}` — Currently selected messagebase ID (0 if none)
- `%{messagebasename}` — Currently selected messagebase name (empty if none)
- `%{messagebaseareaid}` — Currently selected messagebase area ID (0 if none)
- `%{messagebaseareaname}` — Currently selected messagebase area name (empty if none)

Selections persist across script calls and are saved to USER_HISTORY on logout.

Variables
~~~~~~~~~
Any variable set with `SET` or `PROMPT` can be referenced:
    set greeting `Hello`
    print `%{greeting}, world!\r\n`

Session variables are shared between the main script and all subscripts.
Variables persist for the duration of the user's session.

Special Variables
~~~~~~~~~~~~~~~~~
- `%{ansi}` — Set by DETECTANSI, "1" if ANSI terminal detected
- `%{_key}` — Last key pressed (set by some input commands)
- `%{_input}` — Last line input (set by PROMPT in line mode)

Variable names are case-insensitive. Variables not yet set expand to empty string.

Command Reference
-----------------
Complete alphabetical list of all script commands:

| Command | Category | Description |
|---------|----------|-------------|
| ADD | Math | Integer addition |
| ANYKEY | Input | Wait for keypress |
| BG | Output | Set background colour |
| CALL | System | Host callbacks (time, door, disconnect, etc.) |
| CLL | Output | Clear current line |
| CLS | Output | Clear screen |
| DETECTANSI | Terminal | Detect ANSI terminal |
| DIV | Math | Integer division |
| DOING | Status | Update activity display |
| ELSE | Flow | Block IF false branch |
| ENDIF | Flow | Block IF terminator |
| FG | Output | Set foreground colour |
| FGBG | Output | Set foreground and background |
| FILEBASE | Filebase | Filebase operations |
| FLASH | Output | Toggle blinking text |
| GOTO | Flow | Jump to label |
| HASKEY | String | Check user access key |
| IF | Flow | Conditional (GOTO or THEN) |
| LABEL | Flow | Define jump target |
| LOGINSCAN | User | Scan for new content |
| LOGOFF | User | Disconnect session |
| LOGON | User | Authenticate user |
| MESSAGEBASE | Messagebase | Messagebase operations |
| MOD | Math | Integer modulo |
| MUL | Math | Integer multiplication |
| ONLINE | Status | List connected users |
| OSCLI | System | Execute CLI command |
| PAUSE | Flow | Delay execution |
| POS | Output | Position cursor |
| PRINT | Output | Send text to terminal |
| PROMPT | Input | Request user input |
| RANDOM | Math | Generate random number |
| RECEIVEFILE | Transfer | Upload file from user |
| RETURN | Flow | Exit script/subscript |
| SCRIPT | Flow | Call subscript |
| SENDFILE | Transfer | Download file to user |
| SENDMAIL | Mail | Send private message |
| SENDNETMAIL | Mail | Send FTN netmail |
| SET | Variables | Assign variable value |
| STOP | Flow | Exit script (alias for RETURN) |
| STRLEN | String | Get string length |
| SYSOPCHAT | User | Page sysop for chat |
| THEN | Flow | Block IF true branch |
| TYPE | Output | Display file contents |

Examples
--------

Time-Based Greeting
~~~~~~~~~~~~~~~~~~~
{
    if %{hour} < 12 goto morning
    if %{hour} < 17 goto afternoon
    goto evening

    label morning
    set greeting `Good morning`
    goto show_greeting

    label afternoon
    set greeting `Good afternoon`
    goto show_greeting

    label evening
    set greeting `Good evening`
    goto show_greeting

    label show_greeting
    print `%{greeting}! Today is %{date}.\r\n`
}

Christmas Banner
~~~~~~~~~~~~~~~~
{
    if %{day} == 25 && %{month} == 12 goto christmas
    goto normal

    label christmas
    fgbg 1 0
    print `*** Merry Christmas! ***\r\n`
    fgbg 7 0

    label normal
}

Access Control
~~~~~~~~~~~~~~
{
    if %{sysop} == 1 goto sysop_menu
    if %{accesslevel} >= 100 goto admin_menu
    if %{registered} == 0 goto guest_menu
    goto user_menu

    label sysop_menu
    print `Welcome, Sysop!\r\n`
    goto continue

    label admin_menu
    print `Welcome, Administrator!\r\n`
    goto continue

    label guest_menu
    print `Welcome, Guest! Type NEW to register.\r\n`
    goto continue

    label user_menu
    print `Welcome back!\r\n`

    label continue
}

Key-Based Access Control
~~~~~~~~~~~~~~~~~~~~~~~~
{
    /* Check if user has download key */
    haskey can_download D
    if can_download == 0 goto no_download
    
    print `Download menu available.\r\n`
    goto continue
    
    label no_download
    print `You don't have download access.\r\n`
    
    label continue
    
    /* Check for premium features key */
    haskey is_premium P
    if is_premium == 1 goto show_premium
    goto skip_premium
    
    label show_premium
    print `Premium features enabled!\r\n`
    
    label skip_premium
}

Block IF Example - User Welcome
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{
    /* Demonstrate nested block IF/THEN/ELSE/ENDIF */
    
    if %{registered} == 1 then
        /* User is logged in */
        print `Welcome back, %{realname}!\r\n`
        
        if %{sysop} == 1 then
            /* Sysop gets special treatment */
            fgbg 3 0
            print `SYSOP MODE ACTIVE\r\n`
            fgbg 7 0
            print `System status: All modules running.\r\n`
        else
            /* Regular user - check access level */
            if %{accesslevel} >= 100 then
                print `You have Administrator access.\r\n`
            else
                if %{accesslevel} >= 50 then
                    print `You have Power User access.\r\n`
                else
                    print `Standard user access.\r\n`
                endif
            endif
        endif
        
        /* Check for new mail using block IF */
        loginscan
        
    else
        /* Guest user */
        print `Welcome, Guest!\r\n`
        print `Type NEW at the login prompt to register.\r\n`
        
        if %{ansi} == 1 then
            type `<Converse$Dir>.BBS.Art.Guest`
        else
            print `[ASCII mode - ANSI art not displayed]\r\n`
        endif
    endif
}

Dynamic Menu with Contains Operator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{
    label menu
    print `\r\nMain Menu\r\n`
    print `---------\r\n`
    print `[F]iles  [M]essages  [O]nline  [Q]uit\r\n`
    print `Command: `
    prompt choice char echo
    print `\r\n`
    
    /* Using contains for flexible input matching */
    if choice contains `f` goto files
    if choice contains `F` goto files
    if choice contains `m` goto messages
    if choice contains `M` goto messages
    if choice contains `o` goto online
    if choice contains `O` goto online
    if choice contains `q` goto quit
    if choice contains `Q` goto quit
    
    print `Unknown option.\r\n`
    goto menu
    
    label files
    doing `Browsing files`
    filebase list
    goto menu
    
    label messages
    doing `Reading messages`
    messagebase list
    goto menu
    
    label online
    doing `Viewing online users`
    online
    goto menu
    
    label quit
    doing `Logging off`
    logoff
}

Number Guessing Game
~~~~~~~~~~~~~~~~~~~~
{
    print `I'm thinking of a number 1-10...\r\n`
    random secret 1 10
    set attempts 0

    label game_loop
    add attempts attempts 1
    print `Guess: `
    prompt guess line echo

    strlen len guess
    if len == 0 goto quit

    if guess == %{secret} goto win
    if guess > %{secret} goto too_high
    print `Too low!\r\n`
    goto game_loop

    label too_high
    print `Too high!\r\n`
    goto game_loop

    label win
    print `Correct in %{attempts} tries!\r\n`
    goto done

    label quit
    print `The answer was %{secret}.\r\n`

    label done
}

Weekend/Hours Check
~~~~~~~~~~~~~~~~~~~
{
    /* Check for weekend */
    if %{dayofweek} == 0 || %{dayofweek} == 6 goto closed_weekend

    /* Check business hours (9am-5pm) */
    if %{hour} < 9 || %{hour} >= 17 goto closed_hours

    /* Open for business */
    print `Sysop chat is available.\r\n`
    goto done

    label closed_weekend
    print `Sorry, chat unavailable on weekends.\r\n`
    goto done

    label closed_hours
    print `Sorry, chat only available 9am-5pm.\r\n`

    label done
}

SYSOPCHAT - Interactive Sysop Chat
----------------------------------

The `SYSOPCHAT` command allows users to page and chat with the sysop in
real-time. When executed:

1. User is prompted to enter a reason for wanting to chat
2. Pressing Enter with no reason cancels the request
3. If a reason is given, a pager window appears on the sysop's desktop
4. The pager beeps repeatedly for 30 seconds
5. Sysop can click "Start" to begin chat, or "Ignore" to decline
6. If the timeout expires, user sees a "not available" message

During chat:
- The user's terminal shows a split-screen interface (ANSI)
- Top half shows sysop's typing
- Bottom half shows user's typing
- Sysop types in a Wimp window, text appears on user's screen
- User types on their terminal, text appears in Wimp window
- Chat ends when sysop clicks "End Chat"

Example:
{
    /* Only offer chat during business hours */
    if %{hour} < 9 || %{hour} >= 17 goto nochat
    
    prompt choice `Would you like to chat with the sysop? (Y/N): `
    if %{choice} != Y && %{choice} != y goto nochat
    
    sysopchat
    
    label nochat
}

Tips
----
- Always `PROMPT` before using a variable in conditions.
- Use `DOING` to show activity in the server status window.
- Keep lines under ~255 characters for RISC OS CLI limits.
- Use `PAUSE` sparingly to avoid sluggish UI.
- Test compound conditions carefully — they evaluate left-to-right.
- ZMODEM is recommended for file transfers (fastest, most reliable).
- Use `%{registered}` to check if user is logged in before showing
  user-specific content.
- Use block IF/THEN/ELSE/ENDIF for complex conditional logic instead of
  multiple GOTOs — it's more readable and less error-prone.
- Subscripts share variables with callers — use this for modular design.

Technical Architecture
----------------------

Script Execution Model
~~~~~~~~~~~~~~~~~~~~~~
The script engine operates as a state machine within the LineTask Wimp
application. Execution is cooperative and non-blocking:

1. LineTask receives null polls from the Wimp
2. On each poll, the script engine executes one instruction
3. I/O operations (PROMPT, file transfers) yield to the Wimp
4. Timers and socket I/O are handled between instructions

This model ensures the desktop remains responsive during script execution.

Instruction Parsing
~~~~~~~~~~~~~~~~~~~
Each instruction is parsed into:
- Command type (enum SCRIPT_CMD_*)
- Up to 8 argument tokens (strings, max 256 chars each)
- Whitespace-separated unless backtick-quoted

Macro expansion occurs at execution time, not parse time. This allows
dynamic variable resolution.

Condition Evaluation
~~~~~~~~~~~~~~~~~~~~
Conditions are evaluated left-to-right without operator precedence:

    a == 1 && b == 2 || c == 3

Is evaluated as:
    ((a == 1) && (b == 2)) || (c == 3)

For complex logic, use nested block IFs or multiple statements.

Block IF Implementation
~~~~~~~~~~~~~~~~~~~~~~~
Block IF uses a nesting stack to track THEN/ELSE/ENDIF pairs:

- When IF...THEN evaluates false, the parser enters "skip mode"
- In skip mode, commands are parsed but not executed
- Nested IFs in skip mode increment a depth counter
- ELSE at current depth switches execution state
- ENDIF at current depth exits the block

This allows arbitrary nesting of conditionals.

Call Stack
~~~~~~~~~~
The SCRIPT command pushes the current execution state onto a call stack:
- Current script path
- Line number (program counter)
- Local IF nesting state

When the subscript ends, the state is popped and execution resumes.
Maximum depth is 8 levels to prevent stack overflow.

Variable Storage
~~~~~~~~~~~~~~~~
Variables are stored in a hash table keyed by name (case-insensitive).
Each entry contains:
- Variable name (64 chars max)
- Value string (1024 chars max)
- Flags (internal use)

Variables are allocated from RMA and freed at session end.

File Transfer Integration
~~~~~~~~~~~~~~~~~~~~~~~~~
File transfers (SENDFILE/RECEIVEFILE) set the script status to
SCRIPT_STATUS_WAIT_TRANSFER. The transfer state machine runs on
subsequent null polls until complete. During transfer:

- Script execution is paused
- The Support module line state shows transfer_active=1
- Idle timeout is suspended

On completion, script execution resumes at the next instruction.

Error Handling
~~~~~~~~~~~~~~
Errors are logged to the line log and optionally displayed to the user:

- Unknown command: Script halts with error message
- Missing label: GOTO fails silently (returns to caller if subscript)
- File not found: TYPE/SCRIPT fails, execution continues
- SWI errors: Logged, may halt script depending on severity

Debug output uses the Reporter module when available.

Internal Command Codes
~~~~~~~~~~~~~~~~~~~~~~
For reference, the internal command enum (from LineTask/h/script):

    SCRIPT_CMD_UNKNOWN = 0
    SCRIPT_CMD_LABEL = 1
    SCRIPT_CMD_GOTO = 2
    SCRIPT_CMD_IF = 3
    SCRIPT_CMD_PRINT = 4
    SCRIPT_CMD_TYPE = 5
    SCRIPT_CMD_PROMPT = 6
    SCRIPT_CMD_SET = 7
    SCRIPT_CMD_LOGON = 8
    SCRIPT_CMD_LOGOFF = 9
    SCRIPT_CMD_CALL = 10
    SCRIPT_CMD_DOING = 11
    SCRIPT_CMD_RETURN = 12
    SCRIPT_CMD_ONLINE = 13
    SCRIPT_CMD_FG = 14
    SCRIPT_CMD_BG = 15
    SCRIPT_CMD_FGBG = 16
    SCRIPT_CMD_CLS = 17
    SCRIPT_CMD_POS = 18
    SCRIPT_CMD_ANYKEY = 19
    SCRIPT_CMD_ADD = 20
    SCRIPT_CMD_SUB = 21
    SCRIPT_CMD_MUL = 22
    SCRIPT_CMD_DIV = 23
    SCRIPT_CMD_MOD = 24
    SCRIPT_CMD_RANDOM = 25
    SCRIPT_CMD_STRLEN = 26
    SCRIPT_CMD_HASKEY = 27
    SCRIPT_CMD_FILEBASE = 28
    SCRIPT_CMD_MESSAGEBASE = 29
    SCRIPT_CMD_SENDFILE = 30
    SCRIPT_CMD_RECEIVEFILE = 31
    SCRIPT_CMD_SENDMAIL = 32
    SCRIPT_CMD_SENDNETMAIL = 33
    SCRIPT_CMD_LOGINSCAN = 34
    SCRIPT_CMD_DETECTANSI = 35
    SCRIPT_CMD_FLASH = 36
    SCRIPT_CMD_SCRIPT = 37
    SCRIPT_CMD_PAUSE = 38
    SCRIPT_CMD_SYSOPCHAT = 39
    SCRIPT_CMD_OSCLI = 40
    SCRIPT_CMD_CLL = 41
    SCRIPT_CMD_THEN = 42
    SCRIPT_CMD_ELSE = 43
    SCRIPT_CMD_ENDIF = 44
