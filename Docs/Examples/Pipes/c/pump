#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <limits.h>

#include "kernel.h"

#define CONVERSE_PIPES_BASE             0x5AA00
#define SWI_CONVERSE_INPUT_WRITE_BLOCK (CONVERSE_PIPES_BASE + 13)
#define SWI_CONVERSE_OUTPUT_READ_BLOCK (CONVERSE_PIPES_BASE + 14)
#define SWI_OS_BYTE                    0x00000006

/* Pumps bytes bidirectionally between two lines using the block SWIs. */

#define BUFFER_BYTES 512

static void wait_tick(void)
{
  _kernel_swi_regs regs;
  memset(&regs, 0, sizeof(regs));
  regs.r[0] = 1;
  _kernel_swi(SWI_OS_BYTE, &regs, &regs);
}

static _kernel_oserror *converse_input_write_block(int line,
                                                   const uint8_t *data,
                                                   size_t length,
                                                   int *written)
{
  /* Attempts to push up to 'length' bytes into the destination input buffer. */
  _kernel_swi_regs regs;
  size_t request = length;

  if (request > (size_t)INT32_MAX)
  {
    request = (size_t)INT32_MAX;
  }

  memset(&regs, 0, sizeof(regs));
  regs.r[0] = line;
  regs.r[1] = (int)(uintptr_t)data;
  regs.r[2] = (int)request;

  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_INPUT_WRITE_BLOCK, &regs, &regs);
  if (!error && written)
  {
    *written = regs.r[0];
  }

  return error;
}

static _kernel_oserror *converse_output_read_block(int line,
                                                   uint8_t *dest,
                                                   size_t capacity,
                                                   int *copied)
{
  /* Grabs as much slave->host data as will fit in the staging buffer. */
  _kernel_swi_regs regs;
  size_t request = capacity;

  if (request > (size_t)INT32_MAX)
  {
    request = (size_t)INT32_MAX;
  }

  memset(&regs, 0, sizeof(regs));
  regs.r[0] = line;
  regs.r[1] = (int)(uintptr_t)dest;
  regs.r[2] = (int)request;

  _kernel_oserror *error = _kernel_swi(SWI_CONVERSE_OUTPUT_READ_BLOCK, &regs, &regs);
  if (!error && copied)
  {
    *copied = regs.r[0];
  }

  return error;
}

static int pump_direction(int src_line,
                          int dst_line,
                          uint8_t *buffer,
                          size_t *pending,
                          unsigned long long *total)
{
  int activity = 0;

  if (*pending < BUFFER_BYTES)
  {
    int copied = 0;
    _kernel_oserror *error = converse_output_read_block(src_line,
                                                        buffer + *pending,
                                                        BUFFER_BYTES - *pending,
                                                        &copied);
    if (error)
    {
      fprintf(stderr,
              "ConversePipes_OutputReadBlock failed on line %d: %s\n",
              src_line,
              error->errmess);
      return -1;
    }

    if (copied > 0)
    {
      /* Append newly drained bytes to the buffered payload. */
      *pending += (size_t)copied;
      activity = 1;
    }
  }

  while (*pending > 0)
  {
    int transferred = 0;
    _kernel_oserror *error = converse_input_write_block(dst_line,
                                                        buffer,
                                                        *pending,
                                                        &transferred);
    if (error)
    {
      fprintf(stderr,
              "ConversePipes_InputWriteBlock failed on line %d: %s\n",
              dst_line,
              error->errmess);
      return -1;
    }

    if (transferred == 0)
    {
      break;
    }

    if ((size_t)transferred < *pending)
    {
      /* Keep any leftovers at the start of the buffer for the next pass. */
      memmove(buffer, buffer + transferred, *pending - (size_t)transferred);
    }

    *pending -= (size_t)transferred;
    *total += (unsigned long long)transferred;
    activity = 1;
  }

  return activity;
}

int main(int argc, char **argv)
{
  if (argc != 3)
  {
    fprintf(stderr, "Usage: %s <line-a> <line-b>\n", argv[0]);
    return 1;
  }

  const int line_a = atoi(argv[1]);
  const int line_b = atoi(argv[2]);

  if (line_a < 0 || line_a >= 32 || line_b < 0 || line_b >= 32)
  {
    fprintf(stderr, "Line numbers must be between 0 and 31.\n");
    return 1;
  }

  uint8_t a_to_b[BUFFER_BYTES];
  uint8_t b_to_a[BUFFER_BYTES];
  size_t pending_a_to_b = 0;
  size_t pending_b_to_a = 0;
  unsigned long long total_a_to_b = 0;
  unsigned long long total_b_to_a = 0;

  printf("Pumping between lines %d <-> %d (Ctrl+C to stop).\n", line_a, line_b);

  for (;;)
  {
    int moved_a = pump_direction(line_a, line_b, a_to_b, &pending_a_to_b, &total_a_to_b);
    int moved_b = pump_direction(line_b, line_a, b_to_a, &pending_b_to_a, &total_b_to_a);

    if (moved_a < 0 || moved_b < 0)
    {
      return 1;
    }

    if (total_a_to_b || total_b_to_a)
    {
      /* Show live counters so the operator can confirm traffic is flowing. */
      fprintf(stderr,
              "\rA->B %llu bytes | B->A %llu bytes | pending %zu/%zu",
              total_a_to_b,
              total_b_to_a,
              pending_a_to_b,
              pending_b_to_a);
      fflush(stderr);
    }

    if (moved_a == 0 && moved_b == 0)
    {
      /* Both pipes idle: sleep briefly before polling again. */
      wait_tick();
    }
  }
}
